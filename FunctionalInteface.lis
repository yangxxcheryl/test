                        .module FunctionalInteface.c
                        .area text(rom, con, rel)
                ;       slaveNum -> R10
                        .even
 0000           _GetMotState::
 0000 AA92              st -y,R10
 0002 A02E              mov R10,R16
 0004           ; 
 0004           ; 
 0004           ; #include <iom1280v.h>
 0004           ; #include <macros.h>
 0004           ; #include "B1404_LIB.h"
 0004           ; #include "LibCommon.h"
 0004           ; 
 0004           ; 
 0004           ; /*
 0004           ; 从机模块命令接口，为上层提供控制函数
 0004           ; */
 0004           ; 
 0004           ; /************************************** 电机控制 *********************************************/
 0004           ; unsigned char  GetMotState(unsigned char slaveNum)
 0004           ; {
 0004           ;       return GetSlaveState(slaveNum);
 0004 0A2D              mov R16,R10
 0006 0E940000          xcall _GetSlaveState
 000A           L2:
 000A                   .dbline 0 ; func end
 000A A990              ld R10,y+
 000C 0895              ret
 000E           ;        command -> y+0
 000E           ;       slaveNum -> R20
                        .even
 000E           _MotStop::
 000E 4A93              st -y,R20
 0010 402F              mov R20,R16
 0012 2897              sbiw R28,8
 0014           ; }
 0014           ; 
 0014           ; unsigned char MotStop(unsigned char slaveNum)
 0014           ; {
 0014           ;       COMMAND_STRING command;
 0014           ;       if(slaveNum>=SLAVE_NUM)
 0014 4F30              cpi R20,15
 0016 10F0              brlo L4
 0018           X0:
 0018           ; 		return 1;
 0018 01E0              ldi R16,1
 001A 0FC0              xjmp L3
 001C           L4:
 001C           ; //	if(GetSlaveState(slaveNum)==STA_SLAVE_FREE){	// 在电机为空闲状态下发送
 001C           ; 	command.cmd = (slaveNum << 3)  +  1;
 001C 842F              mov R24,R20
 001E 880F              lsl R24
 0020 880F              lsl R24
 0022 880F              lsl R24
 0024 8F5F              subi R24,255    ; addi 1
 0026 8883              std y+0,R24
 0028           ;       command.cmdLen =  1 + 1;
 0028 82E0              ldi R24,2
 002A 8F83              std y+7,R24
 002C           ;       command.pam[0] = CMD_MOT_STOP;
 002C 89E0              ldi R24,9
 002E 8983              std y+1,R24
 0030           ;       InsertUrgentCommand(slaveNum, &command);
 0030 9E01              movw R18,R28
 0032 042F              mov R16,R20
 0034 0E940000          xcall _InsertUrgentCommand
 0038           ; //            }
 0038           ;       return 0;
 0038 0027              clr R16
 003A           L3:
 003A                   .dbline 0 ; func end
 003A 2896              adiw R28,8
 003C 4991              ld R20,y+
 003E 0895              ret
 0040           ;            num -> R12,R13
 0040           ;          pChar -> R10,R11
 0040           ;        command -> y+0
 0040           ;              n -> y+14
 0040           ;       slaveNum -> R20
                        .even
 0040           _MotRun::
 0040 3A93              st -y,r19
 0042 2A93              st -y,r18
 0044 0E940000          xcall push_xgset303C
 0048 402F              mov R20,R16
 004A 2897              sbiw R28,8
 004C           ; }
 004C           ; 
 004C           ; unsigned char MotRun(unsigned char slaveNum, signed int n){
 004C           ;       COMMAND_STRING command;
 004C           ;       unsigned char *pChar;
 004C           ;       signed int num;
 004C           ;       num = n;
 004C CE84              ldd R12,y+14
 004E DF84              ldd R13,y+15
 0050           ;       pChar = (unsigned char *)(&n);
 0050 CE01              movw R24,R28
 0052 0E96              adiw R24,14
 0054 5C01              movw R10,R24
 0056           ;       if(slaveNum>=SLAVE_NUM)
 0056 4F30              cpi R20,15
 0058 10F0              brlo L9
 005A           X1:
 005A           ; 		return 1;
 005A 01E0              ldi R16,1
 005C 1BC0              xjmp L8
 005E           L9:
 005E           ; 	SetMotPosIdle(slaveNum);
 005E 042F              mov R16,R20
 0060 1127              clr R17
 0062 0E940000          xcall _SetMotPosIdle
 0066           ; //    if(GetSlaveState(slaveNum)==STA_SLAVE_FREE){    // 在电机为空闲状态下发送
 0066           ;               command.cmd = (slaveNum<<3) + 3;
 0066 842F              mov R24,R20
 0068 880F              lsl R24
 006A 880F              lsl R24
 006C 880F              lsl R24
 006E 8D5F              subi R24,253    ; addi 3
 0070 8883              std y+0,R24
 0072           ;               command.cmdLen = 1+3;
 0072 84E0              ldi R24,4
 0074 8F83              std y+7,R24
 0076           ;               num = (unsigned int)n;
 0076 CE84              ldd R12,y+14
 0078 DF84              ldd R13,y+15
 007A           ;               command.pam[0] = CMD_MOT_RUN;
 007A 81E0              ldi R24,1
 007C 8983              std y+1,R24
 007E           ;               command.pam[2] = *pChar++;
 007E F501              movw R30,R10
 0080 2190              ld R2,Z+
 0082 5F01              movw R10,R30
 0084 2B82              std y+3,R2
 0086           ;               command.pam[1] = *pChar;
 0086 2080              ldd R2,z+0
 0088 2A82              std y+2,R2
 008A           ;               
 008A           ;               InsertCommand(slaveNum, &command);
 008A 9E01              movw R18,R28
 008C 042F              mov R16,R20
 008E 0E940000          xcall _InsertCommand
 0092           ; //            }
 0092           ; /*    if(slaveNum == MOT_DILUENT)
 0092           ;               StartLiquidMonitor(0);
 0092           ;       else if(slaveNum == MOT_FLUID)
 0092           ;               StartLiquidMonitor(1);
 0092           ;       else if(slaveNum == MOT_EFFLUENT)
 0092           ;               StartLiquidMonitor(2);*/
 0092           ;       return 0;
 0092 0027              clr R16
 0094           L8:
 0094                   .dbline 0 ; func end
 0094 2896              adiw R28,8
 0096 0E940000          xcall pop_xgset303C
 009A 2296              adiw R28,2
 009C 0895              ret
 009E           ;            num -> R10,R11
 009E           ;        command -> y+0
 009E           ;              x -> R10,R11
 009E           ;       slaveNum -> R20
                        .even
 009E           _MotRunTo::
 009E 0E940000          xcall push_xgset300C
 00A2 5901              movw R10,R18
 00A4 402F              mov R20,R16
 00A6 2897              sbiw R28,8
 00A8           ; }
 00A8           ; unsigned char MotRunTo(unsigned char slaveNum, signed int x){
 00A8           ;       COMMAND_STRING command;
 00A8           ;       unsigned int num;
 00A8           ;       if(slaveNum>=SLAVE_NUM)
 00A8 4F30              cpi R20,15
 00AA 10F0              brlo L18
 00AC           X2:
 00AC           ; 		return 1;
 00AC 01E0              ldi R16,1
 00AE 18C0              xjmp L17
 00B0           L18:
 00B0           ; 	SetMotPosIdle(slaveNum);
 00B0 042F              mov R16,R20
 00B2 1127              clr R17
 00B4 0E940000          xcall _SetMotPosIdle
 00B8           ; //    if(GetSlaveState(slaveNum)==STA_SLAVE_FREE){    // 在电机为空闲状态下发送
 00B8           ;               command.cmd = (slaveNum << 3) + 3;
 00B8 842F              mov R24,R20
 00BA 880F              lsl R24
 00BC 880F              lsl R24
 00BE 880F              lsl R24
 00C0 8D5F              subi R24,253    ; addi 3
 00C2 8883              std y+0,R24
 00C4           ;               command.cmdLen = 1+3;
 00C4 84E0              ldi R24,4
 00C6 8F83              std y+7,R24
 00C8           ;               num = (unsigned int)x;
 00C8           ;               command.pam[0] = CMD_MOT_RUN_TO;
 00C8 82E0              ldi R24,2
 00CA 8983              std y+1,R24
 00CC           ;               command.pam[1] = (unsigned char)(num>>8);
 00CC 1501              movw R2,R10
 00CE 232C              mov R2,R3
 00D0 3324              clr R3
 00D2 2A82              std y+2,R2
 00D4           ;               command.pam[2] = (unsigned char)num;
 00D4 AB82              std y+3,R10
 00D6           ;               InsertCommand(slaveNum, &command);
 00D6 9E01              movw R18,R28
 00D8 042F              mov R16,R20
 00DA 0E940000          xcall _InsertCommand
 00DE           ; //            }
 00DE           ;       return 0;
 00DE 0027              clr R16
 00E0           L17:
 00E0                   .dbline 0 ; func end
 00E0 2896              adiw R28,8
 00E2 0C940000          xjmp pop_xgset300C
 00E6           ;        command -> y+0
 00E6           ;      definePos -> R10
 00E6           ;       slaveNum -> R20
                        .even
 00E6           _MotRunToSite::
 00E6 AA92              st -y,R10
 00E8 4A93              st -y,R20
 00EA A22E              mov R10,R18
 00EC 402F              mov R20,R16
 00EE 2897              sbiw R28,8
 00F0           ; }
 00F0           ; unsigned char MotRunToSite(unsigned char slaveNum, unsigned char definePos){
 00F0           ;       COMMAND_STRING command;
 00F0           ;       if(slaveNum>=SLAVE_NUM)
 00F0 4F30              cpi R20,15
 00F2 10F0              brlo L27
 00F4           X3:
 00F4           ; 		return 1;
 00F4 01E0              ldi R16,1
 00F6 13C0              xjmp L26
 00F8           L27:
 00F8           ; 	SetMotPosIdle(slaveNum);
 00F8 042F              mov R16,R20
 00FA 1127              clr R17
 00FC 0E940000          xcall _SetMotPosIdle
 0100           ; //    if(GetSlaveState(slaveNum)==STA_SLAVE_FREE){    // 在电机为空闲状态下发送
 0100           ;               command.cmd = (slaveNum << 3) + 2;
 0100 842F              mov R24,R20
 0102 880F              lsl R24
 0104 880F              lsl R24
 0106 880F              lsl R24
 0108 8E5F              subi R24,254    ; addi 2
 010A 8883              std y+0,R24
 010C           ;               command.cmdLen = 1+2;
 010C 83E0              ldi R24,3
 010E 8F83              std y+7,R24
 0110           ;               command.pam[0] = CMD_MOT_RUN_TO_SITE;
 0110 8983              std y+1,R24
 0112           ;               command.pam[1] = definePos;
 0112 AA82              std y+2,R10
 0114           ;               InsertCommand(slaveNum, &command);
 0114 9E01              movw R18,R28
 0116 042F              mov R16,R20
 0118 0E940000          xcall _InsertCommand
 011C           ; //            }
 011C           ;       return 0;
 011C 0027              clr R16
 011E           L26:
 011E                   .dbline 0 ; func end
 011E 2896              adiw R28,8
 0120 4991              ld R20,y+
 0122 A990              ld R10,y+
 0124 0895              ret
 0126           ;        command -> y+0
 0126           ;        current -> R10
 0126           ;          accel -> R12
 0126           ;         maxVel -> R14
 0126           ;       slaveNum -> R20
                        .even
 0126           _SetMotRunPam::
 0126 0E940000          xcall push_xgset30FC
 012A E22E              mov R14,R18
 012C 402F              mov R20,R16
 012E 2897              sbiw R28,8
 0130 C888              ldd R12,y+16
 0132 AA88              ldd R10,y+18
 0134           ; }
 0134           ; unsigned char SetMotRunPam(unsigned char slaveNum, unsigned char maxVel, unsigned char accel, unsigned char current){
 0134           ;       COMMAND_STRING command;
 0134           ;       if(slaveNum>=SLAVE_NUM)
 0134 4F30              cpi R20,15
 0136 10F0              brlo L34
 0138           X4:
 0138           ; 		return 1;
 0138 01E0              ldi R16,1
 013A 12C0              xjmp L33
 013C           L34:
 013C           ; //	if(GetSlaveState(slaveNum)==STA_SLAVE_FREE){	// 在电机为空闲状态下发送
 013C           ; 		command.cmd = (slaveNum<<3) + 4;
 013C 842F              mov R24,R20
 013E 880F              lsl R24
 0140 880F              lsl R24
 0142 880F              lsl R24
 0144 8C5F              subi R24,252    ; addi 4
 0146 8883              std y+0,R24
 0148           ;               command.pam[0] = CMD_MOT_SET_PAM;
 0148 84E0              ldi R24,4
 014A 8983              std y+1,R24
 014C           ;               command.pam[1] = maxVel;
 014C EA82              std y+2,R14
 014E           ;               command.pam[2] = accel;
 014E CB82              std y+3,R12
 0150           ;               command.pam[3] = current;
 0150 AC82              std y+4,R10
 0152           ;               command.cmdLen = 5;
 0152 85E0              ldi R24,5
 0154 8F83              std y+7,R24
 0156           ;               InsertCommand(slaveNum, &command);
 0156 9E01              movw R18,R28
 0158 042F              mov R16,R20
 015A 0E940000          xcall _InsertCommand
 015E           ; //            }
 015E           ;       return 0;
 015E 0027              clr R16
 0160           L33:
 0160                   .dbline 0 ; func end
 0160 2896              adiw R28,8
 0162 0C940000          xjmp pop_xgset30FC
 0166           ;        command -> y+0
 0166           ;           lock -> R10
 0166           ;       slaveNum -> R20
                        .even
 0166           _MotSetLock::
 0166 AA92              st -y,R10
 0168 4A93              st -y,R20
 016A A22E              mov R10,R18
 016C 402F              mov R20,R16
 016E 2897              sbiw R28,8
 0170           ; }
 0170           ; unsigned char MotSetLock(unsigned char slaveNum, unsigned char lock){
 0170           ;       COMMAND_STRING command;
 0170           ;       if(slaveNum>=SLAVE_NUM)
 0170 4F30              cpi R20,15
 0172 10F0              brlo L45
 0174           X5:
 0174           ; 		return 1;
 0174 01E0              ldi R16,1
 0176 10C0              xjmp L44
 0178           L45:
 0178           ; //	if(GetSlaveState(slaveNum)==STA_SLAVE_FREE){	// 在电机为空闲状态下发送
 0178           ; 		command.cmd = (slaveNum << 3) + 2;
 0178 842F              mov R24,R20
 017A 880F              lsl R24
 017C 880F              lsl R24
 017E 880F              lsl R24
 0180 8E5F              subi R24,254    ; addi 2
 0182 8883              std y+0,R24
 0184           ;               command.cmdLen = 1 + 2;
 0184 83E0              ldi R24,3
 0186 8F83              std y+7,R24
 0188           ;               command.pam[0] = CMD_MOT_ENABLE;
 0188 2224              clr R2
 018A 2982              std y+1,R2
 018C           ;               command.pam[1] = lock;
 018C AA82              std y+2,R10
 018E           ;               InsertCommand(slaveNum, &command);
 018E 9E01              movw R18,R28
 0190 042F              mov R16,R20
 0192 0E940000          xcall _InsertCommand
 0196           ; //            }
 0196           ;       return 0;
 0196 0027              clr R16
 0198           L44:
 0198                   .dbline 0 ; func end
 0198 2896              adiw R28,8
 019A 4991              ld R20,y+
 019C A990              ld R10,y+
 019E 0895              ret
 01A0           ;         enable -> <dead>
 01A0           ;       slaveNum -> <dead>
                        .even
 01A0           _MotSetEnable::
 01A0 0E940000          xcall push_arg4
 01A4           ; }
 01A4           ; unsigned char MotSetEnable(unsigned char slaveNum, unsigned char enable){
 01A4           ; /*    COMMAND_STRING command;
 01A4           ;       command.cmd = (slaveNum<<3) | CMD_MOT_ENABLE;
 01A4           ;       command.cmdLen = 1+1;
 01A4           ;       command.pam[0] = enable;
 01A4           ;       InsertCommand(slaveNum, &command);*/
 01A4           ;       return 0;
 01A4 0027              clr R16
 01A6           L51:
 01A6                   .dbline 0 ; func end
 01A6 2496              adiw R28,4
 01A8 0895              ret
 01AA           ;        command -> y+0
 01AA           ;       slaveNum -> R20
                        .even
 01AA           _GetMotPositionFromSlave::
 01AA 4A93              st -y,R20
 01AC 402F              mov R20,R16
 01AE 2897              sbiw R28,8
 01B0           ; }
 01B0           ; unsigned char GetMotPositionFromSlave(unsigned char slaveNum){
 01B0           ;       COMMAND_STRING command;
 01B0           ;       if(slaveNum>=SLAVE_NUM)
 01B0 4F30              cpi R20,15
 01B2 10F0              brlo L53
 01B4           X6:
 01B4           ; 		return 1;
 01B4 01E0              ldi R16,1
 01B6 0FC0              xjmp L52
 01B8           L53:
 01B8           ; //	if(GetSlaveState(slaveNum)==(STA_SLAVE_FREE)){	// 在电机为空闲状态下发送
 01B8           ; 		command.cmd = (slaveNum<<3) + 1;
 01B8 842F              mov R24,R20
 01BA 880F              lsl R24
 01BC 880F              lsl R24
 01BE 880F              lsl R24
 01C0 8F5F              subi R24,255    ; addi 1
 01C2 8883              std y+0,R24
 01C4           ;               command.cmdLen = 1+1;
 01C4 82E0              ldi R24,2
 01C6 8F83              std y+7,R24
 01C8           ;               command.pam[0] = CMD_MOT_GET_POS;
 01C8 85E0              ldi R24,5
 01CA 8983              std y+1,R24
 01CC           ;               InsertCommand(slaveNum, &command);
 01CC 9E01              movw R18,R28
 01CE 042F              mov R16,R20
 01D0 0E940000          xcall _InsertCommand
 01D4           ; //            }
 01D4           ;       return 0;
 01D4 0027              clr R16
 01D6           L52:
 01D6                   .dbline 0 ; func end
 01D6 2896              adiw R28,8
 01D8 4991              ld R20,y+
 01DA 0895              ret
 01DC           ;          state -> R10
 01DC           ;        command -> y+0
 01DC           ;       slaveNum -> R20
                        .even
 01DC           _MotInitCheck::
 01DC AA92              st -y,R10
 01DE 4A93              st -y,R20
 01E0 402F              mov R20,R16
 01E2 2897              sbiw R28,8
 01E4           ; }
 01E4           ; 
 01E4           ; unsigned char MotInitCheck(unsigned char slaveNum){
 01E4           ;       COMMAND_STRING command;
 01E4           ;       unsigned char state;
 01E4           ;       if(slaveNum>=SLAVE_NUM)
 01E4 4F30              cpi R20,15
 01E6 10F0              brlo L58
 01E8           X7:
 01E8           ; 		return 1;
 01E8 01E0              ldi R16,1
 01EA 17C0              xjmp L57
 01EC           L58:
 01EC           ; 	state = GetSlaveState(slaveNum);
 01EC 042F              mov R16,R20
 01EE 0E940000          xcall _GetSlaveState
 01F2 A02E              mov R10,R16
 01F4           ;       SetMotPosIdle(slaveNum);
 01F4 042F              mov R16,R20
 01F6 1127              clr R17
 01F8 0E940000          xcall _SetMotPosIdle
 01FC           ; //    if(state==STA_SLAVE_FREE){      // 在电机为空闲状态下发送
 01FC           ;               command.cmd = (slaveNum<<3) + 1;
 01FC 842F              mov R24,R20
 01FE 880F              lsl R24
 0200 880F              lsl R24
 0202 880F              lsl R24
 0204 8F5F              subi R24,255    ; addi 1
 0206 8883              std y+0,R24
 0208           ;               command.cmdLen = 1+1;
 0208 82E0              ldi R24,2
 020A 8F83              std y+7,R24
 020C           ;               command.pam[0] = CMD_MOT_INIT;
 020C 86E0              ldi R24,6
 020E 8983              std y+1,R24
 0210           ;               InsertCommand(slaveNum, &command);      
 0210 9E01              movw R18,R28
 0212 042F              mov R16,R20
 0214 0E940000          xcall _InsertCommand
 0218           ; //            }
 0218           ;       return 0;
 0218 0027              clr R16
 021A           L57:
 021A                   .dbline 0 ; func end
 021A 2896              adiw R28,8
 021C 4991              ld R20,y+
 021E A990              ld R10,y+
 0220 0895              ret
 0222           ;          state -> R12
 0222           ;        command -> y+0
 0222           ;         posNum -> R10,R11
 0222           ;       slaveNum -> R20
                        .even
 0222           _MotAdjustPosition::
 0222 0E940000          xcall push_xgset303C
 0226 5901              movw R10,R18
 0228 402F              mov R20,R16
 022A 2897              sbiw R28,8
 022C           ; }
 022C           ; unsigned char MotAdjustPosition(unsigned char slaveNum, unsigned posNum){
 022C           ;       COMMAND_STRING command;
 022C           ;       unsigned char state;
 022C           ;       if(slaveNum>=SLAVE_NUM)
 022C 4F30              cpi R20,15
 022E 10F0              brlo L63
 0230           X8:
 0230           ; 		return 1;
 0230 01E0              ldi R16,1
 0232 18C0              xjmp L62
 0234           L63:
 0234           ; 	state = GetSlaveState(slaveNum);
 0234 042F              mov R16,R20
 0236 0E940000          xcall _GetSlaveState
 023A C02E              mov R12,R16
 023C           ;       SetMotPosIdle(slaveNum);
 023C 042F              mov R16,R20
 023E 1127              clr R17
 0240 0E940000          xcall _SetMotPosIdle
 0244           ; //    if(state==STA_SLAVE_FREE){      // 在电机为空闲状态下发送
 0244           ;               command.cmd = (slaveNum<<3) + 2;
 0244 842F              mov R24,R20
 0246 880F              lsl R24
 0248 880F              lsl R24
 024A 880F              lsl R24
 024C 8E5F              subi R24,254    ; addi 2
 024E 8883              std y+0,R24
 0250           ;               command.cmdLen = 1+2;
 0250 83E0              ldi R24,3
 0252 8F83              std y+7,R24
 0254           ;               command.pam[0] = CMD_MOT_ADJUST;
 0254 87E0              ldi R24,7
 0256 8983              std y+1,R24
 0258           ;               command.pam[1] = posNum;
 0258 AA82              std y+2,R10
 025A           ;               
 025A           ;               InsertCommand(slaveNum, &command);
 025A 9E01              movw R18,R28
 025C 042F              mov R16,R20
 025E 0E940000          xcall _InsertCommand
 0262           ; //            }
 0262           ;       return 0;
 0262 0027              clr R16
 0264           L62:
 0264                   .dbline 0 ; func end
 0264 2896              adiw R28,8
 0266 0C940000          xjmp pop_xgset303C
 026A           ;          state -> R14
 026A           ;        command -> y+0
 026A           ;           pam1 -> R10
 026A           ;           pam0 -> R12
 026A           ;       slaveNum -> R20
                        .even
 026A           _MotSetPam::
 026A 0E940000          xcall push_xgset30FC
 026E C22E              mov R12,R18
 0270 402F              mov R20,R16
 0272 2897              sbiw R28,8
 0274 A888              ldd R10,y+16
 0276           ; }
 0276           ; unsigned char MotSetPam(unsigned char slaveNum, unsigned char pam0, unsigned char pam1){
 0276           ;       COMMAND_STRING command;
 0276           ;       unsigned char state;
 0276           ;       if(slaveNum>=SLAVE_NUM)
 0276 4F30              cpi R20,15
 0278 10F0              brlo L70
 027A           X9:
 027A           ; 		return 1;
 027A 01E0              ldi R16,1
 027C 15C0              xjmp L69
 027E           L70:
 027E           ; 	state = GetSlaveState(slaveNum);
 027E 042F              mov R16,R20
 0280 0E940000          xcall _GetSlaveState
 0284 E02E              mov R14,R16
 0286           ; //    if(state==STA_SLAVE_FREE){      // 在电机为空闲状态下发送
 0286           ;               command.cmd = (slaveNum<<3) + 3;
 0286 842F              mov R24,R20
 0288 880F              lsl R24
 028A 880F              lsl R24
 028C 880F              lsl R24
 028E 8D5F              subi R24,253    ; addi 3
 0290 8883              std y+0,R24
 0292           ;               command.cmdLen = 1+3;
 0292 84E0              ldi R24,4
 0294 8F83              std y+7,R24
 0296           ;               command.pam[0] = CMD_MOT_SET_BASE_PAM;
 0296 88E0              ldi R24,8
 0298 8983              std y+1,R24
 029A           ;               command.pam[1] = pam0;
 029A CA82              std y+2,R12
 029C           ;               command.pam[2] = pam1;
 029C AB82              std y+3,R10
 029E           ;               InsertCommand(slaveNum, &command);
 029E 9E01              movw R18,R28
 02A0 042F              mov R16,R20
 02A2 0E940000          xcall _InsertCommand
 02A6           ; //            }
 02A6           ;       return 0;
 02A6 0027              clr R16
 02A8           L69:
 02A8                   .dbline 0 ; func end
 02A8 2896              adiw R28,8
 02AA 0C940000          xjmp pop_xgset30FC
 02AE           ;        command -> y+0
 02AE           ;        address -> R10
                        .even
 02AE           _SlaveSetAddress::
 02AE AA92              st -y,R10
 02B0 A02E              mov R10,R16
 02B2 2897              sbiw R28,8
 02B4           ; }
 02B4           ; unsigned char SlaveSetAddress(unsigned char address){
 02B4           ;       COMMAND_STRING command;
 02B4           ;       if(address>SLAVE_NUM)
 02B4 8FE0              ldi R24,15
 02B6 8A15              cp R24,R10
 02B8 10F4              brsh L79
 02BA           X10:
 02BA           ; 		return 1;
 02BA 01E0              ldi R16,1
 02BC 13C0              xjmp L78
 02BE           L79:
 02BE           ; 	command.cmd = COMMON_ADDRESS + 3;
 02BE 83E0              ldi R24,3
 02C0 8883              std y+0,R24
 02C2           ;       command.cmdLen = 1+3;
 02C2 84E0              ldi R24,4
 02C4 8F83              std y+7,R24
 02C6           ;       command.pam[0] = CMD_MOT_SET_ADD;
 02C6 87E0              ldi R24,7
 02C8 8983              std y+1,R24
 02CA           ;       command.pam[1] = address;
 02CA AA82              std y+2,R10
 02CC           ;       command.pam[2] = 0xff - address;
 02CC 2A2C              mov R2,R10
 02CE 3324              clr R3
 02D0 8FEF              ldi R24,255
 02D2 90E0              ldi R25,0
 02D4 8219              sub R24,R2
 02D6 9309              sbc R25,R3
 02D8 8B83              std y+3,R24
 02DA           ;       //InsertCommand(COMMON_ADDRESS, &command);
 02DA           ;       InsertCommand(COMMON_ADDRESS, &command);
 02DA 9E01              movw R18,R28
 02DC 0027              clr R16
 02DE 0E940000          xcall _InsertCommand
 02E2           ;       //InsertUrgentCommand(address, &command);
 02E2           ;       return 0;
 02E2 0027              clr R16
 02E4           L78:
 02E4                   .dbline 0 ; func end
 02E4 2896              adiw R28,8
 02E6 A990              ld R10,y+
 02E8 0895              ret
 02EA           ;          state -> R14
 02EA           ;        command -> y+0
 02EA           ;             sw -> R10
 02EA           ;          evNum -> R12
                        .even
 02EA           _SetEValve::
 02EA 0E940000          xcall push_xgset00FC
 02EE A22E              mov R10,R18
 02F0 C02E              mov R12,R16
 02F2 2897              sbiw R28,8
 02F4           ; }
 02F4           ; /*********************************************************************************************/
 02F4           ; 
 02F4           ; /************************************* 液路控制 **********************************************/
 02F4           ; unsigned char SetEValve(unsigned char evNum, unsigned char sw){
 02F4           ;       // evNum:[1:5]阀编号，[0]为所有阀;
 02F4           ;       // sw:开光状态，0关闭，1打开
 02F4           ;       COMMAND_STRING command;
 02F4           ;       unsigned char state;
 02F4           ;       state = GetSlaveState(LIQUID_CONTROL);
 02F4 0DE0              ldi R16,13
 02F6 0E940000          xcall _GetSlaveState
 02FA E02E              mov R14,R16
 02FC           ; //    if(state==STA_SLAVE_FREE){      // 在电机为空闲状态下发送
 02FC           ;               command.cmd = (LIQUID_CONTROL << 3) + 3;
 02FC 8BE6              ldi R24,107
 02FE 8883              std y+0,R24
 0300           ;               command.pam[0] = CMD_LIQ_SET_VALVE;
 0300 81E0              ldi R24,1
 0302 8983              std y+1,R24
 0304           ;               command.pam[1] = evNum;
 0304 CA82              std y+2,R12
 0306           ;               command.pam[2] = sw;
 0306 AB82              std y+3,R10
 0308           ;               command.cmdLen = 4;
 0308 84E0              ldi R24,4
 030A 8F83              std y+7,R24
 030C           ;               
 030C           ;               InsertCommand(LIQUID_CONTROL, &command);
 030C 9E01              movw R18,R28
 030E 0DE0              ldi R16,13
 0310 0E940000          xcall _InsertCommand
 0314           ; //            }
 0314           ;       return 0;
 0314 0027              clr R16
 0316           L87:
 0316                   .dbline 0 ; func end
 0316 2896              adiw R28,8
 0318 0C940000          xjmp pop_xgset00FC
 031C           ;          state -> R12
 031C           ;        command -> y+0
 031C           ;          phNum -> R10
                        .even
 031C           _GetLiquidState::
 031C AA92              st -y,R10
 031E CA92              st -y,R12
 0320 A02E              mov R10,R16
 0322 2897              sbiw R28,8
 0324           ; }
 0324           ; 
 0324           ; unsigned char GetLiquidState(unsigned char phNum){
 0324           ;       // 获取液路传感器状态
 0324           ;       COMMAND_STRING command;
 0324           ;       unsigned char state;
 0324           ;       state = GetSlaveState(LIQUID_CONTROL);
 0324 0DE0              ldi R16,13
 0326 0E940000          xcall _GetSlaveState
 032A C02E              mov R12,R16
 032C           ; //    if(state==STA_SLAVE_FREE){      // 在电机为空闲状态下发送
 032C           ;               command.cmd = (LIQUID_CONTROL<<3) + 2;
 032C 8AE6              ldi R24,106
 032E 8883              std y+0,R24
 0330           ;               command.pam[0] = CMD_LIQ_GET_STATE;
 0330 82E0              ldi R24,2
 0332 8983              std y+1,R24
 0334           ;               command.pam[1] = phNum;
 0334 AA82              std y+2,R10
 0336           ;               command.cmdLen = 3;
 0336 83E0              ldi R24,3
 0338 8F83              std y+7,R24
 033A           ;               InsertCommand(LIQUID_CONTROL, &command);
 033A 9E01              movw R18,R28
 033C 0DE0              ldi R16,13
 033E 0E940000          xcall _InsertCommand
 0342           ; //            }
 0342           ;       return 0;
 0342 0027              clr R16
 0344           L94:
 0344                   .dbline 0 ; func end
 0344 2896              adiw R28,8
 0346 C990              ld R12,y+
 0348 A990              ld R10,y+
 034A 0895              ret
 034C           ;          state -> R14
 034C           ;        command -> y+0
 034C           ;           mode -> R10
 034C           ;          phNum -> R12
                        .even
 034C           _SetLiquidMonitor::
 034C 0E940000          xcall push_xgset00FC
 0350 A22E              mov R10,R18
 0352 C02E              mov R12,R16
 0354 2897              sbiw R28,8
 0356           ; }
 0356           ; 
 0356           ; unsigned char SetLiquidMonitor(unsigned char phNum, unsigned char mode){
 0356           ;       // 设置液路传感器监测模式
 0356           ;       COMMAND_STRING command;
 0356           ;       unsigned char state;
 0356           ;       state = GetSlaveState(LIQUID_CONTROL);
 0356 0DE0              ldi R16,13
 0358 0E940000          xcall _GetSlaveState
 035C E02E              mov R14,R16
 035E           ;       command.cmd = (LIQUID_CONTROL<<3) + 3;
 035E 8BE6              ldi R24,107
 0360 8883              std y+0,R24
 0362           ;       command.pam[0] = CMD_LIQ_SET_MONITOR;
 0362 83E0              ldi R24,3
 0364 8983              std y+1,R24
 0366           ;       command.pam[1] = phNum;
 0366 CA82              std y+2,R12
 0368           ;       command.pam[2] = mode;          // 传感器工作模式 0：无效状态，1：普通模式，2：智能监测模式
 0368 AB82              std y+3,R10
 036A           ;       command.cmdLen = 4;
 036A 84E0              ldi R24,4
 036C 8F83              std y+7,R24
 036E           ;       InsertCommand(LIQUID_CONTROL, &command);
 036E 9E01              movw R18,R28
 0370 0DE0              ldi R16,13
 0372 0E940000          xcall _InsertCommand
 0376           ;       return 0;
 0376 0027              clr R16
 0378           L99:
 0378                   .dbline 0 ; func end
 0378 2896              adiw R28,8
 037A 0C940000          xjmp pop_xgset00FC
 037E           ;          state -> R12
 037E           ;        command -> y+0
 037E           ;          phNum -> R10
                        .even
 037E           _StartLiquidMonitor::
 037E AA92              st -y,R10
 0380 CA92              st -y,R12
 0382 A02E              mov R10,R16
 0384 2897              sbiw R28,8
 0386           ; }
 0386           ; 
 0386           ; unsigned char StartLiquidMonitor(unsigned char phNum){
 0386           ;       // 启动液路传感器监测
 0386           ;       COMMAND_STRING command;
 0386           ;       unsigned char state;
 0386           ;       state = GetSlaveState(LIQUID_CONTROL);
 0386 0DE0              ldi R16,13
 0388 0E940000          xcall _GetSlaveState
 038C C02E              mov R12,R16
 038E           ;       command.cmd = (LIQUID_CONTROL<<3) + 2;
 038E 8AE6              ldi R24,106
 0390 8883              std y+0,R24
 0392           ;       command.pam[0] = CMD_LIQ_START_MONITOR;
 0392 84E0              ldi R24,4
 0394 8983              std y+1,R24
 0396           ;       command.pam[1] = phNum;
 0396 AA82              std y+2,R10
 0398           ;       command.cmdLen = 3;
 0398 83E0              ldi R24,3
 039A 8F83              std y+7,R24
 039C           ;       InsertCommand(LIQUID_CONTROL, &command);
 039C 9E01              movw R18,R28
 039E 0DE0              ldi R16,13
 03A0 0E940000          xcall _InsertCommand
 03A4           ;       return 0;
 03A4 0027              clr R16
 03A6           L106:
 03A6                   .dbline 0 ; func end
 03A6 2896              adiw R28,8
 03A8 C990              ld R12,y+
 03AA A990              ld R10,y+
 03AC 0895              ret
 03AE           ;          state -> R12
 03AE           ;        command -> y+0
 03AE           ;          phNum -> R10
                        .even
 03AE           _ReadLiquidMonitorResult::
 03AE AA92              st -y,R10
 03B0 CA92              st -y,R12
 03B2 A02E              mov R10,R16
 03B4 2897              sbiw R28,8
 03B6           ; }
 03B6           ; 
 03B6           ; unsigned char ReadLiquidMonitorResult(unsigned char phNum){
 03B6           ;       // 读取液路传感器监测结果
 03B6           ;       COMMAND_STRING command;
 03B6           ;       unsigned char state;
 03B6           ;       state = GetSlaveState(LIQUID_CONTROL);
 03B6 0DE0              ldi R16,13
 03B8 0E940000          xcall _GetSlaveState
 03BC C02E              mov R12,R16
 03BE           ;       command.cmd = (LIQUID_CONTROL<<3) + 2;
 03BE 8AE6              ldi R24,106
 03C0 8883              std y+0,R24
 03C2           ;       command.pam[0] = CMD_LIQ_READ_MONITOR;
 03C2 85E0              ldi R24,5
 03C4 8983              std y+1,R24
 03C6           ;       command.pam[1] = phNum;
 03C6 AA82              std y+2,R10
 03C8           ;       command.cmdLen = 3;
 03C8 83E0              ldi R24,3
 03CA 8F83              std y+7,R24
 03CC           ;       InsertCommand(LIQUID_CONTROL, &command);
 03CC 9E01              movw R18,R28
 03CE 0DE0              ldi R16,13
 03D0 0E940000          xcall _InsertCommand
 03D4           ;       return 0;
 03D4 0027              clr R16
 03D6           L111:
 03D6                   .dbline 0 ; func end
 03D6 2896              adiw R28,8
 03D8 C990              ld R12,y+
 03DA A990              ld R10,y+
 03DC 0895              ret
 03DE           ;        command -> y+0
 03DE           ;          phNum -> R10
                        .even
 03DE           _SetLiquidPhotoAdjust::
 03DE AA92              st -y,R10
 03E0 A02E              mov R10,R16
 03E2 2897              sbiw R28,8
 03E4           ; }
 03E4           ; 
 03E4           ; unsigned char SetLiquidPhotoAdjust(unsigned char phNum){
 03E4           ;       // 校准液路光耦
 03E4           ;       COMMAND_STRING command;
 03E4           ;       
 03E4           ;       command.cmd = (LIQUID_CONTROL<<3) + 2;
 03E4 8AE6              ldi R24,106
 03E6 8883              std y+0,R24
 03E8           ;       command.pam[0] = CMD_LIQ_CAL_PHOTO;
 03E8 86E0              ldi R24,6
 03EA 8983              std y+1,R24
 03EC           ;       command.pam[1] = phNum;
 03EC AA82              std y+2,R10
 03EE           ;       command.cmdLen = 3;
 03EE 83E0              ldi R24,3
 03F0 8F83              std y+7,R24
 03F2           ;       InsertCommand(LIQUID_CONTROL, &command);
 03F2 9E01              movw R18,R28
 03F4 0DE0              ldi R16,13
 03F6 0E940000          xcall _InsertCommand
 03FA           ;       return 0;
 03FA 0027              clr R16
 03FC           L116:
 03FC                   .dbline 0 ; func end
 03FC 2896              adiw R28,8
 03FE A990              ld R10,y+
 0400 0895              ret
 0402           ;        command -> y+0
                        .even
 0402           _GetLiquidPhotoInfo::
 0402 2897              sbiw R28,8
 0404           ; }
 0404           ; 
 0404           ; unsigned char GetLiquidPhotoInfo(void){
 0404           ;       // 获取液路传感器输出值
 0404           ;       COMMAND_STRING command;
 0404           ;       
 0404           ;       command.cmd = (LIQUID_CONTROL<<3) + 1;
 0404 89E6              ldi R24,105
 0406 8883              std y+0,R24
 0408           ;       command.pam[0] = CMD_LIQ_GET_PHOTO;
 0408 87E0              ldi R24,7
 040A 8983              std y+1,R24
 040C           ;       command.cmdLen = 2;
 040C 82E0              ldi R24,2
 040E 8F83              std y+7,R24
 0410           ;       InsertCommand(LIQUID_CONTROL, &command);
 0410 9E01              movw R18,R28
 0412 0DE0              ldi R16,13
 0414 0E940000          xcall _InsertCommand
 0418           ;       return 0;
 0418 0027              clr R16
 041A           L121:
 041A                   .dbline 0 ; func end
 041A 2896              adiw R28,8
 041C 0895              ret
 041E           ;        command -> y+0
 041E           ;         liqNum -> R10
                        .even
 041E           _LiquidFlowCheck::
 041E AA92              st -y,R10
 0420 A02E              mov R10,R16
 0422 2897              sbiw R28,8
 0424           ; }
 0424           ; 
 0424           ; unsigned char LiquidFlowCheck(unsigned char liqNum){
 0424           ;       // 液路流量检查
 0424           ;       COMMAND_STRING command;
 0424           ; 
 0424           ;       command.cmd = (LIQUID_CONTROL<<3) + 2;
 0424 8AE6              ldi R24,106
 0426 8883              std y+0,R24
 0428           ;       command.pam[0] = CMD_LIQ_FLOW_CHECK;
 0428 88E0              ldi R24,8
 042A 8983              std y+1,R24
 042C           ;       command.pam[1] = liqNum;
 042C AA82              std y+2,R10
 042E           ;       command.cmdLen = 3;
 042E 83E0              ldi R24,3
 0430 8F83              std y+7,R24
 0432           ;       InsertCommand(LIQUID_CONTROL, &command);
 0432 9E01              movw R18,R28
 0434 0DE0              ldi R16,13
 0436 0E940000          xcall _InsertCommand
 043A           ;       return 0;
 043A 0027              clr R16
 043C           L124:
 043C                   .dbline 0 ; func end
 043C 2896              adiw R28,8
 043E A990              ld R10,y+
 0440 0895              ret
 0442           ;        command -> y+0
 0442           ;          chNum -> R20
                        .even
 0442           _GetStoreState::
 0442 4A93              st -y,R20
 0444 402F              mov R20,R16
 0446 2897              sbiw R28,8
 0448           ; }
 0448           ; /*********************************************************************************************/
 0448           ; 
 0448           ; /************************************* 片仓控制 **********************************************/
 0448           ; 
 0448           ; unsigned char GetStoreState(unsigned  char chNum){
 0448           ;       // 获取片仓状态,0:所有片仓状态;1:指定片仓状态.
 0448           ;       // 0xff:片仓打开,状态无效
 0448           ;       // 0/
 0448           ;       // 0~3:片仓状态
 0448           ;       COMMAND_STRING command;
 0448           ;       if(chNum>6)
 0448 86E0              ldi R24,6
 044A 8417              cp R24,R20
 044C 08F4              brsh L130
 044E           X11:
 044E           ; 		chNum = 6;
 044E 46E0              ldi R20,6
 0450           L130:
 0450           ; 	command.cmd = (STORE_MONITOR<<3) + 2;
 0450 82E7              ldi R24,114
 0452 8883              std y+0,R24
 0454           ;       command.pam[0] = CMD_STORE_GET_STATE;
 0454 81E0              ldi R24,1
 0456 8983              std y+1,R24
 0458           ;       command.pam[1] = chNum;
 0458 4A83              std y+2,R20
 045A           ;       command.cmdLen = 3;
 045A 83E0              ldi R24,3
 045C 8F83              std y+7,R24
 045E           ;       InsertCommand(STORE_MONITOR, &command);
 045E 9E01              movw R18,R28
 0460 0EE0              ldi R16,14
 0462 0E940000          xcall _InsertCommand
 0466           ;       return 0;
 0466 0027              clr R16
 0468           L129:
 0468                   .dbline 0 ; func end
 0468 2896              adiw R28,8
 046A 4991              ld R20,y+
 046C 0895              ret
 046E           ;        command -> y+0
 046E           ;            num -> R10
                        .even
 046E           _SetStoreCAL::
 046E AA92              st -y,R10
 0470 A02E              mov R10,R16
 0472 2897              sbiw R28,8
 0474           ; }
 0474           ; 
 0474           ; unsigned char SetStoreCAL(unsigned char num){
 0474           ;       // 片仓光路校准
 0474           ;       COMMAND_STRING command;
 0474           ; 
 0474           ;       command.cmd = (STORE_MONITOR<<3) + 2;
 0474 82E7              ldi R24,114
 0476 8883              std y+0,R24
 0478           ;       command.pam[0] = CMD_STORE_CAL;
 0478 83E0              ldi R24,3
 047A 8983              std y+1,R24
 047C           ;       command.pam[1] = num;
 047C AA82              std y+2,R10
 047E           ;       command.cmdLen = 3;
 047E 8F83              std y+7,R24
 0480           ;       InsertCommand(STORE_MONITOR, &command);
 0480 9E01              movw R18,R28
 0482 0EE0              ldi R16,14
 0484 0E940000          xcall _InsertCommand
 0488           ;       return 0;
 0488 0027              clr R16
 048A           L136:
 048A                   .dbline 0 ; func end
 048A 2896              adiw R28,8
 048C A990              ld R10,y+
 048E 0895              ret
 0490           ;        command -> y+0
 0490           ;            num -> R10
                        .even
 0490           _GetStorePhoVol::
 0490 AA92              st -y,R10
 0492 A02E              mov R10,R16
 0494 2897              sbiw R28,8
 0496           ; }
 0496           ; 
 0496           ; unsigned char GetStorePhoVol(unsigned char num){
 0496           ;       // 获取光路电压值
 0496           ;       COMMAND_STRING command;
 0496           ; //    if(num == 0)
 0496           ; //            num = 1;
 0496           ; //    if(num>6)
 0496           ; //            num = 6;
 0496           ;       command.cmd = (STORE_MONITOR<<3) + 2;
 0496 82E7              ldi R24,114
 0498 8883              std y+0,R24
 049A           ;       command.pam[0] = CMD_STORE_GET_VOL;
 049A 84E0              ldi R24,4
 049C 8983              std y+1,R24
 049E           ;       command.pam[1] = num;
 049E AA82              std y+2,R10
 04A0           ;       command.cmdLen = 3;
 04A0 83E0              ldi R24,3
 04A2 8F83              std y+7,R24
 04A4           ;       InsertCommand(STORE_MONITOR, &command);
 04A4 9E01              movw R18,R28
 04A6 0EE0              ldi R16,14
 04A8 0E940000          xcall _InsertCommand
 04AC           ;       return 0;
 04AC 0027              clr R16
 04AE           L141:
 04AE                   .dbline 0 ; func end
 04AE 2896              adiw R28,8
 04B0 A990              ld R10,y+
 04B2 0895              ret
 04B4           ;        command -> y+0
 04B4           ;            num -> R10
                        .even
 04B4           _SetStoreDoorOpen::
 04B4 AA92              st -y,R10
 04B6 A02E              mov R10,R16
 04B8 2897              sbiw R28,8
 04BA           ; }
 04BA           ; 
 04BA           ; unsigned char SetStoreDoorOpen(unsigned char num){
 04BA           ;       // 开启片仓门
 04BA           ;       COMMAND_STRING command;
 04BA           ; //    if(num == 0)
 04BA           ; //            num = 1;
 04BA           ; //    if(num>6)
 04BA           ; //            num = 6;
 04BA           ;       command.cmd = (STORE_MONITOR<<3) + 2;
 04BA 82E7              ldi R24,114
 04BC 8883              std y+0,R24
 04BE           ;       command.pam[0] = CMD_STORE_OPEN;
 04BE 85E0              ldi R24,5
 04C0 8983              std y+1,R24
 04C2           ;       command.pam[1] = num;
 04C2 AA82              std y+2,R10
 04C4           ;       command.cmdLen = 3;
 04C4 83E0              ldi R24,3
 04C6 8F83              std y+7,R24
 04C8           ;       InsertCommand(STORE_MONITOR, &command);
 04C8 9E01              movw R18,R28
 04CA 0EE0              ldi R16,14
 04CC 0E940000          xcall _InsertCommand
 04D0           ;       return 0;
 04D0 0027              clr R16
 04D2           L146:
 04D2                   .dbline 0 ; func end
 04D2 2896              adiw R28,8
 04D4 A990              ld R10,y+
 04D6 0895              ret
 04D8           ; }
