Interrupt Vectors
    00000 940C 1309 JMP	__start|__text_start
    00016 940C 9A1C JMP	_pcint2_isr
    00028 940C 97DD JMP	_timer1_ovf_isr
    0002E 940C 975A JMP	_timer0_ovf_isr
    00032 940C 98F5 JMP	_uart0_rx_isr
    00036 940C 9928 JMP	_uart0_tx_isr
    0003A 940C 9ADD JMP	_adc_isr
    00048 940C 993A JMP	_uart1_rx_isr
    0004E 940C 6CA0 JMP	_twi_isr
    00066 940C 994F JMP	_uart2_rx_isr
    0006A 940C 9998 JMP	_uart2_tx_isr
    0006C 940C 99DD JMP	_uart3_rx_isr
    00070 940C 99F2 JMP	_uart3_tx_isr

Program Code (text area)
_InitCommandTransferData:
  p                    --> R18
  i                    --> R16
    01276 0000      NOP
    01277 332A      CPI	R18,0x3A
    01278 3433      CPI	R19,0x43
FILE: D:\Work\主控软件\2032A2~1\BusTransmissionLayer.c
(0086) 
    01279 2034      AND	R3,R4
    0127A 6157      ORI	R21,0x17
(0087) #include <iom1280v.h>
    0127B 7469      ANDI	R22,0x49
    0127C 6341      ORI	R20,0x31
    0127D 4F6B      SBCI	R22,0xFB
(0088) #include <macros.h>
    0127E 7475      ANDI	R23,0x45
    0127F 664F      ORI	R20,0x6F
    01280 6954      ORI	R21,0x94
    01281 656D      ORI	R22,0x5D
    01282 0A0D      SBC	R0,R29
    01283 2F00      MOV	R16,R16
    01284 202F      AND	R2,R15
    01285 694C      ORI	R20,0x9C
    01286 7571      ANDI	R23,0x51
    01287 6469      ORI	R22,0x49
(0089) #include "B1404_LIB.h"
(0090) #include "LibCommon.h"
(0091) 
(0092) 
(0093) 
(0094) /************************* 从机命令缓冲区 **************************/
    01288 6420      ORI	R18,0x40
    01289 7465      ANDI	R22,0x45
(0095) typedef struct _COMMAND_BUF{
    0128A 6365      ORI	R22,0x35
    0128B 3A74      CPI	R23,0xA4
    0128C 2520      EOR	R18,R0
(0096) 	COMMAND_STRING buf[COMMAND_BUF_LEN];
    0128D 0D64      ADD	R22,R4
    0128E 000A      NOP
    0128F 3221      CPI	R18,0x21
    01290 3039      CPI	R19,0x9
    01291 2032      AND	R3,R2
    01292 2524      EOR	R18,R4
    01293 0D64      ADD	R22,R4
    01294 000A      NOP
    01295 3221      CPI	R18,0x21
    01296 3039      CPI	R19,0x9
(0097) 	unsigned char pTop;
(0098) 	unsigned char pEnd;
    01297 2031      AND	R3,R1
    01298 2524      EOR	R18,R4
(0099) 	unsigned char transmitState;	// 命令发送状态 0已经执行完毕或空命令，1新命令存入等待送， 2新命令已发送处于执行状态
    01299 0D64      ADD	R22,R4
    0129A 000A      NOP
    0129B 7325      ANDI	R18,0x35
(0100) }COMMAND_BUF;
    0129C 2420      EOR	R2,R0
    0129D 6425      ORI	R18,0x45
    0129E 0A0D      SBC	R0,R29
    0129F 2000      TST	R0
    012A0 2024      AND	R2,R4
    012A1 0D00      ADD	R16,R0
    012A2 000A      NOP
    012A3 2420      EOR	R2,R0
    012A4 3425      CPI	R18,0x45
    012A5 2064      AND	R6,R4
(0101) 
(0102) // 命令发送控制
    012A6 2524      EOR	R18,R4
    012A7 6434      ORI	R19,0x44
(0103) typedef struct _COMMAND_TRANSMIT_CONTROL{
    012A8 2420      EOR	R2,R0
    012A9 0020      NOP
    012AA 2420      EOR	R2,R0
(0104) 	unsigned char registerSlave[SLAVE_NUM];	// 使用的从机在这里登记
    012AB 3425      CPI	R18,0x45
    012AC 0D64      ADD	R22,R4
    012AD 000A      NOP
    012AE 7325      ANDI	R18,0x35
    012AF 2420      EOR	R2,R0
    012B0 0020      NOP
    012B1 7325      ANDI	R18,0x35
    012B2 2420      EOR	R2,R0
    012B3 3425      CPI	R18,0x45
    012B4 2064      AND	R6,R4
    012B5 2524      EOR	R18,R4
_AddInfoEventToStack:
  pEnd                 --> R10
  p                    --> R20
  pChar                --> R22
  i                    --> R10
  len                  --> R14
  info                 --> R12
  slave                --> Y,+10
    012B6 6434      ORI	R19,0x44
    012B7 0A0D      SBC	R0,R29
    012B8 2A00      OR	R0,R16
    012B9 3233      CPI	R19,0x23
    012BA 3530      CPI	R19,0x50
    012BB 5420      SUBI	R18,0x40
(0105) 	unsigned char curSlave;					// 当前的通信的从机
(0106) 	unsigned char waitCount;				// 信息返回超时计时
(0107) 	COMMAND_BUF cmdBuf[SLAVE_NUM];			// 命令缓冲组，每个元素下标表示相应的从机编号
(0108) 	unsigned char slaveState[SLAVE_NUM];	// 记录每个从机的状态
(0109) }COMMAND_TRANSMIT_CONTROL;
(0110) // 当前命令发送缓冲区
(0111) typedef struct _TRANSFER_BUF{
(0112) 	COMMAND_STRING cmd;
(0113) 	unsigned char pSend;					// 命令数据发送指针
    012BC 7365      ANDI	R22,0x35
    012BD 4274      SBCI	R23,0x24
(0114) }TRANSFER_BUF;
    012BE 7453      ANDI	R21,0x43
(0115) 
    012BF 7065      ANDI	R22,5
(0116) /*typedef struct _COMMAND_URGENT_BUF{
    012C0 7453      ANDI	R21,0x43
    012C1 7461      ANDI	R22,0x41
(0117) 	COMMAND_STRING buf[COMMAND_BUF_LEN];
    012C2 2065      AND	R6,R5
(0118) 	unsigned char slaveNum[COMMAND_BUF_LEN];	// 命令对应的从机号
    012C3 2524      EOR	R18,R4
    012C4 6432      ORI	R19,0x42
    012C5 2420      EOR	R2,R0
    012C6 3225      CPI	R18,0x25
    012C7 0D64      ADD	R22,R4
(0119) 	unsigned char pTop;
    012C8 000A      NOP
    012C9 332A      CPI	R18,0x3A
    012CA 3032      CPI	R19,2
    012CB 2034      AND	R3,R4
    012CC 6554      ORI	R21,0x54
    012CD 7473      ANDI	R23,0x43
    012CE 5341      SUBI	R20,0x31
    012CF 6574      ORI	R23,0x54
    012D0 5370      SUBI	R23,0x30
    012D1 6174      ORI	R23,0x14
(0120) 	unsigned char pEnd;
    012D2 6574      ORI	R23,0x54
    012D3 2420      EOR	R2,R0
    012D4 3225      CPI	R18,0x25
    012D5 2064      AND	R6,R4
    012D6 2524      EOR	R18,R4
    012D7 6432      ORI	R19,0x42
    012D8 0A0D      SBC	R0,R29
    012D9 2500      EOR	R16,R0
    012DA 0D73      ADD	R23,R3
    012DB 000A      NOP
(0121) }COMMAND_URGENT_BUF;*/
    012DC 0025      NOP
(0122) typedef struct _COMMAND_URGENT_BUF{
    012DD 0D00      ADD	R16,R0
    012DE 000A      NOP
    012DF 2420      EOR	R2,R0
    012E0 3425      CPI	R18,0x45
    012E1 2064      AND	R6,R4
    012E2 2024      AND	R2,R4
    012E3 2500      EOR	R16,R0
(0123) 	COMMAND_STRING buf[SLAVE_NUM];	// 数组下标对应从机号
    012E4 2073      AND	R7,R3
    012E5 2024      AND	R2,R4
    012E6 2500      EOR	R16,R0
    012E7 2073      AND	R7,R3
    012E8 2524      EOR	R18,R4
    012E9 6434      ORI	R19,0x44
(0124) 	unsigned char state[SLAVE_NUM];	// 命令有效状态, 0:无效，1:有效
    012EA 2420      EOR	R2,R0
    012EB 3425      CPI	R18,0x45
(0125) //	unsigned char pTop;
    012EC 0D64      ADD	R22,R4
    012ED 000A      NOP
    012EE 7325      ANDI	R18,0x35
    012EF 2420      EOR	R2,R0
    012F0 2520      EOR	R18,R0
    012F1 0D64      ADD	R22,R4
    012F2 000A      NOP
    012F3 332A      CPI	R18,0x3A
    012F4 3032      CPI	R19,2
(0126) //	unsigned char pEnd;
(0127) }COMMAND_URGENT_BUF;
    012F5 2032      AND	R3,R2
    012F6 6E55      ORI	R21,0xE5
(0128) 
    012F7 6F6C      ORI	R22,0xFC
(0129) 
(0130) /*************************** 信息事件堆 *****************************/
(0131) 
    012F8 6461      ORI	R22,0x41
    012F9 7453      ANDI	R21,0x43
    012FA 7065      ANDI	R22,5
    012FB 7453      ANDI	R21,0x43
    012FC 7461      ANDI	R22,0x41
(0132) // 信息事件队列
    012FD 2065      AND	R6,R5
    012FE 2524      EOR	R18,R4
    012FF 6432      ORI	R19,0x42
    01300 2420      EOR	R2,R0
    01301 3225      CPI	R18,0x25
    01302 0D64      ADD	R22,R4
(0133) typedef struct _INFO_EVENT_STACK{	// 信息事件队列
    01303 000A      NOP
    01304 7325      ANDI	R18,0x35
    01305 2420      EOR	R2,R0
    01306 3425      CPI	R18,0x45
    01307 0D64      ADD	R22,R4
(0134) 	unsigned char pTop;
    01308 000A      NOP
__start|__text_start:
    01309 EFCF      LDI	R28,0xFF
    0130A E2D1      LDI	R29,0x21
    0130B BFCD      OUT	0x3D,R28
_SetTransferBufStateQueryCmd:
  slaveNum             --> R20
    0130C BFDE      OUT	0x3E,R29
    0130D 51CE      SUBI	R28,0x1E
    0130E 40D0      SBCI	R29,0
(0135) 	unsigned char pEnd;
(0136) 	INFO_EVENT info[INFO_EVENT_NUM];
(0137) }INFO_EVENT_STACK;
(0138) /*************************** 错误事件堆 *****************************
(0139) typedef struct _ERROR_EVENT{
(0140) 	unsigned char slaveNum;				// 从机编号
(0141) 	unsigned char error;				// 错误信息
(0142) }ERROR_EVENT;
(0143) typedef struct _ERROR_EVENT_STACK{
(0144) 	unsigned char pTop;
(0145) 	unsigned char pEnd;
(0146) 	unsigned char error[ERROR_EVENT_NUM];
(0147) }ERROR_EVENT_STACK;
(0148) */
(0149) typedef struct _DEVIVE_INFO{
(0150) 	unsigned char buf[20];
(0151) 	unsigned char pRec;
(0152) 	unsigned char infoLen;
(0153) 	unsigned char isValid;
(0154) }DEVICE_INFO;
(0155) 
(0156) 
(0157) INFO_EVENT_STACK InfoEventStack;
    0130F EA0A      LDI	R16,0xAA
    01310 8308      ST	Y,R16
(0158) //ERROR_EVENT_STACK ErrorEventStack;
(0159) COMMAND_TRANSMIT_CONTROL TransmitControl;
    01311 2400      CLR	R0
    01312 E9E7      LDI	R30,0x97
    01313 E0FA      LDI	R31,0xA
    01314 E11E      LDI	R17,0x1E
    01315 38ED      CPI	R30,0x8D
(0160) TRANSFER_BUF TransferBuf;
    01316 07F1      CPC	R31,R17
    01317 F011      BEQ	0x131A
    01318 9201      ST	Z+,R0
    01319 CFFB      RJMP	0x1315
(0161) unsigned char TransferStart;		// 命令传输启动标识
    0131A 8300      ST	Z,R16
    0131B E7EB      LDI	R30,0x7B
    0131C E1FD      LDI	R31,0x1D
    0131D E0A0      LDI	R26,0
    0131E E0B2      LDI	R27,2
(0162) DEVICE_INFO DeviceInfo;
(0163) COMMAND_URGENT_BUF CmdUrgentBuf;	// 紧急命令
    0131F E216      LDI	R17,0x26
    01320 E000      LDI	R16,0
    01321 BF0B      OUT	0x3B,R16
    01322 31E2      CPI	R30,0x12
    01323 07F1      CPC	R31,R17
    01324 F021      BEQ	0x1329
    01325 95C8      LPM
    01326 9631      ADIW	R30,1
    01327 920D      ST	X+,R0
(0164) extern unsigned char ControlModel;			// 0:正常， 1:超级终端调试
(0165) 
(0166) void InitCommandTransferData(void){
    01328 CFF9      RJMP	0x1322
    01329 940E 71E1 CALL	_main
_exit:
    0132B CFFF      RJMP	_exit
_InitCommandTransferData:
    0132C 2422      CLR	R2
    0132D 9220 0B39 STS	TransferStart,R2
    0132F E928      LDI	R18,0x98
    01330 E132      LDI	R19,0x12
    01331 2700      CLR	R16
    01332 2711      CLR	R17
    01333 C006      RJMP	0x133A
    01334 2422      CLR	R2
    01335 01F9      MOVW	R30,R18
    01336 9221      ST	Z+,R2
    01337 019F      MOVW	R18,R30
    01338 5F0F      SUBI	R16,0xFF
    01339 4F1F      SBCI	R17,0xFF
(0167) 	unsigned int i;
    0133A 380C      CPI	R16,0x8C
    0133B E0E2      LDI	R30,2
    0133C 071E      CPC	R17,R30
    0133D F3B0      BCS	0x1334
    0133E E423      LDI	R18,0x43
    0133F E03B      LDI	R19,0xB
    01340 2700      CLR	R16
    01341 2711      CLR	R17
(0168) 	unsigned char *p;
    01342 C006      RJMP	0x1349
(0169) 
(0170) 	TransferStart = 0;
(0171) 	p = (unsigned char *)&InfoEventStack;
    01343 2422      CLR	R2
    01344 01F9      MOVW	R30,R18
    01345 9221      ST	Z+,R2
    01346 019F      MOVW	R18,R30
    01347 5F0F      SUBI	R16,0xFF
    01348 4F1F      SBCI	R17,0xFF
    01349 3505      CPI	R16,0x55
(0172) 	for(i=0; i<sizeof(INFO_EVENT_STACK); i++){
    0134A E0E7      LDI	R30,7
    0134B 071E      CPC	R17,R30
    0134C F3B0      BCS	0x1343
(0173) 		*(p++) = 0;
    0134D E32A      LDI	R18,0x3A
    0134E E03B      LDI	R19,0xB
    0134F 2700      CLR	R16
_InsertCmdToTransferBuf:
  pEnd                 --> R12
  pTop                 --> R10
  pCmdBuf              --> R22
  slaveNum             --> R20
    01350 2711      CLR	R17
    01351 C006      RJMP	0x1358
    01352 2422      CLR	R2
    01353 01F9      MOVW	R30,R18
(0174) 		}
(0175) /*	p = (unsigned char *)&ErrorEventStack;
(0176) 	for(i=0; i<sizeof(ERROR_EVENT_STACK); i++){
(0177) 		*(p++) = 0;
(0178) 		}*/
(0179) 	p = (unsigned char *)&TransmitControl;
    01354 9221      ST	Z+,R2
    01355 019F      MOVW	R18,R30
(0180) 	for(i=0; i<sizeof(COMMAND_TRANSMIT_CONTROL); i++){
(0181) 		*(p++) = 0;
    01356 5F0F      SUBI	R16,0xFF
    01357 4F1F      SBCI	R17,0xFF
    01358 3009      CPI	R16,0x9
    01359 E0E0      LDI	R30,0
    0135A 071E      CPC	R17,R30
(0182) 		}
    0135B F3B0      BCS	0x1352
    0135C E92B      LDI	R18,0x9B
    0135D E03A      LDI	R19,0xA
    0135E 2700      CLR	R16
(0183) 	p = (unsigned char *)&TransferBuf;
    0135F 2711      CLR	R17
    01360 C006      RJMP	0x1367
    01361 2422      CLR	R2
    01362 01F9      MOVW	R30,R18
    01363 9221      ST	Z+,R2
(0184) 	for(i=0; i<sizeof(TRANSFER_BUF); i++){
(0185) 		*(p++) = 0;
    01364 019F      MOVW	R18,R30
    01365 5F0F      SUBI	R16,0xFF
    01366 4F1F      SBCI	R17,0xFF
    01367 3807      CPI	R16,0x87
    01368 E0E0      LDI	R30,0
    01369 071E      CPC	R17,R30
    0136A F3B0      BCS	0x1361
    0136B 9508      RET
_AddInfoEventToStack:
    0136C 940E AD5F CALL	push_arg4
(0186) 		}
(0187) 	p = (unsigned char *)&CmdUrgentBuf;
    0136E 940E AE78 CALL	push_xgsetF0FC
    01370 0169      MOVW	R12,R18
    01371 84EE      LDD	R14,Y+14
    01372 90A0 1299 LDS	R10,InfoEventStack+1
    01374 2D4A      MOV	R20,R10
    01375 9543      INC	R20
    01376 3342      CPI	R20,0x32
    01377 F409      BNE	0x1379
    01378 2744      CLR	R20
    01379 9020 1298 LDS	R2,InfoEventStack
    0137B 1542      CP	R20,R2
    0137C F409      BNE	0x137E
    0137D C030      RJMP	0x13AE
    0137E E00D      LDI	R16,0xD
(0188) 	for(i=0; i<sizeof(COMMAND_URGENT_BUF); i++){
    0137F 2D1A      MOV	R17,R10
    01380 0301      MULSU	R16,R17
    01381 E98A      LDI	R24,0x9A
    01382 E192      LDI	R25,0x12
    01383 01F0      MOVW	R30,R0
    01384 0FE8      ADD	R30,R24
    01385 1FF9      ADC	R31,R25
    01386 840A      LDD	R0,Y+10
(0189) 		*(p++) = 0;
    01387 8200      ST	Z,R0
(0190) 		}
(0191) }
    01388 0301      MULSU	R16,R17
    01389 E98B      LDI	R24,0x9B
    0138A E192      LDI	R25,0x12
    0138B 01F0      MOVW	R30,R0
    0138C 0FE8      ADD	R30,R24
    0138D 1FF9      ADC	R31,R25
    0138E 01D6      MOVW	R26,R12
    0138F 902D      LD	R2,X+
(0192) 
    01390 016D      MOVW	R12,R26
    01391 8220      ST	Z,R2
    01392 94EA      DEC	R14
    01393 0301      MULSU	R16,R17
    01394 EA86      LDI	R24,0xA6
    01395 E192      LDI	R25,0x12
(0193) 
    01396 01F0      MOVW	R30,R0
    01397 0FE8      ADD	R30,R24
    01398 1FF9      ADC	R31,R25
    01399 82E0      ST	Z,R14
    0139A 0301      MULSU	R16,R17
(0194) // 将收到的从机信息放入信息队列等待处理
    0139B 01B0      MOVW	R22,R0
    0139C E98C      LDI	R24,0x9C
(0195) void AddInfoEventToStack(unsigned char slave, unsigned char * info, unsigned char len){
    0139D E192      LDI	R25,0x12
    0139E 0F68      ADD	R22,R24
    0139F 1F79      ADC	R23,R25
    013A0 24AA      CLR	R10
    013A1 C007      RJMP	0x13A9
    013A2 01F6      MOVW	R30,R12
    013A3 01DB      MOVW	R26,R22
    013A4 9001      LD	R0,Z+
    013A5 016F      MOVW	R12,R30
    013A6 920D      ST	X+,R0
    013A7 01BD      MOVW	R22,R26
    013A8 94A3      INC	R10
    013A9 14AE      CP	R10,R14
    013AA F3B8      BCS	0x13A2
    013AB 9340 1299 STS	InfoEventStack+1,R20
(0196) 	unsigned char pEnd, i, p;
    013AD C010      RJMP	0x13BE
(0197) 	unsigned char *pChar;
(0198) 	pEnd = InfoEventStack.pEnd;
    013AE 9180 00C1 LDS	R24,0xC1
    013B0 7E8F      ANDI	R24,0xEF
    013B1 9380 00C1 STS	0xC1,R24
    013B3 852A      LDD	R18,Y+10
    013B4 2733      CLR	R19
(0199) 	p = pEnd;
    013B5 EC03      LDI	R16,0xC3
    013B6 E012      LDI	R17,2
    013B7 940E A90D CALL	_uart_Printf
(0200) 	p ++;
(0201) 	if(p == INFO_EVENT_NUM)
(0202) 		p = 0;
    013B9 9180 00C1 LDS	R24,0xC1
_SendCommandData:
  l                    --> Y,+1
  p                    --> Y,+1
  pCmdBuf              --> R22
  c                    --> R14
  pEnd                 --> R10
  pTop                 --> R12
  curSlave             --> R20
    013BB 6180      ORI	R24,0x10
    013BC 9380 00C1 STS	0xC1,R24
(0203) 	if(p != InfoEventStack.pTop){
(0204) 		InfoEventStack.info[pEnd].slaveNum = slave;
(0205) 		InfoEventStack.info[pEnd].event = *(info ++);	// 消息类型
(0206) 		len --;
(0207) 		InfoEventStack.info[pEnd].infoLen = len;	// 消息参数长度
(0208) 		pChar = &InfoEventStack.info[pEnd].info[0];
(0209) 		for(i=0; i<len; i++){
(0210) 			*(pChar++) = *(info++);
(0211) 			}
(0212) 		InfoEventStack.pEnd = p;
(0213) 		}
(0214) 	else
(0215) 	{
(0216) 		Uart0ReUnable;
    013BE 940E AE6D CALL	pop_xgsetF0FC
    013C0 9624      ADIW	R28,4
(0217) 		uart_Printf("// Even save fail [%d]\r\n", slave);
    013C1 9508      RET
(0218) 		Uart0ReEnable;
(0219) 	}
_SetTransferBufStateQueryCmd:
    013C2 934A      ST	-Y,R20
    013C3 2F40      MOV	R20,R16
(0220) }
    013C4 9721      SBIW	R28,1
    013C5 304F      CPI	R20,0xF
(0221) /*void SetTransferBufStateQueryCmd(unsigned char slaveNum){
    013C6 F070      BCS	0x13D5
    013C7 9180 00C1 LDS	R24,0xC1
(0222) 	unsigned char pEnd, pTop, p;
(0223) 	pTop = CmdUrgentBuf.pTop;
    013C9 7E8F      ANDI	R24,0xEF
    013CA 9380 00C1 STS	0xC1,R24
(0224) 	pEnd = CmdUrgentBuf.pEnd;
(0225) 	
(0226) 	if(pTop != pEnd){
    013CC EA0D      LDI	R16,0xAD
(0227) 		if(CmdUrgentBuf.slaveNum[pTop] == slaveNum){
(0228) 			MemCopy(&(CmdUrgentBuf.buf[pTop]),&TransferBuf.cmd, sizeof(COMMAND_STRING));	// 将新命令存入发送缓冲区
    013CD E012      LDI	R17,2
    013CE 940E A90D CALL	_uart_Printf
    013D0 9180 00C1 LDS	R24,0xC1
(0229) 			pTop ++;
(0230) 			if(pTop == COMMAND_BUF_LEN)
    013D2 6180      ORI	R24,0x10
    013D3 9380 00C1 STS	0xC1,R24
(0231) 				pTop = 0;
    013D5 E183      LDI	R24,0x13
    013D6 E09B      LDI	R25,0xB
(0232) 			CmdUrgentBuf.pTop = pTop;
    013D7 2FE4      MOV	R30,R20
(0233) 			return;
(0234) 			}
    013D8 27FF      CLR	R31
    013D9 0FE8      ADD	R30,R24
    013DA 1FF9      ADC	R31,R25
    013DB 8020      LD	R2,Z
(0235) 		}
    013DC 2022      TST	R2
    013DD F0D9      BEQ	0x13F9
    013DE E088      LDI	R24,0x8
(0236) 	TransferBuf.cmd.cmd = (slaveNum<<3) & 0xf8;
    013DF 8388      ST	Y,R24
    013E0 E32A      LDI	R18,0x3A
(0237) 	TransferBuf.cmd.cmdLen = 1;
    013E1 E03B      LDI	R19,0xB
(0238) 	
(0239) }*/
(0240) void SetTransferBufStateQueryCmd(unsigned char slaveNum)
    013E2 E98B      LDI	R24,0x9B
    013E3 E09A      LDI	R25,0xA
    013E4 2F04      MOV	R16,R20
    013E5 2711      CLR	R17
(0241) {
(0242) 	if(slaveNum>=SLAVE_NUM)
    013E6 0F00      LSL	R16
(0243) 	{
    013E7 1F11      ROL	R17
    013E8 0F00      LSL	R16
    013E9 1F11      ROL	R17
    013EA 0F00      LSL	R16
    013EB 1F11      ROL	R17
(0244) 		Uart0ReUnable;
    013EC 0F08      ADD	R16,R24
    013ED 1F19      ADC	R17,R25
    013EE 940E 7118 CALL	_MemCopy
    013F0 E183      LDI	R24,0x13
    013F1 E09B      LDI	R25,0xB
(0245) 		uart_Printf("// SlaveNum error! \r\n");
    013F2 2FE4      MOV	R30,R20
    013F3 27FF      CLR	R31
    013F4 0FE8      ADD	R30,R24
    013F5 1FF9      ADC	R31,R25
    013F6 2422      CLR	R2
(0246) 		Uart0ReEnable;
(0247) 	}
    013F7 8220      ST	Z,R2
    013F8 C00A      RJMP	0x1403
    013F9 2F84      MOV	R24,R20
    013FA 0F88      LSL	R24
    013FB 0F88      LSL	R24
    013FC 0F88      LSL	R24
    013FD 7F88      ANDI	R24,0xF8
(0248) 	if(CmdUrgentBuf.state[slaveNum])
    013FE 9380 0B3A STS	TransferBuf,R24
    01400 E081      LDI	R24,1
(0249) 	{
    01401 9380 0B41 STS	TransferBuf+7,R24
    01403 9621      ADIW	R28,1
    01404 9149      LD	R20,Y+
    01405 9508      RET
(0250) 		// 有紧急命令
(0251) 		MemCopy(&(CmdUrgentBuf.buf[slaveNum]),&TransferBuf.cmd, sizeof(COMMAND_STRING));	// 将新命令存入发送缓冲区
_InsertCmdToTransferBuf:
    01406 940E AEB3 CALL	push_xgsetF03C
    01408 2F40      MOV	R20,R16
    01409 9721      SBIW	R28,1
    0140A 304F      CPI	R20,0xF
(0252) 		CmdUrgentBuf.state[slaveNum] = 0;	// 命令已处理，清除
    0140B F070      BCS	0x141A
(0253) 	}
    0140C 9180 00C1 LDS	R24,0xC1
(0254) 	else	// 无紧急命令，发送空闲查询
(0255) 	{
(0256) 		TransferBuf.cmd.cmd = (slaveNum<<3) & 0xf8;
    0140E 7E8F      ANDI	R24,0xEF
    0140F 9380 00C1 STS	0xC1,R24
    01411 EA0D      LDI	R16,0xAD
(0257) 		TransferBuf.cmd.cmdLen = 1;
(0258) 	}
    01412 E012      LDI	R17,2
(0259) }
    01413 940E A90D CALL	_uart_Printf
    01415 9180 00C1 LDS	R24,0xC1
    01417 6180      ORI	R24,0x10
(0260) void InsertCmdToTransferBuf(unsigned char slaveNum){
    01418 9380 00C1 STS	0xC1,R24
    0141A E183      LDI	R24,0x13
    0141B E09B      LDI	R25,0xB
    0141C 2FE4      MOV	R30,R20
    0141D 27FF      CLR	R31
(0261) 	COMMAND_BUF * pCmdBuf;
    0141E 0FE8      ADD	R30,R24
    0141F 1FF9      ADC	R31,R25
    01420 8020      LD	R2,Z
    01421 2022      TST	R2
    01422 F0D9      BEQ	0x143E
(0262) 	unsigned char pTop, pEnd;
(0263) 	
    01423 E088      LDI	R24,0x8
    01424 8388      ST	Y,R24
    01425 E32A      LDI	R18,0x3A
(0264) 	if(slaveNum>=SLAVE_NUM)
    01426 E03B      LDI	R19,0xB
    01427 E98B      LDI	R24,0x9B
    01428 E09A      LDI	R25,0xA
    01429 2F04      MOV	R16,R20
(0265) 	{
    0142A 2711      CLR	R17
    0142B 0F00      LSL	R16
    0142C 1F11      ROL	R17
    0142D 0F00      LSL	R16
    0142E 1F11      ROL	R17
(0266) 		Uart0ReUnable;
(0267) 		uart_Printf("// SlaveNum error! \r\n");
    0142F 0F00      LSL	R16
    01430 1F11      ROL	R17
    01431 0F08      ADD	R16,R24
(0268) 		Uart0ReEnable;
    01432 1F19      ADC	R17,R25
(0269) 	}
(0270) 	if(CmdUrgentBuf.state[slaveNum]){
(0271) 		// 有紧急命令
    01433 940E 7118 CALL	_MemCopy
    01435 E183      LDI	R24,0x13
    01436 E09B      LDI	R25,0xB
(0272) 		MemCopy(&(CmdUrgentBuf.buf[slaveNum]),&TransferBuf.cmd, sizeof(COMMAND_STRING));	// 将新命令存入发送缓冲区
(0273) 		CmdUrgentBuf.state[slaveNum] = 0;	// 命令已处理，清除
    01437 2FE4      MOV	R30,R20
    01438 27FF      CLR	R31
    01439 0FE8      ADD	R30,R24
    0143A 1FF9      ADC	R31,R25
(0274) 		}
    0143B 2422      CLR	R2
(0275) 	else{	// 无紧急命令
(0276) 		pCmdBuf = &TransmitControl.cmdBuf[slaveNum];
(0277) 		pTop = pCmdBuf->pTop;
(0278) 		pEnd = pCmdBuf->pEnd;
(0279) 		if(pTop != pEnd){			// 设置新的指针
(0280) 			MemCopy(&(pCmdBuf->buf[pTop]),&TransferBuf.cmd, sizeof(COMMAND_STRING));
(0281) 			}
(0282) 		else{
(0283) 			TransferBuf.cmd.cmd = (slaveNum<<3) & 0xf8;
(0284) 			TransferBuf.cmd.cmdLen = 1;
    0143C 8220      ST	Z,R2
    0143D C030      RJMP	0x146E
    0143E E70B      LDI	R16,0x7B
(0285) 			}
(0286) 		//	SetTransferBufStateQueryCmd(slaveNum);
(0287) 		}
    0143F 2F14      MOV	R17,R20
(0288) }
    01440 0301      MULSU	R16,R17
    01441 01B0      MOVW	R22,R0
(0289) static unsigned char CommandBackFlag;	// 命令发送返回标识，如果没收到返回信息表示从机丢失
    01442 E584      LDI	R24,0x54
(0290) // 发送命令字节
    01443 E09B      LDI	R25,0xB
    01444 0F68      ADD	R22,R24
    01445 1F79      ADC	R23,R25
    01446 01FB      MOVW	R30,R22
    01447 58E8      SUBI	R30,0x88
    01448 4FFF      SBCI	R31,0xFF
    01449 80A0      LD	R10,Z
    0144A 57E8      SUBI	R30,0x78
    0144B 40F0      SBCI	R31,0
(0291) void SendCommandData(void)
(0292) {
    0144C 58E7      SUBI	R30,0x87
    0144D 4FFF      SBCI	R31,0xFF
(0293) 	// 发送命令数据
    0144E 80C0      LD	R12,Z
    0144F 57E9      SUBI	R30,0x79
    01450 40F0      SBCI	R31,0
    01451 14AC      CP	R10,R12
    01452 F089      BEQ	0x1464
    01453 E088      LDI	R24,0x8
    01454 8388      ST	Y,R24
    01455 E32A      LDI	R18,0x3A
(0294) 	unsigned char curSlave;
    01456 E03B      LDI	R19,0xB
    01457 2D0A      MOV	R16,R10
    01458 2711      CLR	R17
    01459 0F00      LSL	R16
    0145A 1F11      ROL	R17
    0145B 0F00      LSL	R16
    0145C 1F11      ROL	R17
    0145D 0F00      LSL	R16
    0145E 1F11      ROL	R17
    0145F 0F0E      ADD	R16,R30
    01460 1F1F      ADC	R17,R31
    01461 940E 7118 CALL	_MemCopy
(0295) 	unsigned char p,l,c;
(0296) 	unsigned char pTop, pEnd;
(0297) 	static unsigned char checkSum;
    01463 C00A      RJMP	0x146E
    01464 2F84      MOV	R24,R20
(0298) 	static unsigned char cmdReSendCnt = 0;
(0299) 	COMMAND_BUF * pCmdBuf;
(0300) 
(0301) 	if(TransferStart == 0)
(0302) 		return;				// 命令传输未启动
(0303) 	
(0304) 	curSlave = TransmitControl.curSlave;
(0305) 	pTop = TransferBuf.pSend;
(0306) 	pEnd = TransferBuf.cmd.cmdLen;
(0307) 	
(0308) 	if(pTop < pEnd)
(0309) 	{
(0310) 		// 发送命令
(0311) 		if(pTop == 0)
(0312) 		{
    01465 0F88      LSL	R24
(0313) 			if(cmdReSendCnt == 0)
(0314) 			{
    01466 0F88      LSL	R24
    01467 0F88      LSL	R24
(0315) 				Uart2SendAdd(0);
(0316) 				cmdReSendCnt = 1;
(0317) 				return;	// 地址重发
(0318) 			}
(0319) 			Uart2SendAdd(TransferBuf.cmd.cmd);		// 发送地址和命令
    01468 7F88      ANDI	R24,0xF8
    01469 9380 0B3A STS	TransferBuf,R24
(0320) 			cmdReSendCnt = 0;
    0146B E081      LDI	R24,1
    0146C 9380 0B41 STS	TransferBuf+7,R24
(0321) 			checkSum = 0;
(0322) 		}
    0146E 9621      ADIW	R28,1
_ReceiveSlaveInfo:
  pChar                --> Y,+9
  pEnd                 --> R12
  pTop                 --> R20
  curSlave             --> R10
  info                 --> R20
    0146F 940C AEBC JMP	pop_xgsetF03C
_SendCommandData:
    01471 940E AE78 CALL	push_xgsetF0FC
(0323) 		else
(0324) 		{
(0325) 			if(GetUart2DataSendResult()!=0)
(0326) 			{
(0327) 				pTop = 0;
(0328) 				Uart0ReUnable;
(0329) 				uart_Printf("//DataSendErr1,No:%d\r\n", curSlave);
(0330) 				Uart0ReEnable;
(0331) 			}
(0332) 			c = TransferBuf.cmd.pam[pTop-1];
(0333) 			Uart2SendDat(c);	// 发送参数
(0334) 			checkSum += c;
    01473 9020 0B39 LDS	R2,TransferStart
(0335) 		}
    01475 2022      TST	R2
    01476 F409      BNE	0x1478
    01477 C0AB      RJMP	0x1523
(0336) 		TransferBuf.pSend ++;	// 数据发送指针加一
(0337) 	}
    01478 9140 0B52 LDS	R20,TransmitControl+15
    0147A 90C0 0B42 LDS	R12,TransferBuf+8
(0338) 	else if(pTop == pEnd)
(0339) 	{
(0340) 		// 发送校验
    0147C 90A0 0B41 LDS	R10,TransferBuf+7
(0341) 		if(GetUart2DataSendResult()!=0)
    0147E 14CA      CP	R12,R10
    0147F F008      BCS	0x1481
    01480 C041      RJMP	0x14C2
    01481 20CC      TST	R12
    01482 F4A9      BNE	0x1498
    01483 9020 0200 LDS	R2,cmdReSendCnt
(0342) 		{
    01485 2022      TST	R2
    01486 F439      BNE	0x148E
    01487 2700      CLR	R16
(0343) 			pTop = 0;
    01488 940E 99A4 CALL	_Uart2SendAdd
(0344) 			Uart0ReUnable;
    0148A E081      LDI	R24,1
    0148B 9380 0200 STS	cmdReSendCnt,R24
    0148D C095      RJMP	0x1523
(0345) 			uart_Printf("//DataSendErr2,No:%d\r\n", curSlave);
(0346) 			Uart0ReEnable;
(0347) 		}
    0148E 9100 0B3A LDS	R16,TransferBuf
    01490 940E 99A4 CALL	_Uart2SendAdd
    01492 2422      CLR	R2
    01493 9220 0200 STS	cmdReSendCnt,R2
    01495 9220 0A97 STS	wasteCardNoneUseful+88,R2
(0348) 		if(pEnd > 1)
    01497 C024      RJMP	0x14BC
    01498 940E 994C CALL	_GetUart2DataSendResult
    0149A 2300      TST	R16
(0349) 			Uart2SendDat(checkSum);	// 发送校验和
    0149B F089      BEQ	0x14AD
    0149C 24CC      CLR	R12
    0149D 9180 00C1 LDS	R24,0xC1
(0350) 		TransferBuf.pSend ++;	// 数据发送指针加一
(0351) 		DeviceInfo.pRec == 0;
    0149F 7E8F      ANDI	R24,0xEF
    014A0 9380 00C1 STS	0xC1,R24
    014A2 2F24      MOV	R18,R20
    014A3 2733      CLR	R19
    014A4 E906      LDI	R16,0x96
    014A5 E012      LDI	R17,2
(0352) 		TransmitControl.waitCount = 15;//5
(0353) 	}
(0354) 	else
(0355) 	{
(0356) 		if(TransmitControl.waitCount)
(0357) 		{
    014A6 940E A90D CALL	_uart_Printf
    014A8 9180 00C1 LDS	R24,0xC1
    014AA 6180      ORI	R24,0x10
    014AB 9380 00C1 STS	0xC1,R24
(0358) 			TransmitControl.waitCount --;
    014AD E38A      LDI	R24,0x3A
    014AE E09B      LDI	R25,0xB
    014AF 2DEC      MOV	R30,R12
    014B0 27FF      CLR	R31
    014B1 0FE8      ADD	R30,R24
(0359) 		}
    014B2 1FF9      ADC	R31,R25
    014B3 80E0      LD	R14,Z
    014B4 2D0E      MOV	R16,R14
    014B5 940E 99B8 CALL	_Uart2SendDat
(0360) 		else
    014B7 9020 0A97 LDS	R2,wasteCardNoneUseful+88
(0361) 		{
(0362) 		/*	if(CommandBackFlag != 255){	// 前一次发送的命令未收到反馈信息，需要重新发送
(0363) 			//	TransmitControl.cmdBuf[curSlave].transmitState = 2;	// 重新发送命令
    014B9 0C2E      ADD	R2,R14
    014BA 9220 0A97 STS	wasteCardNoneUseful+88,R2
(0364) 				if(CommandBackFlag == 28)
(0365) 					uart_Printf("// Command back lose: %d %d %d %d %d\r\n", DeviceInfo.buf[0], DeviceInfo.buf[1], DeviceInfo.buf[2], DeviceInfo.buf[3], DeviceInfo.buf[4]);
    014BC 9180 0B42 LDS	R24,TransferBuf+8
    014BE 5F8F      SUBI	R24,0xFF
(0366) 				else
    014BF 9380 0B42 STS	TransferBuf+8,R24
    014C1 C061      RJMP	0x1523
(0367) 					uart_Printf("// Command back lose :%d %d, cmd%d\r\n", CommandBackFlag,DeviceInfo.pRec,TransferBuf.cmd.cmd);
    014C2 14CA      CP	R12,R10
(0368) 				}*/
(0369) 			CommandBackFlag = 0;
(0370) 			do
    014C3 F529      BNE	0x14E9
    014C4 940E 994C CALL	_GetUart2DataSendResult
(0371) 			{
    014C6 2300      TST	R16
    014C7 F089      BEQ	0x14D9
    014C8 24CC      CLR	R12
(0372) 				curSlave ++;
    014C9 9180 00C1 LDS	R24,0xC1
    014CB 7E8F      ANDI	R24,0xEF
    014CC 9380 00C1 STS	0xC1,R24
(0373) 				if(curSlave == SLAVE_NUM)
(0374) 					curSlave = 0;
    014CE 2F24      MOV	R18,R20
    014CF 2733      CLR	R19
    014D0 E70F      LDI	R16,0x7F
    014D1 E012      LDI	R17,2
(0375) 			}while(TransmitControl.registerSlave[curSlave]==0);
    014D2 940E A90D CALL	_uart_Printf
    014D4 9180 00C1 LDS	R24,0xC1
    014D6 6180      ORI	R24,0x10
    014D7 9380 00C1 STS	0xC1,R24
    014D9 E081      LDI	R24,1
    014DA 158A      CP	R24,R10
    014DB F420      BCC	0x14E0
    014DC 9100 0A97 LDS	R16,wasteCardNoneUseful+88
    014DE 940E 99B8 CALL	_Uart2SendDat
    014E0 9180 0B42 LDS	R24,TransferBuf+8
    014E2 5F8F      SUBI	R24,0xFF
    014E3 9380 0B42 STS	TransferBuf+8,R24
    014E5 E08F      LDI	R24,0xF
    014E6 9380 0B53 STS	TransmitControl+16,R24
    014E8 C03A      RJMP	0x1523
    014E9 9020 0B53 LDS	R2,TransmitControl+16
(0376) 				
    014EB 2022      TST	R2
    014EC F029      BEQ	0x14F2
    014ED 2D82      MOV	R24,R2
    014EE 5081      SUBI	R24,1
    014EF 9380 0B53 STS	TransmitControl+16,R24
(0377) 			TransmitControl.curSlave = curSlave;		// 指向下一个有效的从机
(0378) 			pCmdBuf = &TransmitControl.cmdBuf[curSlave];
    014F1 C031      RJMP	0x1523
    014F2 2422      CLR	R2
(0379) 			switch(pCmdBuf->transmitState)
    014F3 9220 0A9A STS	wasteCardNoneUseful+91,R2
(0380) 			{
    014F5 9543      INC	R20
    014F6 304F      CPI	R20,0xF
    014F7 F409      BNE	0x14F9
(0381) 				case 0:				// 开始新传输
(0382) 					InsertCmdToTransferBuf(curSlave);
(0383) 				/*	pTop = CmdUrgentBuf.pTop;
(0384) 					pEnd = CmdUrgentBuf.pEnd;
(0385) 					if(pTop == pEnd){	// 保证紧急命令先发送
    014F8 2744      CLR	R20
    014F9 E483      LDI	R24,0x43
    014FA E09B      LDI	R25,0xB
    014FB 2FE4      MOV	R30,R20
    014FC 27FF      CLR	R31
(0386) 						pTop = pCmdBuf->pTop;
(0387) 						pEnd = pCmdBuf->pEnd;
    014FD 0FE8      ADD	R30,R24
    014FE 1FF9      ADC	R31,R25
    014FF 8020      LD	R2,Z
(0388) 						if(pTop != pEnd){			// 设置新的指针
    01500 2022      TST	R2
    01501 F399      BEQ	0x14F5
    01502 9340 0B52 STS	TransmitControl+15,R20
    01504 E70B      LDI	R16,0x7B
    01505 2F14      MOV	R17,R20
    01506 0301      MULSU	R16,R17
    01507 01B0      MOVW	R22,R0
    01508 E584      LDI	R24,0x54
    01509 E09B      LDI	R25,0xB
    0150A 0F68      ADD	R22,R24
    0150B 1F79      ADC	R23,R25
    0150C 01FB      MOVW	R30,R22
    0150D 58E6      SUBI	R30,0x86
    0150E 4FFF      SBCI	R31,0xFF
    0150F 8160      LD	R22,Z
    01510 2777      CLR	R23
    01511 3060      CPI	R22,0
    01512 0767      CPC	R22,R23
    01513 F029      BEQ	0x1519
    01514 3062      CPI	R22,2
    01515 E0E0      LDI	R30,0
    01516 077E      CPC	R23,R30
    01517 F021      BEQ	0x151C
    01518 C005      RJMP	0x151E
    01519 2F04      MOV	R16,R20
    0151A DEEB      RCALL	_InsertCmdToTransferBuf
    0151B C002      RJMP	0x151E
    0151C 2F04      MOV	R16,R20
    0151D DEA4      RCALL	_SetTransferBufStateQueryCmd
    0151E 2422      CLR	R2
    0151F 9220 0B42 STS	TransferBuf+8,R2
    01521 9220 0B36 STS	DeviceInfo+20,R2
    01523 940C AE6D JMP	pop_xgsetF0FC
_ReceiveSlaveInfo:
    01525 940E AEA5 CALL	push_xgset303C
    01527 2F40      MOV	R20,R16
    01528 9728      SBIW	R28,0x8
(0389) 							pCmdBuf->transmitState = 1;	// 设置命令处于等待发送状态
(0390) 							MemCopy(&(pCmdBuf->buf[pTop]),&TransferBuf.cmd, sizeof(COMMAND_STRING));	// 将新命令存入发送缓冲区
(0391) 							}
    01529 90A0 0B52 LDS	R10,TransmitControl+15
    0152B E08F      LDI	R24,0xF
    0152C 9380 0B53 STS	TransmitControl+16,R24
    0152E 9020 0B36 LDS	R2,DeviceInfo+20
    01530 2022      TST	R2
    01531 F519      BNE	0x1555
(0392) 						else
    01532 9340 0A9A STS	wasteCardNoneUseful+91,R20
(0393) 							SetTransferBufStateQueryCmd(curSlave);
(0394) 						}
    01534 2E24      MOV	R2,R20
    01535 9426      LSR	R2
    01536 9426      LSR	R2
    01537 9426      LSR	R2
    01538 9220 0A98 STS	wasteCardNoneUseful+89,R2
    0153A 2F84      MOV	R24,R20
    0153B 7087      ANDI	R24,7
(0395) 					else
    0153C 9380 0B37 STS	DeviceInfo+21,R24
    0153E 2388      TST	R24
    0153F F421      BNE	0x1544
    01540 E081      LDI	R24,1
    01541 9380 0B38 STS	DeviceInfo+22,R24
    01543 C06A      RJMP	0x15AE
    01544 E282      LDI	R24,0x22
    01545 E09B      LDI	R25,0xB
    01546 91E0 0B36 LDS	R30,DeviceInfo+20
(0396) 						SetTransferBufStateQueryCmd(curSlave);*/
(0397) 					break;
    01548 27FF      CLR	R31
    01549 0FE8      ADD	R30,R24
    0154A 1FF9      ADC	R31,R25
    0154B 8340      ST	Z,R20
    0154C 9180 0B36 LDS	R24,DeviceInfo+20
    0154E 5F8F      SUBI	R24,0xFF
(0398) 				case 2:				// 命令发送完毕，查询从机状态
    0154F 9380 0B36 STS	DeviceInfo+20,R24
    01551 2422      CLR	R2
    01552 9220 0A99 STS	wasteCardNoneUseful+90,R2
    01554 C059      RJMP	0x15AE
    01555 9180 0B37 LDS	R24,DeviceInfo+21
(0399) 					SetTransferBufStateQueryCmd(curSlave);
    01557 5F8F      SUBI	R24,0xFF
(0400) 					break;
(0401) 				default:
    01558 9020 0B36 LDS	R2,DeviceInfo+20
(0402) 					break;
    0155A 1628      CP	R2,R24
(0403) 			}
    0155B F490      BCC	0x156E
(0404) 			TransferBuf.pSend = 0;	// 初始化发送指针
    0155C E282      LDI	R24,0x22
    0155D E09B      LDI	R25,0xB
    0155E 2DE2      MOV	R30,R2
    0155F 27FF      CLR	R31
    01560 0FE8      ADD	R30,R24
    01561 1FF9      ADC	R31,R25
    01562 8340      ST	Z,R20
    01563 9180 0B36 LDS	R24,DeviceInfo+20
(0405) 			DeviceInfo.pRec = 0;
(0406) 		}
    01565 5F8F      SUBI	R24,0xFF
    01566 9380 0B36 STS	DeviceInfo+20,R24
    01568 9020 0A99 LDS	R2,wasteCardNoneUseful+90
    0156A 0E24      ADD	R2,R20
    0156B 9220 0A99 STS	wasteCardNoneUseful+90,R2
    0156D C040      RJMP	0x15AE
    0156E 9020 0A99 LDS	R2,wasteCardNoneUseful+90
(0407) 	}
    01570 1624      CP	R2,R20
    01571 F439      BNE	0x1579
    01572 E081      LDI	R24,1
    01573 9380 0B38 STS	DeviceInfo+22,R24
(0408) }
    01575 E006      LDI	R16,6
    01576 940E 99B8 CALL	_Uart2SendDat
    01578 C035      RJMP	0x15AE
    01579 EF8E      LDI	R24,0xFE
(0409) // 接收一个字节的从机消息存入消息缓冲区
    0157A 9380 0A9A STS	wasteCardNoneUseful+91,R24
    0157C E007      LDI	R16,7
    0157D 940E 99B8 CALL	_Uart2SendDat
(0410) void ReceiveSlaveInfo(unsigned char info)
(0411) {
    0157F 9020 17D8 LDS	R2,ControlModel
(0412) 	// 接收从机返回信息
(0413) 	unsigned char curSlave;
    01581 2022      TST	R2
    01582 F119      BEQ	0x15A6
    01583 9180 00C1 LDS	R24,0xC1
    01585 7E8F      ANDI	R24,0xEF
    01586 9380 00C1 STS	0xC1,R24
    01588 9020 0B24 LDS	R2,DeviceInfo+2
(0414) 	static unsigned char state;
    0158A 2433      CLR	R3
    0158B 823F      STD	Y+7,R3
    0158C 822E      STD	Y+6,R2
    0158D 9020 0B23 LDS	R2,DeviceInfo+1
    0158F 2433      CLR	R3
    01590 823D      STD	Y+5,R3
    01591 822C      STD	Y+4,R2
    01592 2E24      MOV	R2,R20
(0415) 	static unsigned char checkSum;
(0416) 	unsigned char pTop, pEnd;
(0417) 	unsigned char *pChar;
(0418) 
(0419) 	curSlave = TransmitControl.curSlave;    // 当前从机号
    01593 2433      CLR	R3
    01594 823B      STD	Y+3,R3
    01595 822A      STD	Y+2,R2
    01596 9020 0A99 LDS	R2,wasteCardNoneUseful+90
    01598 2433      CLR	R3
    01599 8239      STD	Y+1,R3
(0420) 	TransmitControl.waitCount = 15;			// 超时等待计数 5
    0159A 8228      ST	Y,R2
    0159B 2D2A      MOV	R18,R10
(0421) 	// 接收设备消息
(0422) 	if(DeviceInfo.pRec == 0)
    0159C 2733      CLR	R19
(0423) 	{
    0159D E509      LDI	R16,0x59
    0159E E012      LDI	R17,2
(0424) 		// 接收状态字节
    0159F 940E A90D CALL	_uart_Printf
(0425) 		CommandBackFlag = info;      //返回到的第一个命令就是状态加上长度
    015A1 9180 00C1 LDS	R24,0xC1
    015A3 6180      ORI	R24,0x10
    015A4 9380 00C1 STS	0xC1,R24
    015A6 2422      CLR	R2
    015A7 9220 0B37 STS	DeviceInfo+21,R2
(0426) 		state = info >> 3;
(0427) 		DeviceInfo.infoLen = info & 0x07;      //长度是后三位来表示
    015A9 9220 0B36 STS	DeviceInfo+20,R2
    015AB E082      LDI	R24,2
    015AC 9380 0B53 STS	TransmitControl+16,R24
    015AE 9020 0B38 LDS	R2,DeviceInfo+22
    015B0 2022      TST	R2
    015B1 F409      BNE	0x15B3
    015B2 C0E3      RJMP	0x1696
(0428) 		if(DeviceInfo.infoLen == 0)	
(0429) 			DeviceInfo.isValid = 1;
(0430) 		else                                   //命令长度不是为0，有命令
(0431) 		{
(0432) 			DeviceInfo.buf[DeviceInfo.pRec] = info;
(0433) 			DeviceInfo.pRec ++;
(0434) 			checkSum = 0;
(0435) 		}
(0436) 	}
(0437) 	else
(0438) 	{
(0439) 		// 接收设备返回消息
(0440) 		if(DeviceInfo.pRec < DeviceInfo.infoLen + 1)
    015B3 EF8F      LDI	R24,0xFF
    015B4 9380 0A9A STS	wasteCardNoneUseful+91,R24
    015B6 9140 0A98 LDS	R20,wasteCardNoneUseful+89
(0441) 		{
    015B8 2755      CLR	R21
    015B9 3040      CPI	R20,0
    015BA 0745      CPC	R20,R21
(0442) 			DeviceInfo.buf[DeviceInfo.pRec] = info;
    015BB F119      BEQ	0x15DF
    015BC 3041      CPI	R20,1
    015BD E0E0      LDI	R30,0
    015BE 075E      CPC	R21,R30
    015BF F149      BEQ	0x15E9
(0443) 			DeviceInfo.pRec ++;
    015C0 3042      CPI	R20,2
(0444) 			checkSum += info;
(0445) 		}
    015C1 E0E0      LDI	R30,0
    015C2 075E      CPC	R21,R30
    015C3 F409      BNE	0x15C5
    015C4 C071      RJMP	0x1636
    015C5 3043      CPI	R20,3
    015C6 E0E0      LDI	R30,0
    015C7 075E      CPC	R21,R30
    015C8 F409      BNE	0x15CA
    015C9 C076      RJMP	0x1640
    015CA 3044      CPI	R20,4
(0446) 		else         //最后一个数据就是校验和的数值
    015CB E0E0      LDI	R30,0
(0447) 		{
(0448) 			if(checkSum == info)				// 设备返回消息接收成功
    015CC 075E      CPC	R21,R30
    015CD F409      BNE	0x15CF
    015CE C071      RJMP	0x1640
    015CF 3045      CPI	R20,5
    015D0 E0E0      LDI	R30,0
    015D1 075E      CPC	R21,R30
    015D2 F409      BNE	0x15D4
    015D3 C095      RJMP	0x1669
    015D4 3046      CPI	R20,6
    015D5 E0E0      LDI	R30,0
(0449) 			{
(0450) 				DeviceInfo.isValid = 1;         //整个消息接受完成了
(0451) 				Uart2SendDat(STA_SLAVE_RECEIVE_OK);	
(0452) 			}
(0453) 			else
    015D6 075E      CPC	R21,R30
    015D7 F409      BNE	0x15D9
    015D8 C09E      RJMP	0x1677
(0454) 			{							
    015D9 3047      CPI	R20,7
    015DA E0E0      LDI	R30,0
    015DB 075E      CPC	R21,R30
(0455) 				CommandBackFlag = 254;
    015DC F409      BNE	0x15DE
    015DD C0A4      RJMP	0x1682
(0456) 				Uart2SendDat(STA_SLAVE_RECEIVE_ERR);
    015DE C0AD      RJMP	0x168C
    015DF E889      LDI	R24,0x89
(0457) 				if(ControlModel != 0)
    015E0 E192      LDI	R25,0x12
    015E1 2DEA      MOV	R30,R10
    015E2 27FF      CLR	R31
(0458) 				{                    //校验和错误报错了
(0459) 					Uart0ReUnable;
(0460) 					uart_Printf("// Info err,Num:%d,Sum:%d,%d(%d,%d)\r\n",curSlave,checkSum,info,DeviceInfo.buf[1],DeviceInfo.buf[2]);
(0461) 					Uart0ReEnable;
(0462) 				}
(0463) 				DeviceInfo.infoLen = 0;
(0464) 				DeviceInfo.pRec = 0;
_RegisterSlave:
  slaveNum             --> R16
    015E3 0FE8      ADD	R30,R24
    015E4 1FF9      ADC	R31,R25
    015E5 9020 0A98 LDS	R2,wasteCardNoneUseful+89
    015E7 8220      ST	Z,R2
    015E8 C0A3      RJMP	0x168C
    015E9 E889      LDI	R24,0x89
    015EA E192      LDI	R25,0x12
    015EB 2DEA      MOV	R30,R10
_StartCommandTransfer:
  i                    --> R20
    015EC 27FF      CLR	R31
(0465) 				TransmitControl.waitCount = 2;
(0466) 			}
(0467) 		}
(0468) 	}
(0469) 	// 设备消息处理
    015ED 0FE8      ADD	R30,R24
    015EE 1FF9      ADC	R31,R25
(0470) 	if(DeviceInfo.isValid)
(0471) 	{
    015EF 9020 0A98 LDS	R2,wasteCardNoneUseful+89
    015F1 8220      ST	Z,R2
    015F2 E70B      LDI	R16,0x7B
    015F3 2D1A      MOV	R17,R10
    015F4 0301      MULSU	R16,R17
    015F5 EC8E      LDI	R24,0xCE
    015F6 E09B      LDI	R25,0xB
    015F7 01F0      MOVW	R30,R0
(0472) 		CommandBackFlag = 255;
(0473) 		switch(state)
    015F8 0FE8      ADD	R30,R24
    015F9 1FF9      ADC	R31,R25
(0474) 		{
    015FA 8180      LD	R24,Z
    015FB 3082      CPI	R24,2
(0475) 			case 0:			// 待机
    015FC F009      BEQ	0x15FE
    015FD C08E      RJMP	0x168C
    015FE 0301      MULSU	R16,R17
    015FF EC8C      LDI	R24,0xCC
    01600 E09B      LDI	R25,0xB
    01601 01F0      MOVW	R30,R0
    01602 0FE8      ADD	R30,R24
    01603 1FF9      ADC	R31,R25
_InsertCommand:
  pTop                 --> R14
  p                    --> R20
  pEnd                 --> R22
  pCmdStr              --> R12
  slaveNum             --> R10
    01604 8140      LD	R20,Z
    01605 0301      MULSU	R16,R17
    01606 EC8D      LDI	R24,0xCD
    01607 E09B      LDI	R25,0xB
    01608 01F0      MOVW	R30,R0
(0476) 				TransmitControl.slaveState[curSlave] = state;
(0477) 				break;
(0478) 			case 1:			// 空闲
(0479) 				TransmitControl.slaveState[curSlave] = state;
(0480) 				if(TransmitControl.cmdBuf[curSlave].transmitState == 2)
(0481) 				{
(0482) 					pTop = TransmitControl.cmdBuf[curSlave].pTop;
    01609 0FE8      ADD	R30,R24
(0483) 					pEnd = TransmitControl.cmdBuf[curSlave].pEnd;
    0160A 1FF9      ADC	R31,R25
    0160B 80C0      LD	R12,Z
    0160C 154C      CP	R20,R12
    0160D F069      BEQ	0x161B
    0160E 9543      INC	R20
    0160F 304F      CPI	R20,0xF
    01610 F409      BNE	0x1612
    01611 2744      CLR	R20
    01612 E70B      LDI	R16,0x7B
(0484) 					if(pTop != pEnd)
    01613 2D1A      MOV	R17,R10
    01614 0301      MULSU	R16,R17
    01615 EC8C      LDI	R24,0xCC
    01616 E09B      LDI	R25,0xB
    01617 01F0      MOVW	R30,R0
    01618 0FE8      ADD	R30,R24
    01619 1FF9      ADC	R31,R25
(0485) 					{
    0161A 8340      ST	Z,R20
(0486) 						pTop ++;
(0487) 						if(pTop == COMMAND_BUF_LEN)
    0161B E70B      LDI	R16,0x7B
(0488) 							pTop = 0;
    0161C 2D1A      MOV	R17,R10
    0161D 0301      MULSU	R16,R17
(0489) 						TransmitControl.cmdBuf[curSlave].pTop = pTop;
    0161E EC8E      LDI	R24,0xCE
(0490) 					}
    0161F E09B      LDI	R25,0xB
    01620 01F0      MOVW	R30,R0
(0491) 					TransmitControl.cmdBuf[curSlave].transmitState = 0;
    01621 0FE8      ADD	R30,R24
    01622 1FF9      ADC	R31,R25
    01623 2422      CLR	R2
    01624 8220      ST	Z,R2
    01625 9180 00C1 LDS	R24,0xC1
    01627 7E8F      ANDI	R24,0xEF
    01628 9380 00C1 STS	0xC1,R24
    0162A 2D2A      MOV	R18,R10
    0162B 2733      CLR	R19
    0162C E404      LDI	R16,0x44
    0162D E012      LDI	R17,2
    0162E 940E A90D CALL	_uart_Printf
    01630 9180 00C1 LDS	R24,0xC1
    01632 6180      ORI	R24,0x10
    01633 9380 00C1 STS	0xC1,R24
    01635 C056      RJMP	0x168C
    01636 E889      LDI	R24,0x89
    01637 E192      LDI	R25,0x12
(0492) 					Uart0ReUnable;	
    01638 2DEA      MOV	R30,R10
(0493) 					uart_Printf("//CmdBackErr,No:%d\r\n", curSlave);
    01639 27FF      CLR	R31
    0163A 0FE8      ADD	R30,R24
(0494) 					Uart0ReEnable;
    0163B 1FF9      ADC	R31,R25
(0495) 				}
    0163C 9020 0A98 LDS	R2,wasteCardNoneUseful+89
    0163E 8220      ST	Z,R2
    0163F C04C      RJMP	0x168C
    01640 E70B      LDI	R16,0x7B
    01641 2D1A      MOV	R17,R10
    01642 0301      MULSU	R16,R17
    01643 EC8C      LDI	R24,0xCC
    01644 E09B      LDI	R25,0xB
(0496) 				break;
    01645 01F0      MOVW	R30,R0
(0497) 			case 2:			// 忙
(0498) 				TransmitControl.slaveState[curSlave] = state;
    01646 0FE8      ADD	R30,R24
    01647 1FF9      ADC	R31,R25
    01648 8140      LD	R20,Z
    01649 0301      MULSU	R16,R17
    0164A EC8D      LDI	R24,0xCD
(0499) 				break;
    0164B E09B      LDI	R25,0xB
    0164C 01F0      MOVW	R30,R0
    0164D 0FE8      ADD	R30,R24
    0164E 1FF9      ADC	R31,R25
    0164F 80C0      LD	R12,Z
    01650 154C      CP	R20,R12
(0500) 			case 3:			// 命令完成
    01651 F069      BEQ	0x165F
    01652 9543      INC	R20
    01653 304F      CPI	R20,0xF
    01654 F409      BNE	0x1656
    01655 2744      CLR	R20
(0501) 			case 4:			// 命令出错
    01656 E70B      LDI	R16,0x7B
(0502) 				// 命令缓冲区指针更新
    01657 2D1A      MOV	R17,R10
    01658 0301      MULSU	R16,R17
(0503) 				pTop = TransmitControl.cmdBuf[curSlave].pTop;
(0504) 				pEnd = TransmitControl.cmdBuf[curSlave].pEnd;
    01659 EC8C      LDI	R24,0xCC
(0505) 				if(pTop != pEnd)
    0165A E09B      LDI	R25,0xB
    0165B 01F0      MOVW	R30,R0
    0165C 0FE8      ADD	R30,R24
    0165D 1FF9      ADC	R31,R25
_InsertUrgentCommand:
  pCmdStr              --> R12
  slaveNum             --> R10
    0165E 8340      ST	Z,R20
    0165F E70B      LDI	R16,0x7B
    01660 2D1A      MOV	R17,R10
    01661 0301      MULSU	R16,R17
    01662 EC8E      LDI	R24,0xCE
(0506) 				{
(0507) 					pTop ++;
(0508) 					if(pTop == COMMAND_BUF_LEN)
(0509) 						pTop = 0;
(0510) 					TransmitControl.cmdBuf[curSlave].pTop = pTop;		// 设置新的指针
(0511) 				}
(0512) 				TransmitControl.cmdBuf[curSlave].transmitState = 0;		// 新的通讯开始
(0513) 			case 5:			// 状态发生改变
(0514) #ifdef DEBUG
(0515) 				if(state==4)
(0516) 				{
(0517) 					if(ControlModel != 0)
(0518) 					{
(0519) 						Uart0ReUnable;
(0520) 						uart_Printf("//CmdErr,No:%d\r\n", curSlave);
(0521) 						Uart0ReEnable;
(0522) 					}
(0523) 				}
(0524) #endif
(0525) 				if(state != 4)
(0526) 					if(DeviceInfo.infoLen != 0)		// 空消息不处理
    01663 E09B      LDI	R25,0xB
(0527) 						AddInfoEventToStack(curSlave, &DeviceInfo.buf[1], DeviceInfo.infoLen);	
    01664 01F0      MOVW	R30,R0
    01665 0FE8      ADD	R30,R24
    01666 1FF9      ADC	R31,R25
    01667 2422      CLR	R2
    01668 8220      ST	Z,R2
    01669 9180 0A98 LDS	R24,wasteCardNoneUseful+89
    0166B 3084      CPI	R24,4
    0166C F0F9      BEQ	0x168C
(0528) 				break;
    0166D 9020 0B37 LDS	R2,DeviceInfo+21
    0166F 2022      TST	R2
    01670 F0D9      BEQ	0x168C
    01671 8228      ST	Y,R2
    01672 E223      LDI	R18,0x23
    01673 E03B      LDI	R19,0xB
    01674 2D0A      MOV	R16,R10
    01675 DCF6      RCALL	_AddInfoEventToStack
    01676 C015      RJMP	0x168C
    01677 E70B      LDI	R16,0x7B
    01678 2D1A      MOV	R17,R10
    01679 0301      MULSU	R16,R17
    0167A EC8E      LDI	R24,0xCE
    0167B E09B      LDI	R25,0xB
    0167C 01F0      MOVW	R30,R0
    0167D 0FE8      ADD	R30,R24
(0529) 			case 6:			// 命令发送成功
    0167E 1FF9      ADC	R31,R25
    0167F E082      LDI	R24,2
    01680 8380      ST	Z,R24
    01681 C00A      RJMP	0x168C
    01682 E70B      LDI	R16,0x7B
    01683 2D1A      MOV	R17,R10
    01684 0301      MULSU	R16,R17
    01685 EC8E      LDI	R24,0xCE
(0530) 				TransmitControl.cmdBuf[curSlave].transmitState = 2;	
    01686 E09B      LDI	R25,0xB
(0531) 				break;
(0532) 			case 7:			// 命令发送失败
    01687 01F0      MOVW	R30,R0
    01688 0FE8      ADD	R30,R24
    01689 1FF9      ADC	R31,R25
    0168A 2422      CLR	R2
    0168B 8220      ST	Z,R2
(0533) 				TransmitControl.cmdBuf[curSlave].transmitState = 0;	// 重新发送命令
    0168C E082      LDI	R24,2
    0168D 9380 0B53 STS	TransmitControl+16,R24
    0168F 2422      CLR	R2
    01690 9220 0B38 STS	DeviceInfo+22,R2
(0534) 				break;
    01692 9220 0B37 STS	DeviceInfo+21,R2
    01694 9220 0B36 STS	DeviceInfo+20,R2
    01696 9628      ADIW	R28,0x8
(0535) 			default:
    01697 940C AEAC JMP	pop_xgset303C
(0536) 				break;
_RegisterSlave:
    01699 E483      LDI	R24,0x43
(0537) 			}
(0538) 		TransmitControl.waitCount = 2;		// 通信结束，退出超时等待
    0169A E09B      LDI	R25,0xB
(0539) 		DeviceInfo.isValid = 0;
    0169B 2FE0      MOV	R30,R16
    0169C 27FF      CLR	R31
    0169D 0FE8      ADD	R30,R24
    0169E 1FF9      ADC	R31,R25
_GetSlaveState:
  pTop                 --> R12
  pEnd                 --> R14
  slaveNum             --> R10
    0169F E081      LDI	R24,1
    016A0 8380      ST	Z,R24
    016A1 9508      RET
(0540) 		DeviceInfo.infoLen = 0;
(0541) 		DeviceInfo.pRec = 0;
(0542) 		}
(0543) }
(0544) 
(0545) unsigned char RegisterSlave(unsigned char slaveNum)
(0546) {
_StartCommandTransfer:
    016A2 934A      ST	-Y,R20
    016A3 2744      CLR	R20
    016A4 C011      RJMP	0x16B6
    016A5 E483      LDI	R24,0x43
    016A6 E09B      LDI	R25,0xB
    016A7 2FE4      MOV	R30,R20
    016A8 27FF      CLR	R31
    016A9 0FE8      ADD	R30,R24
    016AA 1FF9      ADC	R31,R25
(0547) //	if(TransferStart)
    016AB 8020      LD	R2,Z
    016AC 2022      TST	R2
    016AD F039      BEQ	0x16B5
    016AE 2F04      MOV	R16,R20
    016AF DD12      RCALL	_SetTransferBufStateQueryCmd
    016B0 9340 0B52 STS	TransmitControl+15,R20
(0548) //		return;				// 命令传输已启动，不能再注册从机
    016B2 E081      LDI	R24,1
    016B3 9380 0B39 STS	TransferStart,R24
(0549) 	TransmitControl.registerSlave[slaveNum] = 1;
    016B5 9543      INC	R20
    016B6 304F      CPI	R20,0xF
    016B7 F368      BCS	0x16A5
    016B8 9149      LD	R20,Y+
    016B9 9508      RET
_InsertCommand:
    016BA 940E AE78 CALL	push_xgsetF0FC
(0550) }
(0551) void StartCommandTransfer(void)
    016BC 0169      MOVW	R12,R18
    016BD 2EA0      MOV	R10,R16
    016BE 9721      SBIW	R28,1
_SendInfoEvent:
  pTop                 --> R20
    016BF 94F8      BCLR	7
(0552) {
(0553) 	unsigned char i;
(0554) 	for(i = 0; i < SLAVE_NUM; i++)
(0555) 	{
(0556) 		if(TransmitControl.registerSlave[i] != 0)		// 找到第一个从机并设置默认命令，启动传输
(0557) 		{
(0558) 			SetTransferBufStateQueryCmd(i);
(0559) 			TransmitControl.curSlave = i;
(0560) 			TransferStart = 1;
    016C0 E70B      LDI	R16,0x7B
    016C1 2D1A      MOV	R17,R10
    016C2 0301      MULSU	R16,R17
    016C3 EC8C      LDI	R24,0xCC
(0561) 		}
    016C4 E09B      LDI	R25,0xB
(0562) 	}
    016C5 01F0      MOVW	R30,R0
    016C6 0FE8      ADD	R30,R24
    016C7 1FF9      ADC	R31,R25
(0563) }
    016C8 80E0      LD	R14,Z
    016C9 0301      MULSU	R16,R17
(0564) // 新命令
    016CA EC8D      LDI	R24,0xCD
    016CB E09B      LDI	R25,0xB
    016CC 01F0      MOVW	R30,R0
    016CD 0FE8      ADD	R30,R24
(0565) unsigned char InsertCommand(unsigned char slaveNum, COMMAND_STRING * pCmdStr){
(0566) 	unsigned char pEnd, pTop, p;
(0567) 	CLI();
    016CE 1FF9      ADC	R31,R25
    016CF 8160      LD	R22,Z
    016D0 2F46      MOV	R20,R22
    016D1 9563      INC	R22
    016D2 306F      CPI	R22,0xF
    016D3 F008      BCS	0x16D5
    016D4 2766      CLR	R22
    016D5 156E      CP	R22,R14
    016D6 F129      BEQ	0x16FC
    016D7 E088      LDI	R24,0x8
(0568) 	pTop = TransmitControl.cmdBuf[slaveNum].pTop;
    016D8 8388      ST	Y,R24
(0569) 	pEnd = TransmitControl.cmdBuf[slaveNum].pEnd;
    016D9 E70B      LDI	R16,0x7B
    016DA 2D1A      MOV	R17,R10
(0570) 	p = pEnd;
    016DB 0301      MULSU	R16,R17
(0571) 
    016DC 0110      MOVW	R2,R0
    016DD E584      LDI	R24,0x54
(0572) 	pEnd ++;
(0573) 	if(pEnd >= COMMAND_BUF_LEN)
    016DE E09B      LDI	R25,0xB
    016DF 0E28      ADD	R2,R24
    016E0 1E39      ADC	R3,R25
    016E1 2F24      MOV	R18,R20
    016E2 2733      CLR	R19
_SetGetCardTestMode:
  m                    --> R20
    016E3 0F22      LSL	R18
    016E4 1F33      ROL	R19
FILE: D:\Work\主控软件\2032A2~1\cardStoreProcess.c
(0001) #include <iom1280v.h>
(0002) #include "B1404_LIB.h"
(0003) #include "Common.h"
(0004) #include "eeprom.h"
(0005) //*************************************************
(0006) extern unsigned char CardNoneUseful;	// 老化测试,不需要检测有无试剂片
(0007) unsigned char CardStoreTestFlag;		// 片仓取片测试
(0008) extern unsigned int _DropMode;			// 滴样模式,控制是否需要抽打混匀
(0009) extern unsigned char _MixtureMode;		// 1:1模式下,是否需要抽打混匀
(0010) extern unsigned char InsertRingFlag;
(0011) extern unsigned char insertflag[30];	// 插入转盘标志
(0012) extern unsigned char workSwitch;			// 停止工作开关
(0013) extern RING_QUEUE	RingQueue;
(0014) static unsigned char WaitPhotoFlag = 0;
(0015) static unsigned char ReScanfFlag = 0;
(0016) static unsigned int  CardScanfPos = 0;
(0017) extern unsigned long SecondCount;
(0018) extern TEST_QUEUE TestQueueA;
(0019) extern TEST_QUEUE TestQueueB;
(0020) //*************************************************
(0021) extern unsigned char GetNewTestCard;
(0022) extern unsigned char CurInsertRingNum;
(0023) extern unsigned char TurnPlateUsedLock;
(0024) extern unsigned char WorkProcessStep;
(0025) unsigned char CardStoreOpenLook = 0;
(0026) extern unsigned int _AutoTestCycleNum;
(0027) 
(0028) //
(0029) unsigned char preCardStoreNum = 1;		// 用于取片测试下,片仓的切换
(0030) static unsigned char stopFlag = 0;		//整机暂停导致取片测试清零标识
(0031) static unsigned char preGetCardNum[5];	// 用于取片测试下,计算每个片仓取片数量
(0032) extern unsigned char WithoutPuncture;	// 默认为0 穿刺   1  不穿刺测橙黄G   2 不穿刺测老化
(0033) unsigned char LastCardGetState;			// 上一次取片测试是否完成
(0034) 
(0035) void SetGetCardTestMode(unsigned char m)
(0036) {
(0037) 	if(m > 1)
    016E5 0F22      LSL	R18
    016E6 1F33      ROL	R19
    016E7 0F22      LSL	R18
(0038) 		m = 1;
    016E8 1F33      ROL	R19
(0039) 	CardStoreTestFlag = m;
    016E9 0D22      ADD	R18,R2
    016EA 1D33      ADC	R19,R3
(0040) 	if(1 == CardStoreTestFlag)
    016EB 0186      MOVW	R16,R12
    016EC 940E 7118 CALL	_MemCopy
(0041) 	{
(0042) 		CardNoneUseful = 0;		// 输入此命令,自动关闭老化测试
    016EE 9543      INC	R20
    016EF 304F      CPI	R20,0xF
(0043) 		_AutoTestCycleNum = 124; 	// 124
    016F0 F409      BNE	0x16F2
    016F1 2744      CLR	R20
    016F2 E70B      LDI	R16,0x7B
    016F3 2D1A      MOV	R17,R10
    016F4 0301      MULSU	R16,R17
    016F5 EC8D      LDI	R24,0xCD
(0044) 		LastCardGetState = 1;	
    016F6 E09B      LDI	R25,0xB
    016F7 01F0      MOVW	R30,R0
    016F8 0FE8      ADD	R30,R24
(0045) 		preCardStoreNum = 1;	// 默认从1号片仓开始
    016F9 1FF9      ADC	R31,R25
    016FA 8340      ST	Z,R20
(0046) 		SetDiluentRatio(1);		// 设置稀释比例为1:1
    016FB C013      RJMP	0x170F
    016FC 9180 00C1 LDS	R24,0xC1
(0047) #ifdef Puncture
(0048) 		WithoutPuncture = 2;	// 不穿刺		
(0049) #endif
(0050) 		Uart0ReUnable;
    016FE 7E8F      ANDI	R24,0xEF
    016FF 9380 00C1 STS	0xC1,R24
    01701 2D2A      MOV	R18,R10
    01702 2733      CLR	R19
(0051) 		uart_Printf("%s $ 1\r\n",strM3125);
    01703 E206      LDI	R16,0x26
    01704 E012      LDI	R17,2
    01705 940E A90D CALL	_uart_Printf
    01707 9180 00C1 LDS	R24,0xC1
(0052) 		Uart0ReEnable;
    01709 6180      ORI	R24,0x10
    0170A 9380 00C1 STS	0xC1,R24
    0170C 9478      BSET	7
    0170D E001      LDI	R16,1
(0053) 	}
    0170E C002      RJMP	0x1711
(0054) 	else
(0055) 	{
(0056) 		_AutoTestCycleNum = 0;
    0170F 9478      BSET	7
    01710 2700      CLR	R16
    01711 9621      ADIW	R28,1
    01712 940C AE6D JMP	pop_xgsetF0FC
_InsertUrgentCommand:
    01714 940E AE7E CALL	push_xgset003C
(0057) 		Uart0ReUnable;
    01716 0169      MOVW	R12,R18
    01717 2EA0      MOV	R10,R16
    01718 9721      SBIW	R28,1
    01719 94F8      BCLR	7
(0058) 		uart_Printf("%s $ 0\r\n",strM3129);
    0171A E183      LDI	R24,0x13
    0171B E09B      LDI	R25,0xB
    0171C 2DEA      MOV	R30,R10
    0171D 27FF      CLR	R31
    0171E 0FE8      ADD	R30,R24
    0171F 1FF9      ADC	R31,R25
(0059) 		Uart0ReEnable;
    01720 8020      LD	R2,Z
    01721 2022      TST	R2
    01722 F4D1      BNE	0x173D
    01723 E088      LDI	R24,0x8
    01724 8388      ST	Y,R24
(0060) 	}
    01725 E98B      LDI	R24,0x9B
    01726 E09A      LDI	R25,0xA
(0061) }
(0062) 
(0063) static void ReStartCardGetTest(void)
(0064) {
(0065) 	unsigned char i;
(0066) 	for(i = 0;i < 5;i++)
_ReStartCardGetTest:
  i                    --> R16
    01727 2D2A      MOV	R18,R10
    01728 2733      CLR	R19
(0067) 		preGetCardNum[i] = 0;
    01729 0F22      LSL	R18
    0172A 1F33      ROL	R19
    0172B 0F22      LSL	R18
    0172C 1F33      ROL	R19
    0172D 0F22      LSL	R18
    0172E 1F33      ROL	R19
    0172F 0F28      ADD	R18,R24
    01730 1F39      ADC	R19,R25
    01731 0186      MOVW	R16,R12
    01732 940E 7118 CALL	_MemCopy
(0068) 	preCardStoreNum = 1;
    01734 E183      LDI	R24,0x13
    01735 E09B      LDI	R25,0xB
    01736 2DEA      MOV	R30,R10
(0069) 	LastCardGetState = 1;
    01737 27FF      CLR	R31
    01738 0FE8      ADD	R30,R24
(0070) 	_AutoTestCycleNum = 124; 	// 124
    01739 1FF9      ADC	R31,R25
    0173A E081      LDI	R24,1
    0173B 8380      ST	Z,R24
    0173C C013      RJMP	0x1750
    0173D 9180 00C1 LDS	R24,0xC1
    0173F 7E8F      ANDI	R24,0xEF
(0071) }
(0072) 
(0073) void clearstopFlag(void)
(0074) {
(0075) 	if(stopFlag == 1)
_clearstopFlag:
    01740 9380 00C1 STS	0xC1,R24
    01742 2D2A      MOV	R18,R10
    01743 2733      CLR	R19
(0076) 		stopFlag = 0;
    01744 E002      LDI	R16,2
    01745 E012      LDI	R17,2
    01746 940E A90D CALL	_uart_Printf
_CardGetTestDone:
    01748 9180 00C1 LDS	R24,0xC1
(0077) }
(0078) 
(0079) static void CardGetTestDone(void)
(0080) {
(0081) 	static unsigned char num;
(0082) 	if(1 == stopFlag)	return;
    0174A 6180      ORI	R24,0x10
    0174B 9380 00C1 STS	0xC1,R24
    0174D 9478      BSET	7
(0083) 	stopFlag = 0;
    0174E E001      LDI	R16,1
    0174F C002      RJMP	0x1752
    01750 9478      BSET	7
(0084) 	LastCardGetState = 1;
    01751 2700      CLR	R16
    01752 9621      ADIW	R28,1
    01753 940C AE58 JMP	pop_xgset003C
(0085) 	if(preCardStoreNum >= 1)
_GetSlaveState:
    01755 940E AE7C CALL	push_xgset00FC
    01757 2EA0      MOV	R10,R16
(0086) 	{
(0087) 		preGetCardNum[preCardStoreNum - 1]++;
    01758 E70B      LDI	R16,0x7B
    01759 2D1A      MOV	R17,R10
    0175A 0301      MULSU	R16,R17
    0175B EC8C      LDI	R24,0xCC
    0175C E09B      LDI	R25,0xB
    0175D 01F0      MOVW	R30,R0
    0175E 0FE8      ADD	R30,R24
    0175F 1FF9      ADC	R31,R25
    01760 80C0      LD	R12,Z
    01761 0301      MULSU	R16,R17
    01762 EC8D      LDI	R24,0xCD
(0088) 		if(preGetCardNum[preCardStoreNum - 1] >= 25)  // 25
    01763 E09B      LDI	R25,0xB
    01764 01F0      MOVW	R30,R0
    01765 0FE8      ADD	R30,R24
    01766 1FF9      ADC	R31,R25
    01767 80E0      LD	R14,Z
    01768 14CE      CP	R12,R14
    01769 F441      BNE	0x1772
    0176A E889      LDI	R24,0x89
    0176B E192      LDI	R25,0x12
    0176C 2DEA      MOV	R30,R10
(0089) 		{
(0090) 			preCardStoreNum++;
    0176D 27FF      CLR	R31
    0176E 0FE8      ADD	R30,R24
    0176F 1FF9      ADC	R31,R25
    01770 8100      LD	R16,Z
    01771 C001      RJMP	0x1773
(0091) 			if(preCardStoreNum > 5)
    01772 E002      LDI	R16,2
    01773 940C AE5D JMP	pop_xgset00FC
_SendInfoEvent:
    01775 934A      ST	-Y,R20
    01776 9020 0201 LDS	R2,SendEventCritical
(0092) 				preCardStoreNum = 5;
    01778 2022      TST	R2
(0093) 		}
(0094) 	}
(0095) 	num = preGetCardNum[0] +  preGetCardNum[1] + preGetCardNum[2] + preGetCardNum[3] +  preGetCardNum[4];
    01779 F009      BEQ	0x177B
    0177A C01C      RJMP	0x1797
    0177B E081      LDI	R24,1
    0177C 9380 0201 STS	SendEventCritical,R24
    0177E 9140 1298 LDS	R20,InfoEventStack
    01780 9020 1299 LDS	R2,InfoEventStack+1
    01782 1542      CP	R20,R2
    01783 F081      BEQ	0x1794
    01784 E00D      LDI	R16,0xD
    01785 2F14      MOV	R17,R20
    01786 0301      MULSU	R16,R17
    01787 0180      MOVW	R16,R0
    01788 E98A      LDI	R24,0x9A
(0096) 	Uart0ReUnable;
    01789 E192      LDI	R25,0x12
    0178A 0F08      ADD	R16,R24
    0178B 1F19      ADC	R17,R25
    0178C 940E 3222 CALL	_SlaveEventAssignProcess
(0097) 	uart_Printf("%s $%4d\r\n",strM3128,num);
    0178E 9543      INC	R20
    0178F 3342      CPI	R20,0x32
    01790 F409      BNE	0x1792
    01791 2744      CLR	R20
    01792 9340 1298 STS	InfoEventStack,R20
    01794 2422      CLR	R2
    01795 9220 0201 STS	SendEventCritical,R2
    01797 9149      LD	R20,Y+
(0098) 	Uart0ReEnable;
    01798 9508      RET
_SetGetCardTestMode:
    01799 934A      ST	-Y,R20
    0179A 2F40      MOV	R20,R16
    0179B E081      LDI	R24,1
    0179C 1784      CP	R24,R20
(0099) 	if(num >= 125)	 // 125
    0179D F408      BCC	0x179F
    0179E E041      LDI	R20,1
    0179F 9340 1559 STS	CardStoreTestFlag,R20
(0100) 	{
(0101) 		ReStartCardGetTest();
    017A1 3041      CPI	R20,1
(0102) 		CardStoreTestFlag = 0;	 // 退出取片测试模式
    017A2 F511      BNE	0x17C5
    017A3 2422      CLR	R2
    017A4 9220 06F6 STS	CardNoneUseful,R2
(0103) 		LastCardGetState = 0;	 // 上一次取片动作完成
    017A6 E78C      LDI	R24,0x7C
(0104) 		SetDiluentRatio(9);
    017A7 E090      LDI	R25,0
    017A8 9390 052F STS	_AutoTestCycleNum+1,R25
(0105) #ifdef Puncture
(0106) 		WithoutPuncture = 0;	// 恢复穿刺		
(0107) #endif
(0108) 		Uart0ReUnable;
    017AA 9380 052E STS	_AutoTestCycleNum,R24
    017AC E081      LDI	R24,1
    017AD 9380 1553 STS	LastCardGetState,R24
(0109) 		uart_Printf("%s\r\n", strM3127);
    017AF 9380 02E1 STS	preCardStoreNum,R24
    017B1 E001      LDI	R16,1
    017B2 940E 5283 CALL	_SetDiluentRatio
    017B4 9180 00C1 LDS	R24,0xC1
(0110) 		Uart0ReEnable;
    017B6 7E8F      ANDI	R24,0xEF
    017B7 9380 00C1 STS	0xC1,R24
    017B9 EC20      LDI	R18,0xC0
(0111) 	}
    017BA E03E      LDI	R19,0xE
    017BB EE03      LDI	R16,0xE3
_CalCardStorePos:
  i                    --> R20
  num                  --> R16
    017BC E013      LDI	R17,3
    017BD 940E A90D CALL	_uart_Printf
(0112) }
(0113) 
(0114) unsigned int CalCardStorePos(unsigned char num)
(0115) {
(0116) 	unsigned int i;
(0117) 	switch(num)
    017BF 9180 00C1 LDS	R24,0xC1
    017C1 6180      ORI	R24,0x10
    017C2 9380 00C1 STS	0xC1,R24
    017C4 C016      RJMP	0x17DB
    017C5 2422      CLR	R2
    017C6 2433      CLR	R3
    017C7 9230 052F STS	_AutoTestCycleNum+1,R3
    017C9 9220 052E STS	_AutoTestCycleNum,R2
    017CB 9180 00C1 LDS	R24,0xC1
    017CD 7E8F      ANDI	R24,0xEF
    017CE 9380 00C1 STS	0xC1,R24
    017D0 E228      LDI	R18,0x28
    017D1 E03F      LDI	R19,0xF
    017D2 ED0A      LDI	R16,0xDA
    017D3 E013      LDI	R17,3
    017D4 940E A90D CALL	_uart_Printf
(0118) 	{
(0119) 		case 1:		i = 975-25;	break;			// 79mm / 0.081 = 975;
    017D6 9180 00C1 LDS	R24,0xC1
(0120) 		case 2:		i = 1383-25;	break;		// (79+33)mm / 0.081 = 1383
    017D8 6180      ORI	R24,0x10
    017D9 9380 00C1 STS	0xC1,R24
(0121) 		case 3:		i = 1790-25;	break;		// (79+66)mm / 0.081 = 1790
    017DB 9149      LD	R20,Y+
    017DC 9508      RET
    017DD 2700      CLR	R16
(0122) 		case 4:		i = 2198-25;	break;		// (79+99)mm / 0.081 = 2198
    017DE C009      RJMP	0x17E8
    017DF E584      LDI	R24,0x54
    017E0 E195      LDI	R25,0x15
(0123) 		case 5:		i = 2605-45;	break;		// (79+132)mm / 0.081 = 2605
    017E1 2FE0      MOV	R30,R16
    017E2 27FF      CLR	R31
    017E3 0FE8      ADD	R30,R24
(0124) 		default:	i = 975-25;	break;
    017E4 1FF9      ADC	R31,R25
    017E5 2422      CLR	R2
(0125) 	}
(0126) 	return i;
    017E6 8220      ST	Z,R2
    017E7 9503      INC	R16
    017E8 3005      CPI	R16,5
    017E9 F3A8      BCS	0x17DF
_SetCardTrolleyState:
  state                --> R16
    017EA E081      LDI	R24,1
    017EB 9380 02E1 STS	preCardStoreNum,R24
(0127) }
(0128) 
(0129) unsigned char CardTrolleySta = 255;		// 小车初始状态 0:小车平置, 1:小车翻起, 255:状态未稳定
(0130) unsigned char CardTrolleySet=0;//小车的执行状态
(0131) void SetCardTrolleyState(unsigned char state){
(0132) 	// state==0 关闭; state==1 翻起; state==2 吸平
(0133) 	CardTrolleySet = state;//
    017ED 9380 1553 STS	LastCardGetState,R24
(0134) 	switch(state){
    017EF E78C      LDI	R24,0x7C
    017F0 E090      LDI	R25,0
    017F1 9390 052F STS	_AutoTestCycleNum+1,R25
    017F3 9380 052E STS	_AutoTestCycleNum,R24
    017F5 9508      RET
_clearstopFlag:
    017F6 9180 02E2 LDS	R24,stopFlag
    017F8 3081      CPI	R24,1
    017F9 F419      BNE	0x17FD
    017FA 2422      CLR	R2
    017FB 9220 02E2 STS	stopFlag,R2
(0135) 		case 0:		// 关闭
(0136) 			PORTF &= 0xfc;		// Forward OFF 01111100
    017FD 9508      RET
    017FE 9722      SBIW	R28,2
(0137) 			break;
    017FF 9180 02E2 LDS	R24,stopFlag
(0138) 		case 1:		// 翻起
(0139) 			PORTF &= 0xfc;
    01801 3081      CPI	R24,1
    01802 F409      BNE	0x1804
(0140) 			PORTF |= 0x01;
    01803 C06C      RJMP	0x1870
(0141) 			break;
    01804 2422      CLR	R2
(0142) 		case 2:		// 吸平
(0143) 			PORTF &= 0xfc;
    01805 9220 02E2 STS	stopFlag,R2
    01807 E081      LDI	R24,1
(0144) 			PORTF |= 0x02;
    01808 9380 1553 STS	LastCardGetState,R24
(0145) 			break;
(0146) 		}
(0147) 	if(CardTrolleySet == 0)
    0180A 9180 02E1 LDS	R24,preCardStoreNum
    0180C 3081      CPI	R24,1
(0148) 	{
(0149) 	//	PORTF &= 0xfe;		// Forward OFF 01111111
(0150) 	//	PORTF |= 0x02;		// Reverse ON  00000010
(0151) 		PORTF &= 0xfc;		// Forward OFF 01111100
    0180D F108      BCS	0x182F
    0180E E583      LDI	R24,0x53
    0180F E195      LDI	R25,0x15
(0152) 	}
    01810 9020 02E1 LDS	R2,preCardStoreNum
(0153) 	else 
(0154) 	{
(0155) 		PORTF |= 0x01;		// Forward ON 11111100
    01812 2433      CLR	R3
    01813 0E28      ADD	R2,R24
    01814 1E39      ADC	R3,R25
(0156) 	//	PORTF &= 0xfd;		// Reverse OFF 11111101
(0157) 	}
(0158) }
(0159) unsigned char GetCardTrolleyState(void)
(0160) {
(0161) 	return CardTrolleySta;
_GetCardTrolleyState:
    01815 01F1      MOVW	R30,R2
    01816 8180      LD	R24,Z
    01817 5F8F      SUBI	R24,0xFF
(0162) }
(0163) void CardTrolleyTurnProcess(void){		// 卡片小车翻转处理
(0164) 	unsigned char sw;
(0165) 	if(PINL & 0x04){//端口定义 不为0
_CardTrolleyTurnProcess:
  sw                   --> Y,+1
    01818 8380      ST	Z,R24
    01819 E583      LDI	R24,0x53
    0181A E195      LDI	R25,0x15
    0181B 91E0 02E1 LDS	R30,preCardStoreNum
(0166) 	//	sw = 1;		// 小车平置
(0167) 		CardTrolleySta = 1;
    0181D 27FF      CLR	R31
    0181E 0FE8      ADD	R30,R24
(0168) 		}
    0181F 1FF9      ADC	R31,R25
(0169) 	else{
(0170) 	//	sw = 0;		// 小车翻起
(0171) 		CardTrolleySta = 0;
    01820 8180      LD	R24,Z
    01821 3189      CPI	R24,0x19
    01822 F060      BCS	0x182F
(0172) 		}
    01823 9180 02E1 LDS	R24,preCardStoreNum
    01825 5F8F      SUBI	R24,0xFF
    01826 9380 02E1 STS	preCardStoreNum,R24
(0173) }
(0174) 
(0175) 
(0176) /********************************  片仓状态处理程序  ***************************************/
(0177) unsigned char CardStoreOpenState;	// 片仓开关状态
(0178) unsigned char CardSurplusState[6];		// 卡片剩余状态
(0179) unsigned char CardStoretate[6];		// 片仓状态
(0180) 
(0181) void _SenCardStoreState(unsigned char num)
(0182) {
(0183) 	switch(CardSurplusState[num])
    01828 E085      LDI	R24,5
    01829 9020 02E1 LDS	R2,preCardStoreNum
    0182B 1582      CP	R24,R2
    0182C F410      BCC	0x182F
    0182D 9380 02E1 STS	preCardStoreNum,R24
    0182F 9020 1555 LDS	R2,LastCardGetState+2
    01831 9030 1554 LDS	R3,LastCardGetState+1
    01833 0C32      ADD	R3,R2
    01834 9020 1556 LDS	R2,LastCardGetState+3
    01836 0C32      ADD	R3,R2
    01837 9020 1557 LDS	R2,LastCardGetState+4
    01839 0C32      ADD	R3,R2
    0183A 9020 1558 LDS	R2,LastCardGetState+5
    0183C 0C32      ADD	R3,R2
    0183D 9230 1524 STS	liqDetBaseAdc+63,R3
    0183F 9180 00C1 LDS	R24,0xC1
    01841 7E8F      ANDI	R24,0xEF
(0184) 	{
(0185) 		case INFO_STORE_FULL:
(0186) 			Uart0ReUnable;
    01842 9380 00C1 STS	0xC1,R24
    01844 2C23      MOV	R2,R3
    01845 2433      CLR	R3
    01846 8239      STD	Y+1,R3
(0187) 			uart_Printf("%s $%4d\r\n", strM3132, num+1);
    01847 8228      ST	Y,R2
    01848 E02E      LDI	R18,0xE
    01849 E03F      LDI	R19,0xF
    0184A ED00      LDI	R16,0xD0
    0184B E013      LDI	R17,3
    0184C 940E A90D CALL	_uart_Printf
    0184E 9180 00C1 LDS	R24,0xC1
    01850 6180      ORI	R24,0x10
    01851 9380 00C1 STS	0xC1,R24
(0188) 			Uart0ReEnable;
    01853 9180 1524 LDS	R24,liqDetBaseAdc+63
    01855 378D      CPI	R24,0x7D
    01856 F0C8      BCS	0x1870
(0189) 			break;
    01857 DF85      RCALL	0x17DD
(0190) 		case INFO_STORE_LITTLE:
(0191) 			Uart0ReUnable;
    01858 2422      CLR	R2
    01859 9220 1559 STS	CardStoreTestFlag,R2
    0185B 9220 1553 STS	LastCardGetState,R2
(0192) 			uart_Printf("%s $%4d\r\n", strM3133, num+1);
    0185D E009      LDI	R16,0x9
    0185E 940E 5283 CALL	_SetDiluentRatio
    01860 9180 00C1 LDS	R24,0xC1
    01862 7E8F      ANDI	R24,0xEF
    01863 9380 00C1 STS	0xC1,R24
    01865 EF23      LDI	R18,0xF3
    01866 E03E      LDI	R19,0xE
    01867 EC0B      LDI	R16,0xCB
(0193) 			Uart0ReEnable;
    01868 E013      LDI	R17,3
    01869 940E A90D CALL	_uart_Printf
    0186B 9180 00C1 LDS	R24,0xC1
(0194) 			break;
    0186D 6180      ORI	R24,0x10
(0195) 		case INFO_STORE_EMPTY:
(0196) 			Uart0ReUnable;
    0186E 9380 00C1 STS	0xC1,R24
    01870 9622      ADIW	R28,2
    01871 9508      RET
_CalCardStorePos:
    01872 934A      ST	-Y,R20
(0197) 			uart_Printf("%s $%4d\r\n", strM3134, num+1);
    01873 935A      ST	-Y,R21
    01874 2F40      MOV	R20,R16
    01875 2755      CLR	R21
    01876 3041      CPI	R20,1
    01877 E0E0      LDI	R30,0
    01878 075E      CPC	R21,R30
    01879 F089      BEQ	0x188B
    0187A 3042      CPI	R20,2
    0187B E0E0      LDI	R30,0
    0187C 075E      CPC	R21,R30
    0187D F081      BEQ	0x188E
(0198) 			Uart0ReEnable;
    0187E 3043      CPI	R20,3
    0187F E0E0      LDI	R30,0
    01880 075E      CPC	R21,R30
    01881 F079      BEQ	0x1891
    01882 3044      CPI	R20,4
(0199) 			break;
(0200) 		case INFO_STORE_ERROR:
(0201) 		default:
(0202) 			break;
    01883 E0E0      LDI	R30,0
    01884 075E      CPC	R21,R30
    01885 F071      BEQ	0x1894
_ReportCardStoreState:
  i                    --> R20
  num                  --> R10
    01886 3045      CPI	R20,5
    01887 E0E0      LDI	R30,0
    01888 075E      CPC	R21,R30
(0203) 	}
(0204) }
(0205) void ReportCardStoreState(unsigned char num)
(0206) {
(0207) 	// 向上位机报告当前片仓状态
(0208) 	unsigned char i;
(0209) 	if(num == 0)
    01889 F069      BEQ	0x1897
    0188A C00F      RJMP	0x189A
(0210) 	{
(0211) 		for(i=0; i<5; i++)
    0188B EB46      LDI	R20,0xB6
    0188C E053      LDI	R21,3
(0212) 		{
(0213) 			_SenCardStoreState(i);
    0188D C00E      RJMP	0x189C
    0188E E44E      LDI	R20,0x4E
    0188F E055      LDI	R21,5
    01890 C00B      RJMP	0x189C
    01891 EE45      LDI	R20,0xE5
(0214) 		}
(0215) 	}
    01892 E056      LDI	R21,6
(0216) 	else
(0217) 	{
(0218) 		num --;
    01893 C008      RJMP	0x189C
(0219) 		_SenCardStoreState(num);
    01894 E74D      LDI	R20,0x7D
    01895 E058      LDI	R21,0x8
(0220) 	}
    01896 C005      RJMP	0x189C
    01897 E040      LDI	R20,0
    01898 E05A      LDI	R21,0xA
_CardStoreSteteProcess:
  pInfo                --> R20
  num                  --> R22
  pInfoEvent           --> R10
    01899 C002      RJMP	0x189C
    0189A EB46      LDI	R20,0xB6
    0189B E053      LDI	R21,3
    0189C 018A      MOVW	R16,R20
(0221) }
(0222) 
(0223) _CONST unsigned char Num2Bit[] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};
(0224) unsigned char CardStoreSteteProcess(INFO_EVENT * pInfoEvent)
(0225) {
(0226) 	unsigned char num;
(0227) 	unsigned char * pInfo;
(0228) 	if(pInfoEvent->event != INFO_STORE_STATE_ALL){
    0189D 9159      LD	R21,Y+
    0189E 9149      LD	R20,Y+
    0189F 9508      RET
_SetCardTrolleyState:
    018A0 934A      ST	-Y,R20
(0229) 		num = pInfoEvent->info[0];
    018A1 935A      ST	-Y,R21
(0230) 		if(num>5)
    018A2 9300 02E4 STS	CardTrolleySet,R16
    018A4 2F40      MOV	R20,R16
(0231) 			return 0;
    018A5 2755      CLR	R21
    018A6 3040      CPI	R20,0
(0232) 		}
(0233) 	//num = 5-num;	// 颠倒顺序
(0234) 	switch(pInfoEvent->event){
    018A7 0745      CPC	R20,R21
    018A8 F049      BEQ	0x18B2
    018A9 3041      CPI	R20,1
    018AA E0E0      LDI	R30,0
    018AB 075E      CPC	R21,R30
    018AC F049      BEQ	0x18B6
    018AD 3042      CPI	R20,2
    018AE E0E0      LDI	R30,0
    018AF 075E      CPC	R21,R30
    018B0 F051      BEQ	0x18BB
    018B1 C00D      RJMP	0x18BF
    018B2 B381      IN	R24,0x11
    018B3 7F8C      ANDI	R24,0xFC
    018B4 BB81      OUT	0x11,R24
    018B5 C009      RJMP	0x18BF
    018B6 B381      IN	R24,0x11
    018B7 7F8C      ANDI	R24,0xFC
    018B8 BB81      OUT	0x11,R24
    018B9 9A88      SBI	0x11,0
    018BA C004      RJMP	0x18BF
    018BB B381      IN	R24,0x11
    018BC 7F8C      ANDI	R24,0xFC
    018BD BB81      OUT	0x11,R24
    018BE 9A89      SBI	0x11,1
    018BF 9020 02E4 LDS	R2,CardTrolleySet
    018C1 2022      TST	R2
    018C2 F421      BNE	0x18C7
    018C3 B381      IN	R24,0x11
    018C4 7F8C      ANDI	R24,0xFC
    018C5 BB81      OUT	0x11,R24
    018C6 C001      RJMP	0x18C8
    018C7 9A88      SBI	0x11,0
    018C8 9159      LD	R21,Y+
    018C9 9149      LD	R20,Y+
    018CA 9508      RET
_GetCardTrolleyState:
    018CB 9100 02E3 LDS	R16,CardTrolleySta
    018CD 9508      RET
_CardTrolleyTurnProcess:
    018CE 9020 0109 LDS	R2,0x109
    018D0 FE22      SBRS	R2,2
    018D1 C004      RJMP	0x18D6
(0235) 		case INFO_STORE_OPEN:		// 片仓打开
(0236) 			CardStoreOpenState |= Num2Bit[num];
    018D2 E081      LDI	R24,1
    018D3 9380 02E3 STS	CardTrolleySta,R24
    018D5 C003      RJMP	0x18D9
    018D6 2422      CLR	R2
    018D7 9220 02E3 STS	CardTrolleySta,R2
    018D9 9508      RET
__SenCardStoreState:
    018DA 940E AE83 CALL	push_xgset300C
    018DC 2EA0      MOV	R10,R16
    018DD 9722      SBIW	R28,2
(0237) 			CardStoretate[num] = INFO_STORE_OPEN;
    018DE E48C      LDI	R24,0x4C
    018DF E195      LDI	R25,0x15
    018E0 2DEA      MOV	R30,R10
    018E1 27FF      CLR	R31
    018E2 0FE8      ADD	R30,R24
    018E3 1FF9      ADC	R31,R25
    018E4 8140      LD	R20,Z
    018E5 2755      CLR	R21
(0238) 			Uart0ReUnable;
    018E6 3146      CPI	R20,0x16
    018E7 E0E0      LDI	R30,0
    018E8 075E      CPC	R21,R30
    018E9 F071      BEQ	0x18F8
    018EA 3147      CPI	R20,0x17
(0239) 			uart_Printf("%s $%4d\r\n",strM3130, num+1);
    018EB E0E0      LDI	R30,0
    018EC 075E      CPC	R21,R30
    018ED F101      BEQ	0x190E
    018EE 3148      CPI	R20,0x18
    018EF E0E0      LDI	R30,0
    018F0 075E      CPC	R21,R30
    018F1 F191      BEQ	0x1924
    018F2 3149      CPI	R20,0x19
    018F3 E0E0      LDI	R30,0
    018F4 075E      CPC	R21,R30
    018F5 F409      BNE	0x18F7
(0240) 			Uart0ReEnable;
    018F6 C042      RJMP	0x1939
    018F7 C041      RJMP	0x1939
    018F8 9180 00C1 LDS	R24,0xC1
    018FA 7E8F      ANDI	R24,0xEF
(0241) 			break;
    018FB 9380 00C1 STS	0xC1,R24
(0242) 		case INFO_STORE_CLOSE:		// 片仓关闭
(0243) 			CardStoreOpenState &= (0xff-Num2Bit[num]);
    018FD 2D8A      MOV	R24,R10
    018FE 2799      CLR	R25
    018FF 9601      ADIW	R24,1
    01900 8399      STD	Y+1,R25
    01901 8388      ST	Y,R24
    01902 E628      LDI	R18,0x68
    01903 E03F      LDI	R19,0xF
    01904 ED00      LDI	R16,0xD0
    01905 E013      LDI	R17,3
    01906 940E A90D CALL	_uart_Printf
    01908 9180 00C1 LDS	R24,0xC1
    0190A 6180      ORI	R24,0x10
    0190B 9380 00C1 STS	0xC1,R24
    0190D C02B      RJMP	0x1939
    0190E 9180 00C1 LDS	R24,0xC1
(0244) 			CardStoretate[num] = INFO_STORE_CLOSE;
    01910 7E8F      ANDI	R24,0xEF
    01911 9380 00C1 STS	0xC1,R24
    01913 2D8A      MOV	R24,R10
    01914 2799      CLR	R25
    01915 9601      ADIW	R24,1
    01916 8399      STD	Y+1,R25
(0245) 			Uart0ReUnable;
    01917 8388      ST	Y,R24
    01918 E72C      LDI	R18,0x7C
    01919 E03F      LDI	R19,0xF
    0191A ED00      LDI	R16,0xD0
    0191B E013      LDI	R17,3
(0246) 			uart_Printf("%s $%4d\r\n", strM3131, num+1);
    0191C 940E A90D CALL	_uart_Printf
    0191E 9180 00C1 LDS	R24,0xC1
    01920 6180      ORI	R24,0x10
    01921 9380 00C1 STS	0xC1,R24
    01923 C015      RJMP	0x1939
    01924 9180 00C1 LDS	R24,0xC1
    01926 7E8F      ANDI	R24,0xEF
(0247) 			Uart0ReEnable;
    01927 9380 00C1 STS	0xC1,R24
    01929 2D8A      MOV	R24,R10
    0192A 2799      CLR	R25
    0192B 9601      ADIW	R24,1
(0248) 			_SenCardStoreState(num);	// 片仓关闭后发送片仓存储状态
    0192C 8399      STD	Y+1,R25
    0192D 8388      ST	Y,R24
(0249) 			break;
    0192E E922      LDI	R18,0x92
(0250) 		case INFO_STORE_FULL:		// 片仓满
(0251) 			CardSurplusState[num] = pInfoEvent->event;
    0192F E03F      LDI	R19,0xF
    01930 ED00      LDI	R16,0xD0
    01931 E013      LDI	R17,3
    01932 940E A90D CALL	_uart_Printf
    01934 9180 00C1 LDS	R24,0xC1
    01936 6180      ORI	R24,0x10
    01937 9380 00C1 STS	0xC1,R24
(0252) 			CardStoretate[num] = INFO_STORE_FULL;
    01939 9622      ADIW	R28,2
    0193A 940C AE88 JMP	pop_xgset300C
_ReportCardStoreState:
    0193C 92AA      ST	-Y,R10
    0193D 934A      ST	-Y,R20
    0193E 2EA0      MOV	R10,R16
    0193F 20AA      TST	R10
    01940 F441      BNE	0x1949
(0253) 			break;
    01941 2744      CLR	R20
(0254) 		case INFO_STORE_LITTLE:		// 片仓少量
(0255) 			CardSurplusState[num] = pInfoEvent->event;
    01942 C003      RJMP	0x1946
    01943 2F04      MOV	R16,R20
    01944 DF95      RCALL	__SenCardStoreState
    01945 9543      INC	R20
    01946 3045      CPI	R20,5
    01947 F3D8      BCS	0x1943
    01948 C003      RJMP	0x194C
    01949 94AA      DEC	R10
    0194A 2D0A      MOV	R16,R10
    0194B DF8E      RCALL	__SenCardStoreState
(0256) 			CardStoretate[num] = INFO_STORE_LITTLE;
    0194C 9149      LD	R20,Y+
    0194D 90A9      LD	R10,Y+
    0194E 9508      RET
_CardStoreSteteProcess:
    0194F 940E AE97 CALL	push_xgsetF00C
    01951 0158      MOVW	R10,R16
    01952 9722      SBIW	R28,2
    01953 01F5      MOVW	R30,R10
(0257) 			break;
    01954 8181      LDD	R24,Z+1
(0258) 		case INFO_STORE_EMPTY:		// 片仓空
(0259) 			CardSurplusState[num] = pInfoEvent->event;
    01955 318D      CPI	R24,0x1D
    01956 F031      BEQ	0x195D
    01957 8162      LDD	R22,Z+2
    01958 E085      LDI	R24,5
    01959 1786      CP	R24,R22
    0195A F410      BCC	0x195D
    0195B 2700      CLR	R16
    0195C C107      RJMP	0x1A64
    0195D 01F5      MOVW	R30,R10
    0195E 8141      LDD	R20,Z+1
(0260) 			CardStoretate[num] = INFO_STORE_EMPTY;
    0195F 2755      CLR	R21
    01960 3144      CPI	R20,0x14
    01961 E0E0      LDI	R30,0
    01962 075E      CPC	R21,R30
    01963 F121      BEQ	0x1988
    01964 3145      CPI	R20,0x15
    01965 E0E0      LDI	R30,0
    01966 075E      CPC	R21,R30
(0261) 			break;
    01967 F409      BNE	0x1969
(0262) 		case INFO_STORE_ERROR:		// 片仓状态错误
(0263) 			CardSurplusState[num] = pInfoEvent->event;
    01968 C049      RJMP	0x19B2
    01969 3146      CPI	R20,0x16
    0196A E0E0      LDI	R30,0
    0196B 075E      CPC	R21,R30
    0196C F409      BNE	0x196E
    0196D C077      RJMP	0x19E5
    0196E 3147      CPI	R20,0x17
    0196F E0E0      LDI	R30,0
    01970 075E      CPC	R21,R30
    01971 F409      BNE	0x1973
(0264) 			CardStoretate[num] = INFO_STORE_ERROR;
    01972 C085      RJMP	0x19F8
    01973 3148      CPI	R20,0x18
    01974 E0E0      LDI	R30,0
    01975 075E      CPC	R21,R30
    01976 F409      BNE	0x1978
    01977 C093      RJMP	0x1A0B
    01978 3149      CPI	R20,0x19
    01979 E0E0      LDI	R30,0
(0265) 			break;
    0197A 075E      CPC	R21,R30
(0266) 		case INFO_STORE_STATE_ALL:	// 全部片仓状态信息
(0267) 			pInfo = &(pInfoEvent->info[0]);
    0197B F409      BNE	0x197D
    0197C C0A1      RJMP	0x1A1E
    0197D 314D      CPI	R20,0x1D
(0268) 			for(num=0; num<6; num++){
    0197E E0E0      LDI	R30,0
    0197F 075E      CPC	R21,R30
(0269) 				if(*pInfo >= INFO_STORE_FULL && *pInfo <= INFO_STORE_ERROR){
    01980 F409      BNE	0x1982
    01981 C0AF      RJMP	0x1A31
    01982 314E      CPI	R20,0x1E
    01983 E0E0      LDI	R30,0
    01984 075E      CPC	R21,R30
    01985 F409      BNE	0x1987
    01986 C0C7      RJMP	0x1A4E
    01987 C0DB      RJMP	0x1A63
    01988 EF88      LDI	R24,0xF8
(0270) 					CardSurplusState[num] = *pInfo;
    01989 E094      LDI	R25,4
    0198A 2FE6      MOV	R30,R22
    0198B 27FF      CLR	R31
    0198C 0FE8      ADD	R30,R24
    0198D 1FF9      ADC	R31,R25
    0198E 9026      ELPM	R2,Z
    0198F 9030 1552 LDS	R3,CardStoreOpenState
    01991 2832      OR	R3,R2
(0271) 					}
(0272) 				pInfo ++;
    01992 9230 1552 STS	CardStoreOpenState,R3
    01994 E486      LDI	R24,0x46
    01995 E195      LDI	R25,0x15
    01996 2FE6      MOV	R30,R22
(0273) 				}
(0274) 			break;
    01997 27FF      CLR	R31
(0275) 		case INFO_STORE_STATE_SPC:	// 指定片仓状态信息
(0276) 			pInfo = &(pInfoEvent->info[1]);
    01998 0FE8      ADD	R30,R24
    01999 1FF9      ADC	R31,R25
    0199A E184      LDI	R24,0x14
(0277) 			if(*pInfo >= INFO_STORE_FULL && *pInfo <= INFO_STORE_ERROR){
    0199B 8380      ST	Z,R24
    0199C 9180 00C1 LDS	R24,0xC1
    0199E 7E8F      ANDI	R24,0xEF
    0199F 9380 00C1 STS	0xC1,R24
    019A1 2F86      MOV	R24,R22
    019A2 2799      CLR	R25
    019A3 9601      ADIW	R24,1
(0278) 				CardSurplusState[num] = *pInfo;
    019A4 8399      STD	Y+1,R25
    019A5 8388      ST	Y,R24
    019A6 E32F      LDI	R18,0x3F
    019A7 E03F      LDI	R19,0xF
    019A8 ED00      LDI	R16,0xD0
    019A9 E013      LDI	R17,3
    019AA 940E A90D CALL	_uart_Printf
    019AC 9180 00C1 LDS	R24,0xC1
(0279) 				}
(0280) 		default:
(0281) 			break;
(0282) 		}
(0283) 	return 0;
    019AE 6180      ORI	R24,0x10
    019AF 9380 00C1 STS	0xC1,R24
_printf_CardstoreProcess_StepState:
    019B1 C0B1      RJMP	0x1A63
(0284) }
(0285) 
(0286) 
(0287) /*********************************************************************************************/
(0288) 
(0289) static unsigned char CardstoreProcess_workStep,CardstoreProcess_mainStep;
(0290) 
(0291) void printf_CardstoreProcess_StepState(void)
(0292) {
(0293) 	uart_Printf("*3203 CardStoreStepState $%2d $%2d\r\n",CardstoreProcess_mainStep,CardstoreProcess_workStep);
    019B2 EF88      LDI	R24,0xF8
    019B3 E094      LDI	R25,4
    019B4 2FE6      MOV	R30,R22
    019B5 27FF      CLR	R31
    019B6 0FE8      ADD	R30,R24
    019B7 1FF9      ADC	R31,R25
    019B8 9026      ELPM	R2,Z
    019B9 2433      CLR	R3
    019BA EF8F      LDI	R24,0xFF
    019BB E090      LDI	R25,0
    019BC 1982      SUB	R24,R2
    019BD 0993      SBC	R25,R3
    019BE 9020 1552 LDS	R2,CardStoreOpenState
_GetNewPieceFromStoreProcess:
  pos                  --> Y,+5
  siTmp                --> R22
  ucTmp                --> R20
  pInfoEvent           --> Y,+10
    019C0 2433      CLR	R3
    019C1 2228      AND	R2,R24
    019C2 2239      AND	R3,R25
    019C3 9220 1552 STS	CardStoreOpenState,R2
(0294) }
(0295) 
(0296) 
(0297) /********************************  测试卡提取处理程序  ***************************************/
(0298) extern unsigned char _GetCardMainStep, _GetCardWorkStep;
(0299) extern SAMP_INFO NewTestInfo;
(0300) 
(0301) unsigned char GetNewPieceFromStoreProcess(INFO_EVENT * pInfoEvent){
(0302) 	static unsigned char mainStep;		
(0303) 	static unsigned char workStep;
(0304) 	static signed int storePos;
(0305) 	static unsigned char inWork,i,j;
(0306) 	static unsigned char waitMotCardTrolley, waitMotCardLoad,waitMotCardUnload, waitMotTurnPlate;
(0307) 	static unsigned char oldStoreState;
(0308) 	static unsigned char oldGetCardState;
(0309) 	static unsigned char curCardStoreNum;
(0310) 	static unsigned char checkReDoCnt, takeRedoCnt;
(0311) 	signed int siTmp;
(0312) 	unsigned char pos;
(0313) 	unsigned char ucTmp;
(0314) 	CardstoreProcess_mainStep = mainStep;
    019C5 E486      LDI	R24,0x46
    019C6 E195      LDI	R25,0x15
    019C7 2FE6      MOV	R30,R22
    019C8 27FF      CLR	R31
(0315) 	CardstoreProcess_workStep = workStep;
    019C9 0FE8      ADD	R30,R24
    019CA 1FF9      ADC	R31,R25
    019CB E185      LDI	R24,0x15
    019CC 8380      ST	Z,R24
(0316) 	if(inWork)
    019CD 9180 00C1 LDS	R24,0xC1
    019CF 7E8F      ANDI	R24,0xEF
    019D0 9380 00C1 STS	0xC1,R24
(0317) 	{
(0318) 		if(waitMotCardTrolley)
    019D2 2F86      MOV	R24,R22
    019D3 2799      CLR	R25
    019D4 9601      ADIW	R24,1
    019D5 8399      STD	Y+1,R25
    019D6 8388      ST	Y,R24
(0319) 		{
(0320) 			if(WaitDelayTime(MOT_STORE_CARD_MOVE))
    019D7 E523      LDI	R18,0x53
    019D8 E03F      LDI	R19,0xF
    019D9 ED00      LDI	R16,0xD0
    019DA E013      LDI	R17,3
    019DB 940E A90D CALL	_uart_Printf
(0321) 			{
(0322) 				if(GetMotState(MOT_STORE_CARD_MOVE) != STA_SLAVE_FREE)	
    019DD 9180 00C1 LDS	R24,0xC1
    019DF 6180      ORI	R24,0x10
    019E0 9380 00C1 STS	0xC1,R24
(0323) 					return 0;
    019E2 2F06      MOV	R16,R22
    019E3 DEF6      RCALL	__SenCardStoreState
(0324) 				inWork = 0;
    019E4 C07E      RJMP	0x1A63
    019E5 E48C      LDI	R24,0x4C
    019E6 E195      LDI	R25,0x15
(0325) 				waitMotCardTrolley = 0;
    019E7 2FE6      MOV	R30,R22
    019E8 27FF      CLR	R31
(0326) 				SetDelayTime(MOT_STORE_CARD_MOVE,0);
    019E9 0FE8      ADD	R30,R24
    019EA 1FF9      ADC	R31,R25
    019EB 01D5      MOVW	R26,R10
    019EC 9611      ADIW	R26,1
    019ED 902C      LD	R2,X
(0327) 			}
    019EE 8220      ST	Z,R2
(0328) 			else	// 5秒延时到,取片卡片
(0329) 			{
(0330) 				MotStop(MOT_STORE_CARD_MOVE);
    019EF E486      LDI	R24,0x46
    019F0 E195      LDI	R25,0x15
    019F1 2FE6      MOV	R30,R22
(0331) 				SetBeepWarning();
    019F2 27FF      CLR	R31
    019F3 0FE8      ADD	R30,R24
(0332) #ifndef UartSendLong
(0333) 				Uart0ReUnable;
(0334) 				uart_Printf("!3528 $%8d\r\n", NewTestInfo.testSerial);
(0335) 				Uart0ReEnable;
(0336) #else
(0337) 				Uart0ReUnable;
    019F4 1FF9      ADC	R31,R25
    019F5 E186      LDI	R24,0x16
    019F6 8380      ST	Z,R24
    019F7 C06B      RJMP	0x1A63
    019F8 E48C      LDI	R24,0x4C
(0338) 				uart_Printf("!3528 $ ");
    019F9 E195      LDI	R25,0x15
    019FA 2FE6      MOV	R30,R22
    019FB 27FF      CLR	R31
    019FC 0FE8      ADD	R30,R24
(0339) 				uart0SendInt(NewTestInfo.testSerial);
    019FD 1FF9      ADC	R31,R25
    019FE 01D5      MOVW	R26,R10
    019FF 9611      ADIW	R26,1
    01A00 902C      LD	R2,X
    01A01 8220      ST	Z,R2
    01A02 E486      LDI	R24,0x46
    01A03 E195      LDI	R25,0x15
    01A04 2FE6      MOV	R30,R22
    01A05 27FF      CLR	R31
    01A06 0FE8      ADD	R30,R24
(0340) 				uart_Printf("\r\n");
    01A07 1FF9      ADC	R31,R25
    01A08 E187      LDI	R24,0x17
    01A09 8380      ST	Z,R24
    01A0A C058      RJMP	0x1A63
(0341) 				Uart0ReEnable;
    01A0B E48C      LDI	R24,0x4C
    01A0C E195      LDI	R25,0x15
    01A0D 2FE6      MOV	R30,R22
    01A0E 27FF      CLR	R31
    01A0F 0FE8      ADD	R30,R24
(0342) #endif
(0343) 				inWork = 0;
    01A10 1FF9      ADC	R31,R25
    01A11 01D5      MOVW	R26,R10
    01A12 9611      ADIW	R26,1
(0344) 				waitMotCardTrolley = 0;
    01A13 902C      LD	R2,X
    01A14 8220      ST	Z,R2
(0345) 				workSwitch = 0;
    01A15 E486      LDI	R24,0x46
    01A16 E195      LDI	R25,0x15
(0346) 				Uart0ReUnable;
    01A17 2FE6      MOV	R30,R22
    01A18 27FF      CLR	R31
    01A19 0FE8      ADD	R30,R24
    01A1A 1FF9      ADC	R31,R25
    01A1B E188      LDI	R24,0x18
(0347) 				uart_Printf("%s\r\n",strM0106);
    01A1C 8380      ST	Z,R24
    01A1D C045      RJMP	0x1A63
    01A1E E48C      LDI	R24,0x4C
    01A1F E195      LDI	R25,0x15
    01A20 2FE6      MOV	R30,R22
    01A21 27FF      CLR	R31
(0348) 				Uart0ReEnable;
    01A22 0FE8      ADD	R30,R24
    01A23 1FF9      ADC	R31,R25
    01A24 01D5      MOVW	R26,R10
    01A25 9611      ADIW	R26,1
    01A26 902C      LD	R2,X
(0349) 				if(CardStoreTestFlag != 0)
    01A27 8220      ST	Z,R2
    01A28 E486      LDI	R24,0x46
    01A29 E195      LDI	R25,0x15
    01A2A 2FE6      MOV	R30,R22
(0350) 				{
(0351) 					ReStartCardGetTest();// 重新开始
    01A2B 27FF      CLR	R31
(0352) 					stopFlag = 1;
    01A2C 0FE8      ADD	R30,R24
    01A2D 1FF9      ADC	R31,R25
    01A2E E189      LDI	R24,0x19
(0353) 					Uart0ReUnable;
    01A2F 8380      ST	Z,R24
    01A30 C032      RJMP	0x1A63
    01A31 01A5      MOVW	R20,R10
    01A32 5F4E      SUBI	R20,0xFE
    01A33 4F5F      SBCI	R21,0xFF
(0354) 					uart_Printf("%s\r\n",strM3126);
    01A34 2766      CLR	R22
    01A35 C015      RJMP	0x1A4B
    01A36 01FA      MOVW	R30,R20
    01A37 8020      LD	R2,Z
    01A38 2433      CLR	R3
    01A39 2D82      MOV	R24,R2
(0355) 					Uart0ReEnable;
    01A3A 3186      CPI	R24,0x16
    01A3B F060      BCS	0x1A48
    01A3C E189      LDI	R24,0x19
    01A3D 1582      CP	R24,R2
    01A3E F048      BCS	0x1A48
(0356) 					
(0357) 				}
(0358) 			}
(0359) 		}
(0360) 		
(0361) 		if(waitMotCardLoad)
    01A3F E48C      LDI	R24,0x4C
    01A40 E195      LDI	R25,0x15
    01A41 2FE6      MOV	R30,R22
    01A42 27FF      CLR	R31
    01A43 0FE8      ADD	R30,R24
(0362) 		{
(0363) 			if(WaitDelayTime(MOT_CARD_LOAD))
    01A44 1FF9      ADC	R31,R25
    01A45 01DA      MOVW	R26,R20
    01A46 902C      LD	R2,X
    01A47 8220      ST	Z,R2
    01A48 5F4F      SUBI	R20,0xFF
    01A49 4F5F      SBCI	R21,0xFF
(0364) 			{
(0365) 				if(GetMotState(MOT_CARD_LOAD)!=STA_SLAVE_FREE)
    01A4A 9563      INC	R22
    01A4B 3066      CPI	R22,6
    01A4C F348      BCS	0x1A36
    01A4D C015      RJMP	0x1A63
    01A4E 01A5      MOVW	R20,R10
    01A4F 5F4D      SUBI	R20,0xFD
(0366) 					return 0;
    01A50 4F5F      SBCI	R21,0xFF
    01A51 01FA      MOVW	R30,R20
    01A52 8020      LD	R2,Z
(0367) 				inWork = 0;
    01A53 2433      CLR	R3
    01A54 2D82      MOV	R24,R2
    01A55 3186      CPI	R24,0x16
(0368) 				waitMotCardLoad = 0;
    01A56 F060      BCS	0x1A63
    01A57 E189      LDI	R24,0x19
(0369) 				SetDelayTime(MOT_CARD_LOAD,0);
    01A58 1582      CP	R24,R2
    01A59 F048      BCS	0x1A63
    01A5A E48C      LDI	R24,0x4C
    01A5B E195      LDI	R25,0x15
    01A5C 2FE6      MOV	R30,R22
(0370) 			}
    01A5D 27FF      CLR	R31
(0371) 			else	// 5秒延时到，进片回零位卡片
(0372) 			{
(0373) 				MotStop(MOT_CARD_LOAD);
    01A5E 0FE8      ADD	R30,R24
    01A5F 1FF9      ADC	R31,R25
    01A60 01DA      MOVW	R26,R20
(0374) 				SetBeepWarning();	
    01A61 902C      LD	R2,X
    01A62 8220      ST	Z,R2
(0375) #ifndef UartSendLong
(0376) 				Uart0ReUnable;
(0377) 				uart_Printf("!3529 $%8d\r\n", NewTestInfo.testSerial);
(0378) 				Uart0ReEnable;
(0379) #else
(0380) 				Uart0ReUnable;
    01A63 2700      CLR	R16
    01A64 9622      ADIW	R28,2
    01A65 940C AE9E JMP	pop_xgsetF00C
_printf_CardstoreProcess_StepState:
    01A67 9722      SBIW	R28,2
(0381) 				uart_Printf("!3529 $ ");
    01A68 9020 1545 LDS	R2,liqDetBaseAdc+96
    01A6A 2433      CLR	R3
    01A6B 8239      STD	Y+1,R3
(0382) 				uart0SendInt(NewTestInfo.testSerial);
    01A6C 8228      ST	Y,R2
    01A6D 9120 1544 LDS	R18,liqDetBaseAdc+95
    01A6F 2733      CLR	R19
    01A70 EA06      LDI	R16,0xA6
    01A71 E013      LDI	R17,3
    01A72 940E A90D CALL	_uart_Printf
    01A74 9622      ADIW	R28,2
    01A75 9508      RET
(0383) 				uart_Printf("\r\n");
_GetNewPieceFromStoreProcess:
    01A76 931A      ST	-Y,R17
    01A77 930A      ST	-Y,R16
    01A78 940E AE97 CALL	push_xgsetF00C
(0384) 				Uart0ReEnable;
    01A7A 9724      SBIW	R28,4
    01A7B 9020 1525 LDS	R2,liqDetBaseAdc+64
    01A7D 9220 1544 STS	liqDetBaseAdc+95,R2
(0385) #endif
(0386) 				inWork = 0;
    01A7F 9020 1526 LDS	R2,liqDetBaseAdc+65
    01A81 9220 1545 STS	liqDetBaseAdc+96,R2
(0387) 				waitMotCardLoad = 0;
    01A83 9020 1529 LDS	R2,liqDetBaseAdc+68
(0388) 				workSwitch = 0;
    01A85 2022      TST	R2
(0389) 				Uart0ReUnable;
    01A86 F409      BNE	0x1A88
    01A87 C0DC      RJMP	0x1B64
    01A88 9020 152C LDS	R2,liqDetBaseAdc+71
    01A8A 2022      TST	R2
(0390) 				uart_Printf("%s\r\n",strM0106);
    01A8B F409      BNE	0x1A8D
    01A8C C068      RJMP	0x1AF5
    01A8D E008      LDI	R16,0x8
    01A8E 940E 97C6 CALL	_WaitDelayTime
    01A90 2300      TST	R16
(0391) 				Uart0ReEnable;
    01A91 F099      BEQ	0x1AA5
    01A92 E008      LDI	R16,0x8
    01A93 940E 6A0C CALL	_GetMotState
    01A95 3001      CPI	R16,1
(0392) 				if(CardStoreTestFlag != 0)
    01A96 F019      BEQ	0x1A9A
    01A97 2700      CLR	R16
    01A98 940C 24AE JMP	0x24AE
(0393) 				{
(0394) 					ReStartCardGetTest();// 重新开始
    01A9A 2422      CLR	R2
(0395) 					stopFlag = 1;
    01A9B 9220 1529 STS	liqDetBaseAdc+68,R2
    01A9D 9220 152C STS	liqDetBaseAdc+71,R2
(0396) 					Uart0ReUnable;
    01A9F 2722      CLR	R18
    01AA0 2733      CLR	R19
    01AA1 E008      LDI	R16,0x8
    01AA2 940E 97B7 CALL	_SetDelayTime
(0397) 					uart_Printf("%s\r\n",strM3126);
    01AA4 C050      RJMP	0x1AF5
    01AA5 E008      LDI	R16,0x8
    01AA6 940E 6A13 CALL	_MotStop
    01AA8 940E 372D CALL	_SetBeepWarning
(0398) 					Uart0ReEnable;
    01AAA 9180 00C1 LDS	R24,0xC1
    01AAC 7E8F      ANDI	R24,0xEF
    01AAD 9380 00C1 STS	0xC1,R24
(0399) 				}
(0400) 			}
(0401) 		}
(0402) 	}
(0403) 	if(workSwitch == 0)							return 0;
    01AAF E90D      LDI	R16,0x9D
    01AB0 E013      LDI	R17,3
    01AB1 940E A90D CALL	_uart_Printf
    01AB3 9120 1664 LDS	R18,LiquidPhoNum
(0404) 	if(WaitDelayTime(MOT_STORE_CARD_MOVE))		return 0;
    01AB5 9130 1665 LDS	R19,timeOut
    01AB7 9100 1662 LDS	R16,NewTestInfo|liqDetBaseAdc+1
    01AB9 9110 1663 LDS	R17,CardStorePhoNum
    01ABB 940E A940 CALL	_uart0SendInt
    01ABD E90A      LDI	R16,0x9A
(0405) 	if(WaitDelayTime(MOT_CARD_LOAD))			return 0;
    01ABE E013      LDI	R17,3
    01ABF 940E A90D CALL	_uart_Printf
    01AC1 9180 00C1 LDS	R24,0xC1
    01AC3 6180      ORI	R24,0x10
    01AC4 9380 00C1 STS	0xC1,R24
    01AC6 2422      CLR	R2
(0406) 	if(WaitDelayTime(MOT_CARD_UNLOAD))			return 0;
    01AC7 9220 1529 STS	liqDetBaseAdc+68,R2
    01AC9 9220 152C STS	liqDetBaseAdc+71,R2
    01ACB 9220 06F7 STS	workSwitch,R2
    01ACD 9180 00C1 LDS	R24,0xC1
    01ACF 7E8F      ANDI	R24,0xEF
(0407) 	if(waitMotCardTrolley){	if(GetMotState(MOT_STORE_CARD_MOVE)!=STA_SLAVE_FREE)	return 0;waitMotCardTrolley = 0;}
    01AD0 9380 00C1 STS	0xC1,R24
    01AD2 EA21      LDI	R18,0xA1
    01AD3 E035      LDI	R19,5
    01AD4 EC0B      LDI	R16,0xCB
    01AD5 E013      LDI	R17,3
    01AD6 940E A90D CALL	_uart_Printf
    01AD8 9180 00C1 LDS	R24,0xC1
    01ADA 6180      ORI	R24,0x10
    01ADB 9380 00C1 STS	0xC1,R24
    01ADD 9020 1559 LDS	R2,CardStoreTestFlag
    01ADF 2022      TST	R2
(0408) 	if(waitMotCardLoad){if(GetMotState(MOT_CARD_LOAD)!=STA_SLAVE_FREE)	return 0;waitMotCardLoad = 0;}
    01AE0 F0A1      BEQ	0x1AF5
    01AE1 DCFB      RCALL	0x17DD
    01AE2 E081      LDI	R24,1
    01AE3 9380 02E2 STS	stopFlag,R24
    01AE5 9180 00C1 LDS	R24,0xC1
    01AE7 7E8F      ANDI	R24,0xEF
    01AE8 9380 00C1 STS	0xC1,R24
    01AEA ED25      LDI	R18,0xD5
    01AEB E03E      LDI	R19,0xE
    01AEC EC0B      LDI	R16,0xCB
    01AED E013      LDI	R17,3
    01AEE 940E A90D CALL	_uart_Printf
(0409) 	if(waitMotCardUnload){if(GetMotState(MOT_CARD_UNLOAD)!=STA_SLAVE_FREE)	return 0;waitMotCardUnload = 0;}
    01AF0 9180 00C1 LDS	R24,0xC1
    01AF2 6180      ORI	R24,0x10
    01AF3 9380 00C1 STS	0xC1,R24
    01AF5 9020 152D LDS	R2,liqDetBaseAdc+72
    01AF7 2022      TST	R2
    01AF8 F409      BNE	0x1AFA
    01AF9 C06A      RJMP	0x1B64
    01AFA E004      LDI	R16,4
    01AFB 940E 97C6 CALL	_WaitDelayTime
    01AFD 2EA0      MOV	R10,R16
    01AFE 2300      TST	R16
    01AFF F0A1      BEQ	0x1B14
(0410) 	if(waitMotTurnPlate){if(GetMotState(MOT_TURN_PLATE)!=STA_SLAVE_FREE)	return 0;waitMotTurnPlate = 0;}
    01B00 E004      LDI	R16,4
    01B01 940E 6A0C CALL	_GetMotState
    01B03 2F40      MOV	R20,R16
    01B04 3001      CPI	R16,1
    01B05 F019      BEQ	0x1B09
    01B06 2700      CLR	R16
    01B07 940C 24AE JMP	0x24AE
    01B09 2422      CLR	R2
    01B0A 9220 1529 STS	liqDetBaseAdc+68,R2
    01B0C 9220 152D STS	liqDetBaseAdc+72,R2
    01B0E 2722      CLR	R18
    01B0F 2733      CLR	R19
(0411) 	
(0412) 	switch(mainStep){
    01B10 E004      LDI	R16,4
    01B11 940E 97B7 CALL	_SetDelayTime
    01B13 C050      RJMP	0x1B64
    01B14 E004      LDI	R16,4
    01B15 940E 6A13 CALL	_MotStop
    01B17 940E 372D CALL	_SetBeepWarning
    01B19 9180 00C1 LDS	R24,0xC1
    01B1B 7E8F      ANDI	R24,0xEF
    01B1C 9380 00C1 STS	0xC1,R24
    01B1E E901      LDI	R16,0x91
    01B1F E013      LDI	R17,3
    01B20 940E A90D CALL	_uart_Printf
    01B22 9120 1664 LDS	R18,LiquidPhoNum
    01B24 9130 1665 LDS	R19,timeOut
    01B26 9100 1662 LDS	R16,NewTestInfo|liqDetBaseAdc+1
    01B28 9110 1663 LDS	R17,CardStorePhoNum
    01B2A 940E A940 CALL	_uart0SendInt
    01B2C E90A      LDI	R16,0x9A
    01B2D E013      LDI	R17,3
    01B2E 940E A90D CALL	_uart_Printf
    01B30 9180 00C1 LDS	R24,0xC1
    01B32 6180      ORI	R24,0x10
    01B33 9380 00C1 STS	0xC1,R24
    01B35 2422      CLR	R2
    01B36 9220 1529 STS	liqDetBaseAdc+68,R2
    01B38 9220 152D STS	liqDetBaseAdc+72,R2
    01B3A 9220 06F7 STS	workSwitch,R2
    01B3C 9180 00C1 LDS	R24,0xC1
    01B3E 7E8F      ANDI	R24,0xEF
    01B3F 9380 00C1 STS	0xC1,R24
    01B41 EA21      LDI	R18,0xA1
    01B42 E035      LDI	R19,5
    01B43 EC0B      LDI	R16,0xCB
    01B44 E013      LDI	R17,3
    01B45 940E A90D CALL	_uart_Printf
    01B47 9180 00C1 LDS	R24,0xC1
    01B49 6180      ORI	R24,0x10
    01B4A 9380 00C1 STS	0xC1,R24
(0413) 		case 0:	// 准备工作，判断是否有新的测试开始
(0414) 			if(GetNewTestCard != 0 && GetNewTestCard < 6)
    01B4C 9020 1559 LDS	R2,CardStoreTestFlag
    01B4E 2022      TST	R2
    01B4F F0A1      BEQ	0x1B64
    01B50 DC8C      RCALL	0x17DD
(0415) 			{
(0416) 				mainStep = 100;
    01B51 E081      LDI	R24,1
    01B52 9380 02E2 STS	stopFlag,R24
(0417) 				workStep = 0;
    01B54 9180 00C1 LDS	R24,0xC1
    01B56 7E8F      ANDI	R24,0xEF
(0418) 				curCardStoreNum = GetNewTestCard;
    01B57 9380 00C1 STS	0xC1,R24
    01B59 ED25      LDI	R18,0xD5
(0419) 				MotInitCheck(MOT_STORE_CARD_MOVE);
    01B5A E03E      LDI	R19,0xE
    01B5B EC0B      LDI	R16,0xCB
    01B5C E013      LDI	R17,3
(0420) 				SetCardTrolleyState(0);	
    01B5D 940E A90D CALL	_uart_Printf
(0421) 				SetDelayTime(MOT_STORE_CARD_MOVE,10);
    01B5F 9180 00C1 LDS	R24,0xC1
    01B61 6180      ORI	R24,0x10
    01B62 9380 00C1 STS	0xC1,R24
(0422) 				waitMotCardTrolley = 1; 
    01B64 9020 06F7 LDS	R2,workSwitch
    01B66 2022      TST	R2
(0423) 				checkReDoCnt = 0;
    01B67 F419      BNE	0x1B6B
    01B68 2700      CLR	R16
    01B69 940C 24AE JMP	0x24AE
(0424) 				takeRedoCnt = 0;
    01B6B E008      LDI	R16,0x8
(0425) 				if(0 != CardStoreTestFlag)
    01B6C 940E 97C6 CALL	_WaitDelayTime
    01B6E 2EA0      MOV	R10,R16
    01B6F 2300      TST	R16
    01B70 F019      BEQ	0x1B74
    01B71 2700      CLR	R16
(0426) 					LastCardGetState = 0;
    01B72 940C 24AE JMP	0x24AE
    01B74 E004      LDI	R16,4
(0427) 			}
    01B75 940E 97C6 CALL	_WaitDelayTime
(0428) 			else
(0429) 				return 1;	
    01B77 2EA0      MOV	R10,R16
    01B78 2300      TST	R16
    01B79 F019      BEQ	0x1B7D
(0430) 			break;
(0431) 		case 100:
(0432) 			ucTmp = CardSurplusState[GetNewTestCard - 1];
    01B7A 2700      CLR	R16
    01B7B 940C 24AE JMP	0x24AE
    01B7D E005      LDI	R16,5
    01B7E 940E 97C6 CALL	_WaitDelayTime
    01B80 2EA0      MOV	R10,R16
    01B81 2300      TST	R16
(0433) 			if(CardNoneUseful == 0)
    01B82 F019      BEQ	0x1B86
    01B83 2700      CLR	R16
    01B84 940C 24AE JMP	0x24AE
(0434) 			{
(0435) 				if(ucTmp == INFO_STORE_EMPTY)
    01B86 9020 152C LDS	R2,liqDetBaseAdc+71
(0436) 				{
(0437) 					SetBeepWarning();
    01B88 2022      TST	R2
    01B89 F061      BEQ	0x1B96
(0438) 					Uart0ReUnable;
    01B8A E008      LDI	R16,0x8
    01B8B 940E 6A0C CALL	_GetMotState
    01B8D 2F40      MOV	R20,R16
    01B8E 3001      CPI	R16,1
(0439) 					uart_Printf("!3520 $%4d\r\n", GetNewTestCard);
    01B8F F019      BEQ	0x1B93
    01B90 2700      CLR	R16
    01B91 940C 24AE JMP	0x24AE
    01B93 2422      CLR	R2
    01B94 9220 152C STS	liqDetBaseAdc+71,R2
(0440) 					Uart0ReEnable;
    01B96 9020 152D LDS	R2,liqDetBaseAdc+72
    01B98 2022      TST	R2
    01B99 F061      BEQ	0x1BA6
    01B9A E004      LDI	R16,4
(0441) 					mainStep = 101;
    01B9B 940E 6A0C CALL	_GetMotState
    01B9D 2F40      MOV	R20,R16
(0442) 				}
    01B9E 3001      CPI	R16,1
(0443) 				else if(ucTmp == INFO_STORE_ERROR)
    01B9F F019      BEQ	0x1BA3
    01BA0 2700      CLR	R16
(0444) 				{
(0445) 					Uart0ReUnable;
    01BA1 940C 24AE JMP	0x24AE
    01BA3 2422      CLR	R2
    01BA4 9220 152D STS	liqDetBaseAdc+72,R2
(0446) 					uart_Printf("!3522 $%4d\r\n", GetNewTestCard);
    01BA6 9020 152E LDS	R2,liqDetBaseAdc+73
    01BA8 2022      TST	R2
    01BA9 F061      BEQ	0x1BB6
    01BAA E005      LDI	R16,5
    01BAB 940E 6A0C CALL	_GetMotState
(0447) 					Uart0ReEnable;
    01BAD 2F40      MOV	R20,R16
    01BAE 3001      CPI	R16,1
    01BAF F019      BEQ	0x1BB3
    01BB0 2700      CLR	R16
    01BB1 940C 24AE JMP	0x24AE
(0448) 					mainStep = 101;
    01BB3 2422      CLR	R2
    01BB4 9220 152E STS	liqDetBaseAdc+73,R2
(0449) 				}
    01BB6 9020 152F LDS	R2,liqDetBaseAdc+74
    01BB8 2022      TST	R2
(0450) 				else
(0451) 				{
(0452) 					mainStep = 1;
(0453) 					CardStoreOpenLook = 1;	
    01BB9 F061      BEQ	0x1BC6
    01BBA E001      LDI	R16,1
(0454) 				}
(0455) 			}
    01BBB 940E 6A0C CALL	_GetMotState
(0456) 			else
(0457) 			{
(0458) 				mainStep = 1;
    01BBD 2F40      MOV	R20,R16
    01BBE 3001      CPI	R16,1
(0459) 				CardStoreOpenLook = 1;
    01BBF F019      BEQ	0x1BC3
    01BC0 2700      CLR	R16
(0460) 			}
(0461) 			oldStoreState = ucTmp;
    01BC1 940C 24AE JMP	0x24AE
(0462) 			break;
    01BC3 2422      CLR	R2
    01BC4 9220 152F STS	liqDetBaseAdc+74,R2
(0463) 		case 101:
(0464) 			ucTmp = CardSurplusState[GetNewTestCard-1];
    01BC6 9140 1525 LDS	R20,liqDetBaseAdc+64
    01BC8 2755      CLR	R21
    01BC9 3040      CPI	R20,0
    01BCA 0745      CPC	R20,R21
    01BCB F409      BNE	0x1BCD
    01BCC C034      RJMP	0x1C01
(0465) 			if(ucTmp != oldStoreState)
    01BCD 3041      CPI	R20,1
    01BCE E0E0      LDI	R30,0
    01BCF 075E      CPC	R21,R30
    01BD0 F409      BNE	0x1BD2
    01BD1 C0BC      RJMP	0x1C8E
(0466) 				mainStep = 100;
    01BD2 3042      CPI	R20,2
    01BD3 E0E0      LDI	R30,0
    01BD4 075E      CPC	R21,R30
(0467) 			break;
    01BD5 F409      BNE	0x1BD7
(0468) 		case 1:		// 小车移到片仓前
(0469) 			switch(workStep)
    01BD6 C150      RJMP	0x1D27
    01BD7 3043      CPI	R20,3
    01BD8 E0E0      LDI	R30,0
    01BD9 075E      CPC	R21,R30
    01BDA F409      BNE	0x1BDC
    01BDB C1FF      RJMP	0x1DDB
    01BDC 3045      CPI	R20,5
    01BDD E0E0      LDI	R30,0
    01BDE 075E      CPC	R21,R30
    01BDF F409      BNE	0x1BE1
    01BE0 C2BD      RJMP	0x1E9E
    01BE1 3046      CPI	R20,6
    01BE2 E0E0      LDI	R30,0
    01BE3 075E      CPC	R21,R30
    01BE4 F409      BNE	0x1BE6
    01BE5 C5B0      RJMP	0x2196
    01BE6 3047      CPI	R20,7
    01BE7 E0E0      LDI	R30,0
    01BE8 075E      CPC	R21,R30
    01BE9 F409      BNE	0x1BEB
    01BEA C5CA      RJMP	0x21B5
    01BEB 3048      CPI	R20,0x8
(0470) 			{
(0471) 				case 0:
(0472) 					storePos = 494;		// 40mm / 0.081 = 494
    01BEC E0E0      LDI	R30,0
    01BED 075E      CPC	R21,R30
    01BEE F409      BNE	0x1BF0
    01BEF C5D6      RJMP	0x21C6
    01BF0 3040      CPI	R20,0
    01BF1 E0E0      LDI	R30,0
(0473) 					SetMotRunPam(MOT_STORE_CARD_MOVE,200,20,CURRENT_STORE_MOVE);
    01BF2 075E      CPC	R21,R30
    01BF3 F414      BGE	0x1BF6
    01BF4 940C 24AD JMP	0x24AD
    01BF6 3644      CPI	R20,0x64
    01BF7 E0E0      LDI	R30,0
    01BF8 075E      CPC	R21,R30
    01BF9 F1B1      BEQ	0x1C30
(0474) 					if(CardStoreOpenState & 0x3f){	// 如果片仓开启
    01BFA 3645      CPI	R20,0x65
    01BFB E0E0      LDI	R30,0
    01BFC 075E      CPC	R21,R30
    01BFD F409      BNE	0x1BFF
(0475) 						Uart0ReUnable;
    01BFE C07C      RJMP	0x1C7B
    01BFF 940C 24AD JMP	0x24AD
    01C01 9140 165F LDS	R20,GetNewTestCard
(0476) 						uart_Printf("!3525\r\n");
    01C03 2344      TST	R20
    01C04 F141      BEQ	0x1C2D
    01C05 3046      CPI	R20,6
    01C06 F530      BCC	0x1C2D
(0477) 						Uart0ReEnable;
    01C07 E684      LDI	R24,0x64
    01C08 9380 1525 STS	liqDetBaseAdc+64,R24
    01C0A 2422      CLR	R2
    01C0B 9220 1526 STS	liqDetBaseAdc+65,R2
(0478) 						workStep = 2;
    01C0D 2E24      MOV	R2,R20
    01C0E 9220 1532 STS	liqDetBaseAdc+77,R2
(0479) 						break;
    01C10 E008      LDI	R16,0x8
    01C11 940E 6AFA CALL	_MotInitCheck
    01C13 2700      CLR	R16
    01C14 DC8B      RCALL	_SetCardTrolleyState
    01C15 E02A      LDI	R18,0xA
    01C16 E030      LDI	R19,0
(0480) 						}
(0481) 					MotRunTo(MOT_STORE_CARD_MOVE,storePos);			// 	
(0482) 					workStep = 1;
    01C17 E008      LDI	R16,0x8
    01C18 940E 97B7 CALL	_SetDelayTime
(0483) 					break;
    01C1A E081      LDI	R24,1
(0484) 				case 1:
(0485) 					if(CardStoreOpenState & 0x3f){	// 如果片仓开启
    01C1B 9380 152C STS	liqDetBaseAdc+71,R24
    01C1D 2422      CLR	R2
    01C1E 9220 1533 STS	liqDetBaseAdc+78,R2
(0486) 						MotStop(MOT_STORE_CARD_MOVE);
    01C20 9220 1534 STS	liqDetBaseAdc+79,R2
(0487) 						Uart0ReUnable;
    01C22 9020 1559 LDS	R2,CardStoreTestFlag
    01C24 2022      TST	R2
    01C25 F411      BNE	0x1C28
    01C26 940C 24AD JMP	0x24AD
(0488) 						uart_Printf("!3525\r\n");
    01C28 2422      CLR	R2
    01C29 9220 1553 STS	LastCardGetState,R2
(0489) 						Uart0ReEnable;
    01C2B 940C 24AD JMP	0x24AD
    01C2D E001      LDI	R16,1
    01C2E 940C 24AE JMP	0x24AE
(0490) 						workStep = 2;
    01C30 E48B      LDI	R24,0x4B
    01C31 E195      LDI	R25,0x15
    01C32 91E0 165F LDS	R30,GetNewTestCard
(0491) 						}
    01C34 27FF      CLR	R31
    01C35 0FE8      ADD	R30,R24
    01C36 1FF9      ADC	R31,R25
    01C37 8140      LD	R20,Z
    01C38 9020 06F6 LDS	R2,CardNoneUseful
(0492) 					else{	// 片仓处于关闭状态，等待片仓小车停止
(0493) 						if(GetMotState(MOT_STORE_CARD_MOVE)!=STA_SLAVE_FREE)
(0494) 							break;
    01C3A 2022      TST	R2
(0495) 						else
(0496) 							workStep = 3;
    01C3B F5B1      BNE	0x1C72
    01C3C 3148      CPI	R20,0x18
    01C3D F4B9      BNE	0x1C55
(0497) 						}
(0498) 					break;
    01C3E 940E 372D CALL	_SetBeepWarning
(0499) 				case 2:		// 片仓处于开启状态，等待片仓关闭后从新启动片仓电机
(0500) 					if((CardStoreOpenState & 0x3f) == 0){
    01C40 9180 00C1 LDS	R24,0xC1
    01C42 7E8F      ANDI	R24,0xEF
    01C43 9380 00C1 STS	0xC1,R24
(0501) 						siTmp = GetMotPositionOfStep(MOT_STORE_CARD_MOVE) + 5;
    01C45 9120 165F LDS	R18,GetNewTestCard
    01C47 2733      CLR	R19
    01C48 E804      LDI	R16,0x84
    01C49 E013      LDI	R17,3
(0502) 						if(siTmp<storePos){
    01C4A 940E A90D CALL	_uart_Printf
    01C4C 9180 00C1 LDS	R24,0xC1
    01C4E 6180      ORI	R24,0x10
    01C4F 9380 00C1 STS	0xC1,R24
(0503) 							MotRunTo(MOT_STORE_CARD_MOVE,storePos);
    01C51 E685      LDI	R24,0x65
    01C52 9380 1525 STS	liqDetBaseAdc+64,R24
    01C54 C022      RJMP	0x1C77
(0504) 							SetDelayTime(MOT_STORE_CARD_MOVE,1);
    01C55 3149      CPI	R20,0x19
    01C56 F4A9      BNE	0x1C6C
    01C57 9180 00C1 LDS	R24,0xC1
    01C59 7E8F      ANDI	R24,0xEF
(0505) 							workStep = 1;
    01C5A 9380 00C1 STS	0xC1,R24
    01C5C 9120 165F LDS	R18,GetNewTestCard
(0506) 							}
    01C5E 2733      CLR	R19
    01C5F E707      LDI	R16,0x77
    01C60 E013      LDI	R17,3
(0507) 						else{
(0508) 							workStep = 3;
(0509) 							}
(0510) 						}
(0511) 					break;
    01C61 940E A90D CALL	_uart_Printf
(0512) 				case 3:	// 片仓取片小车已运行到片仓起始处
(0513) 					SetDelayTime(MOT_STORE_CARD_MOVE,10);
    01C63 9180 00C1 LDS	R24,0xC1
    01C65 6180      ORI	R24,0x10
    01C66 9380 00C1 STS	0xC1,R24
(0514) 				//	CardStoreOpenLook = 1;
(0515) 					workStep = 0;
    01C68 E685      LDI	R24,0x65
    01C69 9380 1525 STS	liqDetBaseAdc+64,R24
(0516) 					mainStep = 2;
    01C6B C00B      RJMP	0x1C77
    01C6C E081      LDI	R24,1
(0517) 					break;
(0518) 				}
(0519) 			break;
    01C6D 9380 1525 STS	liqDetBaseAdc+64,R24
(0520) 		case 2:		// 小车移动到取片起始位置
(0521) 			switch(workStep){
    01C6F 9380 02E0 STS	CardStoreOpenLook,R24
    01C71 C005      RJMP	0x1C77
    01C72 E081      LDI	R24,1
    01C73 9380 1525 STS	liqDetBaseAdc+64,R24
    01C75 9380 02E0 STS	CardStoreOpenLook,R24
    01C77 9340 1530 STS	liqDetBaseAdc+75,R20
    01C79 940C 24AD JMP	0x24AD
    01C7B E48B      LDI	R24,0x4B
    01C7C E195      LDI	R25,0x15
    01C7D 91E0 165F LDS	R30,GetNewTestCard
    01C7F 27FF      CLR	R31
    01C80 0FE8      ADD	R30,R24
    01C81 1FF9      ADC	R31,R25
    01C82 8140      LD	R20,Z
    01C83 9020 1530 LDS	R2,liqDetBaseAdc+75
    01C85 1542      CP	R20,R2
    01C86 F411      BNE	0x1C89
    01C87 940C 24AD JMP	0x24AD
    01C89 E684      LDI	R24,0x64
    01C8A 9380 1525 STS	liqDetBaseAdc+64,R24
(0522) 				case 0:
(0523) 					if(CardStoreOpenState & 0x3f)
    01C8C 940C 24AD JMP	0x24AD
    01C8E 9160 1526 LDS	R22,liqDetBaseAdc+65
(0524) 					{
(0525) 						Uart0ReUnable;
    01C90 2777      CLR	R23
    01C91 3060      CPI	R22,0
    01C92 0767      CPC	R22,R23
    01C93 F089      BEQ	0x1CA5
(0526) 						uart_Printf("!3526\r\n");
    01C94 3061      CPI	R22,1
    01C95 E0E0      LDI	R30,0
    01C96 077E      CPC	R23,R30
    01C97 F409      BNE	0x1C99
(0527) 						Uart0ReEnable;
    01C98 C03B      RJMP	0x1CD4
    01C99 3062      CPI	R22,2
    01C9A E0E0      LDI	R30,0
    01C9B 077E      CPC	R23,R30
    01C9C F409      BNE	0x1C9E
(0528) 						workStep = 2;
    01C9D C05A      RJMP	0x1CF8
    01C9E 3063      CPI	R22,3
    01C9F E0E0      LDI	R30,0
(0529) 						break;
    01CA0 077E      CPC	R23,R30
(0530) 						}
(0531) 					storePos = CalCardStorePos(GetNewTestCard);	
    01CA1 F409      BNE	0x1CA3
    01CA2 C078      RJMP	0x1D1B
    01CA3 940C 24AD JMP	0x24AD
    01CA5 EE8E      LDI	R24,0xEE
    01CA6 E091      LDI	R25,1
    01CA7 9390 1528 STS	liqDetBaseAdc+67,R25
(0532) 					SetMotRunPam(MOT_STORE_CARD_MOVE,200,20,CURRENT_STORE_MOVE);
    01CA9 9380 1527 STS	liqDetBaseAdc+66,R24
    01CAB E08A      LDI	R24,0xA
    01CAC 838A      STD	Y+2,R24
    01CAD E184      LDI	R24,0x14
    01CAE 8388      ST	Y,R24
    01CAF EC28      LDI	R18,0xC8
    01CB0 E008      LDI	R16,0x8
(0533) 					MotRunTo(MOT_STORE_CARD_MOVE,storePos);			// 	
    01CB1 940E 6A9F CALL	_SetMotRunPam
    01CB3 9180 1552 LDS	R24,CardStoreOpenState
    01CB5 738F      ANDI	R24,0x3F
    01CB6 F091      BEQ	0x1CC9
    01CB7 9180 00C1 LDS	R24,0xC1
(0534) 					workStep = 1;
    01CB9 7E8F      ANDI	R24,0xEF
    01CBA 9380 00C1 STS	0xC1,R24
(0535) 					break;
    01CBC E60F      LDI	R16,0x6F
    01CBD E013      LDI	R17,3
    01CBE 940E A90D CALL	_uart_Printf
(0536) 				case 1:
(0537) 					if(CardStoreOpenState & 0x3f)
(0538) 					{
(0539) 						MotStop(MOT_STORE_CARD_MOVE);
    01CC0 9180 00C1 LDS	R24,0xC1
    01CC2 6180      ORI	R24,0x10
(0540) 						Uart0ReUnable;
    01CC3 9380 00C1 STS	0xC1,R24
    01CC5 E082      LDI	R24,2
    01CC6 9380 1526 STS	liqDetBaseAdc+65,R24
(0541) 						uart_Printf("!3526\r\n");
    01CC8 C7E4      RJMP	0x24AD
    01CC9 9120 1527 LDS	R18,liqDetBaseAdc+66
    01CCB 9130 1528 LDS	R19,liqDetBaseAdc+67
(0542) 						Uart0ReEnable;
    01CCD E008      LDI	R16,0x8
    01CCE 940E 6A5B CALL	_MotRunTo
    01CD0 E081      LDI	R24,1
(0543) 						workStep = 2;
    01CD1 9380 1526 STS	liqDetBaseAdc+65,R24
    01CD3 C7D9      RJMP	0x24AD
(0544) 						}
    01CD4 9180 1552 LDS	R24,CardStoreOpenState
(0545) 					else{
(0546) 						if(GetMotState(MOT_STORE_CARD_MOVE)!=STA_SLAVE_FREE)
    01CD6 738F      ANDI	R24,0x3F
    01CD7 F0A9      BEQ	0x1CED
    01CD8 E008      LDI	R16,0x8
    01CD9 940E 6A13 CALL	_MotStop
(0547) 							break;
    01CDB 9180 00C1 LDS	R24,0xC1
(0548) 						else
(0549) 							workStep = 3;
    01CDD 7E8F      ANDI	R24,0xEF
    01CDE 9380 00C1 STS	0xC1,R24
(0550) 						}
(0551) 					break;
    01CE0 E60F      LDI	R16,0x6F
    01CE1 E013      LDI	R17,3
    01CE2 940E A90D CALL	_uart_Printf
    01CE4 9180 00C1 LDS	R24,0xC1
(0552) 				case 2:		// 片仓处于开启状态，等待片仓关闭后从新启动片仓电机
(0553) 					if((CardStoreOpenState & 0x3f) == 0){
(0554) 						siTmp = GetMotPositionOfStep(MOT_STORE_CARD_MOVE) + 5;
    01CE6 6180      ORI	R24,0x10
    01CE7 9380 00C1 STS	0xC1,R24
    01CE9 E082      LDI	R24,2
    01CEA 9380 1526 STS	liqDetBaseAdc+65,R24
(0555) 						if(siTmp<storePos){
    01CEC C7C0      RJMP	0x24AD
    01CED E008      LDI	R16,0x8
    01CEE 940E 6A0C CALL	_GetMotState
    01CF0 2F60      MOV	R22,R16
    01CF1 3001      CPI	R16,1
    01CF2 F009      BEQ	0x1CF4
(0556) 							MotRunTo(MOT_STORE_CARD_MOVE,storePos);
    01CF3 C7B9      RJMP	0x24AD
    01CF4 E083      LDI	R24,3
    01CF5 9380 1526 STS	liqDetBaseAdc+65,R24
(0557) 							SetDelayTime(MOT_STORE_CARD_MOVE,1);
    01CF7 C7B5      RJMP	0x24AD
    01CF8 9180 1552 LDS	R24,CardStoreOpenState
    01CFA 738F      ANDI	R24,0x3F
    01CFB F009      BEQ	0x1CFD
(0558) 							workStep = 1;
    01CFC C7B0      RJMP	0x24AD
    01CFD E008      LDI	R16,0x8
    01CFE 940E 2DAD CALL	_GetMotPositionOfStep
(0559) 							}
    01D00 01B8      MOVW	R22,R16
    01D01 5F6B      SUBI	R22,0xFB
    01D02 4F7F      SBCI	R23,0xFF
(0560) 						else{
(0561) 							workStep = 3;
(0562) 							}
(0563) 						}
(0564) 					break;
    01D03 9020 1527 LDS	R2,liqDetBaseAdc+66
(0565) 				case 3:	// 片仓取片小车已运行到目的地
(0566) 					MotInitCheck(MOT_CARD_LOAD);
    01D05 9030 1528 LDS	R3,liqDetBaseAdc+67
(0567) 					waitMotCardLoad = 1;
    01D07 1562      CP	R22,R2
    01D08 0573      CPC	R23,R3
    01D09 F46C      BGE	0x1D17
(0568) 					SetDelayTime(MOT_STORE_CARD_MOVE,5);
    01D0A 0191      MOVW	R18,R2
    01D0B E008      LDI	R16,0x8
    01D0C 940E 6A5B CALL	_MotRunTo
    01D0E E021      LDI	R18,1
(0569) 					workStep = 4;
    01D0F E030      LDI	R19,0
    01D10 E008      LDI	R16,0x8
    01D11 940E 97B7 CALL	_SetDelayTime
(0570) 					break;
    01D13 E081      LDI	R24,1
    01D14 9380 1526 STS	liqDetBaseAdc+65,R24
    01D16 C796      RJMP	0x24AD
    01D17 E083      LDI	R24,3
(0571) 				case 4:
(0572) 					MotRunTo(MOT_CARD_LOAD,-25);
(0573) 					waitMotCardLoad = 1;
    01D18 9380 1526 STS	liqDetBaseAdc+65,R24
    01D1A C792      RJMP	0x24AD
(0574) 					workStep = 0;
    01D1B E02A      LDI	R18,0xA
    01D1C E030      LDI	R19,0
    01D1D E008      LDI	R16,0x8
(0575) 					mainStep = 3;
    01D1E 940E 97B7 CALL	_SetDelayTime
    01D20 2422      CLR	R2
(0576) 					break;
(0577) 				}
(0578) 			break;
    01D21 9220 1526 STS	liqDetBaseAdc+65,R2
(0579) 		case 3:// 钩片抬起，小车钩片前进，使之进入钩片道槽
(0580) 			switch(workStep){
    01D23 E082      LDI	R24,2
    01D24 9380 1525 STS	liqDetBaseAdc+64,R24
    01D26 C786      RJMP	0x24AD
    01D27 90A0 1526 LDS	R10,liqDetBaseAdc+65
    01D29 24BB      CLR	R11
    01D2A 20AA      TST	R10
    01D2B F411      BNE	0x1D2E
    01D2C 20BB      TST	R11
    01D2D F0B1      BEQ	0x1D44
    01D2E 01C5      MOVW	R24,R10
    01D2F 3081      CPI	R24,1
    01D30 E0E0      LDI	R30,0
    01D31 079E      CPC	R25,R30
    01D32 F409      BNE	0x1D34
    01D33 C041      RJMP	0x1D75
    01D34 3082      CPI	R24,2
    01D35 E0E0      LDI	R30,0
    01D36 079E      CPC	R25,R30
    01D37 F409      BNE	0x1D39
    01D38 C060      RJMP	0x1D99
    01D39 3083      CPI	R24,3
    01D3A E0E0      LDI	R30,0
    01D3B 079E      CPC	R25,R30
    01D3C F409      BNE	0x1D3E
    01D3D C07F      RJMP	0x1DBD
    01D3E 3084      CPI	R24,4
    01D3F E0E0      LDI	R30,0
    01D40 079E      CPC	R25,R30
    01D41 F409      BNE	0x1D43
    01D42 C089      RJMP	0x1DCC
    01D43 C769      RJMP	0x24AD
    01D44 9180 1552 LDS	R24,CardStoreOpenState
    01D46 738F      ANDI	R24,0x3F
    01D47 F091      BEQ	0x1D5A
    01D48 9180 00C1 LDS	R24,0xC1
    01D4A 7E8F      ANDI	R24,0xEF
    01D4B 9380 00C1 STS	0xC1,R24
    01D4D E607      LDI	R16,0x67
    01D4E E013      LDI	R17,3
    01D4F 940E A90D CALL	_uart_Printf
    01D51 9180 00C1 LDS	R24,0xC1
    01D53 6180      ORI	R24,0x10
    01D54 9380 00C1 STS	0xC1,R24
    01D56 E082      LDI	R24,2
    01D57 9380 1526 STS	liqDetBaseAdc+65,R24
(0581) 				case 0:	
(0582) 					SetCardTrolleyState(1);
    01D59 C753      RJMP	0x24AD
    01D5A 9100 165F LDS	R16,GetNewTestCard
(0583) 					SetMotRunPam(MOT_STORE_CARD_MOVE,16,10,CURRENT_STORE_MOVE);
    01D5C DB15      RCALL	_CalCardStorePos
    01D5D 0158      MOVW	R10,R16
    01D5E 92B0 1528 STS	liqDetBaseAdc+67,R11
    01D60 92A0 1527 STS	liqDetBaseAdc+66,R10
(0584) 					MotRun(MOT_STORE_CARD_MOVE,-98);
    01D62 E08A      LDI	R24,0xA
    01D63 838A      STD	Y+2,R24
    01D64 E184      LDI	R24,0x14
    01D65 8388      ST	Y,R24
    01D66 EC28      LDI	R18,0xC8
(0585) 					waitMotCardTrolley = 1;
    01D67 E008      LDI	R16,0x8
    01D68 940E 6A9F CALL	_SetMotRunPam
(0586) 					workStep = 1;
    01D6A 9120 1527 LDS	R18,liqDetBaseAdc+66
(0587) 					break;
    01D6C 9130 1528 LDS	R19,liqDetBaseAdc+67
(0588) 				case 1:
(0589) 					SetCardTrolleyState(0);
    01D6E E008      LDI	R16,0x8
(0590) 					workStep = 2;
    01D6F 940E 6A5B CALL	_MotRunTo
    01D71 E081      LDI	R24,1
(0591) 					break;
    01D72 9380 1526 STS	liqDetBaseAdc+65,R24
(0592) 				case 2:		
(0593) 					SetMotRunPam(MOT_STORE_CARD_MOVE,100,10,CURRENT_STORE_MOVE);
    01D74 C738      RJMP	0x24AD
    01D75 9180 1552 LDS	R24,CardStoreOpenState
    01D77 738F      ANDI	R24,0x3F
    01D78 F0A9      BEQ	0x1D8E
    01D79 E008      LDI	R16,0x8
(0594) 					MotRun(MOT_STORE_CARD_MOVE,-(235+70));	
    01D7A 940E 6A13 CALL	_MotStop
    01D7C 9180 00C1 LDS	R24,0xC1
    01D7E 7E8F      ANDI	R24,0xEF
(0595) 					waitMotCardTrolley = 1;
    01D7F 9380 00C1 STS	0xC1,R24
    01D81 E607      LDI	R16,0x67
(0596) 				//	workStep = 3;
(0597) 					workStep = 7;
    01D82 E013      LDI	R17,3
    01D83 940E A90D CALL	_uart_Printf
(0598) 					break;
    01D85 9180 00C1 LDS	R24,0xC1
(0599) 				case 3:
(0600) 					MotRun(MOT_STORE_CARD_MOVE,86);		
    01D87 6180      ORI	R24,0x10
    01D88 9380 00C1 STS	0xC1,R24
    01D8A E082      LDI	R24,2
(0601) 					waitMotCardTrolley = 1;
    01D8B 9380 1526 STS	liqDetBaseAdc+65,R24
    01D8D C71F      RJMP	0x24AD
(0602) 					workStep = 4;
    01D8E E008      LDI	R16,0x8
    01D8F 940E 6A0C CALL	_GetMotState
(0603) 					break;
    01D91 2EA0      MOV	R10,R16
(0604) 				case 4:
(0605) 					MotRun(MOT_STORE_CARD_MOVE,-86);			
    01D92 3001      CPI	R16,1
    01D93 F009      BEQ	0x1D95
    01D94 C718      RJMP	0x24AD
    01D95 E083      LDI	R24,3
    01D96 9380 1526 STS	liqDetBaseAdc+65,R24
(0606) 					waitMotCardTrolley = 1;
    01D98 C714      RJMP	0x24AD
    01D99 9180 1552 LDS	R24,CardStoreOpenState
(0607) 					workStep = 5;
    01D9B 738F      ANDI	R24,0x3F
    01D9C F009      BEQ	0x1D9E
(0608) 					break;
    01D9D C70F      RJMP	0x24AD
(0609) 				case 5:
(0610) 					MotRun(MOT_STORE_CARD_MOVE,99);	
    01D9E E008      LDI	R16,0x8
    01D9F 940E 2DAD CALL	_GetMotPositionOfStep
    01DA1 0158      MOVW	R10,R16
    01DA2 01B5      MOVW	R22,R10
(0611) 					waitMotCardTrolley = 1;
    01DA3 5F6B      SUBI	R22,0xFB
    01DA4 4F7F      SBCI	R23,0xFF
    01DA5 9020 1527 LDS	R2,liqDetBaseAdc+66
(0612) 					workStep = 6;
    01DA7 9030 1528 LDS	R3,liqDetBaseAdc+67
(0613) 					break;
    01DA9 1562      CP	R22,R2
(0614) 				case 6:
(0615) 					MotRun(MOT_STORE_CARD_MOVE,-150);
    01DAA 0573      CPC	R23,R3
    01DAB F46C      BGE	0x1DB9
    01DAC 0191      MOVW	R18,R2
    01DAD E008      LDI	R16,0x8
    01DAE 940E 6A5B CALL	_MotRunTo
(0616) 					waitMotCardTrolley = 1;
    01DB0 E021      LDI	R18,1
    01DB1 E030      LDI	R19,0
(0617) 					workStep = 7;
    01DB2 E008      LDI	R16,0x8
    01DB3 940E 97B7 CALL	_SetDelayTime
(0618) 					break;
    01DB5 E081      LDI	R24,1
(0619) 				case 7:
(0620) 					SetDelayTime(MOT_STORE_CARD_MOVE,10);
    01DB6 9380 1526 STS	liqDetBaseAdc+65,R24
    01DB8 C6F4      RJMP	0x24AD
    01DB9 E083      LDI	R24,3
    01DBA 9380 1526 STS	liqDetBaseAdc+65,R24
(0621) 					workStep = 8;
    01DBC C6F0      RJMP	0x24AD
    01DBD E004      LDI	R16,4
(0622) 					break;
    01DBE 940E 6AFA CALL	_MotInitCheck
(0623) 				case 8:
(0624) 					SetCardTrolleyState(2);
    01DC0 E081      LDI	R24,1
(0625) 					MotRun(MOT_STORE_CARD_MOVE,320);
    01DC1 9380 152D STS	liqDetBaseAdc+72,R24
    01DC3 E025      LDI	R18,5
    01DC4 E030      LDI	R19,0
    01DC5 E008      LDI	R16,0x8
(0626) 					waitMotCardTrolley = 1;
    01DC6 940E 97B7 CALL	_SetDelayTime
    01DC8 E084      LDI	R24,4
(0627) 					workStep = 9;
    01DC9 9380 1526 STS	liqDetBaseAdc+65,R24
    01DCB C6E1      RJMP	0x24AD
(0628) 					break;
    01DCC EE27      LDI	R18,0xE7
(0629) 				case 9:
(0630) 					SetCardTrolleyState(0);
    01DCD EF3F      LDI	R19,0xFF
    01DCE E004      LDI	R16,4
(0631) 					workStep = 0;
    01DCF 940E 6A5B CALL	_MotRunTo
    01DD1 E081      LDI	R24,1
(0632) 					mainStep = 5;
    01DD2 9380 152D STS	liqDetBaseAdc+72,R24
    01DD4 2422      CLR	R2
(0633) 					break;
(0634) 				default:
(0635) 					break;
(0636) 				}
(0637) 			break;
    01DD5 9220 1526 STS	liqDetBaseAdc+65,R2
(0638) 		case 5:	// 运行到离开片仓位置
(0639) 			switch(workStep){
    01DD7 E083      LDI	R24,3
    01DD8 9380 1525 STS	liqDetBaseAdc+64,R24
    01DDA C6D2      RJMP	0x24AD
    01DDB 90A0 1526 LDS	R10,liqDetBaseAdc+65
    01DDD 24BB      CLR	R11
    01DDE 20AA      TST	R10
    01DDF F419      BNE	0x1DE3
    01DE0 20BB      TST	R11
    01DE1 F409      BNE	0x1DE3
    01DE2 C033      RJMP	0x1E16
    01DE3 01C5      MOVW	R24,R10
    01DE4 3081      CPI	R24,1
    01DE5 E0E0      LDI	R30,0
    01DE6 079E      CPC	R25,R30
    01DE7 F409      BNE	0x1DE9
    01DE8 C04E      RJMP	0x1E37
    01DE9 3082      CPI	R24,2
    01DEA E0E0      LDI	R30,0
    01DEB 079E      CPC	R25,R30
    01DEC F409      BNE	0x1DEE
    01DED C051      RJMP	0x1E3F
    01DEE 3083      CPI	R24,3
(0640) 				case 0:
(0641) 					SetMotRunPam(MOT_STORE_CARD_MOVE,200,20,CURRENT_STORE_MOVE);
    01DEF E0E0      LDI	R30,0
    01DF0 079E      CPC	R25,R30
    01DF1 F409      BNE	0x1DF3
    01DF2 C05F      RJMP	0x1E52
    01DF3 3084      CPI	R24,4
    01DF4 E0E0      LDI	R30,0
    01DF5 079E      CPC	R25,R30
    01DF6 F409      BNE	0x1DF8
(0642) 					if(CardStoreOpenState & 0x3f)
    01DF7 C066      RJMP	0x1E5E
    01DF8 3085      CPI	R24,5
    01DF9 E0E0      LDI	R30,0
    01DFA 079E      CPC	R25,R30
(0643) 					{	
(0644) 						Uart0ReUnable;
    01DFB F409      BNE	0x1DFD
    01DFC C06D      RJMP	0x1E6A
    01DFD 3086      CPI	R24,6
    01DFE E0E0      LDI	R30,0
    01DFF 079E      CPC	R25,R30
(0645) 						uart_Printf("!3527\r\n");
    01E00 F409      BNE	0x1E02
    01E01 C074      RJMP	0x1E76
    01E02 3087      CPI	R24,7
    01E03 E0E0      LDI	R30,0
(0646) 						Uart0ReEnable;
    01E04 079E      CPC	R25,R30
    01E05 F409      BNE	0x1E07
    01E06 C07B      RJMP	0x1E82
    01E07 3088      CPI	R24,0x8
    01E08 E0E0      LDI	R30,0
(0647) 						workStep = 2;
    01E09 079E      CPC	R25,R30
    01E0A F409      BNE	0x1E0C
    01E0B C07F      RJMP	0x1E8B
(0648) 						break;
    01E0C 3089      CPI	R24,0x9
(0649) 					}
(0650) 					if(WaitPhotoFlag == 0)
    01E0D E0E0      LDI	R30,0
    01E0E 079E      CPC	R25,R30
    01E0F F409      BNE	0x1E11
    01E10 C086      RJMP	0x1E97
(0651) 						MotRunTo(MOT_STORE_CARD_MOVE,494);	
    01E11 308A      CPI	R24,0xA
    01E12 E0E0      LDI	R30,0
    01E13 079E      CPC	R25,R30
    01E14 F059      BEQ	0x1E20
    01E15 C697      RJMP	0x24AD
    01E16 E001      LDI	R16,1
(0652) 					else
(0653) 						MotRunTo(MOT_STORE_CARD_MOVE,0);	
    01E17 DA88      RCALL	_SetCardTrolleyState
    01E18 E022      LDI	R18,2
    01E19 E030      LDI	R19,0
    01E1A E008      LDI	R16,0x8
    01E1B 940E 97B7 CALL	_SetDelayTime
(0654) 					workStep = 1;
    01E1D E08A      LDI	R24,0xA
    01E1E 9380 1526 STS	liqDetBaseAdc+65,R24
(0655) 					break;
    01E20 E08A      LDI	R24,0xA
    01E21 838A      STD	Y+2,R24
    01E22 8388      ST	Y,R24
    01E23 E120      LDI	R18,0x10
(0656) 				case 1:
(0657) 					if(CardStoreOpenState & 0x3f)
(0658) 					{
(0659) 						MotStop(MOT_STORE_CARD_MOVE);
    01E24 E008      LDI	R16,0x8
    01E25 940E 6A9F CALL	_SetMotRunPam
(0660) 						Uart0ReUnable;
    01E27 E92E      LDI	R18,0x9E
    01E28 EF3F      LDI	R19,0xFF
    01E29 E008      LDI	R16,0x8
    01E2A 940E 6A2C CALL	_MotRun
(0661) 						uart_Printf("!3527\r\n");
    01E2C E022      LDI	R18,2
    01E2D E030      LDI	R19,0
    01E2E E008      LDI	R16,0x8
    01E2F 940E 97B7 CALL	_SetDelayTime
(0662) 						Uart0ReEnable;
    01E31 E081      LDI	R24,1
    01E32 9380 152C STS	liqDetBaseAdc+71,R24
    01E34 9380 1526 STS	liqDetBaseAdc+65,R24
(0663) 						workStep = 2;
    01E36 C676      RJMP	0x24AD
    01E37 2700      CLR	R16
(0664) 					}
    01E38 DA67      RCALL	_SetCardTrolleyState
(0665) 					else
(0666) 					{	
(0667) 						if(GetMotState(MOT_STORE_CARD_MOVE)!=STA_SLAVE_FREE)
    01E39 940E 3739 CALL	_SetBeepAck
    01E3B E082      LDI	R24,2
    01E3C 9380 1526 STS	liqDetBaseAdc+65,R24
    01E3E C66E      RJMP	0x24AD
(0668) 							break;
    01E3F E08A      LDI	R24,0xA
(0669) 						else
(0670) 						{
(0671) 							if(WaitPhotoFlag == 0)
    01E40 838A      STD	Y+2,R24
    01E41 8388      ST	Y,R24
    01E42 E624      LDI	R18,0x64
    01E43 E008      LDI	R16,0x8
(0672) 								workStep = 3;
    01E44 940E 6A9F CALL	_SetMotRunPam
    01E46 EC2F      LDI	R18,0xCF
    01E47 EF3E      LDI	R19,0xFE
(0673) 							else
(0674) 							{
(0675) 								//workStep = 20;
(0676) 								//SetMotRunPam(MOT_STORE_CARD_MOVE,50,5,CURRENT_STORE_MOVE);
(0677) 								//workStep = 26;	// 2016-11-18
(0678) 								workStep = 20;		// 2016-11-18
    01E48 E008      LDI	R16,0x8
    01E49 940E 6A2C CALL	_MotRun
(0679) 							}
(0680) 						}
(0681) 					}
(0682) 					break;
    01E4B E081      LDI	R24,1
(0683) 				case 2:		
(0684) 					if((CardStoreOpenState & 0x3f) == 0)
    01E4C 9380 152C STS	liqDetBaseAdc+71,R24
    01E4E E087      LDI	R24,7
    01E4F 9380 1526 STS	liqDetBaseAdc+65,R24
(0685) 					{	
(0686) 						siTmp = GetMotPositionOfStep(MOT_STORE_CARD_MOVE);
    01E51 C65B      RJMP	0x24AD
    01E52 E526      LDI	R18,0x56
    01E53 E030      LDI	R19,0
    01E54 E008      LDI	R16,0x8
    01E55 940E 6A2C CALL	_MotRun
(0687) 						if(WaitPhotoFlag == 0)
    01E57 E081      LDI	R24,1
    01E58 9380 152C STS	liqDetBaseAdc+71,R24
(0688) 						{
(0689) 							if(siTmp>(494+20))
    01E5A E084      LDI	R24,4
    01E5B 9380 1526 STS	liqDetBaseAdc+65,R24
    01E5D C64F      RJMP	0x24AD
    01E5E EA2A      LDI	R18,0xAA
(0690) 							{
(0691) 								MotRunTo(MOT_STORE_CARD_MOVE,494);
    01E5F EF3F      LDI	R19,0xFF
    01E60 E008      LDI	R16,0x8
    01E61 940E 6A2C CALL	_MotRun
    01E63 E081      LDI	R24,1
(0692) 								SetDelayTime(MOT_STORE_CARD_MOVE,1);
    01E64 9380 152C STS	liqDetBaseAdc+71,R24
    01E66 E085      LDI	R24,5
    01E67 9380 1526 STS	liqDetBaseAdc+65,R24
(0693) 								workStep = 1;
    01E69 C643      RJMP	0x24AD
    01E6A E623      LDI	R18,0x63
    01E6B E030      LDI	R19,0
(0694) 							}
    01E6C E008      LDI	R16,0x8
(0695) 							else
(0696) 							{
(0697) 								workStep = 3;
    01E6D 940E 6A2C CALL	_MotRun
    01E6F E081      LDI	R24,1
(0698) 								SetMotRunPam(MOT_STORE_CARD_MOVE,100,20,CURRENT_STORE_MOVE);
    01E70 9380 152C STS	liqDetBaseAdc+71,R24
    01E72 E086      LDI	R24,6
    01E73 9380 1526 STS	liqDetBaseAdc+65,R24
    01E75 C637      RJMP	0x24AD
    01E76 E62A      LDI	R18,0x6A
    01E77 EF3F      LDI	R19,0xFF
(0699) 							}
(0700) 						}
    01E78 E008      LDI	R16,0x8
(0701) 						else
(0702) 						{
(0703) 							if(siTmp > 0)
    01E79 940E 6A2C CALL	_MotRun
    01E7B E081      LDI	R24,1
    01E7C 9380 152C STS	liqDetBaseAdc+71,R24
(0704) 							{
(0705) 								MotRunTo(MOT_STORE_CARD_MOVE,0);
    01E7E E087      LDI	R24,7
    01E7F 9380 1526 STS	liqDetBaseAdc+65,R24
    01E81 C62B      RJMP	0x24AD
    01E82 E02A      LDI	R18,0xA
(0706) 								SetDelayTime(MOT_STORE_CARD_MOVE,1);
    01E83 E030      LDI	R19,0
    01E84 E008      LDI	R16,0x8
    01E85 940E 97B7 CALL	_SetDelayTime
    01E87 E088      LDI	R24,0x8
(0707) 								workStep = 1;
    01E88 9380 1526 STS	liqDetBaseAdc+65,R24
    01E8A C622      RJMP	0x24AD
(0708) 							}
    01E8B E420      LDI	R18,0x40
(0709) 							else
(0710) 							{
(0711) 								//workStep = 20;
(0712) 								//SetMotRunPam(MOT_STORE_CARD_MOVE,50,5,CURRENT_STORE_MOVE);
(0713) 								//workStep = 26;	// 2016-11-18
(0714) 								workStep = 20;		// 2016-11-18
    01E8C E031      LDI	R19,1
    01E8D E008      LDI	R16,0x8
    01E8E 940E 6A2C CALL	_MotRun
(0715) 							}
(0716) 						}
(0717) 					}
(0718) 					break;
    01E90 E081      LDI	R24,1
    01E91 9380 152C STS	liqDetBaseAdc+71,R24
    01E93 E089      LDI	R24,0x9
    01E94 9380 1526 STS	liqDetBaseAdc+65,R24
    01E96 C616      RJMP	0x24AD
    01E97 2422      CLR	R2
(0719) 				case 20:
(0720) 					SetMotRunPam(MOT_STORE_CARD_MOVE,50,5,CURRENT_STORE_MOVE);
(0721) 					MotRunTo(MOT_STORE_CARD_MOVE,70);
    01E98 9220 1526 STS	liqDetBaseAdc+65,R2
    01E9A E085      LDI	R24,5
    01E9B 9380 1525 STS	liqDetBaseAdc+64,R24
(0722) 					waitMotCardTrolley = 1;
    01E9D C60F      RJMP	0x24AD
    01E9E 90A0 1526 LDS	R10,liqDetBaseAdc+65
(0723) 					workStep = 21;
    01EA0 24BB      CLR	R11
    01EA1 01C5      MOVW	R24,R10
    01EA2 3080      CPI	R24,0
(0724) 					break;
    01EA3 E0E0      LDI	R30,0
(0725) 				case 21:
(0726) 					SetMotRunPam(MOT_CARD_LOAD,30,5,CURRENT_CARD_LOAD);
    01EA4 079E      CPC	R25,R30
    01EA5 F40C      BGE	0x1EA7
    01EA6 C606      RJMP	0x24AD
    01EA7 E18D      LDI	R24,0x1D
    01EA8 158A      CP	R24,R10
    01EA9 059B      CPC	R25,R11
    01EAA F40C      BGE	0x1EAC
    01EAB C601      RJMP	0x24AD
(0727) 					//MotRunTo(MOT_CARD_LOAD,55);
(0728) 					MotRunTo(MOT_CARD_LOAD,30);
    01EAC EE84      LDI	R24,0xE4
    01EAD E090      LDI	R25,0
    01EAE 01F5      MOVW	R30,R10
    01EAF 0FEE      LSL	R30
    01EB0 1FFF      ROL	R31
(0729) 					waitMotCardLoad = 1;
    01EB1 0FE8      ADD	R30,R24
    01EB2 1FF9      ADC	R31,R25
    01EB3 9027      ELPM	R2,Z+
(0730) 					workStep = 22;
    01EB4 9036      ELPM	R3,Z
    01EB5 01F1      MOVW	R30,R2
    01EB6 9409      IJMP
(0731) 					break;
    01EB7 E08A      LDI	R24,0xA
(0732) 				case 22:
(0733) 					SetDelayTime(MOT_CARD_LOAD,5);
    01EB8 838A      STD	Y+2,R24
    01EB9 E184      LDI	R24,0x14
    01EBA 8388      ST	Y,R24
    01EBB EC28      LDI	R18,0xC8
    01EBC E008      LDI	R16,0x8
(0734) 					workStep = 23;
    01EBD 940E 6A9F CALL	_SetMotRunPam
    01EBF 9180 1552 LDS	R24,CardStoreOpenState
(0735) 					break;
    01EC1 738F      ANDI	R24,0x3F
    01EC2 F091      BEQ	0x1ED5
    01EC3 9180 00C1 LDS	R24,0xC1
    01EC5 7E8F      ANDI	R24,0xEF
(0736) 				case 23:
(0737) 					MotRunTo(MOT_CARD_LOAD,20);
(0738) 					waitMotCardLoad = 1;
    01EC6 9380 00C1 STS	0xC1,R24
    01EC8 E50F      LDI	R16,0x5F
(0739) 					SetDelayTime(MOT_CARD_LOAD,5);
    01EC9 E013      LDI	R17,3
    01ECA 940E A90D CALL	_uart_Printf
    01ECC 9180 00C1 LDS	R24,0xC1
(0740) 					workStep = 24;
    01ECE 6180      ORI	R24,0x10
    01ECF 9380 00C1 STS	0xC1,R24
(0741) 					break;
    01ED1 E082      LDI	R24,2
(0742) 				case 24:
(0743) 					siTmp = GetCardScanfPos(); 
    01ED2 9380 1526 STS	liqDetBaseAdc+65,R24
    01ED4 C5D8      RJMP	0x24AD
    01ED5 9020 02DC LDS	R2,WaitPhotoFlag
(0744) 					SetMotRunPam(MOT_STORE_CARD_MOVE,250,20,CURRENT_STORE_MOVE);
    01ED7 2022      TST	R2
    01ED8 F431      BNE	0x1EDF
    01ED9 EE2E      LDI	R18,0xEE
    01EDA E031      LDI	R19,1
    01EDB E008      LDI	R16,0x8
    01EDC 940E 6A5B CALL	_MotRunTo
(0745) 					MotRunTo(MOT_STORE_CARD_MOVE,(unsigned int)siTmp);
    01EDE C005      RJMP	0x1EE4
    01EDF 2722      CLR	R18
    01EE0 2733      CLR	R19
    01EE1 E008      LDI	R16,0x8
(0746) 				//	MotRunTo(MOT_STORE_CARD_MOVE,305);
(0747) 					waitMotCardTrolley = 1;
    01EE2 940E 6A5B CALL	_MotRunTo
    01EE4 E081      LDI	R24,1
(0748) 					workStep = 25;
    01EE5 9380 1526 STS	liqDetBaseAdc+65,R24
    01EE7 C5C5      RJMP	0x24AD
(0749) 					break;
    01EE8 9180 1552 LDS	R24,CardStoreOpenState
(0750) 				case 25:
(0751) 					Uart0ReUnable;
    01EEA 738F      ANDI	R24,0x3F
    01EEB F0A9      BEQ	0x1F01
    01EEC E008      LDI	R16,0x8
    01EED 940E 6A13 CALL	_MotStop
(0752) 					uart_Printf("%s $%4d\r\n",strM3146,NewTestInfo.cardStoreNum);
    01EEF 9180 00C1 LDS	R24,0xC1
    01EF1 7E8F      ANDI	R24,0xEF
    01EF2 9380 00C1 STS	0xC1,R24
    01EF4 E50F      LDI	R16,0x5F
    01EF5 E013      LDI	R17,3
    01EF6 940E A90D CALL	_uart_Printf
    01EF8 9180 00C1 LDS	R24,0xC1
(0753) 					Uart0ReEnable;
    01EFA 6180      ORI	R24,0x10
    01EFB 9380 00C1 STS	0xC1,R24
    01EFD E082      LDI	R24,2
(0754) 					SetMotRunPam(MOT_CARD_LOAD,140,10,CURRENT_CARD_LOAD);
    01EFE 9380 1526 STS	liqDetBaseAdc+65,R24
    01F00 C5AC      RJMP	0x24AD
    01F01 E008      LDI	R16,0x8
    01F02 940E 6A0C CALL	_GetMotState
    01F04 2EA0      MOV	R10,R16
    01F05 3001      CPI	R16,1
(0755) 					MotRunTo(MOT_CARD_LOAD,0);
    01F06 F009      BEQ	0x1F08
    01F07 C5A5      RJMP	0x24AD
    01F08 9020 02DC LDS	R2,WaitPhotoFlag
    01F0A 2022      TST	R2
(0756) 					SetDelayTime(waitCardBarcode,50);	// 5s等待拍摄
    01F0B F421      BNE	0x1F10
    01F0C E083      LDI	R24,3
    01F0D 9380 1526 STS	liqDetBaseAdc+65,R24
    01F0F C59D      RJMP	0x24AD
(0757) 					workStep = 3;
    01F10 E184      LDI	R24,0x14
    01F11 9380 1526 STS	liqDetBaseAdc+65,R24
(0758) 					break;
    01F13 C599      RJMP	0x24AD
(0759) 				case 26:
(0760) 					SetDelayTime(MOT_STORE_CARD_MOVE,5);
    01F14 9180 1552 LDS	R24,CardStoreOpenState
    01F16 738F      ANDI	R24,0x3F
    01F17 F009      BEQ	0x1F19
    01F18 C594      RJMP	0x24AD
(0761) 					workStep = 27;
    01F19 E008      LDI	R16,0x8
    01F1A 940E 2DAD CALL	_GetMotPositionOfStep
(0762) 				case 27:
(0763) 					SetMotRunPam(MOT_CARD_LOAD,140,10,CURRENT_CARD_LOAD);
    01F1C 0158      MOVW	R10,R16
    01F1D 01B5      MOVW	R22,R10
    01F1E 9020 02DC LDS	R2,WaitPhotoFlag
    01F20 2022      TST	R2
    01F21 F4F9      BNE	0x1F41
    01F22 E082      LDI	R24,2
    01F23 E092      LDI	R25,2
(0764) 					MotRunTo(MOT_CARD_LOAD,300);	// 15/0.08012 = 184
    01F24 1780      CP	R24,R16
    01F25 0791      CPC	R25,R17
    01F26 F474      BGE	0x1F35
    01F27 EE2E      LDI	R18,0xEE
    01F28 E031      LDI	R19,1
(0765) 					waitMotCardLoad = 1;
    01F29 E008      LDI	R16,0x8
    01F2A 940E 6A5B CALL	_MotRunTo
(0766) 					workStep = 28;
    01F2C E021      LDI	R18,1
    01F2D E030      LDI	R19,0
    01F2E E008      LDI	R16,0x8
(0767) 					break;
    01F2F 940E 97B7 CALL	_SetDelayTime
(0768) 				case 28:
(0769) 					MotRunTo(MOT_CARD_LOAD,0);
    01F31 E081      LDI	R24,1
    01F32 9380 1526 STS	liqDetBaseAdc+65,R24
    01F34 C578      RJMP	0x24AD
(0770) 					waitMotCardLoad = 1;
    01F35 E083      LDI	R24,3
    01F36 9380 1526 STS	liqDetBaseAdc+65,R24
(0771) 					workStep = 29;
    01F38 E08A      LDI	R24,0xA
    01F39 838A      STD	Y+2,R24
    01F3A E184      LDI	R24,0x14
(0772) 					break;
    01F3B 8388      ST	Y,R24
(0773) 				case 29:
(0774) 					SetDelayTime(MOT_STORE_CARD_MOVE,2);
    01F3C E624      LDI	R18,0x64
    01F3D E008      LDI	R16,0x8
    01F3E 940E 6A9F CALL	_SetMotRunPam
    01F40 C56C      RJMP	0x24AD
(0775) 					workStep = 20;
    01F41 2422      CLR	R2
    01F42 2433      CLR	R3
    01F43 1626      CP	R2,R22
(0776) 					break;
    01F44 0637      CPC	R3,R23
(0777) 				case 3:
(0778) 					if(WaitPhotoFlag)
    01F45 F474      BGE	0x1F54
    01F46 2722      CLR	R18
    01F47 2733      CLR	R19
    01F48 E008      LDI	R16,0x8
(0779) 					{
(0780) 						if(WaitDelayTime(waitCardBarcode))
    01F49 940E 6A5B CALL	_MotRunTo
    01F4B E021      LDI	R18,1
    01F4C E030      LDI	R19,0
    01F4D E008      LDI	R16,0x8
    01F4E 940E 97B7 CALL	_SetDelayTime
(0781) 						{
(0782) 							if(GetReCardScanf())	// 需要重新检测
    01F50 E081      LDI	R24,1
    01F51 9380 1526 STS	liqDetBaseAdc+65,R24
    01F53 C559      RJMP	0x24AD
    01F54 E184      LDI	R24,0x14
    01F55 9380 1526 STS	liqDetBaseAdc+65,R24
(0783) 							{
(0784) 								SetDelayTime(waitCardBarcode,0);
    01F57 C555      RJMP	0x24AD
    01F58 E08A      LDI	R24,0xA
    01F59 838A      STD	Y+2,R24
    01F5A E085      LDI	R24,5
(0785) 								SetReCardScanf(0);
    01F5B 8388      ST	Y,R24
    01F5C E322      LDI	R18,0x32
    01F5D E008      LDI	R16,0x8
(0786) 								MotRunTo(MOT_STORE_CARD_MOVE,0);
    01F5E 940E 6A9F CALL	_SetMotRunPam
    01F60 E426      LDI	R18,0x46
    01F61 E030      LDI	R19,0
    01F62 E008      LDI	R16,0x8
(0787) 								waitMotCardTrolley = 1;
    01F63 940E 6A5B CALL	_MotRunTo
    01F65 E081      LDI	R24,1
(0788) 								// workStep = 26;	// 2016-11-18
(0789) 								workStep = 20;	// 2016-11-18
    01F66 9380 152C STS	liqDetBaseAdc+71,R24
    01F68 E185      LDI	R24,0x15
(0790) 							}
(0791) 							break;
    01F69 9380 1526 STS	liqDetBaseAdc+65,R24
(0792) 						}
(0793) 					}
(0794) 					oldGetCardState = PINL & 0x04;	
    01F6B C541      RJMP	0x24AD
    01F6C E084      LDI	R24,4
    01F6D 838A      STD	Y+2,R24
    01F6E E085      LDI	R24,5
(0795) 					MotRunTo(MOT_STORE_CARD_MOVE,0);	
    01F6F 8388      ST	Y,R24
    01F70 E12E      LDI	R18,0x1E
    01F71 E004      LDI	R16,4
    01F72 940E 6A9F CALL	_SetMotRunPam
(0796) 					waitMotCardTrolley = 1;
    01F74 E12E      LDI	R18,0x1E
    01F75 E030      LDI	R19,0
    01F76 E004      LDI	R16,4
(0797) 					if(inWork == 0)
    01F77 940E 6A5B CALL	_MotRunTo
    01F79 E081      LDI	R24,1
    01F7A 9380 152D STS	liqDetBaseAdc+72,R24
(0798) 					{
(0799) 						inWork = 1;							
    01F7C E186      LDI	R24,0x16
(0800) 						SetDelayTime(MOT_STORE_CARD_MOVE,50);
    01F7D 9380 1526 STS	liqDetBaseAdc+65,R24
    01F7F C52D      RJMP	0x24AD
    01F80 E025      LDI	R18,5
    01F81 E030      LDI	R19,0
(0801) 					}
(0802) 					workStep = 4;
    01F82 E004      LDI	R16,4
    01F83 940E 97B7 CALL	_SetDelayTime
(0803) 					break;
    01F85 E187      LDI	R24,0x17
(0804) 				case 4:	// 片仓取片小车已运行到起始位
(0805) 					SetDelayTime(MOT_STORE_CARD_MOVE,10);
    01F86 9380 1526 STS	liqDetBaseAdc+65,R24
    01F88 C524      RJMP	0x24AD
    01F89 E124      LDI	R18,0x14
    01F8A E030      LDI	R19,0
(0806) 					workStep = 5;
    01F8B E004      LDI	R16,4
    01F8C 940E 6A5B CALL	_MotRunTo
(0807) 					break;
    01F8E E081      LDI	R24,1
(0808) 				case 5:	// 检查测试卡是否成功取到
(0809) 					ucTmp = PINL & 0x04;		
    01F8F 9380 152D STS	liqDetBaseAdc+72,R24
    01F91 E025      LDI	R18,5
(0810) 					//*************************************************
(0811) 					if(CardNoneUseful == 0)
    01F92 E030      LDI	R19,0
    01F93 E004      LDI	R16,4
    01F94 940E 97B7 CALL	_SetDelayTime
    01F96 E188      LDI	R24,0x18
(0812) 					{
(0813) 						if(ucTmp == 0 && oldGetCardState == 0)
    01F97 9380 1526 STS	liqDetBaseAdc+65,R24
    01F99 C513      RJMP	0x24AD
    01F9A 940E 2940 CALL	_GetCardScanfPos
    01F9C 0158      MOVW	R10,R16
    01F9D 01B5      MOVW	R22,R10
    01F9E E08A      LDI	R24,0xA
(0814) 						{
(0815) 							if(checkReDoCnt < 2)
    01F9F 838A      STD	Y+2,R24
    01FA0 E184      LDI	R24,0x14
    01FA1 8388      ST	Y,R24
    01FA2 EF2A      LDI	R18,0xFA
(0816) 							{
(0817) 								MotRunTo(MOT_STORE_CARD_MOVE,100);	
    01FA3 E008      LDI	R16,0x8
    01FA4 940E 6A9F CALL	_SetMotRunPam
    01FA6 019B      MOVW	R18,R22
    01FA7 E008      LDI	R16,0x8
(0818) 								waitMotCardTrolley = 1;
    01FA8 940E 6A5B CALL	_MotRunTo
    01FAA E081      LDI	R24,1
(0819) 								checkReDoCnt ++;
    01FAB 9380 152C STS	liqDetBaseAdc+71,R24
    01FAD E189      LDI	R24,0x19
    01FAE 9380 1526 STS	liqDetBaseAdc+65,R24
(0820) 								workStep = 3;
    01FB0 C4FC      RJMP	0x24AD
    01FB1 9180 00C1 LDS	R24,0xC1
(0821) 								break;
    01FB3 7E8F      ANDI	R24,0xEF
(0822) 							}
(0823) 							if(takeRedoCnt < 1)
    01FB4 9380 00C1 STS	0xC1,R24
    01FB6 9020 1667 LDS	R2,i
(0824) 							{
(0825) 								takeRedoCnt ++;
    01FB8 2433      CLR	R3
    01FB9 8239      STD	Y+1,R3
    01FBA 8228      ST	Y,R2
(0826) 								workStep = 0;
    01FBB EA29      LDI	R18,0xA9
    01FBC E130      LDI	R19,0x10
    01FBD ED00      LDI	R16,0xD0
(0827) 								mainStep = 1;
    01FBE E013      LDI	R17,3
    01FBF 940E A90D CALL	_uart_Printf
(0828) 								break;
    01FC1 9180 00C1 LDS	R24,0xC1
(0829) 							}
(0830) 							// 取片失败
(0831) 							SetBeepWarning();
    01FC3 6180      ORI	R24,0x10
(0832) 							if(CardStoreTestFlag != 0)
    01FC4 9380 00C1 STS	0xC1,R24
    01FC6 E084      LDI	R24,4
    01FC7 838A      STD	Y+2,R24
(0833) 							{
(0834) 								ReStartCardGetTest();// 重新开始
    01FC8 E08A      LDI	R24,0xA
    01FC9 8388      ST	Y,R24
(0835) 								Uart0ReUnable;
    01FCA E82C      LDI	R18,0x8C
    01FCB E004      LDI	R16,4
    01FCC 940E 6A9F CALL	_SetMotRunPam
    01FCE 2722      CLR	R18
(0836) 								uart_Printf("%s\r\n",strM3126);
    01FCF 2733      CLR	R19
    01FD0 E004      LDI	R16,4
    01FD1 940E 6A5B CALL	_MotRunTo
    01FD3 E322      LDI	R18,0x32
    01FD4 E030      LDI	R19,0
(0837) 								Uart0ReEnable;
    01FD5 E006      LDI	R16,6
    01FD6 940E 97B7 CALL	_SetDelayTime
    01FD8 E083      LDI	R24,3
    01FD9 9380 1526 STS	liqDetBaseAdc+65,R24
(0838) 							}
(0839) #ifndef UartSendLong
(0840) 							Uart0ReUnable;
(0841) 							uart_Printf("!3540 $%8d", NewTestInfo.testSerial);
(0842) 							uart_Printf(" $%4d $%4d\r\n",oldGetCardState,ucTmp);
(0843) 							Uart0ReEnable;
(0844) #else
(0845) 							Uart0ReUnable;
    01FDB C4D1      RJMP	0x24AD
    01FDC E025      LDI	R18,5
    01FDD E030      LDI	R19,0
    01FDE E008      LDI	R16,0x8
(0846) 							uart_Printf("!3540 $ ");
    01FDF 940E 97B7 CALL	_SetDelayTime
    01FE1 E18B      LDI	R24,0x1B
    01FE2 9380 1526 STS	liqDetBaseAdc+65,R24
(0847) 							uart0SendInt(NewTestInfo.testSerial);
    01FE4 E084      LDI	R24,4
    01FE5 838A      STD	Y+2,R24
    01FE6 E08A      LDI	R24,0xA
    01FE7 8388      ST	Y,R24
    01FE8 E82C      LDI	R18,0x8C
    01FE9 E004      LDI	R16,4
    01FEA 940E 6A9F CALL	_SetMotRunPam
    01FEC E22C      LDI	R18,0x2C
(0848) 							uart_Printf(" $%4d $%4d\r\n",oldGetCardState,ucTmp);
    01FED E031      LDI	R19,1
    01FEE E004      LDI	R16,4
    01FEF 940E 6A5B CALL	_MotRunTo
    01FF1 E081      LDI	R24,1
    01FF2 9380 152D STS	liqDetBaseAdc+72,R24
    01FF4 E18C      LDI	R24,0x1C
    01FF5 9380 1526 STS	liqDetBaseAdc+65,R24
    01FF7 C4B5      RJMP	0x24AD
(0849) 							uart_Printf("\r\n");
    01FF8 2722      CLR	R18
    01FF9 2733      CLR	R19
    01FFA E004      LDI	R16,4
    01FFB 940E 6A5B CALL	_MotRunTo
(0850) 							Uart0ReEnable;
    01FFD E081      LDI	R24,1
    01FFE 9380 152D STS	liqDetBaseAdc+72,R24
    02000 E18D      LDI	R24,0x1D
(0851) #endif
(0852) 						
(0853) 							GetNewTestCard = 250;	
    02001 9380 1526 STS	liqDetBaseAdc+65,R24
    02003 C4A9      RJMP	0x24AD
(0854) 							CardStoreOpenLook = 0;	
    02004 E022      LDI	R18,2
    02005 E030      LDI	R19,0
    02006 E008      LDI	R16,0x8
(0855) 							InsertRingFlag = 1;
    02007 940E 97B7 CALL	_SetDelayTime
    02009 E184      LDI	R24,0x14
(0856) 							workStep = 0;
    0200A 9380 1526 STS	liqDetBaseAdc+65,R24
(0857) 							mainStep = 0;
    0200C C4A0      RJMP	0x24AD
    0200D 9020 02DC LDS	R2,WaitPhotoFlag
(0858) 							break;
    0200F 2022      TST	R2
    02010 F109      BEQ	0x2032
    02011 E006      LDI	R16,6
    02012 940E 97C6 CALL	_WaitDelayTime
    02014 2EA0      MOV	R10,R16
    02015 2300      TST	R16
    02016 F0D9      BEQ	0x2032
(0859) 						}
(0860) 						else if(ucTmp == 4 && oldGetCardState == 0)
(0861) 						{
(0862) 							Uart0ReUnable;
    02017 940E 28EC CALL	_GetReCardScanf
    02019 0158      MOVW	R10,R16
    0201A 3000      CPI	R16,0
    0201B 0701      CPC	R16,R17
(0863) 							uart_Printf("%s $%4d $%4d\r\n",strM3105,oldGetCardState,ucTmp); 
    0201C F409      BNE	0x201E
    0201D C48F      RJMP	0x24AD
    0201E 2722      CLR	R18
    0201F 2733      CLR	R19
    02020 E006      LDI	R16,6
    02021 940E 97B7 CALL	_SetDelayTime
    02023 2700      CLR	R16
    02024 940E 28E9 CALL	_SetReCardScanf
    02026 2722      CLR	R18
    02027 2733      CLR	R19
    02028 E008      LDI	R16,0x8
    02029 940E 6A5B CALL	_MotRunTo
(0864) 							Uart0ReEnable;
    0202B E081      LDI	R24,1
    0202C 9380 152C STS	liqDetBaseAdc+71,R24
    0202E E184      LDI	R24,0x14
    0202F 9380 1526 STS	liqDetBaseAdc+65,R24
(0865) 							workStep = 6;
    02031 C47B      RJMP	0x24AD
    02032 9180 0109 LDS	R24,0x109
(0866) 							oldGetCardState = ucTmp;
    02034 7084      ANDI	R24,4
(0867) 							break;
    02035 9380 1531 STS	liqDetBaseAdc+76,R24
(0868) 						}
(0869) 					}
(0870) 					else
(0871) 						workStep = 6;
    02037 2722      CLR	R18
    02038 2733      CLR	R19
(0872) 					//*********************************************************	
(0873) 					//if(ucTmp == 4 && oldGetCardState == 0)
(0874) 					//	oldGetCardState = ucTmp;
(0875) 					//workStep = 6;
(0876) 					break;
    02039 E008      LDI	R16,0x8
(0877) 				case 6:	// 测试卡移动到滴液位置
(0878) 					SetMotRunPam(MOT_CARD_LOAD,140,10,CURRENT_CARD_LOAD);
    0203A 940E 6A5B CALL	_MotRunTo
    0203C E081      LDI	R24,1
    0203D 9380 152C STS	liqDetBaseAdc+71,R24
    0203F 9020 1529 LDS	R2,liqDetBaseAdc+68
    02041 2022      TST	R2
(0879) 					MotRunTo(MOT_CARD_LOAD,300);	// 15/0.08012 = 184
    02042 F439      BNE	0x204A
    02043 9380 1529 STS	liqDetBaseAdc+68,R24
    02045 E322      LDI	R18,0x32
    02046 E030      LDI	R19,0
(0880) 					workStep = 7;
    02047 E008      LDI	R16,0x8
    02048 940E 97B7 CALL	_SetDelayTime
(0881) 					break;
    0204A E084      LDI	R24,4
(0882) 				case 7:	// 回零准备再次移动到滴液位置，防止测试卡片是歪斜的
(0883) 					MotRunTo(MOT_CARD_LOAD,0);
    0204B 9380 1526 STS	liqDetBaseAdc+65,R24
    0204D C45F      RJMP	0x24AD
    0204E E02A      LDI	R18,0xA
    0204F E030      LDI	R19,0
(0884) 					workStep = 8;
    02050 E008      LDI	R16,0x8
    02051 940E 97B7 CALL	_SetDelayTime
(0885) 					break;
    02053 E085      LDI	R24,5
(0886) 				case 8:	
(0887) 					_SenCardStoreState(GetNewTestCard-1);
    02054 9380 1526 STS	liqDetBaseAdc+65,R24
    02056 C456      RJMP	0x24AD
    02057 9140 0109 LDS	R20,0x109
(0888) 					SetMotRunPam(MOT_CARD_LOAD,140,10,CURRENT_CARD_LOAD);
    02059 7044      ANDI	R20,4
    0205A 9020 06F6 LDS	R2,CardNoneUseful
    0205C 2022      TST	R2
    0205D F009      BEQ	0x205F
    0205E C09F      RJMP	0x20FE
    0205F 2344      TST	R20
    02060 F009      BEQ	0x2062
(0889) 					if(_DropMode == 1)	
    02061 C075      RJMP	0x20D7
    02062 9020 1531 LDS	R2,liqDetBaseAdc+76
    02064 2022      TST	R2
    02065 F009      BEQ	0x2067
    02066 C070      RJMP	0x20D7
    02067 9180 1533 LDS	R24,liqDetBaseAdc+78
(0890) 					{
(0891) 						if(0 == _MixtureMode)// 测试卡移动到抽到混匀位置
    02069 3082      CPI	R24,2
    0206A F488      BCC	0x207C
    0206B E624      LDI	R18,0x64
    0206C E030      LDI	R19,0
(0892) 						{
(0893) 							MotRunTo(MOT_CARD_LOAD,_POS_CARDLOAD_MIX);		// 115
    0206D E008      LDI	R16,0x8
    0206E 940E 6A5B CALL	_MotRunTo
    02070 E081      LDI	R24,1
    02071 9380 152C STS	liqDetBaseAdc+71,R24
(0894) 							waitMotCardLoad = 1;
    02073 9180 1533 LDS	R24,liqDetBaseAdc+78
(0895) 							workStep = 9;
    02075 5F8F      SUBI	R24,0xFF
    02076 9380 1533 STS	liqDetBaseAdc+78,R24
(0896) 						}
    02078 E083      LDI	R24,3
(0897) 						else// 测试卡移动到滴样位置
(0898) 						{
(0899) 							CardStoreOpenLook = 0;		 
    02079 9380 1526 STS	liqDetBaseAdc+65,R24
    0207B C431      RJMP	0x24AD
(0900) 							workStep = 10;
    0207C 9180 1534 LDS	R24,liqDetBaseAdc+79
    0207E 3081      CPI	R24,1
(0901) 						}
(0902) 					}
    0207F F450      BCC	0x208A
(0903) 					else	// 测试卡再次移动到滴液位置
(0904) 					{
(0905) 						MotRunTo(MOT_CARD_LOAD,_POS_CARDLOAD_DROP);
    02080 5F8F      SUBI	R24,0xFF
    02081 9380 1534 STS	liqDetBaseAdc+79,R24
    02083 2422      CLR	R2
    02084 9220 1526 STS	liqDetBaseAdc+65,R2
(0906) 						waitMotCardLoad = 1;
    02086 E081      LDI	R24,1
    02087 9380 1525 STS	liqDetBaseAdc+64,R24
(0907) 						workStep = 0;
    02089 C423      RJMP	0x24AD
    0208A 940E 372D CALL	_SetBeepWarning
(0908) 						mainStep = 6;
    0208C 9020 1559 LDS	R2,CardStoreTestFlag
(0909) 					}
(0910) 					break;
    0208E 2022      TST	R2
(0911) 				case 9:
(0912) 					Uart0ReUnable;
    0208F F091      BEQ	0x20A2
    02090 940E 17DD CALL	0x17DD
    02092 9180 00C1 LDS	R24,0xC1
(0913) 					uart_Printf("%s $%4d\r\n",strM3109,curCardStoreNum);	
    02094 7E8F      ANDI	R24,0xEF
    02095 9380 00C1 STS	0xC1,R24
    02097 ED25      LDI	R18,0xD5
    02098 E03E      LDI	R19,0xE
    02099 EC0B      LDI	R16,0xCB
    0209A E013      LDI	R17,3
    0209B 940E A90D CALL	_uart_Printf
    0209D 9180 00C1 LDS	R24,0xC1
(0914) 					Uart0ReEnable;
    0209F 6180      ORI	R24,0x10
    020A0 9380 00C1 STS	0xC1,R24
    020A2 9180 00C1 LDS	R24,0xC1
(0915) 					GetNewTestCard = 222;		// 设置取出测试卡标识,可以开始抽打混匀
    020A4 7E8F      ANDI	R24,0xEF
    020A5 9380 00C1 STS	0xC1,R24
(0916) 					CardStoreOpenLook = 0;		 
    020A7 E506      LDI	R16,0x56
    020A8 E013      LDI	R17,3
    020A9 940E A90D CALL	_uart_Printf
(0917) 					workStep = 10;
    020AB 9120 1664 LDS	R18,LiquidPhoNum
(0918) 					break;
    020AD 9130 1665 LDS	R19,timeOut
(0919) 				case 10:
(0920) 					if(GetNewTestCard == 233)	// 抽打混匀结束,准备滴样
    020AF 9100 1662 LDS	R16,NewTestInfo|liqDetBaseAdc+1
    020B1 9110 1663 LDS	R17,CardStorePhoNum
(0921) 					{
(0922) 						MotRunTo(MOT_CARD_LOAD,0);
    020B3 940E A940 CALL	_uart0SendInt
    020B5 2E24      MOV	R2,R20
    020B6 2433      CLR	R3
    020B7 8239      STD	Y+1,R3
(0923) 						waitMotCardLoad = 1;
    020B8 8228      ST	Y,R2
    020B9 9120 1531 LDS	R18,liqDetBaseAdc+76
(0924) 					//	mainStep = 6;
(0925) 					//	workStep = 0;
(0926) 						workStep = 11;
    020BB 2733      CLR	R19
    020BC E409      LDI	R16,0x49
    020BD E013      LDI	R17,3
(0927) 					}
(0928) 					break;
    020BE 940E A90D CALL	_uart_Printf
(0929) 				// 2016-12-06 多走点 荧光滴样位置
(0930) 				case 11:
(0931) 					MotRunTo(MOT_CARD_LOAD,-25);
    020C0 E90A      LDI	R16,0x9A
    020C1 E013      LDI	R17,3
    020C2 940E A90D CALL	_uart_Printf
(0932) 					waitMotCardLoad = 1;
    020C4 9180 00C1 LDS	R24,0xC1
    020C6 6180      ORI	R24,0x10
(0933) 					mainStep = 6;
    020C7 9380 00C1 STS	0xC1,R24
    020C9 EF8A      LDI	R24,0xFA
(0934) 					workStep = 0;
    020CA 9380 165F STS	GetNewTestCard,R24
    020CC 2422      CLR	R2
(0935) 					break;
(0936) 				}
(0937) 			break;
    020CD 9220 02E0 STS	CardStoreOpenLook,R2
(0938) 		case 6:
(0939) 			Uart0ReUnable;
    020CF E081      LDI	R24,1
    020D0 9380 0525 STS	InsertRingFlag,R24
    020D2 9220 1526 STS	liqDetBaseAdc+65,R2
(0940) 			uart_Printf("%s $%4d\r\n",strM3106,curCardStoreNum);	
    020D4 9220 1525 STS	liqDetBaseAdc+64,R2
    020D6 C3D6      RJMP	0x24AD
    020D7 3044      CPI	R20,4
    020D8 F009      BEQ	0x20DA
    020D9 C3D3      RJMP	0x24AD
    020DA 9020 1531 LDS	R2,liqDetBaseAdc+76
    020DC 2022      TST	R2
    020DD F009      BEQ	0x20DF
(0941) 			Uart0ReEnable;
    020DE C3CE      RJMP	0x24AD
    020DF 9180 00C1 LDS	R24,0xC1
    020E1 7E8F      ANDI	R24,0xEF
    020E2 9380 00C1 STS	0xC1,R24
(0942) 			GetNewTestCard = 254;			// 设置取出测试卡标识
    020E4 2E24      MOV	R2,R20
    020E5 2433      CLR	R3
(0943) 			CardStoreOpenLook = 0;		// 
    020E6 823B      STD	Y+3,R3
    020E7 822A      STD	Y+2,R2
    020E8 9020 1531 LDS	R2,liqDetBaseAdc+76
(0944) 			mainStep = 7;
    020EA 2433      CLR	R3
    020EB 8239      STD	Y+1,R3
(0945) 			break;
    020EC 8228      ST	Y,R2
(0946) 		case 7:		// 等待滴样完毕后将干片推入转盘
(0947) 			if(GetNewTestCard == 255)
    020ED E229      LDI	R18,0x29
    020EE E03D      LDI	R19,0xD
    020EF E30A      LDI	R16,0x3A
    020F0 E013      LDI	R17,3
    020F1 940E A90D CALL	_uart_Printf
(0948) 			{
(0949) 				SetDelayTime(MOT_CARD_LOAD, 50);
    020F3 9180 00C1 LDS	R24,0xC1
    020F5 6180      ORI	R24,0x10
    020F6 9380 00C1 STS	0xC1,R24
(0950) 				mainStep = 8;
    020F8 E086      LDI	R24,6
    020F9 9380 1526 STS	liqDetBaseAdc+65,R24
(0951) 				workStep = 0;
    020FB 9340 1531 STS	liqDetBaseAdc+76,R20
(0952) 			}break;
    020FD C3AF      RJMP	0x24AD
(0953) 		case 8:		// 将滴完标本的干片装入转盘
(0954) 			switch(workStep)
    020FE E086      LDI	R24,6
    020FF 9380 1526 STS	liqDetBaseAdc+65,R24
    02101 C3AB      RJMP	0x24AD
    02102 E084      LDI	R24,4
    02103 838A      STD	Y+2,R24
    02104 E08A      LDI	R24,0xA
    02105 8388      ST	Y,R24
    02106 E82C      LDI	R18,0x8C
    02107 E004      LDI	R16,4
    02108 940E 6A9F CALL	_SetMotRunPam
    0210A E22C      LDI	R18,0x2C
    0210B E031      LDI	R19,1
    0210C E004      LDI	R16,4
    0210D 940E 6A5B CALL	_MotRunTo
    0210F E087      LDI	R24,7
    02110 9380 1526 STS	liqDetBaseAdc+65,R24
    02112 C39A      RJMP	0x24AD
    02113 2722      CLR	R18
    02114 2733      CLR	R19
    02115 E004      LDI	R16,4
    02116 940E 6A5B CALL	_MotRunTo
    02118 E088      LDI	R24,0x8
    02119 9380 1526 STS	liqDetBaseAdc+65,R24
    0211B C391      RJMP	0x24AD
    0211C 9100 165F LDS	R16,GetNewTestCard
(0955) 			{
(0956) 				case 0:	
(0957) 					if(TurnPlateUsedLock == 0)
    0211E 5001      SUBI	R16,1
    0211F 940E 18DA CALL	__SenCardStoreState
    02121 E084      LDI	R24,4
(0958) 					{
(0959) 						TurnPlateUsedLock = 1;		// 占用转盘标识
    02122 838A      STD	Y+2,R24
    02123 E08A      LDI	R24,0xA
    02124 8388      ST	Y,R24
(0960) 						workStep = 1;
    02125 E82C      LDI	R18,0x8C
    02126 E004      LDI	R16,4
(0961) 					}
(0962) 					break;
    02127 940E 6A9F CALL	_SetMotRunPam
(0963) 				case 1:		// 先让转盘转到零位
(0964) 					SetMotRunPam(MOT_TURN_PLATE,200,20,CURRENT_TURN_PLATE);
    02129 9180 164E LDS	R24,_DropMode
    0212B 9190 164F LDS	R25,_DropMode+1
    0212D 3081      CPI	R24,1
    0212E E0E0      LDI	R30,0
    0212F 079E      CPC	R25,R30
(0965) 					MotRunToSite(MOT_TURN_PLATE,0);		// 转盘运行到零位
    02130 F4B9      BNE	0x2148
    02131 9020 164D LDS	R2,_MixtureMode
    02133 2022      TST	R2
(0966) 					workStep = 20;
    02134 F461      BNE	0x2141
    02135 E82D      LDI	R18,0x8D
    02136 E030      LDI	R19,0
(0967) 					waitMotTurnPlate = 1;
    02137 E004      LDI	R16,4
    02138 940E 6A5B CALL	_MotRunTo
(0968) 					break;
    0213A E081      LDI	R24,1
(0969) 				case 20:
(0970) 					SetDelayTime(MOT_TURN_PLATE,5);
    0213B 9380 152D STS	liqDetBaseAdc+72,R24
    0213D E089      LDI	R24,0x9
    0213E 9380 1526 STS	liqDetBaseAdc+65,R24
(0971) 					workStep = 2;
    02140 C36C      RJMP	0x24AD
    02141 2422      CLR	R2
    02142 9220 02E0 STS	CardStoreOpenLook,R2
(0972) 					break;
    02144 E08A      LDI	R24,0xA
    02145 9380 1526 STS	liqDetBaseAdc+65,R24
    02147 C365      RJMP	0x24AD
    02148 E42A      LDI	R18,0x4A
(0973) 				case 2:		// 再让转盘转到当前位置
(0974) 					//SetMotRunPam(MOT_TURN_PLATE,200,20,CURRENT_TURN_PLATE);	
(0975) 					MotRunToSite(MOT_TURN_PLATE,CurInsertRingNum);
(0976) 					waitMotTurnPlate = 1;
    02149 E030      LDI	R19,0
    0214A E004      LDI	R16,4
    0214B 940E 6A5B CALL	_MotRunTo
(0977) #ifndef LoadCheck
(0978) 					workStep = 3;  // 进片光耦不使用
(0979) #else
(0980) 					workStep = 30;	 // 进片光耦使用
    0214D E081      LDI	R24,1
    0214E 9380 152D STS	liqDetBaseAdc+72,R24
(0981) #endif
(0982) 					break;
    02150 2422      CLR	R2
    02151 9220 1526 STS	liqDetBaseAdc+65,R2
    02153 E086      LDI	R24,6
    02154 9380 1525 STS	liqDetBaseAdc+64,R24
(0983) 				case 30:
(0984) 					SetDelayTime(MOT_TURN_PLATE,5);
(0985) 					workStep = 31;
    02156 C356      RJMP	0x24AD
    02157 9180 00C1 LDS	R24,0xC1
(0986) 					break;
    02159 7E8F      ANDI	R24,0xEF
    0215A 9380 00C1 STS	0xC1,R24
    0215C 9020 1532 LDS	R2,liqDetBaseAdc+77
(0987) 				case 31:
(0988) 					siTmp = getLiqDetADC(LoadChannel);
(0989) 					if(siTmp < CardLocationAD)		// 无试剂片
    0215E 2433      CLR	R3
    0215F 8239      STD	Y+1,R3
    02160 8228      ST	Y,R2
    02161 E721      LDI	R18,0x71
(0990) 					{
(0991) 						workStep = 3;
    02162 E03D      LDI	R19,0xD
    02163 ED00      LDI	R16,0xD0
    02164 E013      LDI	R17,3
(0992) 						Uart0ReUnable;
    02165 940E A90D CALL	_uart_Printf
    02167 9180 00C1 LDS	R24,0xC1
    02169 6180      ORI	R24,0x10
(0993) 						uart_Printf("%s $ %d\r\n",strM3195,(unsigned int)siTmp);
    0216A 9380 00C1 STS	0xC1,R24
    0216C ED8E      LDI	R24,0xDE
    0216D 9380 165F STS	GetNewTestCard,R24
    0216F 2422      CLR	R2
    02170 9220 02E0 STS	CardStoreOpenLook,R2
(0994) 						Uart0ReEnable;
    02172 E08A      LDI	R24,0xA
    02173 9380 1526 STS	liqDetBaseAdc+65,R24
    02175 C337      RJMP	0x24AD
    02176 9180 165F LDS	R24,GetNewTestCard
(0995) 					}
    02178 3E89      CPI	R24,0xE9
    02179 F009      BEQ	0x217B
    0217A C332      RJMP	0x24AD
(0996) 					else 							// 有试剂片
(0997) 					{
(0998) 						workStep = 32;
(0999) 						Uart0ReUnable;
    0217B 2722      CLR	R18
    0217C 2733      CLR	R19
    0217D E004      LDI	R16,4
    0217E 940E 6A5B CALL	_MotRunTo
(1000) 						uart_Printf("%s $ %d\r\n",strE3934,(unsigned int)siTmp);
    02180 E081      LDI	R24,1
    02181 9380 152D STS	liqDetBaseAdc+72,R24
    02183 E08B      LDI	R24,0xB
    02184 9380 1526 STS	liqDetBaseAdc+65,R24
    02186 C326      RJMP	0x24AD
    02187 EE27      LDI	R18,0xE7
(1001) 						Uart0ReEnable;
    02188 EF3F      LDI	R19,0xFF
    02189 E004      LDI	R16,4
    0218A 940E 6A5B CALL	_MotRunTo
    0218C E081      LDI	R24,1
(1002) 						i++;
    0218D 9380 152D STS	liqDetBaseAdc+72,R24
    0218F E086      LDI	R24,6
    02190 9380 1525 STS	liqDetBaseAdc+64,R24
(1003) 						if(i > 2)
    02192 2422      CLR	R2
    02193 9220 1526 STS	liqDetBaseAdc+65,R2
    02195 C317      RJMP	0x24AD
    02196 9180 00C1 LDS	R24,0xC1
(1004) 						{
(1005) 							i = 0;
    02198 7E8F      ANDI	R24,0xEF
    02199 9380 00C1 STS	0xC1,R24
(1006) 							workStep = 3;	// 进片光耦损坏或卸片光耦损坏
    0219B 9020 1532 LDS	R2,liqDetBaseAdc+77
    0219D 2433      CLR	R3
(1007) 							Uart0ReUnable;
    0219E 8239      STD	Y+1,R3
    0219F 8228      ST	Y,R2
    021A0 E32B      LDI	R18,0x3B
    021A1 E03D      LDI	R19,0xD
    021A2 ED00      LDI	R16,0xD0
(1008) 							uart_Printf("%s $%4d\r\n",strE4910,CurInsertRingNum);		// 连续3次进片光耦错误
    021A3 E013      LDI	R17,3
    021A4 940E A90D CALL	_uart_Printf
    021A6 9180 00C1 LDS	R24,0xC1
    021A8 6180      ORI	R24,0x10
    021A9 9380 00C1 STS	0xC1,R24
    021AB EF8E      LDI	R24,0xFE
    021AC 9380 165F STS	GetNewTestCard,R24
(1009) 							Uart0ReEnable;
    021AE 2422      CLR	R2
    021AF 9220 02E0 STS	CardStoreOpenLook,R2
    021B1 E087      LDI	R24,7
    021B2 9380 1525 STS	liqDetBaseAdc+64,R24
(1010) 						}
(1011) 					}
(1012) 					break;
    021B4 C2F8      RJMP	0x24AD
    021B5 9180 165F LDS	R24,GetNewTestCard
    021B7 3F8F      CPI	R24,0xFF
    021B8 F009      BEQ	0x21BA
(1013) 				case 32:
(1014) 					// 将此位置移动至下片位
(1015) 					siTmp = CurInsertRingNum + 25;
(1016) 					if(siTmp >= RING_QUEUE_NUM)
    021B9 C2F3      RJMP	0x24AD
    021BA E322      LDI	R18,0x32
    021BB E030      LDI	R19,0
    021BC E004      LDI	R16,4
(1017) 						siTmp -= RING_QUEUE_NUM;
    021BD 940E 97B7 CALL	_SetDelayTime
(1018) 					MotRunToSite(MOT_TURN_PLATE,siTmp);		// 转盘转到当前位置
    021BF E088      LDI	R24,0x8
    021C0 9380 1525 STS	liqDetBaseAdc+64,R24
    021C2 2422      CLR	R2
(1019) 					waitMotTurnPlate = 1;
    021C3 9220 1526 STS	liqDetBaseAdc+65,R2
    021C5 C2E7      RJMP	0x24AD
(1020) 					workStep = 33;
    021C6 90A0 1526 LDS	R10,liqDetBaseAdc+65
    021C8 24BB      CLR	R11
(1021) 					break;
    021C9 01C5      MOVW	R24,R10
(1022) 				case 33:
(1023) 					SetDelayTime(MOT_TURN_PLATE,5);
    021CA 3580      CPI	R24,0x50
    021CB E0E0      LDI	R30,0
    021CC 079E      CPC	R25,R30
    021CD F409      BNE	0x21CF
    021CE C239      RJMP	0x2408
(1024) 				//	workStep = 34;
(1025) 					workStep = 35;
    021CF E580      LDI	R24,0x50
    021D0 158A      CP	R24,R10
    021D1 059B      CPC	R25,R11
(1026) 					break;
    021D2 F0BC      BLT	0x21EA
(1027) 				/*
(1028) 				case 34:
(1029) 					siTmp = getLiqDetADC(UnloadChannel);
(1030) 					if(siTmp < CardLocationAD)	// 当前位置没有试剂片
(1031) 					{
(1032) 						MotRunToSite(MOT_TURN_PLATE,CurInsertRingNum);
(1033) 						waitMotTurnPlate = 1;
(1034) 						//workStep = 3;
(1035) 						workStep = 30;
(1036) 					}
(1037) 					else 			// 有试剂片
(1038) 					{
(1039) 						workStep = 35;
(1040) 					}		
(1041) 					break;
(1042) 				*/
(1043) 				case 35:
(1044) 					if(GetwasteCardState() == 0)// 废片仓功能开启
    021D3 01C5      MOVW	R24,R10
    021D4 3080      CPI	R24,0
    021D5 E0E0      LDI	R30,0
    021D6 079E      CPC	R25,R30
    021D7 F40C      BGE	0x21D9
(1045) 					{
(1046) 						if((PINK & 0x02) == 0)
    021D8 C2D4      RJMP	0x24AD
    021D9 E287      LDI	R24,0x27
    021DA E090      LDI	R25,0
    021DB 158A      CP	R24,R10
(1047) 						{		// 废片仓打开
(1048) 							TurnPlateUsedLock = 0;
    021DC 059B      CPC	R25,R11
    021DD F40C      BGE	0x21DF
    021DE C2CE      RJMP	0x24AD
(1049) 							mainStep = 8;
    021DF E280      LDI	R24,0x20
    021E0 E091      LDI	R25,1
    021E1 01F5      MOVW	R30,R10
(1050) 							workStep = 0;
    021E2 0FEE      LSL	R30
    021E3 1FFF      ROL	R31
(1051) 							break;
    021E4 0FE8      ADD	R30,R24
(1052) 						}
(1053) 					}
(1054) 					SetMotRunPam(MOT_CARD_UNLOAD,200,20,CURRENT_CARD_UNLOAD);
    021E5 1FF9      ADC	R31,R25
    021E6 9027      ELPM	R2,Z+
    021E7 9036      ELPM	R3,Z
    021E8 01F1      MOVW	R30,R2
    021E9 9409      IJMP
    021EA 01C5      MOVW	R24,R10
    021EB 368F      CPI	R24,0x6F
    021EC E0E0      LDI	R30,0
(1055) 					MotRunTo(MOT_CARD_UNLOAD,_POS_UNLOAD_OUT);		// 卸片行程67mm/0.08128 = 824
    021ED 079E      CPC	R25,R30
    021EE F409      BNE	0x21F0
    021EF C175      RJMP	0x2365
    021F0 C2BC      RJMP	0x24AD
    021F1 9020 1C18 LDS	R2,TurnPlateUsedLock
(1056) 					waitMotCardUnload = 1;
    021F3 2022      TST	R2
    021F4 F009      BEQ	0x21F6
(1057) 					workStep = 36;
    021F5 C2B7      RJMP	0x24AD
    021F6 E081      LDI	R24,1
    021F7 9380 1C18 STS	TurnPlateUsedLock,R24
(1058) 					break;
    021F9 9380 1526 STS	liqDetBaseAdc+65,R24
    021FB C2B1      RJMP	0x24AD
    021FC E081      LDI	R24,1
    021FD 838A      STD	Y+2,R24
    021FE E184      LDI	R24,0x14
    021FF 8388      ST	Y,R24
    02200 EC28      LDI	R18,0xC8
(1059) 				case 36:
(1060) 					SetMotRunPam(MOT_CARD_UNLOAD,100,20,2);
(1061) 					MotRunTo(MOT_CARD_UNLOAD,0);
    02201 E001      LDI	R16,1
    02202 940E 6A9F CALL	_SetMotRunPam
    02204 2722      CLR	R18
    02205 E001      LDI	R16,1
(1062) 					waitMotCardUnload = 1;
    02206 940E 6A7F CALL	_MotRunToSite
    02208 E184      LDI	R24,0x14
(1063) 					workStep = 37;
    02209 9380 1526 STS	liqDetBaseAdc+65,R24
    0220B E081      LDI	R24,1
(1064) 					break;
    0220C 9380 152F STS	liqDetBaseAdc+74,R24
(1065) 				case 37:
(1066) 					SetDelayTime(MOT_CARD_UNLOAD,5);
    0220E C29E      RJMP	0x24AD
    0220F E025      LDI	R18,5
    02210 E030      LDI	R19,0
    02211 E001      LDI	R16,1
(1067) 					workStep = 38; // 检测下片
    02212 940E 97B7 CALL	_SetDelayTime
    02214 E082      LDI	R24,2
(1068) 					break;
    02215 9380 1526 STS	liqDetBaseAdc+65,R24
(1069) 				case 38:	// 下片动作完成之后,检测是否有试剂片
(1070) 					siTmp = getLiqDetADC(UnloadChannel);
    02217 C295      RJMP	0x24AD
    02218 9120 1660 LDS	R18,CurInsertRingNum
    0221A E001      LDI	R16,1
(1071) 					if(siTmp < CardLocationAD)	// 当前位置没有试剂片
    0221B 940E 6A7F CALL	_MotRunToSite
    0221D E081      LDI	R24,1
    0221E 9380 152F STS	liqDetBaseAdc+74,R24
(1072) 					{
(1073) 						MotRunToSite(MOT_TURN_PLATE,CurInsertRingNum);
    02220 E18E      LDI	R24,0x1E
    02221 9380 1526 STS	liqDetBaseAdc+65,R24
    02223 C289      RJMP	0x24AD
(1074) 						waitMotTurnPlate = 1;
    02224 E025      LDI	R18,5
    02225 E030      LDI	R19,0
    02226 E001      LDI	R16,1
(1075) 						//workStep = 3;
(1076) 						workStep = 30;
    02227 940E 97B7 CALL	_SetDelayTime
    02229 E18F      LDI	R24,0x1F
(1077) 					}
    0222A 9380 1526 STS	liqDetBaseAdc+65,R24
(1078) 					else 						// 有试剂片
(1079) 					{
(1080) 						//workStep = 1;
(1081) 						MotRunToSite(MOT_TURN_PLATE,0);		// 转盘运行到零位
    0222C C280      RJMP	0x24AD
    0222D E001      LDI	R16,1
    0222E 940E 9A52 CALL	_getLiqDetADC
(1082) 						waitMotTurnPlate = 1;
    02230 0158      MOVW	R10,R16
    02231 01B5      MOVW	R22,R10
(1083) 						workStep = 32;
    02232 3804      CPI	R16,0x84
    02233 E0E3      LDI	R30,3
    02234 071E      CPC	R17,R30
(1084) 						Uart0ReUnable;
    02235 F4B4      BGE	0x224C
    02236 E083      LDI	R24,3
    02237 9380 1526 STS	liqDetBaseAdc+65,R24
    02239 9180 00C1 LDS	R24,0xC1
(1085) 						uart_Printf("%s $%4d $%4d\r\n",strM3117,CurInsertRingNum,j + 2);		// 对应位置再次下片
    0223B 7E8F      ANDI	R24,0xEF
    0223C 9380 00C1 STS	0xC1,R24
    0223E 8379      STD	Y+1,R23
    0223F 8368      ST	Y,R22
    02240 E822      LDI	R18,0x82
    02241 E133      LDI	R19,0x13
    02242 E300      LDI	R16,0x30
    02243 E013      LDI	R17,3
    02244 940E A90D CALL	_uart_Printf
    02246 9180 00C1 LDS	R24,0xC1
    02248 6180      ORI	R24,0x10
    02249 9380 00C1 STS	0xC1,R24
(1086) 						Uart0ReEnable;
    0224B C261      RJMP	0x24AD
    0224C E280      LDI	R24,0x20
    0224D 9380 1526 STS	liqDetBaseAdc+65,R24
    0224F 9180 00C1 LDS	R24,0xC1
(1087) 						j++;
    02251 7E8F      ANDI	R24,0xEF
    02252 9380 00C1 STS	0xC1,R24
    02254 8379      STD	Y+1,R23
(1088) 						if(j > 2)
    02255 8368      ST	Y,R22
    02256 EA29      LDI	R18,0xA9
    02257 E135      LDI	R19,0x15
    02258 E300      LDI	R16,0x30
    02259 E013      LDI	R17,3
    0225A 940E A90D CALL	_uart_Printf
(1089) 						{
(1090) 							j = 0;
    0225C 9180 00C1 LDS	R24,0xC1
(1091) 							workStep = 39;	// 进片光耦和下片光耦损坏
    0225E 6180      ORI	R24,0x10
    0225F 9380 00C1 STS	0xC1,R24
(1092) 							Uart0ReUnable;
    02261 9180 152A LDS	R24,liqDetBaseAdc+69
    02263 5F8F      SUBI	R24,0xFF
    02264 9380 152A STS	liqDetBaseAdc+69,R24
(1093) 							uart_Printf("%s $%4d\r\n",strE4909,CurInsertRingNum);		// 对应位置连续3次下片失败
    02266 E082      LDI	R24,2
    02267 9020 152A LDS	R2,liqDetBaseAdc+69
    02269 1582      CP	R24,R2
    0226A F008      BCS	0x226C
    0226B C241      RJMP	0x24AD
    0226C 2422      CLR	R2
    0226D 9220 152A STS	liqDetBaseAdc+69,R2
    0226F E083      LDI	R24,3
    02270 9380 1526 STS	liqDetBaseAdc+65,R24
(1094) 							Uart0ReEnable;
    02272 9180 00C1 LDS	R24,0xC1
    02274 7E8F      ANDI	R24,0xEF
    02275 9380 00C1 STS	0xC1,R24
(1095) 						}
(1096) 					}
(1097) 					break;	
    02277 9020 1660 LDS	R2,CurInsertRingNum
    02279 2433      CLR	R3
    0227A 8239      STD	Y+1,R3
    0227B 8228      ST	Y,R2
(1098) 				case 39:	// 连续3次下片都不对，初步判定是进片或下片光耦损坏,仍然执行进片动作
(1099) 					MotRunToSite(MOT_TURN_PLATE,CurInsertRingNum);
(1100) 					waitMotTurnPlate = 1;
    0227C EF29      LDI	R18,0xF9
    0227D E13B      LDI	R19,0x1B
    0227E ED00      LDI	R16,0xD0
(1101) 					workStep = 3;	
    0227F E013      LDI	R17,3
    02280 940E A90D CALL	_uart_Printf
(1102) 					break;								
    02282 9180 00C1 LDS	R24,0xC1
(1103) 				case 3:		
(1104) 					i = 0;
    02284 6180      ORI	R24,0x10
    02285 9380 00C1 STS	0xC1,R24
(1105) 					j = 0;
    02287 C225      RJMP	0x24AD
(1106) 					SetDelayTime(MOT_CARD_LOAD,5);
    02288 9160 1660 LDS	R22,CurInsertRingNum
    0228A 2777      CLR	R23
    0228B 5E67      SUBI	R22,0xE7
    0228C 4F7F      SBCI	R23,0xFF
(1107) 					workStep = 4;
    0228D 316E      CPI	R22,0x1E
    0228E E0E0      LDI	R30,0
    0228F 077E      CPC	R23,R30
(1108) 					break;
    02290 F014      BLT	0x2293
(1109) 				case 4:	// 干片推入转盘
(1110) 				//	SetMotRunPam(MOT_CARD_LOAD,120,2,3);
(1111) 					MotRunTo(MOT_CARD_LOAD,_POS_CARDLOAD_RING);		// 装片行程94mm/0.08128 = 1156
    02291 516E      SUBI	R22,0x1E
    02292 4070      SBCI	R23,0
    02293 2F26      MOV	R18,R22
    02294 E001      LDI	R16,1
    02295 940E 6A7F CALL	_MotRunToSite
(1112) 					Uart0ReUnable;
    02297 E081      LDI	R24,1
    02298 9380 152F STS	liqDetBaseAdc+74,R24
    0229A E281      LDI	R24,0x21
(1113) 					uart_Printf("*3918 CardLoadBegain\r\n");	
    0229B 9380 1526 STS	liqDetBaseAdc+65,R24
    0229D C20F      RJMP	0x24AD
    0229E E025      LDI	R18,5
(1114) 					Uart0ReEnable;
    0229F E030      LDI	R19,0
    022A0 E001      LDI	R16,1
    022A1 940E 97B7 CALL	_SetDelayTime
    022A3 E283      LDI	R24,0x23
(1115) 					waitMotCardLoad = 1;
    022A4 9380 1526 STS	liqDetBaseAdc+65,R24
    022A6 C206      RJMP	0x24AD
(1116) 					workStep = 7;
    022A7 940E A99B CALL	_GetwasteCardState
    022A9 2EA0      MOV	R10,R16
(1117) 					break;
    022AA 2300      TST	R16
(1118) 				case 7:		// 干片装入转盘完成，干片载入小车回到起始位
(1119) 				//	SetMotRunPam(MOT_CARD_LOAD,160,10,4);
(1120) 					SetMotRunPam(MOT_CARD_LOAD,220,10,CURRENT_CARD_LOAD);
    022AB F469      BNE	0x22B9
    022AC 9020 0106 LDS	R2,0x106
    022AE FC21      SBRC	R2,1
    022AF C009      RJMP	0x22B9
    022B0 2422      CLR	R2
    022B1 9220 1C18 STS	TurnPlateUsedLock,R2
(1121) 					Uart0ReUnable;
    022B3 E088      LDI	R24,0x8
    022B4 9380 1525 STS	liqDetBaseAdc+64,R24
    022B6 9220 1526 STS	liqDetBaseAdc+65,R2
(1122) 					uart_Printf("*3919 CardLoadBack\r\n");	
    022B8 C1F4      RJMP	0x24AD
    022B9 E084      LDI	R24,4
    022BA 838A      STD	Y+2,R24
    022BB E184      LDI	R24,0x14
(1123) 					Uart0ReEnable;
    022BC 8388      ST	Y,R24
    022BD EC28      LDI	R18,0xC8
    022BE E005      LDI	R16,5
    022BF 940E 6A9F CALL	_SetMotRunPam
(1124) 					MotRunTo(MOT_CARD_LOAD,0);
    022C1 E420      LDI	R18,0x40
    022C2 E036      LDI	R19,6
    022C3 E005      LDI	R16,5
    022C4 940E 6A5B CALL	_MotRunTo
(1125) 					waitMotCardLoad = 1;
    022C6 E081      LDI	R24,1
    022C7 9380 152E STS	liqDetBaseAdc+73,R24
(1126) 					if(inWork == 0)
    022C9 E284      LDI	R24,0x24
    022CA 9380 1526 STS	liqDetBaseAdc+65,R24
    022CC C1E0      RJMP	0x24AD
(1127) 					{
(1128) 						inWork = 1;
    022CD E082      LDI	R24,2
    022CE 838A      STD	Y+2,R24
(1129) 						SetDelayTime(MOT_CARD_LOAD,50);
    022CF E184      LDI	R24,0x14
    022D0 8388      ST	Y,R24
    022D1 E624      LDI	R18,0x64
    022D2 E005      LDI	R16,5
    022D3 940E 6A9F CALL	_SetMotRunPam
(1130) 					}
(1131) 					workStep = 12;
    022D5 2722      CLR	R18
    022D6 2733      CLR	R19
(1132) 					break;
    022D7 E005      LDI	R16,5
(1133) 				case 12:
(1134) 					MotRunTo(MOT_CARD_LOAD,0);
    022D8 940E 6A5B CALL	_MotRunTo
    022DA E081      LDI	R24,1
    022DB 9380 152E STS	liqDetBaseAdc+73,R24
(1135) 					SetDelayTime(MOT_CARD_LOAD,1);
    022DD E285      LDI	R24,0x25
    022DE 9380 1526 STS	liqDetBaseAdc+65,R24
    022E0 C1CC      RJMP	0x24AD
    022E1 E025      LDI	R18,5
(1136) 					waitMotCardLoad = 1;
    022E2 E030      LDI	R19,0
    022E3 E005      LDI	R16,5
    022E4 940E 97B7 CALL	_SetDelayTime
(1137) 					workStep = 13;
    022E6 E286      LDI	R24,0x26
    022E7 9380 1526 STS	liqDetBaseAdc+65,R24
(1138) 					break;
    022E9 C1C3      RJMP	0x24AD
    022EA E002      LDI	R16,2
    022EB 940E 9A52 CALL	_getLiqDetADC
    022ED 0158      MOVW	R10,R16
(1139) 				case 13:
(1140) 					MotRunTo(MOT_CARD_LOAD,0);
(1141) 					SetDelayTime(MOT_CARD_LOAD,1);
    022EE 01B5      MOVW	R22,R10
    022EF 3804      CPI	R16,0x84
    022F0 E0E3      LDI	R30,3
    022F1 071E      CPC	R17,R30
    022F2 F464      BGE	0x22FF
(1142) 					waitMotCardLoad = 1;
    022F3 9120 1660 LDS	R18,CurInsertRingNum
    022F5 E001      LDI	R16,1
(1143) 					workStep = 11;
    022F6 940E 6A7F CALL	_MotRunToSite
    022F8 E081      LDI	R24,1
(1144) 					break;
    022F9 9380 152F STS	liqDetBaseAdc+74,R24
(1145) 				case 11:
(1146) 					siTmp = GetMotPositionOfStep(MOT_CARD_LOAD);
    022FB E18E      LDI	R24,0x1E
    022FC 9380 1526 STS	liqDetBaseAdc+65,R24
    022FE C1AE      RJMP	0x24AD
(1147) 					if(siTmp != 0)
    022FF 2722      CLR	R18
    02300 E001      LDI	R16,1
    02301 940E 6A7F CALL	_MotRunToSite
(1148) 					{
(1149) 						MotRunTo(MOT_CARD_LOAD,0);
    02303 E081      LDI	R24,1
    02304 9380 152F STS	liqDetBaseAdc+74,R24
    02306 E280      LDI	R24,0x20
(1150) 						waitMotCardLoad = 1;
    02307 9380 1526 STS	liqDetBaseAdc+65,R24
    02309 9180 00C1 LDS	R24,0xC1
(1151) 						break;
    0230B 7E8F      ANDI	R24,0xEF
    0230C 9380 00C1 STS	0xC1,R24
    0230E 9180 152B LDS	R24,liqDetBaseAdc+70
(1152) 					}
(1153) 					if(CardNoneUseful == 0)
(1154) 						workStep = 80;
    02310 2799      CLR	R25
    02311 9602      ADIW	R24,2
    02312 839B      STD	Y+3,R25
(1155) 					else
(1156) 						workStep = 8;
    02313 838A      STD	Y+2,R24
    02314 9020 1660 LDS	R2,CurInsertRingNum
(1157) 					Uart0ReUnable;
    02316 2433      CLR	R3
    02317 8239      STD	Y+1,R3
    02318 8228      ST	Y,R2
    02319 EF2C      LDI	R18,0xFC
    0231A E03D      LDI	R19,0xD
(1158) 					uart_Printf("*3920 CardLoadBackDone\r\n");
    0231B E30A      LDI	R16,0x3A
    0231C E013      LDI	R17,3
    0231D 940E A90D CALL	_uart_Printf
(1159) 					Uart0ReEnable;
    0231F 9180 00C1 LDS	R24,0xC1
    02321 6180      ORI	R24,0x10
    02322 9380 00C1 STS	0xC1,R24
(1160) 					break;
    02324 9180 152B LDS	R24,liqDetBaseAdc+70
(1161) 				//***************************************************
(1162) 				//2016-06-12 添加回来之后重新检测，试剂片是否推入转盘
(1163) 				case 80:
(1164) 					ucTmp = PINL & 0x04;	
    02326 5F8F      SUBI	R24,0xFF
    02327 9380 152B STS	liqDetBaseAdc+70,R24
(1165) 					Uart0ReUnable;
    02329 E082      LDI	R24,2
    0232A 9020 152B LDS	R2,liqDetBaseAdc+70
    0232C 1582      CP	R24,R2
(1166) 					uart_Printf("%s $%4d $%4d\r\n",strM3149,oldGetCardState,ucTmp);	
    0232D F008      BCS	0x232F
    0232E C17E      RJMP	0x24AD
    0232F 2422      CLR	R2
    02330 9220 152B STS	liqDetBaseAdc+70,R2
    02332 E287      LDI	R24,0x27
    02333 9380 1526 STS	liqDetBaseAdc+65,R24
    02335 9180 00C1 LDS	R24,0xC1
    02337 7E8F      ANDI	R24,0xEF
    02338 9380 00C1 STS	0xC1,R24
    0233A 9020 1660 LDS	R2,CurInsertRingNum
(1167) 					Uart0ReEnable;
    0233C 2433      CLR	R3
    0233D 8239      STD	Y+1,R3
    0233E 8228      ST	Y,R2
    0233F ED2D      LDI	R18,0xDD
    02340 E13B      LDI	R19,0x1B
(1168) 					//if(ucTmp == oldGetCardState)	//试剂片还在
(1169) 					if(ucTmp == 4 && oldGetCardState == 4)	//试剂片还在
    02341 ED00      LDI	R16,0xD0
    02342 E013      LDI	R17,3
    02343 940E A90D CALL	_uart_Printf
    02345 9180 00C1 LDS	R24,0xC1
(1170) 					{
(1171) 						//TurnPlateUseLock = 0;
(1172) 						MotRunTo(MOT_TURN_PLATE,0);
    02347 6180      ORI	R24,0x10
    02348 9380 00C1 STS	0xC1,R24
    0234A C162      RJMP	0x24AD
    0234B 9120 1660 LDS	R18,CurInsertRingNum
(1173) 						waitMotTurnPlate = 1;
    0234D E001      LDI	R16,1
    0234E 940E 6A7F CALL	_MotRunToSite
(1174) 						workStep = 1;
    02350 E081      LDI	R24,1
(1175) 					}
    02351 9380 152F STS	liqDetBaseAdc+74,R24
(1176) 					else
(1177) 						workStep = 8;
    02353 E083      LDI	R24,3
    02354 9380 1526 STS	liqDetBaseAdc+65,R24
(1178) 					break;					
    02356 C156      RJMP	0x24AD
    02357 2422      CLR	R2
    02358 9220 152A STS	liqDetBaseAdc+69,R2
(1179) 				//***************************************************
(1180) 				case 8:		// 完成
(1181) 					workStep = 9;
(1182) 					TurnPlateUsedLock = 0;			
    0235A 9220 152B STS	liqDetBaseAdc+70,R2
(1183) 					SetRingQueueUnitUsed(CurInsertRingNum);		// 设置干片已经装入转盘标识
    0235C E025      LDI	R18,5
    0235D E030      LDI	R19,0
    0235E E004      LDI	R16,4
    0235F 940E 97B7 CALL	_SetDelayTime
(1184) 					InsertRingFlag = 1;
    02361 E68F      LDI	R24,0x6F
    02362 9380 1526 STS	liqDetBaseAdc+65,R24
(1185) 					if(insertflag[CurInsertRingNum] == 0)
    02364 C148      RJMP	0x24AD
    02365 E021      LDI	R18,1
    02366 E001      LDI	R16,1
    02367 940E 2FEA CALL	_GetMotorMonitorState
    02369 2EA0      MOV	R10,R16
    0236A 2300      TST	R16
    0236B F421      BNE	0x2370
    0236C E084      LDI	R24,4
    0236D 9380 1526 STS	liqDetBaseAdc+65,R24
(1186) 						insertflag[CurInsertRingNum] = 255;
    0236F C13D      RJMP	0x24AD
    02370 E081      LDI	R24,1
    02371 9380 1526 STS	liqDetBaseAdc+65,R24
    02373 C139      RJMP	0x24AD
    02374 E420      LDI	R18,0x40
(1187) #ifndef UartSendLong					
(1188) 					Uart0ReUnable;
(1189) 					//uart_Printf("%s $%8d",strM3147,NewTestInfo.testSerial); //2016-07-07
(1190) 					uart_Printf("%s $%8d",strM3147,RingQueue.sampInfo[CurInsertRingNum].testSerial); //2016-09-13
(1191) #else
(1192) 					Uart0ReUnable;
    02375 E036      LDI	R19,6
    02376 E004      LDI	R16,4
    02377 940E 6A5B CALL	_MotRunTo
    02379 9180 00C1 LDS	R24,0xC1
(1193) 					uart_Printf("%s $ ",strM3147);
    0237B 7E8F      ANDI	R24,0xEF
    0237C 9380 00C1 STS	0xC1,R24
    0237E E109      LDI	R16,0x19
    0237F E013      LDI	R17,3
(1194) 					uart0SendInt(RingQueue.sampInfo[CurInsertRingNum].testSerial);
    02380 940E A90D CALL	_uart_Printf
    02382 9180 00C1 LDS	R24,0xC1
    02384 6180      ORI	R24,0x10
    02385 9380 00C1 STS	0xC1,R24
    02387 E081      LDI	R24,1
    02388 9380 152D STS	liqDetBaseAdc+72,R24
    0238A E087      LDI	R24,7
    0238B 9380 1526 STS	liqDetBaseAdc+65,R24
    0238D C11F      RJMP	0x24AD
    0238E E084      LDI	R24,4
(1195) #endif
(1196) 					uart_Printf(" $%4d $%4d\r\n",CurInsertRingNum,insertflag[CurInsertRingNum]); //2016-07-07
    0238F 838A      STD	Y+2,R24
    02390 E08A      LDI	R24,0xA
    02391 8388      ST	Y,R24
    02392 ED2C      LDI	R18,0xDC
    02393 E004      LDI	R16,4
    02394 940E 6A9F CALL	_SetMotRunPam
    02396 9180 00C1 LDS	R24,0xC1
    02398 7E8F      ANDI	R24,0xEF
    02399 9380 00C1 STS	0xC1,R24
    0239B E004      LDI	R16,4
    0239C E013      LDI	R17,3
    0239D 940E A90D CALL	_uart_Printf
    0239F 9180 00C1 LDS	R24,0xC1
(1197) 					Uart0ReEnable;
    023A1 6180      ORI	R24,0x10
    023A2 9380 00C1 STS	0xC1,R24
    023A4 2722      CLR	R18
    023A5 2733      CLR	R19
(1198) 					SetMotRunPam(MOT_STORE_CARD_MOVE,200,20,CURRENT_STORE_MOVE);
    023A6 E004      LDI	R16,4
    023A7 940E 6A5B CALL	_MotRunTo
    023A9 E081      LDI	R24,1
    023AA 9380 152D STS	liqDetBaseAdc+72,R24
    023AC 9020 1529 LDS	R2,liqDetBaseAdc+68
(1199) 					break;
    023AE 2022      TST	R2
(1200) 				case 9:		// 取片小车运行到片仓口
(1201) 					MotRunTo(MOT_STORE_CARD_MOVE,432);
    023AF F439      BNE	0x23B7
    023B0 9380 1529 STS	liqDetBaseAdc+68,R24
    023B2 E322      LDI	R18,0x32
    023B3 E030      LDI	R19,0
(1202) 					waitMotCardTrolley = 1;
    023B4 E004      LDI	R16,4
    023B5 940E 97B7 CALL	_SetDelayTime
(1203) 					workStep = 10;
    023B7 E08C      LDI	R24,0xC
    023B8 9380 1526 STS	liqDetBaseAdc+65,R24
(1204) 					break;
    023BA C0F2      RJMP	0x24AD
(1205) 				case 10:
(1206) 					if(0 != CardStoreTestFlag)
    023BB 2722      CLR	R18
    023BC 2733      CLR	R19
    023BD E004      LDI	R16,4
    023BE 940E 6A5B CALL	_MotRunTo
(1207) 					{
(1208) 						CardGetTestDone();	// 测试完成
    023C0 E021      LDI	R18,1
(1209) 					}
(1210) 					workStep = 0;
    023C1 E030      LDI	R19,0
    023C2 E004      LDI	R16,4
    023C3 940E 97B7 CALL	_SetDelayTime
(1211) 					mainStep = 0;
    023C5 E081      LDI	R24,1
(1212) 					inWork = 0;
    023C6 9380 152D STS	liqDetBaseAdc+72,R24
(1213) 					return 1;
    023C8 E08D      LDI	R24,0xD
    023C9 9380 1526 STS	liqDetBaseAdc+65,R24
(1214) 					break;
(1215) 				}
(1216) 			break;
(1217) 		default:
(1218) 			break;
(1219) 		}
(1220) 	return 0;
    023CB C0E1      RJMP	0x24AD
    023CC 2722      CLR	R18
    023CD 2733      CLR	R19
    023CE E004      LDI	R16,4
    023CF 940E 6A5B CALL	_MotRunTo
    023D1 E021      LDI	R18,1
    023D2 E030      LDI	R19,0
(1221) }
(1222) 
(1223) unsigned char GetStoreProcess(void)
(1224) {
(1225) 	static unsigned char mainStep;		
(1226) 	static unsigned char workStep;
(1227) 	static signed int storePos;
(1228) 	static unsigned char inWork;
(1229) 	static unsigned char waitMotCardTrolley, waitMotCardLoad, waitMotTurnPlate;
(1230) 	static unsigned char oldStoreState;
(1231) 	static unsigned char oldGetCardState;
(1232) 	static unsigned char curCardStoreNum;
(1233) 	static unsigned char checkReDoCnt, takeRedoCnt;
(1234) 	signed int siTmp;
(1235) 	unsigned char pos;
(1236) 	unsigned char ucTmp;
(1237) 	if(WaitDelayTime(MOT_STORE_CARD_MOVE))		return 0;
    023D3 E004      LDI	R16,4
    023D4 940E 97B7 CALL	_SetDelayTime
    023D6 E081      LDI	R24,1
    023D7 9380 152D STS	liqDetBaseAdc+72,R24
    023D9 E08B      LDI	R24,0xB
(1238) 	if(WaitDelayTime(MOT_CARD_LOAD))		return 0;
    023DA 9380 1526 STS	liqDetBaseAdc+65,R24
    023DC C0D0      RJMP	0x24AD
    023DD E004      LDI	R16,4
    023DE 940E 2DAD CALL	_GetMotPositionOfStep
    023E0 0158      MOVW	R10,R16
(1239) 	if(waitMotCardTrolley){	if(GetMotState(MOT_STORE_CARD_MOVE)!=STA_SLAVE_FREE)	return 0;waitMotCardTrolley = 0;}
    023E1 01B5      MOVW	R22,R10
    023E2 3000      CPI	R16,0
    023E3 0701      CPC	R16,R17
    023E4 F049      BEQ	0x23EE
    023E5 2722      CLR	R18
    023E6 2733      CLR	R19
    023E7 E004      LDI	R16,4
    023E8 940E 6A5B CALL	_MotRunTo
    023EA E081      LDI	R24,1
    023EB 9380 152D STS	liqDetBaseAdc+72,R24
    023ED C0BF      RJMP	0x24AD
    023EE 9020 06F6 LDS	R2,CardNoneUseful
(1240) 	if(waitMotCardLoad){if(GetMotState(MOT_CARD_LOAD)!=STA_SLAVE_FREE)	return 0;waitMotCardLoad = 0;}
    023F0 2022      TST	R2
    023F1 F421      BNE	0x23F6
    023F2 E580      LDI	R24,0x50
    023F3 9380 1526 STS	liqDetBaseAdc+65,R24
    023F5 C003      RJMP	0x23F9
    023F6 E088      LDI	R24,0x8
    023F7 9380 1526 STS	liqDetBaseAdc+65,R24
    023F9 9180 00C1 LDS	R24,0xC1
    023FB 7E8F      ANDI	R24,0xEF
    023FC 9380 00C1 STS	0xC1,R24
    023FE EE0B      LDI	R16,0xEB
(1241) 	if(waitMotTurnPlate){if(GetMotState(MOT_TURN_PLATE)!=STA_SLAVE_FREE)	return 0;waitMotTurnPlate = 0;}
    023FF E012      LDI	R17,2
    02400 940E A90D CALL	_uart_Printf
    02402 9180 00C1 LDS	R24,0xC1
    02404 6180      ORI	R24,0x10
    02405 9380 00C1 STS	0xC1,R24
    02407 C0A5      RJMP	0x24AD
    02408 9140 0109 LDS	R20,0x109
    0240A 7044      ANDI	R20,4
    0240B 9180 00C1 LDS	R24,0xC1
    0240D 7E8F      ANDI	R24,0xEF
(1242) 	
(1243) 	switch(mainStep)
    0240E 9380 00C1 STS	0xC1,R24
    02410 2E24      MOV	R2,R20
    02411 2433      CLR	R3
    02412 823B      STD	Y+3,R3
    02413 822A      STD	Y+2,R2
    02414 9020 1531 LDS	R2,liqDetBaseAdc+76
    02416 2433      CLR	R3
    02417 8239      STD	Y+1,R3
    02418 8228      ST	Y,R2
    02419 EE2A      LDI	R18,0xEA
    0241A E130      LDI	R19,0x10
    0241B E30A      LDI	R16,0x3A
    0241C E013      LDI	R17,3
    0241D 940E A90D CALL	_uart_Printf
    0241F 9180 00C1 LDS	R24,0xC1
    02421 6180      ORI	R24,0x10
    02422 9380 00C1 STS	0xC1,R24
    02424 3044      CPI	R20,4
    02425 F479      BNE	0x2435
    02426 9180 1531 LDS	R24,liqDetBaseAdc+76
    02428 3084      CPI	R24,4
    02429 F459      BNE	0x2435
    0242A 2722      CLR	R18
    0242B 2733      CLR	R19
    0242C E001      LDI	R16,1
    0242D 940E 6A5B CALL	_MotRunTo
    0242F E081      LDI	R24,1
    02430 9380 152F STS	liqDetBaseAdc+74,R24
    02432 9380 1526 STS	liqDetBaseAdc+65,R24
    02434 C078      RJMP	0x24AD
    02435 E088      LDI	R24,0x8
    02436 9380 1526 STS	liqDetBaseAdc+65,R24
    02438 C074      RJMP	0x24AD
    02439 E089      LDI	R24,0x9
    0243A 9380 1526 STS	liqDetBaseAdc+65,R24
(1244) 	{
(1245) 		case 0:	
(1246) 			MotInitCheck(MOT_CARD_LOAD);
    0243C 2422      CLR	R2
    0243D 9220 1C18 STS	TurnPlateUsedLock,R2
(1247) 			waitMotCardLoad = 1;
    0243F 9100 1660 LDS	R16,CurInsertRingNum
(1248) 			mainStep = 99;
    02441 2711      CLR	R17
    02442 940E 9EFF CALL	_SetRingQueueUnitUsed
(1249) 			break;
    02444 E081      LDI	R24,1
(1250) 		case 99:
(1251) 			mainStep = 100;
    02445 9380 0525 STS	InsertRingFlag,R24
    02447 EC81      LDI	R24,0xC1
(1252) 			MotInitCheck(MOT_STORE_CARD_MOVE);
    02448 E19D      LDI	R25,0x1D
    02449 91E0 1660 LDS	R30,CurInsertRingNum
(1253) 			SetDelayTime(MOT_STORE_CARD_MOVE,10);
    0244B 27FF      CLR	R31
    0244C 0FE8      ADD	R30,R24
    0244D 1FF9      ADC	R31,R25
    0244E 8020      LD	R2,Z
    0244F 2022      TST	R2
(1254) 			waitMotCardTrolley = 1; 
    02450 F439      BNE	0x2458
    02451 91E0 1660 LDS	R30,CurInsertRingNum
(1255) 			break;
    02453 27FF      CLR	R31
(1256) 		case 100:
(1257) 			ucTmp = CardSurplusState[GetNewTestCard-1];
    02454 0FE8      ADD	R30,R24
    02455 1FF9      ADC	R31,R25
    02456 EF8F      LDI	R24,0xFF
    02457 8380      ST	Z,R24
    02458 9180 00C1 LDS	R24,0xC1
    0245A 7E8F      ANDI	R24,0xEF
    0245B 9380 00C1 STS	0xC1,R24
(1258) 			if(CardNoneUseful == 0)
    0245D EB2E      LDI	R18,0xBE
    0245E E130      LDI	R19,0x10
    0245F EE05      LDI	R16,0xE5
(1259) 			{
(1260) 				if(ucTmp == INFO_STORE_EMPTY)
    02460 E012      LDI	R17,2
    02461 940E A90D CALL	_uart_Printf
(1261) 				{
(1262) 					SetBeepWarning();
    02463 9110 1660 LDS	R17,CurInsertRingNum
(1263) 					Uart0ReUnable;
    02465 E00D      LDI	R16,0xD
    02466 0301      MULSU	R16,R17
    02467 E784      LDI	R24,0x74
    02468 E19A      LDI	R25,0x1A
(1264) 					uart_Printf("!3520 $%4d\r\n", GetNewTestCard);
    02469 01F0      MOVW	R30,R0
    0246A 0FE8      ADD	R30,R24
    0246B 1FF9      ADC	R31,R25
    0246C 8100      LD	R16,Z
    0246D 8111      LDD	R17,Z+1
    0246E 8122      LDD	R18,Z+2
    0246F 8133      LDD	R19,Z+3
(1265) 					Uart0ReEnable;
    02470 940E A940 CALL	_uart0SendInt
    02472 90A0 1660 LDS	R10,CurInsertRingNum
    02474 EC81      LDI	R24,0xC1
(1266) 					mainStep = 101;
    02475 E19D      LDI	R25,0x1D
    02476 2DEA      MOV	R30,R10
    02477 27FF      CLR	R31
(1267) 				}
    02478 0FE8      ADD	R30,R24
(1268) 				else if(ucTmp == INFO_STORE_ERROR)
    02479 1FF9      ADC	R31,R25
    0247A 8020      LD	R2,Z
(1269) 				{
(1270) 					Uart0ReUnable;
    0247B 2433      CLR	R3
    0247C 8239      STD	Y+1,R3
    0247D 8228      ST	Y,R2
    0247E 2D2A      MOV	R18,R10
    0247F 2733      CLR	R19
(1271) 					uart_Printf("!3522 $%4d\r\n", GetNewTestCard);
    02480 E409      LDI	R16,0x49
    02481 E013      LDI	R17,3
    02482 940E A90D CALL	_uart_Printf
    02484 9180 00C1 LDS	R24,0xC1
    02486 6180      ORI	R24,0x10
(1272) 					Uart0ReEnable;
    02487 9380 00C1 STS	0xC1,R24
    02489 E08A      LDI	R24,0xA
    0248A 838A      STD	Y+2,R24
    0248B E184      LDI	R24,0x14
(1273) 					mainStep = 101;
    0248C 8388      ST	Y,R24
    0248D EC28      LDI	R18,0xC8
    0248E E008      LDI	R16,0x8
(1274) 				}
    0248F 940E 6A9F CALL	_SetMotRunPam
(1275) 				else
(1276) 				{
(1277) 					mainStep = 1;
    02491 C01B      RJMP	0x24AD
    02492 EB20      LDI	R18,0xB0
(1278) 					CardStoreOpenLook = 1;	
    02493 E031      LDI	R19,1
    02494 E008      LDI	R16,0x8
(1279) 				}
(1280) 			}
    02495 940E 6A5B CALL	_MotRunTo
(1281) 			else
(1282) 			{
(1283) 				mainStep = 1;
    02497 E081      LDI	R24,1
    02498 9380 152C STS	liqDetBaseAdc+71,R24
(1284) 				CardStoreOpenLook = 1;
    0249A E08A      LDI	R24,0xA
(1285) 			}
(1286) 			oldStoreState = ucTmp;
    0249B 9380 1526 STS	liqDetBaseAdc+65,R24
(1287) 			break;
    0249D C00F      RJMP	0x24AD
(1288) 		case 101:
(1289) 			ucTmp = CardSurplusState[GetNewTestCard-1];
    0249E 9020 1559 LDS	R2,CardStoreTestFlag
    024A0 2022      TST	R2
    024A1 F011      BEQ	0x24A4
    024A2 940E 17FE CALL	0x17FE
    024A4 2422      CLR	R2
    024A5 9220 1526 STS	liqDetBaseAdc+65,R2
(1290) 			if(ucTmp != oldStoreState)
    024A7 9220 1525 STS	liqDetBaseAdc+64,R2
    024A9 9220 1529 STS	liqDetBaseAdc+68,R2
(1291) 				mainStep = 100;
    024AB E001      LDI	R16,1
    024AC C001      RJMP	0x24AE
    024AD 2700      CLR	R16
(1292) 			break;
    024AE 9624      ADIW	R28,4
(1293) 		case 1: 	// 小车移到片仓前
(1294) 			switch(workStep)
    024AF 940E AE9E CALL	pop_xgsetF00C
    024B1 9622      ADIW	R28,2
    024B2 9508      RET
_GetStoreProcess:
    024B3 940E AE97 CALL	push_xgsetF00C
    024B5 9723      SBIW	R28,3
    024B6 E008      LDI	R16,0x8
    024B7 940E 97C6 CALL	_WaitDelayTime
    024B9 2300      TST	R16
    024BA F011      BEQ	0x24BD
    024BB 2700      CLR	R16
    024BC C405      RJMP	0x28C2
    024BD E004      LDI	R16,4
    024BE 940E 97C6 CALL	_WaitDelayTime
    024C0 2300      TST	R16
    024C1 F011      BEQ	0x24C4
    024C2 2700      CLR	R16
    024C3 C3FE      RJMP	0x28C2
    024C4 9020 153A LDS	R2,liqDetBaseAdc+85
(1295) 			{
(1296) 				case 0:
(1297) 					storePos = 494;		// 40mm / 0.081 = 494
    024C6 2022      TST	R2
    024C7 F059      BEQ	0x24D3
    024C8 E008      LDI	R16,0x8
    024C9 940E 6A0C CALL	_GetMotState
(1298) 					SetMotRunPam(MOT_STORE_CARD_MOVE,200,20,CURRENT_STORE_MOVE);
    024CB 2F40      MOV	R20,R16
    024CC 3001      CPI	R16,1
    024CD F011      BEQ	0x24D0
    024CE 2700      CLR	R16
    024CF C3F2      RJMP	0x28C2
    024D0 2422      CLR	R2
    024D1 9220 153A STS	liqDetBaseAdc+85,R2
(1299) 					if(CardStoreOpenState & 0x3f) // 如果片仓开启
    024D3 9020 153B LDS	R2,liqDetBaseAdc+86
    024D5 2022      TST	R2
    024D6 F059      BEQ	0x24E2
(1300) 					{	
(1301) 						Uart0ReUnable;
    024D7 E004      LDI	R16,4
    024D8 940E 6A0C CALL	_GetMotState
    024DA 2F40      MOV	R20,R16
    024DB 3001      CPI	R16,1
(1302) 						uart_Printf("!3525\r\n");
    024DC F011      BEQ	0x24DF
    024DD 2700      CLR	R16
    024DE C3E3      RJMP	0x28C2
    024DF 2422      CLR	R2
(1303) 						Uart0ReEnable;
    024E0 9220 153B STS	liqDetBaseAdc+86,R2
    024E2 9020 153C LDS	R2,liqDetBaseAdc+87
    024E4 2022      TST	R2
(1304) 						workStep = 2;
    024E5 F059      BEQ	0x24F1
    024E6 E001      LDI	R16,1
    024E7 940E 6A0C CALL	_GetMotState
(1305) 						break;
    024E9 2F40      MOV	R20,R16
    024EA 3001      CPI	R16,1
    024EB F011      BEQ	0x24EE
    024EC 2700      CLR	R16
    024ED C3D4      RJMP	0x28C2
    024EE 2422      CLR	R2
    024EF 9220 153C STS	liqDetBaseAdc+87,R2
(1306) 					}
(1307) 					MotRunTo(MOT_STORE_CARD_MOVE,storePos);			// 	
(1308) 					workStep = 1;
    024F1 9140 1535 LDS	R20,liqDetBaseAdc+80
(1309) 					break;
    024F3 2755      CLR	R21
(1310) 				case 1:
(1311) 					if(CardStoreOpenState & 0x3f)	// 如果片仓开启
    024F4 3040      CPI	R20,0
    024F5 0745      CPC	R20,R21
    024F6 F139      BEQ	0x251E
    024F7 3041      CPI	R20,1
(1312) 					{	
(1313) 						MotStop(MOT_STORE_CARD_MOVE);
    024F8 E0E0      LDI	R30,0
    024F9 075E      CPC	R21,R30
    024FA F409      BNE	0x24FC
(1314) 						Uart0ReUnable;
    024FB C096      RJMP	0x2592
    024FC 3042      CPI	R20,2
    024FD E0E0      LDI	R30,0
    024FE 075E      CPC	R21,R30
    024FF F409      BNE	0x2501
(1315) 						uart_Printf("!3525\r\n");
    02500 C129      RJMP	0x262A
    02501 3043      CPI	R20,3
    02502 E0E0      LDI	R30,0
    02503 075E      CPC	R21,R30
(1316) 						Uart0ReEnable;
    02504 F409      BNE	0x2506
    02505 C1C3      RJMP	0x26C9
    02506 3045      CPI	R20,5
    02507 E0E0      LDI	R30,0
    02508 075E      CPC	R21,R30
(1317) 						workStep = 2;
    02509 F409      BNE	0x250B
    0250A C274      RJMP	0x277F
    0250B 3040      CPI	R20,0
(1318) 					}
    0250C E0E0      LDI	R30,0
(1319) 					else
(1320) 					{	// 片仓处于关闭状态，等待片仓小车停止
(1321) 						if(GetMotState(MOT_STORE_CARD_MOVE)!=STA_SLAVE_FREE)
    0250D 075E      CPC	R21,R30
    0250E F40C      BGE	0x2510
    0250F C3B1      RJMP	0x28C1
    02510 3643      CPI	R20,0x63
    02511 E0E0      LDI	R30,0
    02512 075E      CPC	R21,R30
(1322) 							break;
    02513 F0A1      BEQ	0x2528
(1323) 						else
(1324) 							workStep = 3;
    02514 3644      CPI	R20,0x64
    02515 E0E0      LDI	R30,0
    02516 075E      CPC	R21,R30
(1325) 					}
(1326) 					break;
    02517 F0F9      BEQ	0x2537
(1327) 				case 2:		// 片仓处于开启状态，等待片仓关闭后从新启动片仓电机
(1328) 					if((CardStoreOpenState & 0x3f) == 0)
    02518 3645      CPI	R20,0x65
    02519 E0E0      LDI	R30,0
    0251A 075E      CPC	R21,R30
    0251B F409      BNE	0x251D
    0251C C064      RJMP	0x2581
(1329) 					{
(1330) 						siTmp = GetMotPositionOfStep(MOT_STORE_CARD_MOVE) + 5;
    0251D C3A3      RJMP	0x28C1
    0251E E004      LDI	R16,4
    0251F 940E 6AFA CALL	_MotInitCheck
    02521 E081      LDI	R24,1
    02522 9380 153B STS	liqDetBaseAdc+86,R24
(1331) 						if(siTmp<storePos)
    02524 E683      LDI	R24,0x63
    02525 9380 1535 STS	liqDetBaseAdc+80,R24
    02527 C399      RJMP	0x28C1
    02528 E684      LDI	R24,0x64
    02529 9380 1535 STS	liqDetBaseAdc+80,R24
(1332) 						{
(1333) 							MotRunTo(MOT_STORE_CARD_MOVE,storePos);
    0252B E008      LDI	R16,0x8
    0252C 940E 6AFA CALL	_MotInitCheck
(1334) 							SetDelayTime(MOT_STORE_CARD_MOVE,1);
    0252E E02A      LDI	R18,0xA
    0252F E030      LDI	R19,0
    02530 E008      LDI	R16,0x8
    02531 940E 97B7 CALL	_SetDelayTime
(1335) 							workStep = 1;
    02533 E081      LDI	R24,1
    02534 9380 153A STS	liqDetBaseAdc+85,R24
(1336) 						}
    02536 C38A      RJMP	0x28C1
(1337) 						else
(1338) 						{
(1339) 							workStep = 3;
    02537 E48B      LDI	R24,0x4B
    02538 E195      LDI	R25,0x15
    02539 91E0 165F LDS	R30,GetNewTestCard
(1340) 						}
(1341) 					}
(1342) 					break;
    0253B 27FF      CLR	R31
    0253C 0FE8      ADD	R30,R24
    0253D 1FF9      ADC	R31,R25
    0253E 8140      LD	R20,Z
    0253F 9020 06F6 LDS	R2,CardNoneUseful
(1343) 				case 3:	// 片仓取片小车已运行到片仓起始处
(1344) 					SetDelayTime(MOT_STORE_CARD_MOVE,10);
(1345) 					workStep = 0;
    02541 2022      TST	R2
    02542 F5B1      BNE	0x2579
(1346) 					mainStep = 2;
    02543 3148      CPI	R20,0x18
    02544 F4B9      BNE	0x255C
    02545 940E 372D CALL	_SetBeepWarning
(1347) 					break;
(1348) 			}
(1349) 			break;
    02547 9180 00C1 LDS	R24,0xC1
    02549 7E8F      ANDI	R24,0xEF
    0254A 9380 00C1 STS	0xC1,R24
    0254C 9120 165F LDS	R18,GetNewTestCard
    0254E 2733      CLR	R19
    0254F E804      LDI	R16,0x84
    02550 E013      LDI	R17,3
    02551 940E A90D CALL	_uart_Printf
    02553 9180 00C1 LDS	R24,0xC1
    02555 6180      ORI	R24,0x10
    02556 9380 00C1 STS	0xC1,R24
    02558 E685      LDI	R24,0x65
    02559 9380 1535 STS	liqDetBaseAdc+80,R24
    0255B C022      RJMP	0x257E
    0255C 3149      CPI	R20,0x19
(1350) 		case 2:		// 小车移动到取片起始位置
(1351) 			switch(workStep)
(1352) 			{
(1353) 				case 0:
(1354) 					if(CardStoreOpenState & 0x3f)
    0255D F4A9      BNE	0x2573
    0255E 9180 00C1 LDS	R24,0xC1
    02560 7E8F      ANDI	R24,0xEF
(1355) 					{
(1356) 						Uart0ReUnable;
    02561 9380 00C1 STS	0xC1,R24
    02563 9120 165F LDS	R18,GetNewTestCard
    02565 2733      CLR	R19
(1357) 						uart_Printf("!3526\r\n");
    02566 E707      LDI	R16,0x77
    02567 E013      LDI	R17,3
    02568 940E A90D CALL	_uart_Printf
(1358) 						Uart0ReEnable;
    0256A 9180 00C1 LDS	R24,0xC1
    0256C 6180      ORI	R24,0x10
    0256D 9380 00C1 STS	0xC1,R24
(1359) 						workStep = 2;
    0256F E685      LDI	R24,0x65
    02570 9380 1535 STS	liqDetBaseAdc+80,R24
(1360) 						break;
    02572 C00B      RJMP	0x257E
(1361) 					}
(1362) 					storePos = CalCardStorePos(GetNewTestCard);	
    02573 E081      LDI	R24,1
    02574 9380 1535 STS	liqDetBaseAdc+80,R24
    02576 9380 02E0 STS	CardStoreOpenLook,R24
    02578 C005      RJMP	0x257E
    02579 E081      LDI	R24,1
    0257A 9380 1535 STS	liqDetBaseAdc+80,R24
(1363) 					SetMotRunPam(MOT_STORE_CARD_MOVE,200,20,CURRENT_STORE_MOVE);
    0257C 9380 02E0 STS	CardStoreOpenLook,R24
    0257E 9340 153D STS	liqDetBaseAdc+88,R20
    02580 C340      RJMP	0x28C1
    02581 E48B      LDI	R24,0x4B
    02582 E195      LDI	R25,0x15
    02583 91E0 165F LDS	R30,GetNewTestCard
(1364) 					MotRunTo(MOT_STORE_CARD_MOVE,storePos);			// 	
    02585 27FF      CLR	R31
    02586 0FE8      ADD	R30,R24
    02587 1FF9      ADC	R31,R25
    02588 8140      LD	R20,Z
    02589 9020 153D LDS	R2,liqDetBaseAdc+88
(1365) 					workStep = 1;
    0258B 1542      CP	R20,R2
    0258C F409      BNE	0x258E
    0258D C333      RJMP	0x28C1
(1366) 					break;
    0258E E684      LDI	R24,0x64
(1367) 				case 1:
(1368) 					if(CardStoreOpenState & 0x3f)
    0258F 9380 1535 STS	liqDetBaseAdc+80,R24
    02591 C32F      RJMP	0x28C1
    02592 9140 1536 LDS	R20,liqDetBaseAdc+81
(1369) 					{
(1370) 						Uart0ReUnable;
    02594 2755      CLR	R21
    02595 3040      CPI	R20,0
    02596 0745      CPC	R20,R21
    02597 F081      BEQ	0x25A8
(1371) 						MotStop(MOT_STORE_CARD_MOVE);
    02598 3041      CPI	R20,1
    02599 E0E0      LDI	R30,0
    0259A 075E      CPC	R21,R30
(1372) 						uart_Printf("!3526\r\n");
    0259B F409      BNE	0x259D
    0259C C03A      RJMP	0x25D7
    0259D 3042      CPI	R20,2
    0259E E0E0      LDI	R30,0
(1373) 						Uart0ReEnable;
    0259F 075E      CPC	R21,R30
    025A0 F409      BNE	0x25A2
    025A1 C059      RJMP	0x25FB
    025A2 3043      CPI	R20,3
    025A3 E0E0      LDI	R30,0
(1374) 						workStep = 2;
    025A4 075E      CPC	R21,R30
    025A5 F409      BNE	0x25A7
    025A6 C077      RJMP	0x261E
(1375) 					}
    025A7 C319      RJMP	0x28C1
(1376) 					else
(1377) 					{
(1378) 						if(GetMotState(MOT_STORE_CARD_MOVE)!=STA_SLAVE_FREE)
    025A8 EE8E      LDI	R24,0xEE
    025A9 E091      LDI	R25,1
    025AA 9390 1538 STS	liqDetBaseAdc+83,R25
    025AC 9380 1537 STS	liqDetBaseAdc+82,R24
(1379) 							break;
    025AE E08A      LDI	R24,0xA
(1380) 						else
(1381) 							workStep = 3;
    025AF 838A      STD	Y+2,R24
    025B0 E184      LDI	R24,0x14
    025B1 8388      ST	Y,R24
(1382) 					}
(1383) 					break;
    025B2 EC28      LDI	R18,0xC8
(1384) 				case 2:		// 片仓处于开启状态，等待片仓关闭后从新启动片仓电机
(1385) 					if((CardStoreOpenState & 0x3f) == 0)
    025B3 E008      LDI	R16,0x8
    025B4 940E 6A9F CALL	_SetMotRunPam
    025B6 9180 1552 LDS	R24,CardStoreOpenState
(1386) 					{
(1387) 						siTmp = GetMotPositionOfStep(MOT_STORE_CARD_MOVE) + 5;
    025B8 738F      ANDI	R24,0x3F
    025B9 F091      BEQ	0x25CC
    025BA 9180 00C1 LDS	R24,0xC1
    025BC 7E8F      ANDI	R24,0xEF
    025BD 9380 00C1 STS	0xC1,R24
(1388) 						if(siTmp<storePos)
    025BF E60F      LDI	R16,0x6F
    025C0 E013      LDI	R17,3
    025C1 940E A90D CALL	_uart_Printf
    025C3 9180 00C1 LDS	R24,0xC1
    025C5 6180      ORI	R24,0x10
(1389) 						{
(1390) 							MotRunTo(MOT_STORE_CARD_MOVE,storePos);
    025C6 9380 00C1 STS	0xC1,R24
    025C8 E082      LDI	R24,2
    025C9 9380 1536 STS	liqDetBaseAdc+81,R24
(1391) 							SetDelayTime(MOT_STORE_CARD_MOVE,1);
    025CB C2F5      RJMP	0x28C1
    025CC 9120 1537 LDS	R18,liqDetBaseAdc+82
    025CE 9130 1538 LDS	R19,liqDetBaseAdc+83
(1392) 							workStep = 1;
    025D0 E008      LDI	R16,0x8
    025D1 940E 6A5B CALL	_MotRunTo
(1393) 						}
    025D3 E081      LDI	R24,1
    025D4 9380 1536 STS	liqDetBaseAdc+81,R24
(1394) 						else
(1395) 						{
(1396) 							workStep = 3;
(1397) 						}
(1398) 					}
(1399) 					break;
    025D6 C2EA      RJMP	0x28C1
(1400) 				case 3:	// 片仓取片小车已运行到目的地
(1401) 					MotInitCheck(MOT_CARD_LOAD);
    025D7 9180 1552 LDS	R24,CardStoreOpenState
    025D9 738F      ANDI	R24,0x3F
(1402) 					SetDelayTime(MOT_STORE_CARD_MOVE,5);
    025DA F0A9      BEQ	0x25F0
    025DB E008      LDI	R16,0x8
    025DC 940E 6A13 CALL	_MotStop
    025DE 9180 00C1 LDS	R24,0xC1
(1403) 					workStep = 0;
    025E0 7E8F      ANDI	R24,0xEF
    025E1 9380 00C1 STS	0xC1,R24
(1404) 					mainStep = 3;
    025E3 E60F      LDI	R16,0x6F
    025E4 E013      LDI	R17,3
(1405) 					break;
(1406) 			}
(1407) 			break;
    025E5 940E A90D CALL	_uart_Printf
(1408) 		case 3:// 钩片抬起，小车钩片前进，使之进入钩片道槽
(1409) 			switch(workStep)
    025E7 9180 00C1 LDS	R24,0xC1
    025E9 6180      ORI	R24,0x10
    025EA 9380 00C1 STS	0xC1,R24
    025EC E082      LDI	R24,2
    025ED 9380 1536 STS	liqDetBaseAdc+81,R24
    025EF C2D1      RJMP	0x28C1
    025F0 E008      LDI	R16,0x8
    025F1 940E 6A0C CALL	_GetMotState
    025F3 2F40      MOV	R20,R16
    025F4 3001      CPI	R16,1
    025F5 F009      BEQ	0x25F7
    025F6 C2CA      RJMP	0x28C1
    025F7 E083      LDI	R24,3
    025F8 9380 1536 STS	liqDetBaseAdc+81,R24
    025FA C2C6      RJMP	0x28C1
    025FB 9180 1552 LDS	R24,CardStoreOpenState
    025FD 738F      ANDI	R24,0x3F
    025FE F009      BEQ	0x2600
    025FF C2C1      RJMP	0x28C1
    02600 E008      LDI	R16,0x8
    02601 940E 2DAD CALL	_GetMotPositionOfStep
    02603 01A8      MOVW	R20,R16
    02604 5F4B      SUBI	R20,0xFB
    02605 4F5F      SBCI	R21,0xFF
    02606 9020 1537 LDS	R2,liqDetBaseAdc+82
    02608 9030 1538 LDS	R3,liqDetBaseAdc+83
    0260A 1542      CP	R20,R2
    0260B 0553      CPC	R21,R3
    0260C F46C      BGE	0x261A
    0260D 0191      MOVW	R18,R2
    0260E E008      LDI	R16,0x8
    0260F 940E 6A5B CALL	_MotRunTo
    02611 E021      LDI	R18,1
    02612 E030      LDI	R19,0
    02613 E008      LDI	R16,0x8
    02614 940E 97B7 CALL	_SetDelayTime
    02616 E081      LDI	R24,1
    02617 9380 1536 STS	liqDetBaseAdc+81,R24
    02619 C2A7      RJMP	0x28C1
    0261A E083      LDI	R24,3
(1410) 			{
(1411) 				case 0:	
(1412) 					SetCardTrolleyState(1);
    0261B 9380 1536 STS	liqDetBaseAdc+81,R24
    0261D C2A3      RJMP	0x28C1
(1413) 					SetMotRunPam(MOT_STORE_CARD_MOVE,16,10,CURRENT_STORE_MOVE);
    0261E E02A      LDI	R18,0xA
    0261F E030      LDI	R19,0
    02620 E008      LDI	R16,0x8
    02621 940E 97B7 CALL	_SetDelayTime
    02623 2422      CLR	R2
    02624 9220 1536 STS	liqDetBaseAdc+81,R2
(1414) 					MotRun(MOT_STORE_CARD_MOVE,-98);
    02626 E082      LDI	R24,2
    02627 9380 1535 STS	liqDetBaseAdc+80,R24
    02629 C297      RJMP	0x28C1
(1415) 					waitMotCardTrolley = 1;
    0262A 9160 1536 LDS	R22,liqDetBaseAdc+81
    0262C 2777      CLR	R23
(1416) 					workStep = 1;
    0262D 3060      CPI	R22,0
    0262E 0767      CPC	R22,R23
(1417) 					break;
    0262F F081      BEQ	0x2640
(1418) 				case 1:
(1419) 					SetCardTrolleyState(0);
    02630 3061      CPI	R22,1
    02631 E0E0      LDI	R30,0
    02632 077E      CPC	R23,R30
(1420) 					workStep = 2;
    02633 F409      BNE	0x2635
    02634 C03D      RJMP	0x2672
    02635 3062      CPI	R22,2
(1421) 					break;
    02636 E0E0      LDI	R30,0
(1422) 				case 2:		
(1423) 					SetMotRunPam(MOT_STORE_CARD_MOVE,100,10,CURRENT_STORE_MOVE);
    02637 077E      CPC	R23,R30
    02638 F409      BNE	0x263A
    02639 C05C      RJMP	0x2696
    0263A 3063      CPI	R22,3
    0263B E0E0      LDI	R30,0
    0263C 077E      CPC	R23,R30
    0263D F409      BNE	0x263F
(1424) 					MotRun(MOT_STORE_CARD_MOVE,-(235+70));	
    0263E C07B      RJMP	0x26BA
    0263F C281      RJMP	0x28C1
    02640 9180 1552 LDS	R24,CardStoreOpenState
    02642 738F      ANDI	R24,0x3F
(1425) 					waitMotCardTrolley = 1;
    02643 F091      BEQ	0x2656
    02644 9180 00C1 LDS	R24,0xC1
(1426) 				//	workStep = 3;
(1427) 					workStep = 7;
    02646 7E8F      ANDI	R24,0xEF
    02647 9380 00C1 STS	0xC1,R24
(1428) 					break;
    02649 E607      LDI	R16,0x67
(1429) 				case 3:
(1430) 					MotRun(MOT_STORE_CARD_MOVE,86);		
    0264A E013      LDI	R17,3
    0264B 940E A90D CALL	_uart_Printf
    0264D 9180 00C1 LDS	R24,0xC1
(1431) 					waitMotCardTrolley = 1;
    0264F 6180      ORI	R24,0x10
    02650 9380 00C1 STS	0xC1,R24
(1432) 					workStep = 4;
    02652 E082      LDI	R24,2
    02653 9380 1536 STS	liqDetBaseAdc+81,R24
(1433) 					break;
    02655 C26B      RJMP	0x28C1
(1434) 				case 4:
(1435) 					MotRun(MOT_STORE_CARD_MOVE,-86);			
    02656 9100 165F LDS	R16,GetNewTestCard
    02658 940E 1872 CALL	_CalCardStorePos
    0265A 0158      MOVW	R10,R16
(1436) 					waitMotCardTrolley = 1;
    0265B 92B0 1538 STS	liqDetBaseAdc+83,R11
    0265D 92A0 1537 STS	liqDetBaseAdc+82,R10
(1437) 					workStep = 5;
    0265F E08A      LDI	R24,0xA
    02660 838A      STD	Y+2,R24
(1438) 					break;
    02661 E184      LDI	R24,0x14
(1439) 				case 5:
(1440) 					MotRun(MOT_STORE_CARD_MOVE,99);	
    02662 8388      ST	Y,R24
    02663 EC28      LDI	R18,0xC8
    02664 E008      LDI	R16,0x8
    02665 940E 6A9F CALL	_SetMotRunPam
(1441) 					waitMotCardTrolley = 1;
    02667 9120 1537 LDS	R18,liqDetBaseAdc+82
    02669 9130 1538 LDS	R19,liqDetBaseAdc+83
(1442) 					workStep = 6;
    0266B E008      LDI	R16,0x8
    0266C 940E 6A5B CALL	_MotRunTo
(1443) 					break;
    0266E E081      LDI	R24,1
    0266F 9380 1536 STS	liqDetBaseAdc+81,R24
    02671 C24F      RJMP	0x28C1
    02672 9180 1552 LDS	R24,CardStoreOpenState
(1444) 				case 6:
(1445) 					MotRun(MOT_STORE_CARD_MOVE,-150);
(1446) 					waitMotCardTrolley = 1;
    02674 738F      ANDI	R24,0x3F
    02675 F0A9      BEQ	0x268B
(1447) 					workStep = 7;
    02676 9180 00C1 LDS	R24,0xC1
    02678 7E8F      ANDI	R24,0xEF
(1448) 					break;
    02679 9380 00C1 STS	0xC1,R24
(1449) 				case 7:
(1450) 					SetDelayTime(MOT_STORE_CARD_MOVE,10);
    0267B E008      LDI	R16,0x8
    0267C 940E 6A13 CALL	_MotStop
    0267E E607      LDI	R16,0x67
(1451) 					workStep = 8;
    0267F E013      LDI	R17,3
    02680 940E A90D CALL	_uart_Printf
(1452) 					break;
    02682 9180 00C1 LDS	R24,0xC1
(1453) 				case 8:
(1454) 					SetCardTrolleyState(2);
    02684 6180      ORI	R24,0x10
    02685 9380 00C1 STS	0xC1,R24
(1455) 					MotRun(MOT_STORE_CARD_MOVE,320);
    02687 E082      LDI	R24,2
    02688 9380 1536 STS	liqDetBaseAdc+81,R24
    0268A C236      RJMP	0x28C1
(1456) 					waitMotCardTrolley = 1;
    0268B E008      LDI	R16,0x8
    0268C 940E 6A0C CALL	_GetMotState
(1457) 					workStep = 9;
    0268E 2F60      MOV	R22,R16
    0268F 3001      CPI	R16,1
    02690 F009      BEQ	0x2692
(1458) 					break;
    02691 C22F      RJMP	0x28C1
(1459) 				case 9:
(1460) 					SetCardTrolleyState(0);
    02692 E083      LDI	R24,3
    02693 9380 1536 STS	liqDetBaseAdc+81,R24
(1461) 					workStep = 0;
    02695 C22B      RJMP	0x28C1
    02696 9180 1552 LDS	R24,CardStoreOpenState
(1462) 					mainStep = 5;
    02698 738F      ANDI	R24,0x3F
    02699 F009      BEQ	0x269B
    0269A C226      RJMP	0x28C1
(1463) 					break;
(1464) 				default:
(1465) 					break;
(1466) 			}
(1467) 			break;
    0269B E008      LDI	R16,0x8
(1468) 		case 5:	// 运行到离开片仓位置
(1469) 			switch(workStep)
    0269C 940E 2DAD CALL	_GetMotPositionOfStep
    0269E 01B8      MOVW	R22,R16
    0269F 01AB      MOVW	R20,R22
    026A0 5F4B      SUBI	R20,0xFB
    026A1 4F5F      SBCI	R21,0xFF
    026A2 9020 1537 LDS	R2,liqDetBaseAdc+82
    026A4 9030 1538 LDS	R3,liqDetBaseAdc+83
    026A6 1542      CP	R20,R2
    026A7 0553      CPC	R21,R3
    026A8 F46C      BGE	0x26B6
    026A9 0191      MOVW	R18,R2
    026AA E008      LDI	R16,0x8
    026AB 940E 6A5B CALL	_MotRunTo
    026AD E021      LDI	R18,1
    026AE E030      LDI	R19,0
    026AF E008      LDI	R16,0x8
    026B0 940E 97B7 CALL	_SetDelayTime
    026B2 E081      LDI	R24,1
    026B3 9380 1536 STS	liqDetBaseAdc+81,R24
    026B5 C20B      RJMP	0x28C1
    026B6 E083      LDI	R24,3
    026B7 9380 1536 STS	liqDetBaseAdc+81,R24
    026B9 C207      RJMP	0x28C1
    026BA E004      LDI	R16,4
    026BB 940E 6AFA CALL	_MotInitCheck
    026BD E025      LDI	R18,5
    026BE E030      LDI	R19,0
    026BF E008      LDI	R16,0x8
    026C0 940E 97B7 CALL	_SetDelayTime
    026C2 2422      CLR	R2
    026C3 9220 1536 STS	liqDetBaseAdc+81,R2
    026C5 E083      LDI	R24,3
    026C6 9380 1535 STS	liqDetBaseAdc+80,R24
    026C8 C1F8      RJMP	0x28C1
    026C9 9160 1536 LDS	R22,liqDetBaseAdc+81
    026CB 2777      CLR	R23
    026CC 3060      CPI	R22,0
    026CD 0767      CPC	R22,R23
    026CE F409      BNE	0x26D0
    026CF C02E      RJMP	0x26FE
    026D0 3061      CPI	R22,1
(1470) 			{
(1471) 				case 0:
(1472) 					SetMotRunPam(MOT_STORE_CARD_MOVE,200,20,CURRENT_STORE_MOVE);
    026D1 E0E0      LDI	R30,0
    026D2 077E      CPC	R23,R30
    026D3 F409      BNE	0x26D5
    026D4 C03E      RJMP	0x2713
    026D5 3062      CPI	R22,2
    026D6 E0E0      LDI	R30,0
    026D7 077E      CPC	R23,R30
    026D8 F409      BNE	0x26DA
(1473) 					if(CardStoreOpenState & 0x3f)
    026D9 C040      RJMP	0x271A
    026DA 3063      CPI	R22,3
    026DB E0E0      LDI	R30,0
    026DC 077E      CPC	R23,R30
(1474) 					{	
(1475) 						Uart0ReUnable;
    026DD F409      BNE	0x26DF
    026DE C04E      RJMP	0x272D
    026DF 3064      CPI	R22,4
    026E0 E0E0      LDI	R30,0
    026E1 077E      CPC	R23,R30
(1476) 						uart_Printf("!3527\r\n");
    026E2 F409      BNE	0x26E4
    026E3 C055      RJMP	0x2739
    026E4 3065      CPI	R22,5
    026E5 E0E0      LDI	R30,0
(1477) 						Uart0ReEnable;
    026E6 077E      CPC	R23,R30
    026E7 F409      BNE	0x26E9
    026E8 C05C      RJMP	0x2745
    026E9 3066      CPI	R22,6
    026EA E0E0      LDI	R30,0
(1478) 						workStep = 2;
    026EB 077E      CPC	R23,R30
    026EC F409      BNE	0x26EE
    026ED C063      RJMP	0x2751
(1479) 						break;
    026EE 3067      CPI	R22,7
(1480) 					}
(1481) 					MotRunTo(MOT_STORE_CARD_MOVE,0);	
    026EF E0E0      LDI	R30,0
    026F0 077E      CPC	R23,R30
    026F1 F409      BNE	0x26F3
    026F2 C06A      RJMP	0x275D
    026F3 3068      CPI	R22,0x8
(1482) 					workStep = 1;
    026F4 E0E0      LDI	R30,0
    026F5 077E      CPC	R23,R30
    026F6 F409      BNE	0x26F8
(1483) 					break;
    026F7 C06E      RJMP	0x2766
(1484) 				case 1:
(1485) 					if(CardStoreOpenState & 0x3f)
    026F8 3069      CPI	R22,0x9
    026F9 E0E0      LDI	R30,0
    026FA 077E      CPC	R23,R30
    026FB F409      BNE	0x26FD
(1486) 					{
(1487) 						MotStop(MOT_STORE_CARD_MOVE);
    026FC C078      RJMP	0x2775
    026FD C1C3      RJMP	0x28C1
    026FE E001      LDI	R16,1
(1488) 						Uart0ReUnable;
    026FF 940E 18A0 CALL	_SetCardTrolleyState
    02701 E08A      LDI	R24,0xA
    02702 838A      STD	Y+2,R24
    02703 8388      ST	Y,R24
(1489) 						uart_Printf("!3527\r\n");
    02704 E120      LDI	R18,0x10
    02705 E008      LDI	R16,0x8
    02706 940E 6A9F CALL	_SetMotRunPam
(1490) 						Uart0ReEnable;
    02708 E92E      LDI	R18,0x9E
    02709 EF3F      LDI	R19,0xFF
    0270A E008      LDI	R16,0x8
    0270B 940E 6A2C CALL	_MotRun
(1491) 						workStep = 2;
    0270D E081      LDI	R24,1
    0270E 9380 153A STS	liqDetBaseAdc+85,R24
(1492) 					}
    02710 9380 1536 STS	liqDetBaseAdc+81,R24
(1493) 					else
(1494) 					{	
(1495) 						if(GetMotState(MOT_STORE_CARD_MOVE)!=STA_SLAVE_FREE)
    02712 C1AE      RJMP	0x28C1
    02713 2700      CLR	R16
    02714 940E 18A0 CALL	_SetCardTrolleyState
    02716 E082      LDI	R24,2
(1496) 							break;
    02717 9380 1536 STS	liqDetBaseAdc+81,R24
(1497) 						else
(1498) 						{
(1499) 							workStep = 4;
    02719 C1A7      RJMP	0x28C1
    0271A E08A      LDI	R24,0xA
(1500) 							SetMotRunPam(MOT_STORE_CARD_MOVE,50,5,CURRENT_STORE_MOVE);
    0271B 838A      STD	Y+2,R24
    0271C 8388      ST	Y,R24
    0271D E624      LDI	R18,0x64
    0271E E008      LDI	R16,0x8
    0271F 940E 6A9F CALL	_SetMotRunPam
    02721 EC2F      LDI	R18,0xCF
    02722 EF3E      LDI	R19,0xFE
(1501) 						}
(1502) 					}
(1503) 					break;
    02723 E008      LDI	R16,0x8
(1504) 				case 2:		
(1505) 					if((CardStoreOpenState & 0x3f) == 0)
    02724 940E 6A2C CALL	_MotRun
    02726 E081      LDI	R24,1
    02727 9380 153A STS	liqDetBaseAdc+85,R24
(1506) 					{	
(1507) 						siTmp = GetMotPositionOfStep(MOT_STORE_CARD_MOVE);
    02729 E087      LDI	R24,7
    0272A 9380 1536 STS	liqDetBaseAdc+81,R24
    0272C C194      RJMP	0x28C1
    0272D E526      LDI	R18,0x56
(1508) 						if(siTmp > 0)
    0272E E030      LDI	R19,0
    0272F E008      LDI	R16,0x8
    02730 940E 6A2C CALL	_MotRun
    02732 E081      LDI	R24,1
(1509) 						{
(1510) 							MotRunTo(MOT_STORE_CARD_MOVE,0);
    02733 9380 153A STS	liqDetBaseAdc+85,R24
    02735 E084      LDI	R24,4
    02736 9380 1536 STS	liqDetBaseAdc+81,R24
(1511) 							SetDelayTime(MOT_STORE_CARD_MOVE,1);
    02738 C188      RJMP	0x28C1
    02739 EA2A      LDI	R18,0xAA
    0273A EF3F      LDI	R19,0xFF
    0273B E008      LDI	R16,0x8
    0273C 940E 6A2C CALL	_MotRun
(1512) 							workStep = 1;
    0273E E081      LDI	R24,1
    0273F 9380 153A STS	liqDetBaseAdc+85,R24
(1513) 						}
    02741 E085      LDI	R24,5
    02742 9380 1536 STS	liqDetBaseAdc+81,R24
(1514) 						else
(1515) 						{
(1516) 							workStep = 4;
(1517) 						}
(1518) 					}
(1519) 					break;
    02744 C17C      RJMP	0x28C1
(1520) 				case 4:
(1521) 						SetMotRunPam(MOT_STORE_CARD_MOVE,50,5,CURRENT_STORE_MOVE);
    02745 E623      LDI	R18,0x63
    02746 E030      LDI	R19,0
    02747 E008      LDI	R16,0x8
    02748 940E 6A2C CALL	_MotRun
    0274A E081      LDI	R24,1
    0274B 9380 153A STS	liqDetBaseAdc+85,R24
(1522) 						MotRunTo(MOT_STORE_CARD_MOVE,70);
    0274D E086      LDI	R24,6
    0274E 9380 1536 STS	liqDetBaseAdc+81,R24
    02750 C170      RJMP	0x28C1
    02751 E62A      LDI	R18,0x6A
(1523) 						waitMotCardTrolley = 1;
    02752 EF3F      LDI	R19,0xFF
    02753 E008      LDI	R16,0x8
    02754 940E 6A2C CALL	_MotRun
(1524) 						workStep = 5;
    02756 E081      LDI	R24,1
    02757 9380 153A STS	liqDetBaseAdc+85,R24
(1525) 						break;
    02759 E087      LDI	R24,7
    0275A 9380 1536 STS	liqDetBaseAdc+81,R24
    0275C C164      RJMP	0x28C1
    0275D E02A      LDI	R18,0xA
    0275E E030      LDI	R19,0
    0275F E008      LDI	R16,0x8
    02760 940E 97B7 CALL	_SetDelayTime
(1526) 				case 5:
(1527) 						SetMotRunPam(MOT_CARD_LOAD,30,5,CURRENT_CARD_LOAD);
(1528) 						MotRunTo(MOT_CARD_LOAD,55); 
    02762 E088      LDI	R24,0x8
    02763 9380 1536 STS	liqDetBaseAdc+81,R24
    02765 C15B      RJMP	0x28C1
(1529) 						waitMotCardLoad = 1;
    02766 E002      LDI	R16,2
    02767 940E 18A0 CALL	_SetCardTrolleyState
(1530) 						workStep = 6;
    02769 E420      LDI	R18,0x40
    0276A E031      LDI	R19,1
    0276B E008      LDI	R16,0x8
(1531) 						SetDelayTime(MOT_STORE_CARD_MOVE,3);
    0276C 940E 6A2C CALL	_MotRun
    0276E E081      LDI	R24,1
    0276F 9380 153A STS	liqDetBaseAdc+85,R24
(1532) 						break;
    02771 E089      LDI	R24,0x9
(1533) 				case 6:
(1534) 						MotRunTo(MOT_CARD_LOAD,20);
    02772 9380 1536 STS	liqDetBaseAdc+81,R24
    02774 C14C      RJMP	0x28C1
    02775 2700      CLR	R16
    02776 940E 18A0 CALL	_SetCardTrolleyState
(1535) 						waitMotCardLoad = 1;
    02778 2422      CLR	R2
    02779 9220 1536 STS	liqDetBaseAdc+81,R2
(1536) 						//workStep = 17;
(1537) 						workStep = 7;
    0277B E085      LDI	R24,5
    0277C 9380 1535 STS	liqDetBaseAdc+80,R24
(1538) 						SetDelayTime(MOT_STORE_CARD_MOVE,3);
    0277E C142      RJMP	0x28C1
    0277F 9160 1536 LDS	R22,liqDetBaseAdc+81
    02781 2777      CLR	R23
(1539) 						break;
    02782 3060      CPI	R22,0
(1540) 				/*
(1541) 				case 17:
(1542) 						MotRunTo(MOT_STORE_CARD_MOVE,0);
(1543) 						workStep = 18;
(1544) 						break;
(1545) 				case 18:
(1546) 						SetDelayTime(MOT_STORE_CARD_MOVE,3);
(1547) 						workStep = 7;
(1548) 						break;
(1549) 				*/
(1550) 				case 7:
(1551) 						siTmp = GetCardScanfPos(); 
    02783 0767      CPC	R22,R23
    02784 F409      BNE	0x2786
    02785 C02E      RJMP	0x27B4
(1552) 						MotRunTo(MOT_STORE_CARD_MOVE,(unsigned int)siTmp);
    02786 3061      CPI	R22,1
    02787 E0E0      LDI	R30,0
    02788 077E      CPC	R23,R30
    02789 F409      BNE	0x278B
(1553) 				//		MotRunTo(MOT_STORE_CARD_MOVE,305);
(1554) 						waitMotCardTrolley = 1;
    0278A C050      RJMP	0x27DB
    0278B 3062      CPI	R22,2
    0278C E0E0      LDI	R30,0
(1555) 						workStep = 8;
    0278D 077E      CPC	R23,R30
    0278E F409      BNE	0x2790
    0278F C077      RJMP	0x2807
(1556) 						break;
    02790 3064      CPI	R22,4
(1557) 				case 8:
(1558) 						SetMotRunPam(MOT_CARD_LOAD,140,10,CURRENT_CARD_LOAD);
    02791 E0E0      LDI	R30,0
    02792 077E      CPC	R23,R30
    02793 F409      BNE	0x2795
    02794 C093      RJMP	0x2828
    02795 3065      CPI	R22,5
    02796 E0E0      LDI	R30,0
    02797 077E      CPC	R23,R30
    02798 F409      BNE	0x279A
(1559) 						MotInitCheck(MOT_CARD_LOAD);
    02799 C0A2      RJMP	0x283C
    0279A 3066      CPI	R22,6
    0279B E0E0      LDI	R30,0
(1560) 						workStep = 9;
    0279C 077E      CPC	R23,R30
    0279D F409      BNE	0x279F
    0279E C0B6      RJMP	0x2855
(1561) 						break;
    0279F 3067      CPI	R22,7
(1562) 				case 9:
(1563) 						Uart0ReUnable;
    027A0 E0E0      LDI	R30,0
    027A1 077E      CPC	R23,R30
    027A2 F409      BNE	0x27A4
    027A3 C0C2      RJMP	0x2866
    027A4 3068      CPI	R22,0x8
(1564) 						uart_Printf("%s $%4d\r\n",strM3146,NewTestInfo.cardStoreNum);
    027A5 E0E0      LDI	R30,0
    027A6 077E      CPC	R23,R30
    027A7 F409      BNE	0x27A9
    027A8 C0CB      RJMP	0x2874
    027A9 3069      CPI	R22,0x9
    027AA E0E0      LDI	R30,0
    027AB 077E      CPC	R23,R30
    027AC F409      BNE	0x27AE
    027AD C0D5      RJMP	0x2883
    027AE 306A      CPI	R22,0xA
    027AF E0E0      LDI	R30,0
(1565) 						Uart0ReEnable;
    027B0 077E      CPC	R23,R30
    027B1 F409      BNE	0x27B3
    027B2 C0EE      RJMP	0x28A1
    027B3 C10D      RJMP	0x28C1
    027B4 E08A      LDI	R24,0xA
(1566) 						SetDelayTime(MOT_STORE_CARD_MOVE,50);
    027B5 838A      STD	Y+2,R24
    027B6 E184      LDI	R24,0x14
    027B7 8388      ST	Y,R24
    027B8 EC28      LDI	R18,0xC8
    027B9 E008      LDI	R16,0x8
(1567) 						workStep = 10;
    027BA 940E 6A9F CALL	_SetMotRunPam
    027BC 9180 1552 LDS	R24,CardStoreOpenState
(1568) 						break;
    027BE 738F      ANDI	R24,0x3F
    027BF F091      BEQ	0x27D2
    027C0 9180 00C1 LDS	R24,0xC1
(1569) 				case 10:
(1570) 						workStep = 0;
(1571) 						mainStep = 0;
    027C2 7E8F      ANDI	R24,0xEF
(1572) 						inWork = 0;
    027C3 9380 00C1 STS	0xC1,R24
(1573) 						CardStoreOpenLook = 0;
    027C5 E50F      LDI	R16,0x5F
    027C6 E013      LDI	R17,3
(1574) 						Uart0ReUnable;
    027C7 940E A90D CALL	_uart_Printf
    027C9 9180 00C1 LDS	R24,0xC1
    027CB 6180      ORI	R24,0x10
(1575) 						uart_Printf("%s $%4d\r\n",strM4199,NewTestInfo.cardStoreNum);
    027CC 9380 00C1 STS	0xC1,R24
    027CE E082      LDI	R24,2
    027CF 9380 1536 STS	liqDetBaseAdc+81,R24
    027D1 C0EF      RJMP	0x28C1
    027D2 2722      CLR	R18
    027D3 2733      CLR	R19
    027D4 E008      LDI	R16,0x8
    027D5 940E 6A5B CALL	_MotRunTo
(1576) 						Uart0ReEnable;
    027D7 E081      LDI	R24,1
    027D8 9380 1536 STS	liqDetBaseAdc+81,R24
    027DA C0E6      RJMP	0x28C1
    027DB 9180 1552 LDS	R24,CardStoreOpenState
(1577) 						return 1;
    027DD 738F      ANDI	R24,0x3F
(1578) 				}
(1579) 		}
(1580) 		return 0;
    027DE F0A9      BEQ	0x27F4
    027DF E008      LDI	R16,0x8
    027E0 940E 6A13 CALL	_MotStop
_SetCardScanf:
  num                  --> R10
    027E2 9180 00C1 LDS	R24,0xC1
    027E4 7E8F      ANDI	R24,0xEF
(1581) }
(1582) 
(1583) void SetCardScanf(unsigned char num)
(1584) {
(1585) 	if(num == 0)
    027E5 9380 00C1 STS	0xC1,R24
(1586) 		WaitPhotoFlag = 0;
    027E7 E50F      LDI	R16,0x5F
    027E8 E013      LDI	R17,3
    027E9 940E A90D CALL	_uart_Printf
(1587) 	else
(1588) 		WaitPhotoFlag = 1;
    027EB 9180 00C1 LDS	R24,0xC1
    027ED 6180      ORI	R24,0x10
(1589) 	Uart0ReUnable;
    027EE 9380 00C1 STS	0xC1,R24
    027F0 E082      LDI	R24,2
    027F1 9380 1536 STS	liqDetBaseAdc+81,R24
(1590) 	uart_Printf("%s $%4d\r\n",strM3123,WaitPhotoFlag);
    027F3 C0CD      RJMP	0x28C1
    027F4 E008      LDI	R16,0x8
    027F5 940E 6A0C CALL	_GetMotState
    027F7 2F60      MOV	R22,R16
    027F8 3001      CPI	R16,1
    027F9 F009      BEQ	0x27FB
    027FA C0C6      RJMP	0x28C1
    027FB E084      LDI	R24,4
    027FC 9380 1536 STS	liqDetBaseAdc+81,R24
(1591) 	Uart0ReEnable;
    027FE E08A      LDI	R24,0xA
    027FF 838A      STD	Y+2,R24
    02800 E085      LDI	R24,5
    02801 8388      ST	Y,R24
    02802 E322      LDI	R18,0x32
    02803 E008      LDI	R16,0x8
    02804 940E 6A9F CALL	_SetMotRunPam
(1592) }
(1593) 
(1594) void SetReCardScanf(const unsigned char num)
(1595) {
(1596) 	ReScanfFlag = num;
_SetReCardScanf:
  num                  --> R16
    02806 C0BA      RJMP	0x28C1
    02807 9180 1552 LDS	R24,CardStoreOpenState
(1597) }
(1598) 
(1599) unsigned char GetReCardScanf(void)
(1600) {
(1601) 	return ReScanfFlag;
_GetReCardScanf:
    02809 738F      ANDI	R24,0x3F
    0280A F009      BEQ	0x280C
    0280B C0B5      RJMP	0x28C1
_SetCardScanfPos:
  i                    --> Y,+2
  n                    --> Y,+3
    0280C E008      LDI	R16,0x8
    0280D 940E 2DAD CALL	_GetMotPositionOfStep
(1602) }
(1603) 
(1604) 
(1605) unsigned int SetCardScanfPos(signed char n)
(1606) {
(1607) 	signed char i;
(1608) 	if(n == 0)
    0280F 0158      MOVW	R10,R16
    02810 01A5      MOVW	R20,R10
    02811 2422      CLR	R2
(1609) 	{
(1610) 		EEPROM_READ(EEP_ADD_CARDSCANF_POS, i);		// 重新读取写入的设置值
    02812 2433      CLR	R3
    02813 1620      CP	R2,R16
    02814 0631      CPC	R3,R17
    02815 F474      BGE	0x2824
    02816 2722      CLR	R18
    02817 2733      CLR	R19
    02818 E008      LDI	R16,0x8
    02819 940E 6A5B CALL	_MotRunTo
    0281B E021      LDI	R18,1
    0281C E030      LDI	R19,0
(1611) 		return (_POS_CARD_SCANF + (signed int)i);
    0281D E008      LDI	R16,0x8
    0281E 940E 97B7 CALL	_SetDelayTime
    02820 E081      LDI	R24,1
    02821 9380 1536 STS	liqDetBaseAdc+81,R24
    02823 C09D      RJMP	0x28C1
(1612) 	}
(1613) 	else
(1614) 	{
(1615) 		if(n <= 100 && n >= -50)	// 参数范围判断
    02824 E084      LDI	R24,4
    02825 9380 1536 STS	liqDetBaseAdc+81,R24
    02827 C099      RJMP	0x28C1
    02828 E08A      LDI	R24,0xA
    02829 838A      STD	Y+2,R24
    0282A E085      LDI	R24,5
(1616) 		{
(1617) 			EEPROM_WRITE(EEP_ADD_CARDSCANF_POS, n);
    0282B 8388      ST	Y,R24
    0282C E322      LDI	R18,0x32
    0282D E008      LDI	R16,0x8
    0282E 940E 6A9F CALL	_SetMotRunPam
    02830 E426      LDI	R18,0x46
    02831 E030      LDI	R19,0
    02832 E008      LDI	R16,0x8
    02833 940E 6A5B CALL	_MotRunTo
    02835 E081      LDI	R24,1
(1618) 		}
(1619) 		EEPROM_READ(EEP_ADD_CARDSCANF_POS, i);		// 重新读取写入的设置值
    02836 9380 153A STS	liqDetBaseAdc+85,R24
    02838 E085      LDI	R24,5
    02839 9380 1536 STS	liqDetBaseAdc+81,R24
    0283B C085      RJMP	0x28C1
    0283C E084      LDI	R24,4
    0283D 838A      STD	Y+2,R24
    0283E E085      LDI	R24,5
    0283F 8388      ST	Y,R24
    02840 E12E      LDI	R18,0x1E
(1620) 		if(i > 100 || i < -50)		// 保存的值有异常
    02841 E004      LDI	R16,4
    02842 940E 6A9F CALL	_SetMotRunPam
    02844 E327      LDI	R18,0x37
    02845 E030      LDI	R19,0
    02846 E004      LDI	R16,4
    02847 940E 6A5B CALL	_MotRunTo
(1621) 		{
(1622) 			i = 0;
    02849 E081      LDI	R24,1
(1623) 			EEPROM_WRITE(EEP_ADD_CARDSCANF_POS, i);	// 清空保存值
    0284A 9380 153B STS	liqDetBaseAdc+86,R24
    0284C E086      LDI	R24,6
    0284D 9380 1536 STS	liqDetBaseAdc+81,R24
    0284F E023      LDI	R18,3
    02850 E030      LDI	R19,0
    02851 E008      LDI	R16,0x8
    02852 940E 97B7 CALL	_SetDelayTime
    02854 C06C      RJMP	0x28C1
(1624) 		}
(1625) 		return (_POS_CARD_SCANF + (signed int)i);
    02855 E124      LDI	R18,0x14
    02856 E030      LDI	R19,0
    02857 E004      LDI	R16,4
    02858 940E 6A5B CALL	_MotRunTo
    0285A E081      LDI	R24,1
    0285B 9380 153B STS	liqDetBaseAdc+86,R24
_GetCardScanfPos:
  i                    --> Y,+2
    0285D E087      LDI	R24,7
(1626) 	}
(1627) }
(1628) 
(1629) unsigned int GetCardScanfPos(void)
(1630) {
(1631) 	signed char i;
(1632) 	EEPROM_READ(EEP_ADD_CARDSCANF_POS, i);		// 重新读取写入的设置值
    0285E 9380 1536 STS	liqDetBaseAdc+81,R24
    02860 E023      LDI	R18,3
    02861 E030      LDI	R19,0
    02862 E008      LDI	R16,0x8
    02863 940E 97B7 CALL	_SetDelayTime
    02865 C05B      RJMP	0x28C1
    02866 D0D9      RCALL	_GetCardScanfPos
    02867 0158      MOVW	R10,R16
    02868 01A5      MOVW	R20,R10
(1633) 	if(i > 100 || i < -50)		// 保存的值有异常
    02869 019A      MOVW	R18,R20
    0286A E008      LDI	R16,0x8
    0286B 940E 6A5B CALL	_MotRunTo
    0286D E081      LDI	R24,1
    0286E 9380 153A STS	liqDetBaseAdc+85,R24
(1634) 	{
(1635) 		i = 0;
    02870 E088      LDI	R24,0x8
    02871 9380 1536 STS	liqDetBaseAdc+81,R24
(1636) 		EEPROM_WRITE(EEP_ADD_CARDSCANF_POS, i);
    02873 C04D      RJMP	0x28C1
    02874 E084      LDI	R24,4
    02875 838A      STD	Y+2,R24
    02876 E08A      LDI	R24,0xA
    02877 8388      ST	Y,R24
    02878 E82C      LDI	R18,0x8C
    02879 E004      LDI	R16,4
    0287A 940E 6A9F CALL	_SetMotRunPam
    0287C E004      LDI	R16,4
(1637) 	}
(1638) 	return (_POS_CARD_SCANF + (signed char)i);
    0287D 940E 6AFA CALL	_MotInitCheck
    0287F E089      LDI	R24,0x9
    02880 9380 1536 STS	liqDetBaseAdc+81,R24
    02882 C03E      RJMP	0x28C1
    02883 9180 00C1 LDS	R24,0xC1
_CardScanfPosCheck:
  Pos                  --> R10
    02885 7E8F      ANDI	R24,0xEF
    02886 9380 00C1 STS	0xC1,R24
(1639) }
(1640) 
(1641) unsigned char CardScanfPosCheck(void)
(1642) {
(1643) 	static unsigned char workStep;
(1644) 	static unsigned char waitMotCardTrolley;
(1645) 	unsigned int Pos;
(1646) 	if(WaitDelayTime(MOT_STORE_CARD_MOVE))		return 0;
    02888 9020 1667 LDS	R2,i
    0288A 2433      CLR	R3
    0288B 8239      STD	Y+1,R3
    0288C 8228      ST	Y,R2
    0288D EA29      LDI	R18,0xA9
    0288E E130      LDI	R19,0x10
(1647) 	if(waitMotCardTrolley){	if(GetMotState(MOT_STORE_CARD_MOVE) != STA_SLAVE_FREE)	return 0;waitMotCardTrolley = 0;}
    0288F ED00      LDI	R16,0xD0
    02890 E013      LDI	R17,3
    02891 940E A90D CALL	_uart_Printf
    02893 9180 00C1 LDS	R24,0xC1
    02895 6180      ORI	R24,0x10
    02896 9380 00C1 STS	0xC1,R24
    02898 E322      LDI	R18,0x32
    02899 E030      LDI	R19,0
    0289A E008      LDI	R16,0x8
    0289B 940E 97B7 CALL	_SetDelayTime
(1648) 	switch(workStep)
    0289D E08A      LDI	R24,0xA
    0289E 9380 1536 STS	liqDetBaseAdc+81,R24
    028A0 C020      RJMP	0x28C1
    028A1 2422      CLR	R2
    028A2 9220 1536 STS	liqDetBaseAdc+81,R2
    028A4 9220 1535 STS	liqDetBaseAdc+80,R2
    028A6 9220 1539 STS	liqDetBaseAdc+84,R2
    028A8 9220 02E0 STS	CardStoreOpenLook,R2
    028AA 9180 00C1 LDS	R24,0xC1
    028AC 7E8F      ANDI	R24,0xEF
    028AD 9380 00C1 STS	0xC1,R24
    028AF 9020 1667 LDS	R2,i
(1649) 	{
(1650) 		case 0:
(1651) 				SetMotRunPam(MOT_STORE_CARD_MOVE,200,20,CURRENT_STORE_MOVE);
    028B1 2433      CLR	R3
    028B2 8239      STD	Y+1,R3
    028B3 8228      ST	Y,R2
    028B4 EA26      LDI	R18,0xA6
    028B5 E13A      LDI	R19,0x1A
    028B6 ED00      LDI	R16,0xD0
    028B7 E013      LDI	R17,3
(1652) 				MotRunTo(MOT_STORE_CARD_MOVE,0);	
    028B8 940E A90D CALL	_uart_Printf
    028BA 9180 00C1 LDS	R24,0xC1
    028BC 6180      ORI	R24,0x10
(1653) 				waitMotCardTrolley = 1;
    028BD 9380 00C1 STS	0xC1,R24
    028BF E001      LDI	R16,1
(1654) 				workStep = 1;
    028C0 C001      RJMP	0x28C2
    028C1 2700      CLR	R16
(1655) 				SetDelayTime(MOT_STORE_CARD_MOVE,5);
    028C2 9623      ADIW	R28,3
    028C3 940C AE9E JMP	pop_xgsetF00C
_SetCardScanf:
    028C5 92AA      ST	-Y,R10
    028C6 2EA0      MOV	R10,R16
(1656) 				break;
    028C7 9722      SBIW	R28,2
(1657) 		case 1:
(1658) 				Pos = GetCardScanfPos();
    028C8 20AA      TST	R10
    028C9 F421      BNE	0x28CE
(1659) 				//SetMotRunPam(MOT_STORE_CARD_MOVE,50,5,CURRENT_STORE_MOVE);
(1660) 				SetMotRunPam(MOT_STORE_CARD_MOVE,250,20,CURRENT_STORE_MOVE);
    028CA 2422      CLR	R2
    028CB 9220 02DC STS	WaitPhotoFlag,R2
    028CD C003      RJMP	0x28D1
    028CE E081      LDI	R24,1
    028CF 9380 02DC STS	WaitPhotoFlag,R24
    028D1 9180 00C1 LDS	R24,0xC1
(1661) 				MotRunTo(MOT_STORE_CARD_MOVE,Pos);	
    028D3 7E8F      ANDI	R24,0xEF
    028D4 9380 00C1 STS	0xC1,R24
(1662) 				waitMotCardTrolley = 1;
    028D6 9020 02DC LDS	R2,WaitPhotoFlag
    028D8 2433      CLR	R3
(1663) 				workStep = 2;
    028D9 8239      STD	Y+1,R3
    028DA 8228      ST	Y,R2
    028DB E82B      LDI	R18,0x8B
(1664) 				break;
    028DC E03E      LDI	R19,0xE
(1665) 		case 2:
(1666) 				SetDelayTime(MOT_STORE_CARD_MOVE,5);
    028DD ED00      LDI	R16,0xD0
    028DE E013      LDI	R17,3
    028DF 940E A90D CALL	_uart_Printf
    028E1 9180 00C1 LDS	R24,0xC1
(1667) 				workStep = 3;
    028E3 6180      ORI	R24,0x10
    028E4 9380 00C1 STS	0xC1,R24
(1668) 				break;
    028E6 9622      ADIW	R28,2
    028E7 90A9      LD	R10,Y+
    028E8 9508      RET
(1669) 		case 3:
(1670) 				workStep = 0;
(1671) 				return 1;
_SetReCardScanf:
    028E9 9300 02DD STS	ReScanfFlag,R16
(1672) 				break;
(1673) 		default:break;
(1674) 	}
(1675) 	return 0;
    028EB 9508      RET
_GetReCardScanf:
    028EC 9100 02DD LDS	R16,ReScanfFlag
    028EE 9508      RET
FILE: D:\Work\主控软件\2032A2~1\CommandString.c
(0001) 
(0002) /*
(0003) 1.命令字符串定义
(0004) 2.终端输入命令解析提取
(0005) */
(0006) /*
(0007) 输入:void CommandExplain(unsigned char c)	在串口输入中断中调用
(0008) 输出:CONTROL_CMD ControlCmd					任务调度中读取并处理
(0009) */
(0010) 
(0011) #include "Common.h"
(0012) /*
(0013) typedef struct _HT_COMMAND_STRING{
(0014) 	_CONST char * pChar;
(0015) 	_CONST unsigned int indx;
(0016) }HTCMD_STR;
(0017) 
(0018) typedef struct _HTCOMMAND_BUF{
(0019) 	unsigned char itemPnt;			// 当前条目指针
(0020) 	unsigned char charPnt;			// 当前条目字符指针
(0021) 	unsigned char cmdStr[35];		// 命令字符串
(0022) 	unsigned char pamStr[6][10];	// 参数
(0023) }HTCOMMAND_BUF;
(0024) */
(0025) typedef struct _UICOMMAND_BUF{
(0026) 	unsigned char itemPnt;			// 当前接收的项目号
(0027) 	unsigned char charPnt;			// 接收指针
(0028) 	unsigned char cmdStr[10];		// 命令名称字符串
(0029) }UICOMMAND_BUF;
(0030) /*
(0031) // 启动
(0032) _CONST char CStr0000[] 		= "echo";		// 回显开关
(0033) _CONST HTCMD_STR HTCmd0000 	= {CStr0000, 0};
(0034) _CONST char CStr0001[] 		= "startrap01";		// 启动仪器
(0035) _CONST HTCMD_STR HTCmd0001 	= {CStr0001, 1};
(0036) _CONST char CStr0002[] 		= "setwork";		// 设置工作进程
(0037) _CONST HTCMD_STR HTCmd0002 	= {CStr0002, 2};
(0038) _CONST char CStr0003[] 		= "askwork";		// 询问当前工作进程
(0039) _CONST HTCMD_STR HTCmd0003 	= {CStr0003, 3};
(0040) _CONST char CStr0004[] 		= "quit";		// 退出当前工作进程
(0041) _CONST HTCMD_STR HTCmd0004 	= {CStr0004, 4};
(0042) _CONST char CStr0005[] 		= "suspend";				// 	暂停工作开关
(0043) _CONST HTCMD_STR HTCmd0005 	= {CStr0005, 5};
(0044) _CONST char CStr0010[] 		= "storedooropen";		// 开启片仓
(0045) _CONST HTCMD_STR HTCmd0010 	= {CStr0010, 10};
(0046) _CONST char CStr0011[] 		= "getstorehumiture";	// 读取片仓温湿度
(0047) _CONST HTCMD_STR HTCmd0011 	= {CStr0011, 11};
(0048) _CONST char CStr0099[] 		= "restart";	// 重起
(0049) _CONST HTCMD_STR HTCmd0099 	= {CStr0099, 99};
(0050) 
(0051) _CONST HTCMD_STR * CmdString0[] = {
(0052) 	&HTCmd0000, &HTCmd0001, &HTCmd0002, &HTCmd0003, &HTCmd0004, &HTCmd0005, &HTCmd0010, &HTCmd0011, &HTCmd0099, 0
(0053) };
(0054) // 机械自检
(0055) _CONST HTCMD_STR * CmdString1[] = {
(0056) 	&HTCmd0003, &HTCmd0004, &HTCmd0005, &HTCmd0099, 0
(0057) };
(0058) // 液路自检
(0059) _CONST HTCMD_STR * CmdString2[] = {
(0060) 	&HTCmd0003, &HTCmd0004, &HTCmd0005, &HTCmd0099, 0
(0061) };
(0062) // 测试
(0063) _CONST char CStr3001[] 		= "settestparamter";	// 设置测试参数
(0064) _CONST HTCMD_STR HTCmd3001 	= {CStr3001, 3001};
(0065) _CONST char CStr3002[] 		= "setworkstore";		// 设置当前取片卡仓号
(0066) _CONST HTCMD_STR HTCmd3002 	= {CStr3002, 3002};
(0067) _CONST char CStr3003[] 		= "setdiluteratio";		// 设置稀释比例
(0068) _CONST HTCMD_STR HTCmd3003 	= {CStr3003, 3003};
(0069) _CONST char CStr3004[] 		= "setreadtime1";		// 设置读数时间1
(0070) _CONST HTCMD_STR HTCmd3004 	= {CStr3004, 3004};
(0071) _CONST char CStr3005[] 		= "setreadtime2";		// 设置读数时间2
(0072) _CONST HTCMD_STR HTCmd3005 	= {CStr3005, 3005};
(0073) _CONST char CStr3006[] 		= "setreadmodule";		// 设置读数模块
(0074) _CONST HTCMD_STR HTCmd3006 	= {CStr3006, 3006};
(0075) _CONST char CStr3007[] 		= "setdropvolume";		// 设置滴液容量
(0076) _CONST HTCMD_STR HTCmd3007 	= {CStr3007, 3007};
(0077) _CONST char CStr3010[] 		= "setautotest";		// 设置连续测试周期
(0078) _CONST HTCMD_STR HTCmd3010 	= {CStr3010, 3010};
(0079) _CONST char CStr3011[] 		= "askstorestate";		// 查询片仓状态
(0080) _CONST HTCMD_STR HTCmd3011 	= {CStr3011, 3011};
(0081) _CONST char CStr3012[] 		= "setlamplum";	// 
(0082) _CONST HTCMD_STR HTCmd3012 	= {CStr3012, 3012};
(0083) _CONST char CStr3013[] 		= "turnonlamp";			// 开启测试光源
(0084) _CONST HTCMD_STR HTCmd3013 	= {CStr3013, 3013};
(0085) _CONST char CStr3014[] 		= "turnofflamp";		// 关闭测试光源
(0086) _CONST HTCMD_STR HTCmd3014 	= {CStr3014, 3014};
(0087) _CONST char CStr3015[] 		= "getworkstore";		// 获取当前工作仓号
(0088) _CONST HTCMD_STR HTCmd3015 	= {CStr3015, 3015};
(0089) _CONST char CStr3020[] 		= "setdebugmode";		// 	设置测试状态下的调试模式，0:正常，1:混匀液测量
(0090) _CONST HTCMD_STR HTCmd3020 	= {CStr3020, 3020};
(0091) 
(0092) _CONST char CStr3050[] 		= "sleep";				// 	进入休眠
(0093) _CONST HTCMD_STR HTCmd3050 	= {CStr3050, 3050};
(0094) _CONST char CStr3051[] 		= "startup";			// 	恢复测试
(0095) _CONST HTCMD_STR HTCmd3051 	= {CStr3051, 3051};
(0096) _CONST char CStr3052[] 		= "setsleeptime";		// 	设置休眠时间
(0097) _CONST HTCMD_STR HTCmd3052 	= {CStr3052, 3052};
(0098) _CONST char CStr3053[] 		= "samplingsw";			// 	取样功能开关
(0099) _CONST HTCMD_STR HTCmd3053 	= {CStr3053, 3053};
(0100) _CONST char CStr3054[] 		= "rereadtest";			// 	重新读取测试卡
(0101) _CONST HTCMD_STR HTCmd3054 	= {CStr3054, 3054};
(0102) _CONST char CStr3055[] 		= "setcleanmode";		// 	设置清洗模式
(0103) _CONST HTCMD_STR HTCmd3055 	= {CStr3055, 3055};
(0104) _CONST char CStr3056[] 		= "setreadclose";		// 	设置读数结束
(0105) _CONST HTCMD_STR HTCmd3056 	= {CStr3056, 3056};
(0106) 
(0107) _CONST char CStr3060[] 		= "manualprimedil";		// 	手动灌注稀释液
(0108) _CONST HTCMD_STR HTCmd3060 	= {CStr3060, 3060};
(0109) _CONST char CStr3061[] 		= "manualprimeflu";		// 	手动灌注清洗液
(0110) _CONST HTCMD_STR HTCmd3061 	= {CStr3061, 3061};
(0111) 
(0112) //_CONST char CStr3090[] 		= "quit";			// 测试退出
(0113) //_CONST HTCMD_STR HTCmd3090 	= {CStr3090, 3090};
(0114) 
(0115) _CONST HTCMD_STR * CmdString3[] = {
(0116) 	 &HTCmd0003, &HTCmd0004, &HTCmd0005, &HTCmd0010, &HTCmd0011, &HTCmd0099, 
(0117) 	 &HTCmd3001, &HTCmd3002, &HTCmd3003, &HTCmd3004, &HTCmd3005, &HTCmd3006, &HTCmd3007, 
(0118) 	 &HTCmd3010, &HTCmd3011, &HTCmd3012, 
(0119) 	 &HTCmd3013, &HTCmd3014, &HTCmd3015, &HTCmd3020, 
(0120) 	 &HTCmd3050, &HTCmd3051, &HTCmd3052, &HTCmd3053, &HTCmd3054, &HTCmd3055, &HTCmd3056,
(0121) 	 &HTCmd3060, &HTCmd3061, 0
(0122) };
(0123) // 维护
(0124) 	// 位置调试命令
(0125) _CONST char CStr4002[] 		= "setneedleonmixpos";		// 取样针位置在混匀池边沿位置调整
(0126) _CONST HTCMD_STR HTCmd4002 	= {CStr4002, 4002};
(0127) _CONST char CStr4004[] 		= "setdropheight";		// 取样针高度调整
(0128) _CONST HTCMD_STR HTCmd4004 	= {CStr4004, 4004};
(0129) _CONST char CStr4005[] 		= "cardloadstartadjust";	// 装片小车起始位调整
(0130) _CONST HTCMD_STR HTCmd4005 	= {CStr4005, 4005};
(0131) _CONST char CStr4006[] 		= "cardloadendadjust";		// 装片小车终止位调整
(0132) _CONST HTCMD_STR HTCmd4006 	= {CStr4006, 4006};
(0133) _CONST char CStr4007[] 		= "cardunloadstartadjust";	// 卸片小车起始位调整
(0134) _CONST HTCMD_STR HTCmd4007 	= {CStr4007, 4007};
(0135) _CONST char CStr4008[] 		= "cardunloadendadjust";	// 卸片小车终止位调整
(0136) _CONST HTCMD_STR HTCmd4008 	= {CStr4008, 4008};
(0137) _CONST char CStr4009[] 		= "liquidphotoadjust";	// 
(0138) _CONST HTCMD_STR HTCmd4009 	= {CStr4009, 4009};
(0139) _CONST char CStr4010[] 		= "cardstorephotoadjust";	// 
(0140) _CONST HTCMD_STR HTCmd4010 	= {CStr4010, 4010};
(0141) // 测试灯源控制
(0142) _CONST char CStr4011[] 		= "setlamplum";	// 
(0143) _CONST HTCMD_STR HTCmd4011 	= {CStr4011, 4011};
(0144) _CONST char CStr4012[] 		= "getlamplum";	// 
(0145) _CONST HTCMD_STR HTCmd4012 	= {CStr4012, 4012};
(0146) _CONST char CStr4013[] 		= "turnonlamp";	// 
(0147) _CONST HTCMD_STR HTCmd4013 	= {CStr4013, 4013};
(0148) _CONST char CStr4014[] 		= "turnofflamp";	// 
(0149) _CONST HTCMD_STR HTCmd4014 	= {CStr4014, 4014};
(0150) 
(0151) _CONST char CStr4015[] 		= "calibvalue";		// 		仪器校准
(0152) _CONST HTCMD_STR HTCmd4015 	= {CStr4015, 4015};
(0153) _CONST char CStr4016[] 		= "calibtest";		// 		仪器校准运行, 称量流量
(0154) _CONST HTCMD_STR HTCmd4016 	= {CStr4016, 4016};
(0155) 	// 机械测试命令
(0156) _CONST char CStr4020[] 		= "turnplatecheck";		// 转盘测试
(0157) _CONST HTCMD_STR HTCmd4020 	= {CStr4020, 4020};
(0158) _CONST char CStr4021[] 		= "needleturncheck";	// 取样臂旋转测试
(0159) _CONST HTCMD_STR HTCmd4021 	= {CStr4021, 4021};
(0160) _CONST char CStr4022[] 		= "needleupdowncheck";	// 取样针上下运行测试
(0161) _CONST HTCMD_STR HTCmd4022 	= {CStr4022, 4022};
(0162) _CONST char CStr4023[] 		= "cardstoremovecheck";	// 片仓小车移动测试
(0163) _CONST HTCMD_STR HTCmd4023 	= {CStr4023, 4023};
(0164) _CONST char CStr4024[] 		= "cardtakehookcheck";		// 卡片钩测试
(0165) _CONST HTCMD_STR HTCmd4024 	= {CStr4024, 4024};
(0166) _CONST char CStr4025[] 		= "cardloadcheck";		// 卡片装载小车测试
(0167) _CONST HTCMD_STR HTCmd4025 	= {CStr4025, 4025};
(0168) _CONST char CStr4026[] 		= "cardunloadcheck";	// 卡片卸载小车测试
(0169) _CONST HTCMD_STR HTCmd4026 	= {CStr4026, 4026};
(0170) _CONST char CStr4029[] 		= "diluentpumpcheck";	// 稀释液泵测试
(0171) _CONST HTCMD_STR HTCmd4029 	= {CStr4029, 4029};
(0172) _CONST char CStr4030[] 		= "leanerpumpcheck";	// 清洗液泵测试
(0173) _CONST HTCMD_STR HTCmd4030 	= {CStr4030, 4030};
(0174) _CONST char CStr4031[] 		= "effluentpumpcheck";	// 废液泵测试
(0175) _CONST HTCMD_STR HTCmd4031 	= {CStr4031, 4031};
(0176) _CONST char CStr4032[] 		= "sampsyringecheck";	// 取样注射器测试
(0177) _CONST HTCMD_STR HTCmd4032 	= {CStr4032, 4032};
(0178) 
(0179) _CONST char CStr4033[] 		= "liquidphotocheck";	// 
(0180) _CONST HTCMD_STR HTCmd4033 	= {CStr4033, 4033};
(0181) _CONST char CStr4034[] 		= "cardstorephotocheck";	// 
(0182) _CONST HTCMD_STR HTCmd4034 	= {CStr4034, 4034};
(0183) 
(0184) _CONST char CStr4035[] 		= "needleonmixsidecheck";	// 
(0185) _CONST HTCMD_STR HTCmd4035 	= {CStr4035, 4035};
(0186) _CONST char CStr4036[] 		= "dropheightcheck";	// 
(0187) _CONST HTCMD_STR HTCmd4036 	= {CStr4036, 4036};
(0188) 
(0189) _CONST char CStr4050[] 		= "diluentquantifytest";	// 稀释液定量测试
(0190) _CONST HTCMD_STR HTCmd4050 	= {CStr4050, 4050};
(0191) _CONST char CStr4051[] 		= "leanerquantifytest";		// 清洗液泵定量测试
(0192) _CONST HTCMD_STR HTCmd4051 	= {CStr4051, 4051};
(0193) _CONST char CStr4052[] 		= "sampquantifytest";		// 取样注射器定量测试
(0194) _CONST HTCMD_STR HTCmd4052 	= {CStr4052, 4052};
(0195) _CONST char CStr4055[] 		= "getsensor";		// 获取电机光藕状态
(0196) _CONST HTCMD_STR HTCmd4055 	= {CStr4055, 4055};
(0197) _CONST char CStr4056[] 		= "getallsensor";		// 获取电机光藕状态
(0198) _CONST HTCMD_STR HTCmd4056 	= {CStr4056, 4056};
(0199) 
(0200) 	// 基本命令
(0201) _CONST char CStr4060[] 		= "motsetposition";		// 设置电机位置
(0202) _CONST HTCMD_STR HTCmd4060 	= {CStr4060, 4060};
(0203) _CONST char CStr4061[] 		= "motinitcheck";		// 电机位置初始化
(0204) _CONST HTCMD_STR HTCmd4061 	= {CStr4061, 4061};
(0205) _CONST char CStr4062[] 		= "motrun";				// 电机运行
(0206) _CONST HTCMD_STR HTCmd4062 	= {CStr4062, 4062};
(0207) _CONST char CStr4063[] 		= "motrunto";			// 电机运行到
(0208) _CONST HTCMD_STR HTCmd4063 	= {CStr4063, 4063};
(0209) _CONST char CStr4064[] 		= "motruntosite";		// 电机运行到指定位置
(0210) _CONST HTCMD_STR HTCmd4064 	= {CStr4064, 4064};
(0211) _CONST char CStr4065[] 		= "setmotparamter";		// 设置电机运行参数
(0212) _CONST HTCMD_STR HTCmd4065 	= {CStr4065, 4065};
(0213) _CONST char CStr4066[] 		= "setmotbaseparamter";		// 设置电机基本参数
(0214) _CONST HTCMD_STR HTCmd4066 	= {CStr4066, 4066};
(0215) _CONST char CStr4067[] 		= "setaddress";			// 设置模块地址
(0216) _CONST HTCMD_STR HTCmd4067 	= {CStr4067, 4067};
(0217) _CONST char CStr4068[] 		= "setevalve";			// 设置电磁阀
(0218) _CONST HTCMD_STR HTCmd4068 	= {CStr4068, 4068};
(0219) _CONST char CStr4069[] 		= "getliquidphosignal";	// 获取液路光耦信号
(0220) _CONST HTCMD_STR HTCmd4069 	= {CStr4069, 4069};
(0221) _CONST char CStr4070[] 		= "liquidphoadjust";	// 液路光耦校准
(0222) _CONST HTCMD_STR HTCmd4070 	= {CStr4070, 4070};
(0223) _CONST char CStr4071[] 		= "getstorestate";		// 获取片仓状态
(0224) _CONST HTCMD_STR HTCmd4071 	= {CStr4071, 4071};
(0225) _CONST char CStr4072[] 		= "cardstorecal";		// 片仓光耦调整
(0226) _CONST HTCMD_STR HTCmd4072 	= {CStr4072, 4072};
(0227) _CONST char CStr4073[] 		= "getstorephosignal";	// 获取片仓光耦信号
(0228) _CONST HTCMD_STR HTCmd4073 	= {CStr4073, 4073};
(0229) _CONST char CStr4074[] 		= "getliquiddetsignal";	// 获取液路探测信号
(0230) _CONST HTCMD_STR HTCmd4074 	= {CStr4074, 4074};
(0231) 
(0232) //_CONST char CStr4090[] 		= "quit";	// 子功能退出
(0233) //_CONST HTCMD_STR HTCmd4090 	= {CStr4090, 4090};
(0234) 
(0235) 
(0236) _CONST HTCMD_STR * CmdString4[] = {
(0237)  	&HTCmd0003, &HTCmd0004, &HTCmd0005, &HTCmd0010, &HTCmd0011, &HTCmd0099, 
(0238) 	&HTCmd4002, &HTCmd4004, &HTCmd4005, &HTCmd4006, &HTCmd4007, &HTCmd4008, &HTCmd4009, &HTCmd4010,
(0239) 	&HTCmd4011, &HTCmd4012, &HTCmd4013, &HTCmd4014, &HTCmd4015, &HTCmd4016,
(0240) 	&HTCmd4020, &HTCmd4021, &HTCmd4022, &HTCmd4023, &HTCmd4024, &HTCmd4025, &HTCmd4026, &HTCmd4029, 
(0241) 	&HTCmd4030, &HTCmd4031, &HTCmd4032, &HTCmd4033, &HTCmd4034, &HTCmd4035, &HTCmd4036, 
(0242) 	&HTCmd4050, &HTCmd4051, &HTCmd4052, &HTCmd4055, &HTCmd4056,
(0243) 	&HTCmd4060, &HTCmd4061, &HTCmd4062, &HTCmd4063, &HTCmd4064, &HTCmd4065, &HTCmd4066, &HTCmd4067, &HTCmd4068, &HTCmd4069, 
(0244) 	&HTCmd4070, &HTCmd4071, &HTCmd4072, &HTCmd4073, &HTCmd4074, 0
(0245) };
(0246) */
(0247) UICOMMAND_BUF UICmdBuf;
(0248) //HTCOMMAND_BUF HTCmdBuf;
(0249) 
(0250) extern unsigned char WorkProcessStep;		// 工作进程号
(0251) extern unsigned char EchoSW;
(0252) 
(0253) CONTROL_CMD ControlCmd;		// 存放解析好的命令, 调用模块直接读取此结构信息, 读取结束后将信息清除
(0254) /*
(0255) unsigned char HTCommandStrMatch(void){
(0256) 	// 命令字符串匹配
(0257) 	unsigned char i;
(0258) 	_CONST HTCMD_STR ** CmdString;
(0259) 
(0260) 	switch(WorkProcessStep){
(0261) 		case 0:
(0262) 		case 255:
(0263) 			i = 0;
(0264) 			while(CmdString0[i]){
(0265) 				if(StringMatching(CmdString0[i]->pChar, HTCmdBuf.cmdStr)){
(0266) 					ControlCmd.cmdIdx = CmdString0[i]->indx;		// 匹配成功，保存命令索引
(0267) 					return 1;
(0268) 					}
(0269) 				else
(0270) 					i++;
(0271) 				}
(0272) 			break;
(0273) 		case 1:
(0274) 			i = 0;
(0275) 			while(CmdString1[i]){
(0276) 				if(StringMatching(CmdString0[i]->pChar, HTCmdBuf.cmdStr)){
(0277) 					ControlCmd.cmdIdx = CmdString0[i]->indx;		// 匹配成功，保存命令索引
(0278) 					return 1;
(0279) 					}
(0280) 				else
(0281) 					i++;
(0282) 				}
(0283) 			break;
(0284) 		case 2:
(0285) 			i = 0;
(0286) 			while(CmdString2[i]){
(0287) 				if(StringMatching(CmdString0[i]->pChar, HTCmdBuf.cmdStr)){
(0288) 					ControlCmd.cmdIdx = CmdString0[i]->indx;		// 匹配成功，保存命令索引
(0289) 					return 1;
(0290) 					}
(0291) 				else
(0292) 					i++;
(0293) 				}
(0294) 			break;
(0295) 		case 3:
(0296) 			i = 0;
(0297) 			while(CmdString3[i]){
(0298) 				if(StringMatching(CmdString3[i]->pChar, HTCmdBuf.cmdStr)){
(0299) 					ControlCmd.cmdIdx = CmdString3[i]->indx;		// 匹配成功，保存命令索引
(0300) 					return 1;
(0301) 					}
(0302) 				else
(0303) 					i++;
(0304) 				}
(0305) 			break;
(0306) 		case 4:
(0307) 			i = 0;
(0308) 			while(CmdString4[i]){
(0309) 				if(StringMatching(CmdString4[i]->pChar, HTCmdBuf.cmdStr)){
(0310) 					ControlCmd.cmdIdx = CmdString4[i]->indx;		// 匹配成功，保存命令索引
(0311) 					return 1;
(0312) 					}
(0313) 				else
(0314) 					i++;
(0315) 				}
(0316) 			break;
(0317) 		default:
(0318) 			i = 0;
(0319) 			while(CmdString0[i]){
(0320) 				if(StringMatching(CmdString0[i]->pChar, HTCmdBuf.cmdStr)){
(0321) 					ControlCmd.cmdIdx = CmdString0[i]->indx;		// 匹配成功，保存命令索引
(0322) 					return 1;
(0323) 					}
(0324) 				else
(0325) 					i++;
(0326) 				}
(0327) 			break;
(0328) 		}
(0329) 	return 0;
(0330) }
(0331) 
(0332) unsigned char HTCommandPammterConvert(void){
(0333) 	// 命令参数转换
(0334) 	unsigned char i;
(0335) 	i = HTCmdBuf.itemPnt;
(0336) 	if(i==0)
(0337) 		return 0;
(0338) 	ControlCmd.pam[i-1] = StringToInt(HTCmdBuf.pamStr[i-1]);
(0339) 	return 1;
(0340) }
(0341) void CommandClear(void){
(0342) 	unsigned char i;
(0343) 	unsigned char * pChar;
(0344) 	pChar = (unsigned char *)(&HTCmdBuf);
(0345) 	for(i=0; i<sizeof(HTCOMMAND_BUF); i++){
(0346) 		*pChar = 0;
(0347) 		pChar ++;
(0348) 		}
(0349) 	pChar = (unsigned char *)(&ControlCmd);
(0350) 	for(i=0; i<sizeof(CONTROL_CMD); i++){
(0351) 		*pChar = 0;
(0352) 		pChar ++;
(0353) 		}
(0354) }
(0355) 
(0356) unsigned char HTCommandExplain(unsigned char c)
(0357) {
(0358) 	// 超级终端命令解释,接收并回显正确的字符
(0359) 	unsigned char i;
(0360) 	unsigned char * pChar;
(0361) 	if(ControlCmd.cmdState == 2)
(0362) 		return 0;
(0363) 	if(ControlCmd.cmdState == 0){	
(0364) 		CommandClear();
(0365) 		}
(0366) 	// 字符接收和处理
(0367) 	switch(HTCmdBuf.itemPnt)		// 根据参数接收进度做不同处理
(0368) 	{
(0369) 		case 0:		// 当前接收命令字符串
(0370) 			if(c>='A' && c<='Z')
(0371) 				c += 0x20;
(0372) 			if((c>='a' && c<='z') || (c>='0' && c<='9'))	// 命令字符接收
(0373) 			{
(0374) 				ControlCmd.cmdState = 1;
(0375) 				if(HTCmdBuf.charPnt < 33)
(0376) 				{
(0377) 					HTCmdBuf.cmdStr[HTCmdBuf.charPnt] = c;
(0378) 					HTCmdBuf.charPnt ++;
(0379) 					uart0SendChar(c);
(0380) 				}
(0381) 			}
(0382) 			else if(c == ':')		// 命令字符串结束
(0383) 			{
(0384) 				HTCmdBuf.cmdStr[HTCmdBuf.charPnt] = 0;		// 字符串结束标识
(0385) 				HTCmdBuf.charPnt = 0;
(0386) 				HTCmdBuf.itemPnt = 1;			// 进入参数接收
(0387) 				uart0SendChar(':');
(0388) 				// 命令字符串匹配，匹配成功返显参数格式，错误则清除
(0389) 				if(HTCommandStrMatch()==0)
(0390) 				{
(0391) 					// 命令匹配错误
(0392) 					uart0SendChar(0x0d);
(0393) 					uart0SendChar(0x0a);
(0394) 					HTCmdBuf.itemPnt = 0;
(0395) 					HTCmdBuf.charPnt = 0;
(0396) 					//ControlCmd.cmdState == 0;
(0397) 					ControlCmd.cmdState = 0;
(0398) 					return 0;
(0399) 				}
(0400) 			}
(0401) 			else if(c == 0x0d )		// 命令接收结束
(0402) 			{
(0403) 				if(HTCmdBuf.charPnt != 0)
(0404) 				{
(0405) 					HTCmdBuf.cmdStr[HTCmdBuf.charPnt] = 0;		// 字符串结束标识
(0406) 					if(HTCommandStrMatch())	// 命令匹配成功
(0407) 					{
(0408) 						HTCmdBuf.charPnt = 0;
(0409) 						ControlCmd.pamLen = 0;		// 命令不带参数
(0410) 						ControlCmd.cmdState = 2;		// 设置接收到命令标识
(0411) 					}	
(0412) 					else	// 命令匹配错误
(0413) 					{
(0414) 						HTCmdBuf.itemPnt = 0;
(0415) 						HTCmdBuf.charPnt = 0;
(0416) 						//ControlCmd.cmdState == 0;
(0417) 						ControlCmd.cmdState = 0;
(0418) 					}
(0419) 				}
(0420) 				else
(0421) 				{
(0422) 					HTCmdBuf.itemPnt = 0;
(0423) 					HTCmdBuf.charPnt = 0;
(0424) 					//ControlCmd.cmdState == 0;
(0425) 					ControlCmd.cmdState = 0;
(0426) 				}
(0427) 				uart0SendChar(0x0d);
(0428) 				uart0SendChar(0x0a);
(0429) 				return 0;
(0430) 			}
(0431) 			else if(c == 0x08){		// 退格
(0432) 				if(HTCmdBuf.charPnt != 0)
(0433) 				{
(0434) 					HTCmdBuf.charPnt --;
(0435) 					HTCmdBuf.cmdStr[HTCmdBuf.charPnt] = 0;
(0436) 					uart0SendChar(0x08);
(0437) 					uart0SendChar(' ');
(0438) 					uart0SendChar(0x08);
(0439) 				}
(0440) 				else
(0441) 				{
(0442) 					HTCmdBuf.itemPnt = 0;
(0443) 					HTCmdBuf.charPnt = 0;
(0444) 					//ControlCmd.cmdState == 0;
(0445) 					ControlCmd.cmdState = 0;
(0446) 					uart0SendChar(0x0d);
(0447) 					uart0SendChar(0x0a);
(0448) 					return 0;
(0449) 				}
(0450) 			}
(0451) 			break;
(0452) 		case 1:		// 参数0
(0453) 		case 2:
(0454) 		case 3:
(0455) 		case 4:
(0456) 		case 5:
(0457) 			if(c == '-')
(0458) 			{
(0459) 				if(HTCmdBuf.charPnt == 0)
(0460) 				{
(0461) 					HTCmdBuf.pamStr[HTCmdBuf.itemPnt-1][0] = c;
(0462) 					HTCmdBuf.charPnt ++;
(0463) 					uart0SendChar(c);
(0464) 				}
(0465) 			}
(0466) 			else if((c>='0' && c<='9'))
(0467) 			{
(0468) 				if(HTCmdBuf.charPnt < 8)
(0469) 				{
(0470) 					HTCmdBuf.pamStr[HTCmdBuf.itemPnt-1][HTCmdBuf.charPnt] = c;
(0471) 					HTCmdBuf.charPnt ++;
(0472) 					uart0SendChar(c);
(0473) 				}
(0474) 			}
(0475) 			else if(c == ',')		// 参数分隔符
(0476) 			{
(0477) 				HTCmdBuf.pamStr[HTCmdBuf.itemPnt-1][HTCmdBuf.charPnt] = 0;
(0478) 				if(HTCmdBuf.itemPnt<6)
(0479) 				{
(0480) 					uart0SendChar(',');
(0481) 					if(HTCommandPammterConvert())
(0482) 					{
(0483) 						HTCmdBuf.itemPnt ++;
(0484) 						HTCmdBuf.charPnt = 0;
(0485) 					}
(0486) 				}
(0487) 			}
(0488) 			else if(c == 0x0d)
(0489) 			{
(0490) 				HTCmdBuf.pamStr[HTCmdBuf.itemPnt-1][HTCmdBuf.charPnt] = 0;
(0491) 				HTCmdBuf.charPnt = 0;
(0492) 				if(HTCommandPammterConvert())
(0493) 				{
(0494) 					HTCmdBuf.charPnt = 0;
(0495) 					ControlCmd.pamLen = HTCmdBuf.itemPnt;
(0496) 					ControlCmd.cmdState = 2;			// 设置命令接收完成标识
(0497) 				}
(0498) 				else		// 接收错误删除命令
(0499) 				{
(0500) 					HTCmdBuf.itemPnt = 0;
(0501) 					HTCmdBuf.charPnt = 0;
(0502) 					//ControlCmd.cmdState == 0;
(0503) 					ControlCmd.cmdState = 0;
(0504) 				}
(0505) 				uart0SendChar(0x0d);
(0506) 				uart0SendChar(0x0a);
(0507) 				return 0;
(0508) 			}
(0509) 			else if(c == 0x08)			// 退格
(0510) 			{
(0511) 				if(HTCmdBuf.charPnt != 0)
(0512) 				{
(0513) 					HTCmdBuf.charPnt --;
(0514) 					HTCmdBuf.pamStr[HTCmdBuf.itemPnt-1][HTCmdBuf.charPnt] = 0;
(0515) 					uart0SendChar(0x08);
(0516) 					uart0SendChar(' ');
(0517) 					uart0SendChar(0x08);
(0518) 				}
(0519) 				else			// 退回到上一个参数
(0520) 				{
(0521) 					if(HTCmdBuf.itemPnt > 1)
(0522) 					{
(0523) 						HTCmdBuf.itemPnt --;
(0524) 						for(i=0; i<10; i++)
(0525) 						{
(0526) 							if(HTCmdBuf.pamStr[HTCmdBuf.itemPnt-1][i] == 0)
(0527) 							{
(0528) 								HTCmdBuf.charPnt = i;
(0529) 								break;
(0530) 							}
(0531) 						}
(0532) 						uart0SendChar(0x08);
(0533) 						uart0SendChar(' ');
(0534) 						uart0SendChar(0x08);
(0535) 					}
(0536) 					else		// 删除命令
(0537) 					{
(0538) 						uart0SendChar(0x0d);
(0539) 						uart0SendChar(0x0a);
(0540) 						HTCmdBuf.itemPnt = 0;
(0541) 						HTCmdBuf.charPnt = 0;
(0542) 						//ControlCmd.cmdState == 0;
(0543) 						ControlCmd.cmdState = 0;
(0544) 						return 0;
(0545) 					}
(0546) 				}
(0547) 			}
(0548) 			break;
(0549) 		default:
(0550) 			break;
(0551) 		}
(0552) 	return 1;
(0553) }
(0554) */
(0555) 
(0556) void CommandClear(void){
(0557) 	unsigned char i;
(0558) 	unsigned char * pChar;
(0559) 	pChar = (unsigned char *)(&ControlCmd);
_SetCardScanfPos|_CommandClear:
  pChar                --> R16
  i                    --> R18
    028EF 931A      ST	-Y,R17
    028F0 930A      ST	-Y,R16
(0560) 	for(i=0; i<sizeof(CONTROL_CMD); i++){
    028F1 9723      SBIW	R28,3
    028F2 802B      LDD	R2,Y+3
(0561) 		*pChar = 0;
    028F3 2022      TST	R2
    028F4 F491      BNE	0x2907
    028F5 E081      LDI	R24,1
(0562) 		pChar ++;
    028F6 E090      LDI	R25,0
    028F7 8399      STD	Y+1,R25
    028F8 8388      ST	Y,R24
    028F9 019E      MOVW	R18,R28
    028FA 5F2E      SUBI	R18,0xFE
    028FB 4F3F      SBCI	R19,0xFF
_UICommandExplain:
  pChar                --> Y,+1
  i                    --> Y,+1
  cmd                  --> R10
  c                    --> R20
    028FC EC0D      LDI	R16,0xCD
    028FD E010      LDI	R17,0
    028FE 940E AF2A CALL	_EEPROMReadBytes_extIO
(0563) 		}
(0564) }
(0565) 
(0566) 
(0567) /*************************************************************************************************
(0568) typedef struct _UICOMMAND_BUF{
(0569) 	unsigned char itemPnt;			// 当前接收的项目号
(0570) 	unsigned char charPnt;			// 接收指针
(0571) 	unsigned char cmdStr[10];		// 命令名称字符串
(0572) }UICOMMAND_BUF;
(0573) /************************************ 用户界面命令解释 *******************************************/
(0574) extern unsigned char checkFlag;
(0575) extern unsigned char UartReceiveBuf[60];
(0576) unsigned char UICommandExplain(unsigned char c){
(0577) 	unsigned char i;
(0578) 	unsigned char * pChar;
(0579) 	unsigned int cmd;
(0580) 	static unsigned char checkSum = 0;
(0581) 	if(ControlCmd.cmdState == 2)
    02900 810A      LDD	R16,Y+2
    02901 2711      CLR	R17
    02902 FD07      SBRC	R16,7
(0582) 		return 0;
    02903 9510      COM	R17
    02904 5C0F      SUBI	R16,0xCF
(0583) 	if(ControlCmd.cmdState == 0)		// 清零
    02905 4F1E      SBCI	R17,0xFE
    02906 C037      RJMP	0x293E
    02907 E684      LDI	R24,0x64
    02908 802B      LDD	R2,Y+3
(0584) 	{
(0585) 		CommandClear();
    02909 1582      CP	R24,R2
(0586) 	}
(0587) 	switch(UICmdBuf.itemPnt)
    0290A F074      BLT	0x2919
    0290B 2D82      MOV	R24,R2
    0290C 3C8E      CPI	R24,0xCE
    0290D F05C      BLT	0x2919
    0290E E081      LDI	R24,1
    0290F E090      LDI	R25,0
    02910 8399      STD	Y+1,R25
    02911 8388      ST	Y,R24
    02912 019E      MOVW	R18,R28
    02913 5F2D      SUBI	R18,0xFD
    02914 4F3F      SBCI	R19,0xFF
    02915 EC0D      LDI	R16,0xCD
    02916 E010      LDI	R17,0
    02917 940E AF45 CALL	_EEPROMWriteBytes_extIO
    02919 E081      LDI	R24,1
    0291A E090      LDI	R25,0
    0291B 8399      STD	Y+1,R25
    0291C 8388      ST	Y,R24
    0291D 019E      MOVW	R18,R28
    0291E 5F2E      SUBI	R18,0xFE
    0291F 4F3F      SBCI	R19,0xFF
    02920 EC0D      LDI	R16,0xCD
    02921 E010      LDI	R17,0
    02922 940E AF2A CALL	_EEPROMReadBytes_extIO
    02924 E684      LDI	R24,0x64
    02925 802A      LDD	R2,Y+2
    02926 1582      CP	R24,R2
    02927 F01C      BLT	0x292B
    02928 2D82      MOV	R24,R2
    02929 3C8E      CPI	R24,0xCE
    0292A F46C      BGE	0x2938
    0292B 2422      CLR	R2
    0292C 822A      STD	Y+2,R2
    0292D E081      LDI	R24,1
    0292E E090      LDI	R25,0
    0292F 8399      STD	Y+1,R25
    02930 8388      ST	Y,R24
    02931 019E      MOVW	R18,R28
    02932 5F2E      SUBI	R18,0xFE
    02933 4F3F      SBCI	R19,0xFF
    02934 EC0D      LDI	R16,0xCD
    02935 E010      LDI	R17,0
    02936 940E AF45 CALL	_EEPROMWriteBytes_extIO
    02938 810A      LDD	R16,Y+2
(0588) 	{
(0589) 		case 0:
(0590) 			if(c == '#')		// 命令开始标志
    02939 2711      CLR	R17
    0293A FD07      SBRC	R16,7
(0591) 			{
(0592) 				UICmdBuf.charPnt = 0;
    0293B 9510      COM	R17
    0293C 5C0F      SUBI	R16,0xCF
    0293D 4F1E      SBCI	R17,0xFE
(0593) 				ControlCmd.cmdState = 1;
    0293E 9625      ADIW	R28,5
    0293F 9508      RET
_GetCardScanfPos:
    02940 9723      SBIW	R28,3
(0594) 				if(EchoSW)
    02941 E081      LDI	R24,1
    02942 E090      LDI	R25,0
    02943 8399      STD	Y+1,R25
    02944 8388      ST	Y,R24
    02945 019E      MOVW	R18,R28
(0595) 				{
(0596) 					if(checkFlag)
    02946 5F2E      SUBI	R18,0xFE
    02947 4F3F      SBCI	R19,0xFF
    02948 EC0D      LDI	R16,0xCD
    02949 E010      LDI	R17,0
(0597) 					{
(0598) 						checkFlag = 0;
    0294A 940E AF2A CALL	_EEPROMReadBytes_extIO
    0294C E684      LDI	R24,0x64
(0599) 						uart0SendChar(0x02);
    0294D 802A      LDD	R2,Y+2
    0294E 1582      CP	R24,R2
    0294F F01C      BLT	0x2953
    02950 2D82      MOV	R24,R2
(0600) 						uart0SendChar(c);
    02951 3C8E      CPI	R24,0xCE
    02952 F46C      BGE	0x2960
    02953 2422      CLR	R2
    02954 822A      STD	Y+2,R2
(0601) 						checkSum += c;			
    02955 E081      LDI	R24,1
    02956 E090      LDI	R25,0
    02957 8399      STD	Y+1,R25
    02958 8388      ST	Y,R24
    02959 019E      MOVW	R18,R28
(0602) 					}
    0295A 5F2E      SUBI	R18,0xFE
(0603) 					else
(0604) 						uart0SendChar(c);
    0295B 4F3F      SBCI	R19,0xFF
    0295C EC0D      LDI	R16,0xCD
    0295D E010      LDI	R17,0
    0295E 940E AF45 CALL	_EEPROMWriteBytes_extIO
(0605) 				}
(0606) 			}
    02960 810A      LDD	R16,Y+2
    02961 2711      CLR	R17
    02962 FD07      SBRC	R16,7
    02963 9510      COM	R17
    02964 5C0F      SUBI	R16,0xCF
(0607) 			else if(c >= '0' && c <= '9')
(0608) 			{
(0609) 				if(UICmdBuf.charPnt < 4)
    02965 4F1E      SBCI	R17,0xFE
    02966 9623      ADIW	R28,3
    02967 9508      RET
_CardScanfPosCheck:
    02968 940E AE83 CALL	push_xgset300C
(0610) 				{
(0611) 					UICmdBuf.cmdStr[UICmdBuf.charPnt] = c;
    0296A 9723      SBIW	R28,3
    0296B E008      LDI	R16,0x8
    0296C 940E 97C6 CALL	_WaitDelayTime
    0296E 2300      TST	R16
    0296F F011      BEQ	0x2972
    02970 2700      CLR	R16
    02971 C05D      RJMP	0x29CF
(0612) 					UICmdBuf.charPnt ++;
    02972 9020 1543 LDS	R2,liqDetBaseAdc+94
    02974 2022      TST	R2
    02975 F051      BEQ	0x2980
    02976 E008      LDI	R16,0x8
(0613) 					if(EchoSW)
    02977 940E 6A0C CALL	_GetMotState
    02979 3001      CPI	R16,1
    0297A F011      BEQ	0x297D
    0297B 2700      CLR	R16
(0614) 					{
(0615) 						if(checkFlag)
    0297C C052      RJMP	0x29CF
    0297D 2422      CLR	R2
    0297E 9220 1543 STS	liqDetBaseAdc+94,R2
(0616) 						{
(0617) 							checkFlag = 0;
    02980 9140 1542 LDS	R20,liqDetBaseAdc+93
    02982 2755      CLR	R21
(0618) 							uart0SendChar(c);
    02983 3040      CPI	R20,0
    02984 0745      CPC	R20,R21
    02985 F069      BEQ	0x2993
    02986 3041      CPI	R20,1
(0619) 							checkSum += c;
    02987 E0E0      LDI	R30,0
    02988 075E      CPC	R21,R30
    02989 F109      BEQ	0x29AB
    0298A 3042      CPI	R20,2
    0298B E0E0      LDI	R30,0
(0620) 						}
    0298C 075E      CPC	R21,R30
(0621) 						else
(0622) 							uart0SendChar(c);
    0298D F191      BEQ	0x29C0
    0298E 3043      CPI	R20,3
    0298F E0E0      LDI	R30,0
    02990 075E      CPC	R21,R30
(0623) 					}
(0624) 				}
(0625) 			}
    02991 F1B9      BEQ	0x29C9
(0626) 			else if(c == '$')	// 出现参数符，结束命令进入参数接收
    02992 C03B      RJMP	0x29CE
    02993 E08A      LDI	R24,0xA
    02994 838A      STD	Y+2,R24
(0627) 			{
(0628) 				if(UICmdBuf.charPnt != 0)
    02995 E184      LDI	R24,0x14
    02996 8388      ST	Y,R24
    02997 EC28      LDI	R18,0xC8
    02998 E008      LDI	R16,0x8
(0629) 				{
(0630) 					UICmdBuf.cmdStr[UICmdBuf.charPnt] = 0;
    02999 940E 6A9F CALL	_SetMotRunPam
    0299B 2722      CLR	R18
    0299C 2733      CLR	R19
    0299D E008      LDI	R16,0x8
    0299E 940E 6A5B CALL	_MotRunTo
    029A0 E081      LDI	R24,1
(0631) 					ControlCmd.cmdIdx = StringToInt(UICmdBuf.cmdStr);
    029A1 9380 1543 STS	liqDetBaseAdc+94,R24
    029A3 9380 1542 STS	liqDetBaseAdc+93,R24
    029A5 E025      LDI	R18,5
    029A6 E030      LDI	R19,0
    029A7 E008      LDI	R16,0x8
    029A8 940E 97B7 CALL	_SetDelayTime
(0632) 					if(checkFlag)
    029AA C023      RJMP	0x29CE
    029AB DF94      RCALL	_GetCardScanfPos
    029AC 0158      MOVW	R10,R16
(0633) 					{
(0634) 						cmd = StringToInt2(&UartReceiveBuf[1]);
    029AD E08A      LDI	R24,0xA
    029AE 838A      STD	Y+2,R24
    029AF E184      LDI	R24,0x14
    029B0 8388      ST	Y,R24
    029B1 EF2A      LDI	R18,0xFA
(0635) 						if(ControlCmd.cmdIdx == cmd)
    029B2 E008      LDI	R16,0x8
    029B3 940E 6A9F CALL	_SetMotRunPam
    029B5 0195      MOVW	R18,R10
    029B6 E008      LDI	R16,0x8
    029B7 940E 6A5B CALL	_MotRunTo
(0636) 							ControlCmd.cmdState = 1;
    029B9 E081      LDI	R24,1
    029BA 9380 1543 STS	liqDetBaseAdc+94,R24
(0637) 					}
(0638) 				}
    029BC E082      LDI	R24,2
(0639) 				else
(0640) 				{
(0641) 					ControlCmd.cmdIdx = 0;
    029BD 9380 1542 STS	liqDetBaseAdc+93,R24
    029BF C00E      RJMP	0x29CE
    029C0 E025      LDI	R18,5
    029C1 E030      LDI	R19,0
    029C2 E008      LDI	R16,0x8
(0642) 				}
(0643) 				if(EchoSW)
    029C3 940E 97B7 CALL	_SetDelayTime
    029C5 E083      LDI	R24,3
    029C6 9380 1542 STS	liqDetBaseAdc+93,R24
(0644) 				{
(0645) 					if(checkFlag)
    029C8 C005      RJMP	0x29CE
    029C9 2422      CLR	R2
    029CA 9220 1542 STS	liqDetBaseAdc+93,R2
(0646) 					{
(0647) 						checkFlag = 0;
    029CC E001      LDI	R16,1
    029CD C001      RJMP	0x29CF
(0648) 						uart0SendChar('$');
    029CE 2700      CLR	R16
    029CF 9623      ADIW	R28,3
    029D0 940C AE88 JMP	pop_xgset300C
(0649) 						checkSum += '$';
_CommandClear:
    029D2 E606      LDI	R16,0x66
    029D3 E115      LDI	R17,0x15
    029D4 2722      CLR	R18
    029D5 C006      RJMP	0x29DC
    029D6 2422      CLR	R2
(0650) 					}
    029D7 01F8      MOVW	R30,R16
(0651) 					else
(0652) 					{
(0653) 						uart0SendChar(' ');
    029D8 8220      ST	Z,R2
    029D9 5F0F      SUBI	R16,0xFF
    029DA 4F1F      SBCI	R17,0xFF
    029DB 9523      INC	R18
(0654) 						uart0SendChar('$');
    029DC 3128      CPI	R18,0x18
    029DD F3C0      BCS	0x29D6
    029DE 9508      RET
_UICommandExplain:
    029DF 940E AEB3 CALL	push_xgsetF03C
(0655) 					}
(0656) 				}
(0657) 				UICmdBuf.itemPnt ++;
    029E1 2F40      MOV	R20,R16
    029E2 9180 1566 LDS	R24,ControlCmd
    029E4 3082      CPI	R24,2
(0658) 				UICmdBuf.charPnt = 0;
    029E5 F411      BNE	0x29E8
    029E6 2700      CLR	R16
    029E7 C34B      RJMP	0x2D33
(0659) 				ControlCmd.pamLen = 0;
    029E8 9020 1566 LDS	R2,ControlCmd
(0660) 			}
    029EA 2022      TST	R2
(0661) 			else if(c == 0x0d)// 回车号，命令结束
    029EB F409      BNE	0x29ED
    029EC DFE5      RCALL	_CommandClear
    029ED 9160 155A LDS	R22,UICmdBuf
(0662) 			{
(0663) 				if(UICmdBuf.charPnt != 0)
    029EF 2777      CLR	R23
    029F0 3060      CPI	R22,0
    029F1 0767      CPC	R22,R23
(0664) 				{
(0665) 					UICmdBuf.cmdStr[UICmdBuf.charPnt] = 0;
    029F2 F149      BEQ	0x2A1C
    029F3 3061      CPI	R22,1
    029F4 E0E0      LDI	R30,0
    029F5 077E      CPC	R23,R30
    029F6 F409      BNE	0x29F8
    029F7 C19F      RJMP	0x2B97
    029F8 3062      CPI	R22,2
    029F9 E0E0      LDI	R30,0
(0666) 					ControlCmd.cmdIdx = StringToInt(UICmdBuf.cmdStr);
    029FA 077E      CPC	R23,R30
    029FB F409      BNE	0x29FD
    029FC C19A      RJMP	0x2B97
    029FD 3063      CPI	R22,3
    029FE E0E0      LDI	R30,0
    029FF 077E      CPC	R23,R30
    02A00 F409      BNE	0x2A02
    02A01 C195      RJMP	0x2B97
    02A02 3064      CPI	R22,4
(0667) 					if(checkFlag)
    02A03 E0E0      LDI	R30,0
    02A04 077E      CPC	R23,R30
    02A05 F409      BNE	0x2A07
    02A06 C190      RJMP	0x2B97
(0668) 					{
(0669) 						cmd = StringToInt(&UartReceiveBuf[1]);
    02A07 3065      CPI	R22,5
    02A08 E0E0      LDI	R30,0
    02A09 077E      CPC	R23,R30
    02A0A F409      BNE	0x2A0C
    02A0B C18B      RJMP	0x2B97
    02A0C 3066      CPI	R22,6
(0670) 						if(ControlCmd.cmdIdx == cmd)
    02A0D E0E0      LDI	R30,0
    02A0E 077E      CPC	R23,R30
    02A0F F409      BNE	0x2A11
    02A10 C186      RJMP	0x2B97
    02A11 3067      CPI	R22,7
    02A12 E0E0      LDI	R30,0
    02A13 077E      CPC	R23,R30
(0671) 							ControlCmd.cmdState = 2;
    02A14 F409      BNE	0x2A16
    02A15 C181      RJMP	0x2B97
    02A16 3068      CPI	R22,0x8
    02A17 E0E0      LDI	R30,0
(0672) 						else
(0673) 						{
(0674) 							ControlCmd.cmdState = 0;
    02A18 077E      CPC	R23,R30
    02A19 F409      BNE	0x2A1B
    02A1A C17C      RJMP	0x2B97
(0675) 							uart0SendChar(0X04);		// EOT
    02A1B C308      RJMP	0x2D24
    02A1C 3243      CPI	R20,0x23
    02A1D F529      BNE	0x2A43
    02A1E 2422      CLR	R2
(0676) 							return 0;
    02A1F 9220 155B STS	UICmdBuf+1,R2
(0677) 						}
(0678) 					}
(0679) 					else
(0680) 						ControlCmd.cmdState = 2;
    02A21 E081      LDI	R24,1
    02A22 9380 1566 STS	ControlCmd,R24
(0681) 				}
    02A24 9020 06F8 LDS	R2,EchoSW
(0682) 				else
(0683) 				{
(0684) 					ControlCmd.cmdState = 0;
    02A26 2022      TST	R2
    02A27 F409      BNE	0x2A29
(0685) 				}
(0686) 				ControlCmd.pamLen = 0;
    02A28 C2FB      RJMP	0x2D24
    02A29 9020 096A LDS	R2,checkFlag
(0687) 				UICmdBuf.itemPnt = 0;
    02A2B 2022      TST	R2
    02A2C F089      BEQ	0x2A3E
(0688) 				UICmdBuf.charPnt = 0;
    02A2D 2422      CLR	R2
    02A2E 9220 096A STS	checkFlag,R2
(0689) 				if(EchoSW)
    02A30 E002      LDI	R16,2
    02A31 E010      LDI	R17,0
    02A32 940E 9E0E CALL	_uart0SendChar
(0690) 				{
(0691) 					if(checkFlag)
    02A34 2F04      MOV	R16,R20
    02A35 2711      CLR	R17
    02A36 940E 9E0E CALL	_uart0SendChar
(0692) 					{
(0693) 						checkFlag = 0;
    02A38 9020 03EC LDS	R2,checkSum
    02A3A 0E24      ADD	R2,R20
(0694) 						uart0SendChar(0x0d);
    02A3B 9220 03EC STS	checkSum,R2
    02A3D C2E6      RJMP	0x2D24
    02A3E 2F04      MOV	R16,R20
(0695) 						uart0SendChar(0X03);
    02A3F 2711      CLR	R17
    02A40 940E 9E0E CALL	_uart0SendChar
    02A42 C2E1      RJMP	0x2D24
(0696) 						checkSum += 0x0d;
    02A43 3340      CPI	R20,0x30
    02A44 F180      BCS	0x2A75
    02A45 E389      LDI	R24,0x39
    02A46 1784      CP	R24,R20
    02A47 F168      BCS	0x2A75
(0697) 						uart0SendChar((checkSum & 0x0F) + 'A');
    02A48 9180 155B LDS	R24,UICmdBuf+1
    02A4A 3084      CPI	R24,4
    02A4B F008      BCS	0x2A4D
    02A4C C2D7      RJMP	0x2D24
    02A4D E58C      LDI	R24,0x5C
    02A4E E195      LDI	R25,0x15
    02A4F 91E0 155B LDS	R30,UICmdBuf+1
(0698) 						uart0SendChar(((checkSum & 0xF0) >> 4) + 'A');
    02A51 27FF      CLR	R31
    02A52 0FE8      ADD	R30,R24
    02A53 1FF9      ADC	R31,R25
    02A54 8340      ST	Z,R20
    02A55 9180 155B LDS	R24,UICmdBuf+1
    02A57 5F8F      SUBI	R24,0xFF
    02A58 9380 155B STS	UICmdBuf+1,R24
    02A5A 9020 06F8 LDS	R2,EchoSW
    02A5C 2022      TST	R2
    02A5D F409      BNE	0x2A5F
    02A5E C2C5      RJMP	0x2D24
    02A5F 9020 096A LDS	R2,checkFlag
(0699) 						uart0SendChar(0x0d);
    02A61 2022      TST	R2
    02A62 F069      BEQ	0x2A70
    02A63 2422      CLR	R2
    02A64 9220 096A STS	checkFlag,R2
(0700) 						uart0SendChar(0x0a);
    02A66 2F04      MOV	R16,R20
    02A67 2711      CLR	R17
    02A68 940E 9E0E CALL	_uart0SendChar
(0701) 						checkSum = 0;
    02A6A 9020 03EC LDS	R2,checkSum
(0702) 					}
    02A6C 0E24      ADD	R2,R20
(0703) 					else
(0704) 					{
(0705) 						uart0SendChar(0x0d);
    02A6D 9220 03EC STS	checkSum,R2
    02A6F C2B4      RJMP	0x2D24
    02A70 2F04      MOV	R16,R20
(0706) 						uart0SendChar(0x0a);
    02A71 2711      CLR	R17
    02A72 940E 9E0E CALL	_uart0SendChar
    02A74 C2AF      RJMP	0x2D24
(0707) 					}
(0708) 				}
(0709) 				return 0;
    02A75 3244      CPI	R20,0x24
    02A76 F009      BEQ	0x2A78
(0710) 			}
(0711) 			else if(c == 0x08)		// 退格
    02A77 C056      RJMP	0x2ACE
    02A78 9020 155B LDS	R2,UICmdBuf+1
(0712) 			{
(0713) 				if(UICmdBuf.charPnt != 0)
    02A7A 2022      TST	R2
    02A7B F121      BEQ	0x2AA0
    02A7C E58C      LDI	R24,0x5C
    02A7D E195      LDI	R25,0x15
(0714) 				{
(0715) 					UICmdBuf.charPnt--;
    02A7E 2DE2      MOV	R30,R2
    02A7F 27FF      CLR	R31
    02A80 0FE8      ADD	R30,R24
    02A81 1FF9      ADC	R31,R25
(0716) 					UICmdBuf.cmdStr[UICmdBuf.charPnt] = 0;
    02A82 2422      CLR	R2
    02A83 8220      ST	Z,R2
    02A84 E50C      LDI	R16,0x5C
    02A85 E115      LDI	R17,0x15
    02A86 940E 714B CALL	_StringToInt
    02A88 9310 1568 STS	ControlCmd+2,R17
    02A8A 9300 1567 STS	ControlCmd+1,R16
(0717) 					if(EchoSW)
    02A8C 9020 096A LDS	R2,checkFlag
    02A8E 2022      TST	R2
    02A8F F0B1      BEQ	0x2AA6
(0718) 					{
(0719) 						uart0SendChar(0x08);
    02A90 EE0B      LDI	R16,0xEB
    02A91 E117      LDI	R17,0x17
    02A92 940E 717E CALL	_StringToInt2
(0720) 						uart0SendChar(' ');
    02A94 0158      MOVW	R10,R16
    02A95 9020 1567 LDS	R2,ControlCmd+1
    02A97 9030 1568 LDS	R3,ControlCmd+2
(0721) 						uart0SendChar(0x08);
    02A99 1620      CP	R2,R16
    02A9A 0631      CPC	R3,R17
    02A9B F451      BNE	0x2AA6
(0722) 					}
(0723) 				}
    02A9C E081      LDI	R24,1
(0724) 				else		// 清除命令
(0725) 				{
(0726) 					ControlCmd.cmdState = 0;
    02A9D 9380 1566 STS	ControlCmd,R24
    02A9F C006      RJMP	0x2AA6
(0727) 					ControlCmd.pamLen = 0;
    02AA0 2422      CLR	R2
    02AA1 2433      CLR	R3
(0728) 					UICmdBuf.itemPnt = 0;
    02AA2 9230 1568 STS	ControlCmd+2,R3
(0729) 					UICmdBuf.charPnt = 0;
    02AA4 9220 1567 STS	ControlCmd+1,R2
(0730) 					if(EchoSW)
    02AA6 9020 06F8 LDS	R2,EchoSW
    02AA8 2022      TST	R2
    02AA9 F0C9      BEQ	0x2AC3
(0731) 					{
(0732) 						uart0SendChar(0x0d);
    02AAA 9020 096A LDS	R2,checkFlag
    02AAC 2022      TST	R2
    02AAD F069      BEQ	0x2ABB
(0733) 						uart0SendChar(0x0a);
    02AAE 2422      CLR	R2
    02AAF 9220 096A STS	checkFlag,R2
    02AB1 E204      LDI	R16,0x24
(0734) 					}
(0735) 					return 0;
    02AB2 E010      LDI	R17,0
    02AB3 940E 9E0E CALL	_uart0SendChar
(0736) 				}
(0737) 			}
(0738) 			break;
(0739) 		case 1:
(0740) 		case 2:
(0741) 		case 3:
(0742) 		case 4:
(0743) 		case 5:
(0744) 		case 6:
(0745) 		case 7:
(0746) 		case 8:
(0747) 			if(c>='0' && c<= '9')
    02AB5 9180 03EC LDS	R24,checkSum
    02AB7 5D8C      SUBI	R24,0xDC
    02AB8 9380 03EC STS	checkSum,R24
(0748) 			{
(0749) 				if(UICmdBuf.charPnt<5)
    02ABA C008      RJMP	0x2AC3
    02ABB E200      LDI	R16,0x20
    02ABC E010      LDI	R17,0
    02ABD 940E 9E0E CALL	_uart0SendChar
(0750) 				{
(0751) 					UICmdBuf.cmdStr[UICmdBuf.charPnt] = c;
    02ABF E204      LDI	R16,0x24
    02AC0 E010      LDI	R17,0
    02AC1 940E 9E0E CALL	_uart0SendChar
    02AC3 9180 155A LDS	R24,UICmdBuf
    02AC5 5F8F      SUBI	R24,0xFF
(0752) 					UICmdBuf.charPnt ++;
    02AC6 9380 155A STS	UICmdBuf,R24
    02AC8 2422      CLR	R2
    02AC9 9220 155B STS	UICmdBuf+1,R2
(0753) 					if(EchoSW)
    02ACB 9220 157D STS	ControlCmd+23,R2
    02ACD C256      RJMP	0x2D24
    02ACE 304D      CPI	R20,0xD
    02ACF F009      BEQ	0x2AD1
(0754) 					{
(0755) 						if(checkFlag)
    02AD0 C089      RJMP	0x2B5A
    02AD1 9020 155B LDS	R2,UICmdBuf+1
    02AD3 2022      TST	R2
(0756) 						{
(0757) 							checkFlag = 0;
    02AD4 F199      BEQ	0x2B08
    02AD5 E58C      LDI	R24,0x5C
    02AD6 E195      LDI	R25,0x15
(0758) 							uart0SendChar(c);
    02AD7 2DE2      MOV	R30,R2
    02AD8 27FF      CLR	R31
    02AD9 0FE8      ADD	R30,R24
    02ADA 1FF9      ADC	R31,R25
(0759) 							checkSum += c;
    02ADB 2422      CLR	R2
    02ADC 8220      ST	Z,R2
    02ADD E50C      LDI	R16,0x5C
    02ADE E115      LDI	R17,0x15
    02ADF 940E 714B CALL	_StringToInt
(0760) 						}
    02AE1 0168      MOVW	R12,R16
    02AE2 92D0 1568 STS	ControlCmd+2,R13
    02AE4 92C0 1567 STS	ControlCmd+1,R12
(0761) 						else
(0762) 						{
(0763) 							uart0SendChar(c);
(0764) 						}
(0765) 					}
(0766) 				}
(0767) 			}
    02AE6 9020 096A LDS	R2,checkFlag
    02AE8 2022      TST	R2
(0768) 			else if(c == '$')
(0769) 			{
(0770) 				if(UICmdBuf.charPnt != 0)
    02AE9 F0D1      BEQ	0x2B04
    02AEA EE0B      LDI	R16,0xEB
    02AEB E117      LDI	R17,0x17
    02AEC 940E 714B CALL	_StringToInt
(0771) 				{
(0772) 					UICmdBuf.cmdStr[UICmdBuf.charPnt] = 0;
    02AEE 0168      MOVW	R12,R16
    02AEF 0156      MOVW	R10,R12
    02AF0 9020 1567 LDS	R2,ControlCmd+1
    02AF2 9030 1568 LDS	R3,ControlCmd+2
    02AF4 1620      CP	R2,R16
    02AF5 0631      CPC	R3,R17
(0773) 					ControlCmd.pam[ControlCmd.pamLen] = StringToInt(UICmdBuf.cmdStr);
    02AF6 F421      BNE	0x2AFB
    02AF7 E082      LDI	R24,2
    02AF8 9380 1566 STS	ControlCmd,R24
    02AFA C010      RJMP	0x2B0B
    02AFB 2422      CLR	R2
    02AFC 9220 1566 STS	ControlCmd,R2
    02AFE E004      LDI	R16,4
    02AFF E010      LDI	R17,0
    02B00 940E 9E0E CALL	_uart0SendChar
    02B02 2700      CLR	R16
    02B03 C22F      RJMP	0x2D33
    02B04 E082      LDI	R24,2
    02B05 9380 1566 STS	ControlCmd,R24
(0774) 					ControlCmd.pamLen ++;
    02B07 C003      RJMP	0x2B0B
    02B08 2422      CLR	R2
    02B09 9220 1566 STS	ControlCmd,R2
(0775) 					UICmdBuf.itemPnt ++;
    02B0B 2422      CLR	R2
    02B0C 9220 157D STS	ControlCmd+23,R2
    02B0E 9220 155A STS	UICmdBuf,R2
(0776) 					UICmdBuf.charPnt = 0;
    02B10 9220 155B STS	UICmdBuf+1,R2
    02B12 9020 06F8 LDS	R2,EchoSW
(0777) 					if(EchoSW)
    02B14 2022      TST	R2
    02B15 F409      BNE	0x2B17
    02B16 C041      RJMP	0x2B58
    02B17 9020 096A LDS	R2,checkFlag
(0778) 					{
(0779) 						if(checkFlag)
    02B19 2022      TST	R2
    02B1A F1A9      BEQ	0x2B50
    02B1B 2422      CLR	R2
(0780) 						{
(0781) 							checkFlag = 0;
    02B1C 9220 096A STS	checkFlag,R2
    02B1E E00D      LDI	R16,0xD
(0782) 							uart0SendChar('$');
    02B1F E010      LDI	R17,0
    02B20 940E 9E0E CALL	_uart0SendChar
    02B22 E003      LDI	R16,3
(0783) 							checkSum += '$';
    02B23 E010      LDI	R17,0
    02B24 940E 9E0E CALL	_uart0SendChar
    02B26 9180 03EC LDS	R24,checkSum
(0784) 						}
    02B28 5F83      SUBI	R24,0xF3
(0785) 						else
(0786) 						{
(0787) 							uart0SendChar(' ');
    02B29 9380 03EC STS	checkSum,R24
    02B2B 2F08      MOV	R16,R24
    02B2C 2711      CLR	R17
(0788) 							uart0SendChar('$');
    02B2D 700F      ANDI	R16,0xF
    02B2E 7010      ANDI	R17,0
    02B2F 5B0F      SUBI	R16,0xBF
    02B30 4F1F      SBCI	R17,0xFF
(0789) 						}
(0790) 					}
(0791) 				}
    02B31 940E 9E0E CALL	_uart0SendChar
(0792) 				else
(0793) 				{
(0794) 					ControlCmd.pam[ControlCmd.pamLen] = 0;
    02B33 9100 03EC LDS	R16,checkSum
    02B35 2711      CLR	R17
    02B36 7F00      ANDI	R16,0xF0
    02B37 7010      ANDI	R17,0
    02B38 9515      ASR	R17
    02B39 9507      ROR	R16
    02B3A 9515      ASR	R17
    02B3B 9507      ROR	R16
    02B3C 9515      ASR	R17
    02B3D 9507      ROR	R16
    02B3E 9515      ASR	R17
(0795) 					ControlCmd.pamLen ++;
    02B3F 9507      ROR	R16
    02B40 5B0F      SUBI	R16,0xBF
    02B41 4F1F      SBCI	R17,0xFF
    02B42 940E 9E0E CALL	_uart0SendChar
(0796) 					UICmdBuf.itemPnt ++;
    02B44 E00D      LDI	R16,0xD
    02B45 E010      LDI	R17,0
    02B46 940E 9E0E CALL	_uart0SendChar
    02B48 E00A      LDI	R16,0xA
(0797) 					UICmdBuf.charPnt = 0;
    02B49 E010      LDI	R17,0
    02B4A 940E 9E0E CALL	_uart0SendChar
(0798) 					if(EchoSW)
    02B4C 2422      CLR	R2
    02B4D 9220 03EC STS	checkSum,R2
    02B4F C008      RJMP	0x2B58
(0799) 					{
(0800) 						if(checkFlag)
    02B50 E00D      LDI	R16,0xD
    02B51 E010      LDI	R17,0
    02B52 940E 9E0E CALL	_uart0SendChar
(0801) 						{
(0802) 							checkFlag = 0;
    02B54 E00A      LDI	R16,0xA
    02B55 E010      LDI	R17,0
    02B56 940E 9E0E CALL	_uart0SendChar
(0803) 							uart0SendChar('$');
    02B58 2700      CLR	R16
    02B59 C1D9      RJMP	0x2D33
    02B5A 3048      CPI	R20,0x8
(0804) 							checkSum += '$';
    02B5B F009      BEQ	0x2B5D
    02B5C C1C7      RJMP	0x2D24
    02B5D 9020 155B LDS	R2,UICmdBuf+1
    02B5F 2022      TST	R2
(0805) 						}
    02B60 F0F9      BEQ	0x2B80
(0806) 						else
(0807) 						{
(0808) 							uart0SendChar(' ');
    02B61 2D82      MOV	R24,R2
    02B62 5081      SUBI	R24,1
    02B63 9380 155B STS	UICmdBuf+1,R24
(0809) 							uart0SendChar('$');
    02B65 E58C      LDI	R24,0x5C
    02B66 E195      LDI	R25,0x15
    02B67 91E0 155B LDS	R30,UICmdBuf+1
(0810) 						}
(0811) 					}
(0812) 				}
(0813) 			}
    02B69 27FF      CLR	R31
(0814) 			else if(c == '-')	// 负号
    02B6A 0FE8      ADD	R30,R24
    02B6B 1FF9      ADC	R31,R25
(0815) 			{
(0816) 				if(UICmdBuf.charPnt==0)
    02B6C 2422      CLR	R2
    02B6D 8220      ST	Z,R2
    02B6E 9020 06F8 LDS	R2,EchoSW
    02B70 2022      TST	R2
(0817) 				{
(0818) 					UICmdBuf.cmdStr[0] = '-';
    02B71 F409      BNE	0x2B73
    02B72 C1B1      RJMP	0x2D24
    02B73 E008      LDI	R16,0x8
(0819) 					UICmdBuf.charPnt ++;
    02B74 E010      LDI	R17,0
    02B75 940E 9E0E CALL	_uart0SendChar
    02B77 E200      LDI	R16,0x20
(0820) 					if(EchoSW)
    02B78 E010      LDI	R17,0
    02B79 940E 9E0E CALL	_uart0SendChar
    02B7B E008      LDI	R16,0x8
    02B7C E010      LDI	R17,0
(0821) 						uart0SendChar(c);
    02B7D 940E 9E0E CALL	_uart0SendChar
    02B7F C1A4      RJMP	0x2D24
    02B80 2422      CLR	R2
(0822) 				}
(0823) 			}
    02B81 9220 1566 STS	ControlCmd,R2
(0824) 			else if(c == 0x0d)	// 回车号，命令结束
    02B83 9220 157D STS	ControlCmd+23,R2
(0825) 			{
(0826) 				if(UICmdBuf.charPnt != 0)
    02B85 9220 155A STS	UICmdBuf,R2
    02B87 9220 155B STS	UICmdBuf+1,R2
(0827) 				{
(0828) 					UICmdBuf.cmdStr[UICmdBuf.charPnt] = 0;
    02B89 9020 06F8 LDS	R2,EchoSW
    02B8B 2022      TST	R2
    02B8C F041      BEQ	0x2B95
    02B8D E00D      LDI	R16,0xD
    02B8E E010      LDI	R17,0
    02B8F 940E 9E0E CALL	_uart0SendChar
(0829) 					ControlCmd.pam[ControlCmd.pamLen] = StringToInt(UICmdBuf.cmdStr);
    02B91 E00A      LDI	R16,0xA
    02B92 E010      LDI	R17,0
    02B93 940E 9E0E CALL	_uart0SendChar
    02B95 2700      CLR	R16
    02B96 C19C      RJMP	0x2D33
    02B97 3340      CPI	R20,0x30
    02B98 F180      BCS	0x2BC9
    02B99 E389      LDI	R24,0x39
    02B9A 1784      CP	R24,R20
    02B9B F168      BCS	0x2BC9
    02B9C 9180 155B LDS	R24,UICmdBuf+1
    02B9E 3085      CPI	R24,5
    02B9F F008      BCS	0x2BA1
    02BA0 C183      RJMP	0x2D24
(0830) 					ControlCmd.pamLen ++;
    02BA1 E58C      LDI	R24,0x5C
    02BA2 E195      LDI	R25,0x15
    02BA3 91E0 155B LDS	R30,UICmdBuf+1
    02BA5 27FF      CLR	R31
(0831) 				}
(0832) 				if(checkFlag)
    02BA6 0FE8      ADD	R30,R24
    02BA7 1FF9      ADC	R31,R25
    02BA8 8340      ST	Z,R20
    02BA9 9180 155B LDS	R24,UICmdBuf+1
(0833) 				{
(0834) 					if(ControlCmd.cmdState == 1)
    02BAB 5F8F      SUBI	R24,0xFF
    02BAC 9380 155B STS	UICmdBuf+1,R24
(0835) 						ControlCmd.cmdState = 2;
    02BAE 9020 06F8 LDS	R2,EchoSW
    02BB0 2022      TST	R2
    02BB1 F409      BNE	0x2BB3
(0836) 					else
(0837) 						ControlCmd.cmdState = 0;
    02BB2 C171      RJMP	0x2D24
    02BB3 9020 096A LDS	R2,checkFlag
(0838) 				}
    02BB5 2022      TST	R2
(0839) 				else
(0840) 					ControlCmd.cmdState = 2;
    02BB6 F069      BEQ	0x2BC4
    02BB7 2422      CLR	R2
    02BB8 9220 096A STS	checkFlag,R2
(0841) 					
(0842) 				UICmdBuf.itemPnt = 0;
    02BBA 2F04      MOV	R16,R20
    02BBB 2711      CLR	R17
(0843) 				UICmdBuf.charPnt = 0;
    02BBC 940E 9E0E CALL	_uart0SendChar
(0844) 				if(EchoSW)
    02BBE 9020 03EC LDS	R2,checkSum
    02BC0 0E24      ADD	R2,R20
    02BC1 9220 03EC STS	checkSum,R2
(0845) 				{
(0846) 					if(checkFlag)
    02BC3 C160      RJMP	0x2D24
    02BC4 2F04      MOV	R16,R20
    02BC5 2711      CLR	R17
    02BC6 940E 9E0E CALL	_uart0SendChar
(0847) 					{
(0848) 						checkFlag = 0;
    02BC8 C15B      RJMP	0x2D24
    02BC9 3244      CPI	R20,0x24
(0849) 						uart0SendChar(0x0d);
    02BCA F009      BEQ	0x2BCC
    02BCB C081      RJMP	0x2C4D
    02BCC 9020 155B LDS	R2,UICmdBuf+1
(0850) 						uart0SendChar(0X03);
    02BCE 2022      TST	R2
    02BCF F409      BNE	0x2BD1
    02BD0 C044      RJMP	0x2C15
    02BD1 E58C      LDI	R24,0x5C
(0851) 						checkSum += 0x0d;
    02BD2 E195      LDI	R25,0x15
    02BD3 2DE2      MOV	R30,R2
    02BD4 27FF      CLR	R31
    02BD5 0FE8      ADD	R30,R24
    02BD6 1FF9      ADC	R31,R25
(0852) 						uart0SendChar((checkSum & 0x0F) + 'A');
    02BD7 2422      CLR	R2
    02BD8 8220      ST	Z,R2
    02BD9 E50C      LDI	R16,0x5C
    02BDA E115      LDI	R17,0x15
    02BDB 940E 714B CALL	_StringToInt
    02BDD 0158      MOVW	R10,R16
    02BDE E689      LDI	R24,0x69
(0853) 						uart0SendChar(((checkSum & 0xF0) >> 4) + 'A');
    02BDF E195      LDI	R25,0x15
    02BE0 91E0 157D LDS	R30,ControlCmd+23
    02BE2 27FF      CLR	R31
    02BE3 0FEE      LSL	R30
    02BE4 1FFF      ROL	R31
    02BE5 0FE8      ADD	R30,R24
    02BE6 1FF9      ADC	R31,R25
    02BE7 82B1      STD	Z+1,R11
    02BE8 82A0      ST	Z,R10
    02BE9 9180 157D LDS	R24,ControlCmd+23
    02BEB 5F8F      SUBI	R24,0xFF
    02BEC 9380 157D STS	ControlCmd+23,R24
    02BEE 9180 155A LDS	R24,UICmdBuf
(0854) 						uart0SendChar(0x0D);
    02BF0 5F8F      SUBI	R24,0xFF
    02BF1 9380 155A STS	UICmdBuf,R24
    02BF3 2422      CLR	R2
(0855) 						uart0SendChar(0x0a);
    02BF4 9220 155B STS	UICmdBuf+1,R2
    02BF6 9020 06F8 LDS	R2,EchoSW
(0856) 						checkSum = 0;
    02BF8 2022      TST	R2
    02BF9 F409      BNE	0x2BFB
    02BFA C129      RJMP	0x2D24
(0857) 					}
    02BFB 9020 096A LDS	R2,checkFlag
(0858) 					else
(0859) 					{
(0860) 						uart0SendChar(0x0D);
    02BFD 2022      TST	R2
    02BFE F069      BEQ	0x2C0C
    02BFF 2422      CLR	R2
(0861) 						uart0SendChar(0x0a);
    02C00 9220 096A STS	checkFlag,R2
    02C02 E204      LDI	R16,0x24
    02C03 E010      LDI	R17,0
(0862) 					}
(0863) 				}
(0864) 				return 0;
    02C04 940E 9E0E CALL	_uart0SendChar
(0865) 			}
(0866) 			else if(c == 0x08){		// 退格
    02C06 9180 03EC LDS	R24,checkSum
(0867) 				if(UICmdBuf.charPnt != 0)
    02C08 5D8C      SUBI	R24,0xDC
    02C09 9380 03EC STS	checkSum,R24
    02C0B C118      RJMP	0x2D24
(0868) 				{
(0869) 					UICmdBuf.charPnt--;
    02C0C E200      LDI	R16,0x20
    02C0D E010      LDI	R17,0
    02C0E 940E 9E0E CALL	_uart0SendChar
(0870) 					UICmdBuf.cmdStr[UICmdBuf.charPnt] = 0;
    02C10 E204      LDI	R16,0x24
    02C11 E010      LDI	R17,0
    02C12 940E 9E0E CALL	_uart0SendChar
    02C14 C10F      RJMP	0x2D24
    02C15 E689      LDI	R24,0x69
    02C16 E195      LDI	R25,0x15
    02C17 91E0 157D LDS	R30,ControlCmd+23
(0871) 					if(EchoSW)
    02C19 27FF      CLR	R31
    02C1A 0FEE      LSL	R30
    02C1B 1FFF      ROL	R31
    02C1C 0FE8      ADD	R30,R24
(0872) 					{
(0873) 						uart0SendChar(0x08);
    02C1D 1FF9      ADC	R31,R25
    02C1E 2422      CLR	R2
    02C1F 2433      CLR	R3
    02C20 8231      STD	Z+1,R3
(0874) 						uart0SendChar(' ');
    02C21 8220      ST	Z,R2
    02C22 9180 157D LDS	R24,ControlCmd+23
    02C24 5F8F      SUBI	R24,0xFF
(0875) 						uart0SendChar(0x08);
    02C25 9380 157D STS	ControlCmd+23,R24
    02C27 9180 155A LDS	R24,UICmdBuf
(0876) 					}
(0877) 				}
    02C29 5F8F      SUBI	R24,0xFF
(0878) 				else		// 清除命令
(0879) 				{
(0880) 					ControlCmd.cmdState = 0;
    02C2A 9380 155A STS	UICmdBuf,R24
    02C2C 9220 155B STS	UICmdBuf+1,R2
(0881) 					ControlCmd.pamLen = 0;
    02C2E 9020 06F8 LDS	R2,EchoSW
(0882) 					UICmdBuf.itemPnt = 0;
    02C30 2022      TST	R2
(0883) 					UICmdBuf.charPnt = 0;
    02C31 F409      BNE	0x2C33
    02C32 C0F1      RJMP	0x2D24
(0884) 					if(EchoSW)
    02C33 9020 096A LDS	R2,checkFlag
    02C35 2022      TST	R2
    02C36 F069      BEQ	0x2C44
(0885) 					{
(0886) 						uart0SendChar(0x0d);
    02C37 2422      CLR	R2
    02C38 9220 096A STS	checkFlag,R2
    02C3A E204      LDI	R16,0x24
(0887) 						uart0SendChar(0x0a);
    02C3B E010      LDI	R17,0
    02C3C 940E 9E0E CALL	_uart0SendChar
    02C3E 9180 03EC LDS	R24,checkSum
(0888) 					}
(0889) 					return 0;
    02C40 5D8C      SUBI	R24,0xDC
(0890) 				}
(0891) 			}
(0892) 			break;
(0893) 		}
(0894) 	if(UICmdBuf.itemPnt > 8)
    02C41 9380 03EC STS	checkSum,R24
    02C43 C0E0      RJMP	0x2D24
    02C44 E200      LDI	R16,0x20
    02C45 E010      LDI	R17,0
(0895) 	{
(0896) 		UICmdBuf.itemPnt = 8;
    02C46 940E 9E0E CALL	_uart0SendChar
(0897) 	}
(0898) 	if(ControlCmd.pamLen >8)
    02C48 E204      LDI	R16,0x24
    02C49 E010      LDI	R17,0
    02C4A 940E 9E0E CALL	_uart0SendChar
    02C4C C0D7      RJMP	0x2D24
(0899) 	{
(0900) 		ControlCmd.pamLen = 8;
    02C4D 324D      CPI	R20,0x2D
    02C4E F4B1      BNE	0x2C65
(0901) 	}
(0902) 	return 1;
    02C4F 9020 155B LDS	R2,UICmdBuf+1
    02C51 2022      TST	R2
_CommandExplain:
  i                    --> R10
  c                    --> R20
    02C52 F009      BEQ	0x2C54
    02C53 C0D0      RJMP	0x2D24
    02C54 E28D      LDI	R24,0x2D
(0903) }
(0904) 
(0905) /*
(0906) void CommandExplain(unsigned char c)
(0907) {
(0908) 	static unsigned char receiveSW = 0;
(0909) 	unsigned char i;
(0910) 		
(0911) 	if(receiveSW == 0)
(0912) 	{
(0913) 		if(c == '#')
(0914) 		{
(0915) 			receiveSW = 1;
(0916) 		}
(0917) 		else 
(0918) 		{
(0919) 			receiveSW = 2;
(0920) 		}
(0921) 	}
(0922) 	switch(receiveSW)
(0923) 	{
(0924) 		case 0:
(0925) 			break;
(0926) 		case 1:
(0927) 			i = UICommandExplain(c);
(0928) 			if(i == 0)
(0929) 				receiveSW = 0;
(0930) 			break;
(0931) 		case 2:
(0932) 			i = HTCommandExplain(c);
(0933) 			if(i == 0)
(0934) 				receiveSW = 0;
(0935) 			break;
(0936) 	}
(0937) }
(0938) */
(0939) 
(0940) void CommandExplain(unsigned char c)
(0941) {
(0942) 	static unsigned char receiveSW = 0;
(0943) 	unsigned char i;
(0944) 		
(0945) 	if(receiveSW == 0)
    02C55 9380 155C STS	UICmdBuf+2,R24
    02C57 2D82      MOV	R24,R2
    02C58 5F8F      SUBI	R24,0xFF
(0946) 	{
(0947) 		if(c == '#')
    02C59 9380 155B STS	UICmdBuf+1,R24
(0948) 		{
(0949) 			receiveSW = 1;
    02C5B 9020 06F8 LDS	R2,EchoSW
    02C5D 2022      TST	R2
(0950) 		}
(0951) 	}
(0952) 	switch(receiveSW)
    02C5E F409      BNE	0x2C60
    02C5F C0C4      RJMP	0x2D24
    02C60 2F04      MOV	R16,R20
    02C61 2711      CLR	R17
    02C62 940E 9E0E CALL	_uart0SendChar
    02C64 C0BF      RJMP	0x2D24
    02C65 304D      CPI	R20,0xD
    02C66 F009      BEQ	0x2C68
    02C67 C081      RJMP	0x2CE9
    02C68 9020 155B LDS	R2,UICmdBuf+1
(0953) 	{
(0954) 		case 0:
(0955) 			break;
(0956) 		case 1:
(0957) 			i = UICommandExplain(c);
    02C6A 2022      TST	R2
    02C6B F0E9      BEQ	0x2C89
(0958) 			if(i == 0)
    02C6C E58C      LDI	R24,0x5C
    02C6D E195      LDI	R25,0x15
(0959) 				receiveSW = 0;
    02C6E 2DE2      MOV	R30,R2
    02C6F 27FF      CLR	R31
    02C70 0FE8      ADD	R30,R24
(0960) 			break;
    02C71 1FF9      ADC	R31,R25
    02C72 2422      CLR	R2
_InitControlLayerData:
  i                    --> R20
    02C73 8220      ST	Z,R2
FILE: D:\Work\主控软件\2032A2~1\control.c
(0001) 
(0002) 
(0003) #include <iom1280v.h>
(0004) #include "B1404_LIB.h"
(0005) #include "Common.h"
(0006) 
(0007) 
(0008) typedef struct _MOTOR_POSITION{
(0009) 	unsigned char defPosNum;	// 预定义位置
(0010) 	int stepPos;		// 步进数位置
(0011) }MOTOR_POSITION;
(0012) 
(0013) 
(0014) extern unsigned char ControlModel;
(0015) extern unsigned char WorkProcessStep;		// 工作进程号
(0016) 
(0017) 
(0018) unsigned char (*EvenPosChangeProcess)(INFO_EVENT * pInfoEvent);
(0019) unsigned char (*EvenLiquidProcess)(INFO_EVENT * pInfoEvent);
(0020) unsigned char (*EvenCardStoreProcess)(INFO_EVENT * pInfoEvent);
(0021) 
(0022) MOTOR_POSITION MotorPosition[SLAVE_NUM];
(0023) unsigned char MotModulePhoSta[SLAVE_NUM][2];	// 电机模块光藕状态信息
(0024) unsigned char LiquidState[4][2];	// 液路状态和参数
(0025) unsigned char StoreHumi;			// 片仓湿度
(0026) unsigned char StoreTemp;			// 片仓温度
(0027) 
(0028) unsigned char _RingPieceState[RING_QUEUE_NUM];	// 转盘干片状态, 0:空, 1:存在, 255:无效
(0029) 
(0030) 
(0031) // 数据初始化
(0032) void InitControlLayerData(void){
(0033) 	unsigned char i;
(0034) 	for(i=0; i<SLAVE_NUM; i++){
    02C74 E50C      LDI	R16,0x5C
    02C75 E115      LDI	R17,0x15
(0035) 		MotorPosition[i].defPosNum = 0xf0;
    02C76 940E 714B CALL	_StringToInt
    02C78 0158      MOVW	R10,R16
    02C79 E689      LDI	R24,0x69
    02C7A E195      LDI	R25,0x15
    02C7B 91E0 157D LDS	R30,ControlCmd+23
    02C7D 27FF      CLR	R31
    02C7E 0FEE      LSL	R30
    02C7F 1FFF      ROL	R31
(0036) 		MotorPosition[i].stepPos = 0x7fff;
    02C80 0FE8      ADD	R30,R24
    02C81 1FF9      ADC	R31,R25
    02C82 82B1      STD	Z+1,R11
    02C83 82A0      ST	Z,R10
    02C84 9180 157D LDS	R24,ControlCmd+23
    02C86 5F8F      SUBI	R24,0xFF
    02C87 9380 157D STS	ControlCmd+23,R24
    02C89 9020 096A LDS	R2,checkFlag
    02C8B 2022      TST	R2
    02C8C F061      BEQ	0x2C99
(0037) 		}
(0038) 	EvenPosChangeProcess = 0;
    02C8D 9180 1566 LDS	R24,ControlCmd
    02C8F 3081      CPI	R24,1
    02C90 F421      BNE	0x2C95
    02C91 E082      LDI	R24,2
    02C92 9380 1566 STS	ControlCmd,R24
(0039) 	EvenLiquidProcess = 0;
    02C94 C007      RJMP	0x2C9C
    02C95 2422      CLR	R2
    02C96 9220 1566 STS	ControlCmd,R2
(0040) 	EvenCardStoreProcess = 0;
    02C98 C003      RJMP	0x2C9C
    02C99 E082      LDI	R24,2
    02C9A 9380 1566 STS	ControlCmd,R24
    02C9C 2422      CLR	R2
(0041) }
(0042) 
(0043) 
(0044) unsigned char GetRingPieceState(unsigned char n){
(0045) 	if(n>=RING_QUEUE_NUM)
_GetRingPieceState:
  n                    --> R16
    02C9D 9220 155A STS	UICmdBuf,R2
(0046) 		return 0xff;
    02C9F 9220 155B STS	UICmdBuf+1,R2
(0047) 	return _RingPieceState[n];
    02CA1 9020 06F8 LDS	R2,EchoSW
    02CA3 2022      TST	R2
    02CA4 F409      BNE	0x2CA6
    02CA5 C041      RJMP	0x2CE7
    02CA6 9020 096A LDS	R2,checkFlag
    02CA8 2022      TST	R2
(0048) }
(0049) 
(0050) // 温湿度
(0051) unsigned char GetStoreHumi(void){
(0052) 	return StoreHumi;
_GetStoreHumi:
    02CA9 F1A9      BEQ	0x2CDF
    02CAA 2422      CLR	R2
    02CAB 9220 096A STS	checkFlag,R2
(0053) }
(0054) unsigned char GetStoreTemp(void){
(0055) 	return StoreTemp;
    02CAD E00D      LDI	R16,0xD
    02CAE E010      LDI	R17,0
_SetMotPosIdle:
  slaveNum             --> R10
    02CAF 940E 9E0E CALL	_uart0SendChar
(0056) }
(0057) 
(0058) // 电机位置
(0059) void SetMotPosIdle(unsigned char slaveNum)
(0060) {
(0061) 	MotorPosition[slaveNum].defPosNum = 0xf0;
    02CB1 E003      LDI	R16,3
    02CB2 E010      LDI	R17,0
    02CB3 940E 9E0E CALL	_uart0SendChar
    02CB5 9180 03EC LDS	R24,checkSum
    02CB7 5F83      SUBI	R24,0xF3
    02CB8 9380 03EC STS	checkSum,R24
    02CBA 2F08      MOV	R16,R24
    02CBB 2711      CLR	R17
    02CBC 700F      ANDI	R16,0xF
_GetMotPositionOfSite:
  slaveNum             --> R10
    02CBD 7010      ANDI	R17,0
    02CBE 5B0F      SUBI	R16,0xBF
(0062) //	MotorPosition[slaveNum].stepPos = 0x7fff;
(0063) }
(0064) unsigned char GetMotPositionOfSite(unsigned char slaveNum){
(0065) 	return MotorPosition[slaveNum].defPosNum;
    02CBF 4F1F      SBCI	R17,0xFF
    02CC0 940E 9E0E CALL	_uart0SendChar
    02CC2 9100 03EC LDS	R16,checkSum
    02CC4 2711      CLR	R17
    02CC5 7F00      ANDI	R16,0xF0
    02CC6 7010      ANDI	R17,0
    02CC7 9515      ASR	R17
    02CC8 9507      ROR	R16
    02CC9 9515      ASR	R17
_GetMotPositionOfStep:
  slaveNum             --> R10
    02CCA 9507      ROR	R16
    02CCB 9515      ASR	R17
(0066) }
(0067) int GetMotPositionOfStep(unsigned char slaveNum){
(0068) 	return MotorPosition[slaveNum].stepPos;
    02CCC 9507      ROR	R16
    02CCD 9515      ASR	R17
    02CCE 9507      ROR	R16
    02CCF 5B0F      SUBI	R16,0xBF
    02CD0 4F1F      SBCI	R17,0xFF
    02CD1 940E 9E0E CALL	_uart0SendChar
    02CD3 E00D      LDI	R16,0xD
    02CD4 E010      LDI	R17,0
    02CD5 940E 9E0E CALL	_uart0SendChar
    02CD7 E00A      LDI	R16,0xA
(0069) }
(0070) 
(0071) // 获取液路状态
(0072) unsigned char GetLiquidMonitorState(unsigned char num){
(0073) 	if(num>3)
_GetLiquidMonitorState:
  num                  --> R16
    02CD8 E010      LDI	R17,0
    02CD9 940E 9E0E CALL	_uart0SendChar
(0074) 		num = 3;
    02CDB 2422      CLR	R2
(0075) 	return LiquidState[num][0];
    02CDC 9220 03EC STS	checkSum,R2
    02CDE C008      RJMP	0x2CE7
    02CDF E00D      LDI	R16,0xD
    02CE0 E010      LDI	R17,0
    02CE1 940E 9E0E CALL	_uart0SendChar
    02CE3 E00A      LDI	R16,0xA
    02CE4 E010      LDI	R17,0
    02CE5 940E 9E0E CALL	_uart0SendChar
(0076) }
(0077) unsigned char GetLiquidMonitorStatePam(unsigned char num){
(0078) 	if(num>3)
    02CE7 2700      CLR	R16
    02CE8 C04A      RJMP	0x2D33
(0079) 		num = 3;
    02CE9 3048      CPI	R20,0x8
(0080) 	return LiquidState[num][1];
    02CEA F5C9      BNE	0x2D24
    02CEB 9020 155B LDS	R2,UICmdBuf+1
    02CED 2022      TST	R2
    02CEE F0F1      BEQ	0x2D0D
    02CEF 2D82      MOV	R24,R2
    02CF0 5081      SUBI	R24,1
    02CF1 9380 155B STS	UICmdBuf+1,R24
    02CF3 E58C      LDI	R24,0x5C
(0081) }
(0082) 
(0083) 
(0084) // 注册位置改变自动处理函数
(0085) unsigned char RegisterPosChangeEvenProcess(void * proc){
(0086) 	EvenPosChangeProcess = proc;
_RegisterPosChangeEvenProcess:
  proc                 --> R16
    02CF4 E195      LDI	R25,0x15
    02CF5 91E0 155B LDS	R30,UICmdBuf+1
    02CF7 27FF      CLR	R31
    02CF8 0FE8      ADD	R30,R24
(0087) }
(0088) void CleanPosChangeEvenProcess(void){
(0089) 	EvenPosChangeProcess = 0;
_CleanPosChangeEvenProcess:
    02CF9 1FF9      ADC	R31,R25
    02CFA 2422      CLR	R2
    02CFB 8220      ST	Z,R2
    02CFC 9020 06F8 LDS	R2,EchoSW
    02CFE 2022      TST	R2
    02CFF F121      BEQ	0x2D24
(0090) }
(0091) // 注册液路事件处理函数
(0092) unsigned char RegisterLiquidEvenProcess(void * proc){
(0093) 	EvenLiquidProcess = proc;
_RegisterLiquidEvenProcess:
  proc                 --> R16
    02D00 E008      LDI	R16,0x8
    02D01 E010      LDI	R17,0
    02D02 940E 9E0E CALL	_uart0SendChar
    02D04 E200      LDI	R16,0x20
(0094) }
(0095) void CleanLiquidEvenProcess(void){
(0096) 	EvenLiquidProcess = 0;
_CleanLiquidEvenProcess:
    02D05 E010      LDI	R17,0
    02D06 940E 9E0E CALL	_uart0SendChar
    02D08 E008      LDI	R16,0x8
    02D09 E010      LDI	R17,0
    02D0A 940E 9E0E CALL	_uart0SendChar
(0097) }
(0098) // 注册片仓事件处理函数
(0099) unsigned char RegisterCardStoreEvenProcess(void * proc){
(0100) 	EvenCardStoreProcess = proc;
_RegisterCardStoreEvenProcess:
  proc                 --> R16
    02D0C C017      RJMP	0x2D24
    02D0D 2422      CLR	R2
    02D0E 9220 1566 STS	ControlCmd,R2
    02D10 9220 157D STS	ControlCmd+23,R2
(0101) }
(0102) void CleanPosCardStoreProcess(void){
(0103) 	EvenCardStoreProcess = 0;
    02D12 9220 155A STS	UICmdBuf,R2
    02D14 9220 155B STS	UICmdBuf+1,R2
    02D16 9020 06F8 LDS	R2,EchoSW
_UpLoadingModuleSensorState:
  i                    --> R22
  s                    --> Y,+6
  num                  --> R20
  slaveNum             --> R10
    02D18 2022      TST	R2
    02D19 F041      BEQ	0x2D22
    02D1A E00D      LDI	R16,0xD
    02D1B E010      LDI	R17,0
    02D1C 940E 9E0E CALL	_uart0SendChar
(0104) }
(0105) 
(0106) // 上传指定传感器状态信息
(0107) extern unsigned char CardSurplusState[6];	// 卡片剩余状态
(0108) extern unsigned char CardStoretate[6];		// 片仓状态
(0109) void UpLoadingModuleSensorState(unsigned char slaveNum, unsigned char num){
(0110) 	char s[2][2] = {"0","1"};
    02D1E E00A      LDI	R16,0xA
    02D1F E010      LDI	R17,0
    02D20 940E 9E0E CALL	_uart0SendChar
    02D22 2700      CLR	R16
    02D23 C00F      RJMP	0x2D33
    02D24 E088      LDI	R24,0x8
    02D25 9020 155A LDS	R2,UICmdBuf
    02D27 1582      CP	R24,R2
    02D28 F410      BCC	0x2D2B
(0111) 	unsigned char i;
(0112) 	switch(slaveNum){
    02D29 9380 155A STS	UICmdBuf,R24
    02D2B E088      LDI	R24,0x8
    02D2C 9020 157D LDS	R2,ControlCmd+23
    02D2E 1582      CP	R24,R2
    02D2F F410      BCC	0x2D32
    02D30 9380 157D STS	ControlCmd+23,R24
    02D32 E001      LDI	R16,1
    02D33 940C AEBC JMP	pop_xgsetF03C
_CommandExplain:
    02D35 940E AE97 CALL	push_xgsetF00C
    02D37 2F40      MOV	R20,R16
    02D38 9020 03ED LDS	R2,receiveSW
    02D3A 2022      TST	R2
    02D3B F429      BNE	0x2D41
    02D3C 3243      CPI	R20,0x23
    02D3D F419      BNE	0x2D41
    02D3E E081      LDI	R24,1
    02D3F 9380 03ED STS	receiveSW,R24
    02D41 9160 03ED LDS	R22,receiveSW
    02D43 2777      CLR	R23
    02D44 3060      CPI	R22,0
    02D45 0767      CPC	R22,R23
    02D46 F069      BEQ	0x2D54
    02D47 3061      CPI	R22,1
    02D48 E0E0      LDI	R30,0
    02D49 077E      CPC	R23,R30
    02D4A F009      BEQ	0x2D4C
    02D4B C008      RJMP	0x2D54
    02D4C 2F04      MOV	R16,R20
    02D4D DC91      RCALL	_UICommandExplain
    02D4E 2EA0      MOV	R10,R16
    02D4F 2300      TST	R16
    02D50 F419      BNE	0x2D54
    02D51 2422      CLR	R2
    02D52 9220 03ED STS	receiveSW,R2
    02D54 940C AE9E JMP	pop_xgsetF00C
_InitControlLayerData:
    02D56 934A      ST	-Y,R20
    02D57 2744      CLR	R20
    02D58 C015      RJMP	0x2D6E
    02D59 E003      LDI	R16,3
    02D5A 2F14      MOV	R17,R20
    02D5B 0301      MULSU	R16,R17
    02D5C ED89      LDI	R24,0xD9
(0113) 		case 0:		// 主控制板上的信号
(0114) 			switch(num){
    02D5D E195      LDI	R25,0x15
    02D5E 01F0      MOVW	R30,R0
    02D5F 0FE8      ADD	R30,R24
    02D60 1FF9      ADC	R31,R25
    02D61 EF80      LDI	R24,0xF0
    02D62 8380      ST	Z,R24
    02D63 0301      MULSU	R16,R17
    02D64 ED8A      LDI	R24,0xDA
    02D65 E195      LDI	R25,0x15
    02D66 01F0      MOVW	R30,R0
    02D67 0FE8      ADD	R30,R24
    02D68 1FF9      ADC	R31,R25
    02D69 EF8F      LDI	R24,0xFF
    02D6A E79F      LDI	R25,0x7F
    02D6B 8391      STD	Z+1,R25
    02D6C 8380      ST	Z,R24
    02D6D 9543      INC	R20
    02D6E 304F      CPI	R20,0xF
    02D6F F348      BCS	0x2D59
    02D70 2422      CLR	R2
    02D71 2433      CLR	R3
    02D72 9230 160B STS	EvenPosChangeProcess+1,R3
    02D74 9220 160A STS	EvenPosChangeProcess,R2
    02D76 9230 1609 STS	EvenLiquidProcess+1,R3
(0115) 				case 0:		// J4 取片检测开关信号
(0116) 					i = (PINL & 0x04);
    02D78 9220 1608 STS	EvenLiquidProcess,R2
(0117) 					if(i!=0)
    02D7A 9230 1607 STS	EvenCardStoreProcess+1,R3
(0118) 						i = 1;
    02D7C 9220 1606 STS	EvenCardStoreProcess,R2
    02D7E 9149      LD	R20,Y+
    02D7F 9508      RET
_GetRingPieceState:
    02D80 310E      CPI	R16,0x1E
(0119) 					Uart0ReUnable;
(0120) 					uart_Printf("%s $%2d $%2d $%c\r\n",strM4201, slaveNum, num, s[i][0]);
    02D81 F010      BCS	0x2D84
    02D82 EF0F      LDI	R16,0xFF
    02D83 C007      RJMP	0x2D8B
    02D84 E983      LDI	R24,0x93
    02D85 E195      LDI	R25,0x15
    02D86 2FE0      MOV	R30,R16
    02D87 27FF      CLR	R31
    02D88 0FE8      ADD	R30,R24
    02D89 1FF9      ADC	R31,R25
    02D8A 8100      LD	R16,Z
    02D8B 9508      RET
_GetStoreHumi:
    02D8C 9100 15B2 LDS	R16,StoreHumi
    02D8E 9508      RET
_GetStoreTemp:
    02D8F 9100 15B1 LDS	R16,StoreTemp
    02D91 9508      RET
_SetMotPosIdle:
    02D92 92AA      ST	-Y,R10
    02D93 2EA0      MOV	R10,R16
    02D94 E003      LDI	R16,3
    02D95 2D1A      MOV	R17,R10
    02D96 0301      MULSU	R16,R17
    02D97 ED89      LDI	R24,0xD9
    02D98 E195      LDI	R25,0x15
    02D99 01F0      MOVW	R30,R0
    02D9A 0FE8      ADD	R30,R24
(0121) 					Uart0ReEnable;
    02D9B 1FF9      ADC	R31,R25
    02D9C EF80      LDI	R24,0xF0
    02D9D 8380      ST	Z,R24
    02D9E 90A9      LD	R10,Y+
    02D9F 9508      RET
(0122) 					break;
_GetMotPositionOfSite:
    02DA0 92AA      ST	-Y,R10
(0123) 				case 1:		// J7 转盘干片检测光藕信号
(0124) 					i = PINK & 0x01;
    02DA1 2EA0      MOV	R10,R16
    02DA2 E003      LDI	R16,3
    02DA3 2D1A      MOV	R17,R10
(0125) 					if(i!=0)
    02DA4 0301      MULSU	R16,R17
(0126) 						i = 1;
    02DA5 ED89      LDI	R24,0xD9
(0127) 					Uart0ReUnable;
    02DA6 E195      LDI	R25,0x15
    02DA7 01F0      MOVW	R30,R0
    02DA8 0FE8      ADD	R30,R24
    02DA9 1FF9      ADC	R31,R25
    02DAA 8100      LD	R16,Z
(0128) 					uart_Printf("%s $%2d $%2d $%c\r\n",strM4201, slaveNum, num, s[i][0]);
    02DAB 90A9      LD	R10,Y+
    02DAC 9508      RET
_GetMotPositionOfStep:
    02DAD 92AA      ST	-Y,R10
    02DAE 2EA0      MOV	R10,R16
    02DAF E003      LDI	R16,3
    02DB0 2D1A      MOV	R17,R10
    02DB1 0301      MULSU	R16,R17
    02DB2 ED8A      LDI	R24,0xDA
    02DB3 E195      LDI	R25,0x15
    02DB4 01F0      MOVW	R30,R0
    02DB5 0FE8      ADD	R30,R24
    02DB6 1FF9      ADC	R31,R25
    02DB7 8100      LD	R16,Z
    02DB8 8111      LDD	R17,Z+1
    02DB9 90A9      LD	R10,Y+
    02DBA 9508      RET
_GetLiquidMonitorState:
    02DBB E083      LDI	R24,3
    02DBC 1780      CP	R24,R16
    02DBD F408      BCC	0x2DBF
    02DBE E003      LDI	R16,3
    02DBF EB83      LDI	R24,0xB3
    02DC0 E195      LDI	R25,0x15
    02DC1 2FE0      MOV	R30,R16
    02DC2 27FF      CLR	R31
    02DC3 0FEE      LSL	R30
    02DC4 1FFF      ROL	R31
(0129) 					Uart0ReEnable;
    02DC5 0FE8      ADD	R30,R24
    02DC6 1FF9      ADC	R31,R25
    02DC7 8100      LD	R16,Z
    02DC8 9508      RET
_GetLiquidMonitorStatePam:
    02DC9 E083      LDI	R24,3
(0130) 					break;
    02DCA 1780      CP	R24,R16
(0131) 				case 2:		// J8 废片盒开关信号
(0132) 					if(GetwasteCardState() == 0)// 废片仓功能开启
    02DCB F408      BCC	0x2DCD
    02DCC E003      LDI	R16,3
    02DCD EB84      LDI	R24,0xB4
    02DCE E195      LDI	R25,0x15
    02DCF 2FE0      MOV	R30,R16
(0133) 					{
(0134) 						i = PINK & 0x02;
    02DD0 27FF      CLR	R31
    02DD1 0FEE      LSL	R30
    02DD2 1FFF      ROL	R31
(0135) 						if(i!=0)
    02DD3 0FE8      ADD	R30,R24
(0136) 							i = 1;
    02DD4 1FF9      ADC	R31,R25
(0137) 						Uart0ReUnable;
    02DD5 8100      LD	R16,Z
    02DD6 9508      RET
_RegisterPosChangeEvenProcess:
    02DD7 9310 160B STS	EvenPosChangeProcess+1,R17
    02DD9 9300 160A STS	EvenPosChangeProcess,R16
(0138) 						uart_Printf("%s $%2d $%2d $%c\r\n",strM4201, slaveNum, num, s[i][0]);
    02DDB 9508      RET
_CleanPosChangeEvenProcess:
    02DDC 2422      CLR	R2
    02DDD 2433      CLR	R3
    02DDE 9230 160B STS	EvenPosChangeProcess+1,R3
    02DE0 9220 160A STS	EvenPosChangeProcess,R2
    02DE2 9508      RET
_RegisterLiquidEvenProcess:
    02DE3 9310 1609 STS	EvenLiquidProcess+1,R17
    02DE5 9300 1608 STS	EvenLiquidProcess,R16
    02DE7 9508      RET
_CleanLiquidEvenProcess:
    02DE8 2422      CLR	R2
    02DE9 2433      CLR	R3
    02DEA 9230 1609 STS	EvenLiquidProcess+1,R3
    02DEC 9220 1608 STS	EvenLiquidProcess,R2
    02DEE 9508      RET
_RegisterCardStoreEvenProcess:
    02DEF 9310 1607 STS	EvenCardStoreProcess+1,R17
    02DF1 9300 1606 STS	EvenCardStoreProcess,R16
    02DF3 9508      RET
(0139) 						Uart0ReEnable;
_CleanPosCardStoreProcess:
    02DF4 2422      CLR	R2
    02DF5 2433      CLR	R3
    02DF6 9230 1607 STS	EvenCardStoreProcess+1,R3
    02DF8 9220 1606 STS	EvenCardStoreProcess,R2
(0140) 					}
(0141) 					break;
    02DFA 9508      RET
_UpLoadingModuleSensorState:
    02DFB 940E AE97 CALL	push_xgsetF00C
    02DFD 2F42      MOV	R20,R18
    02DFE 2EA0      MOV	R10,R16
(0142) 				case 3:		// J10 液面传感器信号
(0143) 					Uart0ReUnable;
(0144) 					uart_Printf("%s $%2d $%2d $%4d\r\n",strM4201, slaveNum, num, getLiqDetADC(NeedleChannel));
    02DFF 972A      SBIW	R28,0xA
    02E00 EE8F      LDI	R24,0xEF
    02E01 E093      LDI	R25,3
    02E02 01FE      MOVW	R30,R28
    02E03 9636      ADIW	R30,6
    02E04 E004      LDI	R16,4
    02E05 E010      LDI	R17,0
    02E06 93FA      ST	-Y,R31
    02E07 93EA      ST	-Y,R30
    02E08 939A      ST	-Y,R25
    02E09 938A      ST	-Y,R24
    02E0A 940E AEFC CALL	asgnblk
    02E0C 2D6A      MOV	R22,R10
    02E0D 2777      CLR	R23
    02E0E 3060      CPI	R22,0
    02E0F 0767      CPC	R22,R23
    02E10 F409      BNE	0x2E12
    02E11 C02E      RJMP	0x2E40
(0145) 					Uart0ReEnable;
    02E12 3061      CPI	R22,1
    02E13 E0E0      LDI	R30,0
    02E14 077E      CPC	R23,R30
    02E15 F409      BNE	0x2E17
    02E16 C10E      RJMP	0x2F25
(0146) 					break;
    02E17 3062      CPI	R22,2
(0147) 				case 4:		// J12 吸样开关信号
(0148) 					i = PINJ & 0x40;
    02E18 E0E0      LDI	R30,0
    02E19 077E      CPC	R23,R30
    02E1A F409      BNE	0x2E1C
(0149) 					if(i!=0)
    02E1B C109      RJMP	0x2F25
(0150) 						i = 1;
    02E1C 3063      CPI	R22,3
(0151) 					Uart0ReUnable;
    02E1D E0E0      LDI	R30,0
    02E1E 077E      CPC	R23,R30
    02E1F F409      BNE	0x2E21
    02E20 C104      RJMP	0x2F25
    02E21 3064      CPI	R22,4
(0152) 					uart_Printf("%s $%2d $%2d $%c\r\n",strM4201, slaveNum, num, s[i][0]);
    02E22 E0E0      LDI	R30,0
    02E23 077E      CPC	R23,R30
    02E24 F409      BNE	0x2E26
    02E25 C0FF      RJMP	0x2F25
    02E26 3065      CPI	R22,5
    02E27 E0E0      LDI	R30,0
    02E28 077E      CPC	R23,R30
    02E29 F409      BNE	0x2E2B
    02E2A C0FA      RJMP	0x2F25
    02E2B 3068      CPI	R22,0x8
    02E2C E0E0      LDI	R30,0
    02E2D 077E      CPC	R23,R30
    02E2E F409      BNE	0x2E30
    02E2F C0F5      RJMP	0x2F25
    02E30 306C      CPI	R22,0xC
    02E31 E0E0      LDI	R30,0
    02E32 077E      CPC	R23,R30
    02E33 F409      BNE	0x2E35
    02E34 C0F0      RJMP	0x2F25
    02E35 306D      CPI	R22,0xD
    02E36 E0E0      LDI	R30,0
    02E37 077E      CPC	R23,R30
    02E38 F409      BNE	0x2E3A
    02E39 C124      RJMP	0x2F5E
    02E3A 306E      CPI	R22,0xE
    02E3B E0E0      LDI	R30,0
(0153) 					Uart0ReEnable;
    02E3C 077E      CPC	R23,R30
    02E3D F409      BNE	0x2E3F
    02E3E C156      RJMP	0x2F95
    02E3F C1A7      RJMP	0x2FE7
    02E40 2F64      MOV	R22,R20
(0154) 					break;
(0155) 				}
(0156) 			break;
    02E41 2777      CLR	R23
(0157) 		case MOT_TURN_PLATE:
(0158) 		case MOT_SAMP_TRUN:
(0159) 		case MOT_SAMP_NEEDLE:
(0160) 		case MOT_CARD_LOAD:
(0161) 		case MOT_CARD_UNLOAD:
(0162) 		case MOT_STORE_CARD_MOVE:
(0163) 		case MOT_SAMP_PUMP:
(0164) 			if(num>1)
    02E42 3060      CPI	R22,0
    02E43 0767      CPC	R22,R23
    02E44 F0A9      BEQ	0x2E5A
(0165) 				num = 1;
    02E45 3061      CPI	R22,1
(0166) 			i = MotModulePhoSta[slaveNum][num];
    02E46 E0E0      LDI	R30,0
    02E47 077E      CPC	R23,R30
    02E48 F409      BNE	0x2E4A
    02E49 C03A      RJMP	0x2E84
    02E4A 3062      CPI	R22,2
    02E4B E0E0      LDI	R30,0
    02E4C 077E      CPC	R23,R30
    02E4D F409      BNE	0x2E4F
    02E4E C05F      RJMP	0x2EAE
    02E4F 3063      CPI	R22,3
    02E50 E0E0      LDI	R30,0
    02E51 077E      CPC	R23,R30
    02E52 F409      BNE	0x2E54
(0167) 			if(i!=0)
    02E53 C089      RJMP	0x2EDD
    02E54 3064      CPI	R22,4
(0168) 				i = 1;
    02E55 E0E0      LDI	R30,0
(0169) 			// 发送电机模块光藕信号
(0170) 			Uart0ReUnable;
    02E56 077E      CPC	R23,R30
    02E57 F409      BNE	0x2E59
    02E58 C0A2      RJMP	0x2EFB
    02E59 C18D      RJMP	0x2FE7
    02E5A 9160 0109 LDS	R22,0x109
(0171) 			uart_Printf("%s $%2d $%2d $%c\r\n",strM4201, slaveNum, num, s[i][0]);
    02E5C 7064      ANDI	R22,4
    02E5D F009      BEQ	0x2E5F
    02E5E E061      LDI	R22,1
    02E5F 9180 00C1 LDS	R24,0xC1
    02E61 7E8F      ANDI	R24,0xEF
    02E62 9380 00C1 STS	0xC1,R24
    02E64 01CE      MOVW	R24,R28
    02E65 9606      ADIW	R24,6
    02E66 2FE6      MOV	R30,R22
    02E67 27FF      CLR	R31
    02E68 0FEE      LSL	R30
    02E69 1FFF      ROL	R31
    02E6A 0FE8      ADD	R30,R24
    02E6B 1FF9      ADC	R31,R25
    02E6C 8020      LD	R2,Z
    02E6D 2433      CLR	R3
    02E6E 823D      STD	Y+5,R3
    02E6F 822C      STD	Y+4,R2
    02E70 2E24      MOV	R2,R20
    02E71 2433      CLR	R3
    02E72 823B      STD	Y+3,R3
    02E73 822A      STD	Y+2,R2
    02E74 2C2A      MOV	R2,R10
(0172) 			Uart0ReEnable;
    02E75 2433      CLR	R3
    02E76 8239      STD	Y+1,R3
    02E77 8228      ST	Y,R2
    02E78 EB2D      LDI	R18,0xBD
    02E79 E13A      LDI	R19,0x1A
(0173) 			break;
    02E7A E102      LDI	R16,0x12
(0174) 		case LIQUID_CONTROL:
(0175) 			if(num>2)
    02E7B E015      LDI	R17,5
    02E7C 940E A90D CALL	_uart_Printf
(0176) 				num = 2;
    02E7E 9180 00C1 LDS	R24,0xC1
(0177) 			// 发送液路状态信号
(0178) 			if(LiquidState[num][0] == INFO_LIQ_FULL)
    02E80 6180      ORI	R24,0x10
    02E81 9380 00C1 STS	0xC1,R24
    02E83 C163      RJMP	0x2FE7
    02E84 9160 0106 LDS	R22,0x106
    02E86 7061      ANDI	R22,1
    02E87 F009      BEQ	0x2E89
    02E88 E061      LDI	R22,1
    02E89 9180 00C1 LDS	R24,0xC1
(0179) 				i = 1;
    02E8B 7E8F      ANDI	R24,0xEF
(0180) 			else
(0181) 				i = 0;
    02E8C 9380 00C1 STS	0xC1,R24
(0182) 			Uart0ReUnable;
    02E8E 01CE      MOVW	R24,R28
    02E8F 9606      ADIW	R24,6
    02E90 2FE6      MOV	R30,R22
    02E91 27FF      CLR	R31
(0183) 			uart_Printf("%s $%2d $%2d $%c\r\n",strM4201, slaveNum, num, s[i][0]);
    02E92 0FEE      LSL	R30
    02E93 1FFF      ROL	R31
    02E94 0FE8      ADD	R30,R24
    02E95 1FF9      ADC	R31,R25
    02E96 8020      LD	R2,Z
    02E97 2433      CLR	R3
    02E98 823D      STD	Y+5,R3
    02E99 822C      STD	Y+4,R2
    02E9A 2E24      MOV	R2,R20
    02E9B 2433      CLR	R3
    02E9C 823B      STD	Y+3,R3
    02E9D 822A      STD	Y+2,R2
    02E9E 2C2A      MOV	R2,R10
    02E9F 2433      CLR	R3
    02EA0 8239      STD	Y+1,R3
    02EA1 8228      ST	Y,R2
    02EA2 EB2D      LDI	R18,0xBD
    02EA3 E13A      LDI	R19,0x1A
    02EA4 E102      LDI	R16,0x12
    02EA5 E015      LDI	R17,5
    02EA6 940E A90D CALL	_uart_Printf
    02EA8 9180 00C1 LDS	R24,0xC1
    02EAA 6180      ORI	R24,0x10
    02EAB 9380 00C1 STS	0xC1,R24
(0184) 			Uart0ReEnable;
    02EAD C139      RJMP	0x2FE7
    02EAE 940E A99B CALL	_GetwasteCardState
    02EB0 2300      TST	R16
(0185) 			break;
    02EB1 F009      BEQ	0x2EB3
(0186) 		case STORE_MONITOR:
(0187) 			if(num>4)
    02EB2 C134      RJMP	0x2FE7
    02EB3 9160 0106 LDS	R22,0x106
(0188) 				num = 4;
    02EB5 7062      ANDI	R22,2
(0189) 			if(CardStoretate[num] == INFO_STORE_OPEN)
    02EB6 F009      BEQ	0x2EB8
    02EB7 E061      LDI	R22,1
    02EB8 9180 00C1 LDS	R24,0xC1
    02EBA 7E8F      ANDI	R24,0xEF
    02EBB 9380 00C1 STS	0xC1,R24
    02EBD 01CE      MOVW	R24,R28
    02EBE 9606      ADIW	R24,6
(0190) 			{
(0191) 				Uart0ReUnable;
    02EBF 2FE6      MOV	R30,R22
    02EC0 27FF      CLR	R31
    02EC1 0FEE      LSL	R30
    02EC2 1FFF      ROL	R31
    02EC3 0FE8      ADD	R30,R24
(0192) 				uart_Printf("%s $%2d $%2d $%4d\r\n",strM4201, slaveNum, num, CardStoretate[num]);
    02EC4 1FF9      ADC	R31,R25
    02EC5 8020      LD	R2,Z
    02EC6 2433      CLR	R3
    02EC7 823D      STD	Y+5,R3
    02EC8 822C      STD	Y+4,R2
    02EC9 2E24      MOV	R2,R20
    02ECA 2433      CLR	R3
    02ECB 823B      STD	Y+3,R3
    02ECC 822A      STD	Y+2,R2
    02ECD 2C2A      MOV	R2,R10
    02ECE 2433      CLR	R3
    02ECF 8239      STD	Y+1,R3
    02ED0 8228      ST	Y,R2
    02ED1 EB2D      LDI	R18,0xBD
    02ED2 E13A      LDI	R19,0x1A
    02ED3 E102      LDI	R16,0x12
    02ED4 E015      LDI	R17,5
    02ED5 940E A90D CALL	_uart_Printf
    02ED7 9180 00C1 LDS	R24,0xC1
    02ED9 6180      ORI	R24,0x10
    02EDA 9380 00C1 STS	0xC1,R24
(0193) 				Uart0ReEnable;
    02EDC C10A      RJMP	0x2FE7
    02EDD 9180 00C1 LDS	R24,0xC1
    02EDF 7E8F      ANDI	R24,0xEF
    02EE0 9380 00C1 STS	0xC1,R24
(0194) 			}
    02EE2 2700      CLR	R16
    02EE3 940E 9A52 CALL	_getLiqDetADC
    02EE5 831D      STD	Y+5,R17
    02EE6 830C      STD	Y+4,R16
(0195) 			else
(0196) 			{
(0197) 				Uart0ReUnable;
(0198) 				uart_Printf("%s $%2d $%2d $%4d\r\n",strM4201, slaveNum, num, CardSurplusState[num]);
    02EE7 2E24      MOV	R2,R20
    02EE8 2433      CLR	R3
    02EE9 823B      STD	Y+3,R3
    02EEA 822A      STD	Y+2,R2
    02EEB 2C2A      MOV	R2,R10
    02EEC 2433      CLR	R3
    02EED 8239      STD	Y+1,R3
    02EEE 8228      ST	Y,R2
    02EEF EB2D      LDI	R18,0xBD
    02EF0 E13A      LDI	R19,0x1A
    02EF1 EF0E      LDI	R16,0xFE
    02EF2 E014      LDI	R17,4
    02EF3 940E A90D CALL	_uart_Printf
    02EF5 9180 00C1 LDS	R24,0xC1
    02EF7 6180      ORI	R24,0x10
    02EF8 9380 00C1 STS	0xC1,R24
    02EFA C0EC      RJMP	0x2FE7
    02EFB 9160 0103 LDS	R22,0x103
    02EFD 7460      ANDI	R22,0x40
    02EFE F009      BEQ	0x2F00
(0199) 				Uart0ReEnable;
    02EFF E061      LDI	R22,1
    02F00 9180 00C1 LDS	R24,0xC1
    02F02 7E8F      ANDI	R24,0xEF
    02F03 9380 00C1 STS	0xC1,R24
(0200) 			}
(0201) 			break;
(0202) 		default:
(0203) 			break;
    02F05 01CE      MOVW	R24,R28
    02F06 9606      ADIW	R24,6
_UpLoadingAllSensorState:
  s                    --> Y,+0
  i                    --> R10
  f                    --> R22
  n                    --> R20
    02F07 2FE6      MOV	R30,R22
    02F08 27FF      CLR	R31
    02F09 0FEE      LSL	R30
(0204) 		}
(0205) }
(0206) 
(0207) // 上传所有传感器信息
(0208) void UpLoadingAllSensorState(void){
(0209) 	char s[2][2] = {"0","1"};
    02F0A 1FFF      ROL	R31
    02F0B 0FE8      ADD	R30,R24
    02F0C 1FF9      ADC	R31,R25
    02F0D 8020      LD	R2,Z
    02F0E 2433      CLR	R3
    02F0F 823D      STD	Y+5,R3
    02F10 822C      STD	Y+4,R2
    02F11 2E24      MOV	R2,R20
    02F12 2433      CLR	R3
    02F13 823B      STD	Y+3,R3
    02F14 822A      STD	Y+2,R2
(0210) 	unsigned char i,n, f;
(0211) 	Uart0ReUnable;
    02F15 2C2A      MOV	R2,R10
    02F16 2433      CLR	R3
    02F17 8239      STD	Y+1,R3
    02F18 8228      ST	Y,R2
    02F19 EB2D      LDI	R18,0xBD
(0212) 	uart_Printf("%s",strM4202);	// 发送开始
    02F1A E13A      LDI	R19,0x1A
    02F1B E102      LDI	R16,0x12
    02F1C E015      LDI	R17,5
    02F1D 940E A90D CALL	_uart_Printf
    02F1F 9180 00C1 LDS	R24,0xC1
(0213) 	Uart0ReEnable;
    02F21 6180      ORI	R24,0x10
    02F22 9380 00C1 STS	0xC1,R24
    02F24 C0C2      RJMP	0x2FE7
(0214) 	// 发送电机模块光藕信息
(0215) 	for(i=1; i<=12; i++){
    02F25 E081      LDI	R24,1
    02F26 1784      CP	R24,R20
    02F27 F408      BCC	0x2F29
(0216) 		if(i==6 || i==7)
    02F28 E041      LDI	R20,1
    02F29 EB8B      LDI	R24,0xBB
    02F2A E195      LDI	R25,0x15
    02F2B 2C2A      MOV	R2,R10
    02F2C 2433      CLR	R3
(0217) 			continue;
    02F2D 0C22      LSL	R2
(0218) 		for(n=0; n<2; n++)
    02F2E 1C33      ROL	R3
    02F2F 0E28      ADD	R2,R24
(0219) 		{
(0220) 			f = MotModulePhoSta[i][n];
    02F30 1E39      ADC	R3,R25
    02F31 2FE4      MOV	R30,R20
    02F32 27FF      CLR	R31
    02F33 0DE2      ADD	R30,R2
    02F34 1DF3      ADC	R31,R3
    02F35 8160      LD	R22,Z
    02F36 2366      TST	R22
    02F37 F009      BEQ	0x2F39
    02F38 E061      LDI	R22,1
    02F39 9180 00C1 LDS	R24,0xC1
    02F3B 7E8F      ANDI	R24,0xEF
    02F3C 9380 00C1 STS	0xC1,R24
(0221) 			if(f!=0)
    02F3E 01CE      MOVW	R24,R28
(0222) 				f = 1;
    02F3F 9606      ADIW	R24,6
(0223) 			// 发送电机模块光藕信号
(0224) 			Uart0ReUnable;
    02F40 2FE6      MOV	R30,R22
    02F41 27FF      CLR	R31
    02F42 0FEE      LSL	R30
    02F43 1FFF      ROL	R31
    02F44 0FE8      ADD	R30,R24
(0225) 			uart_Printf(" $%c",s[f][0]);
    02F45 1FF9      ADC	R31,R25
    02F46 8020      LD	R2,Z
    02F47 2433      CLR	R3
    02F48 823D      STD	Y+5,R3
    02F49 822C      STD	Y+4,R2
    02F4A 2E24      MOV	R2,R20
    02F4B 2433      CLR	R3
    02F4C 823B      STD	Y+3,R3
    02F4D 822A      STD	Y+2,R2
    02F4E 2C2A      MOV	R2,R10
    02F4F 2433      CLR	R3
    02F50 8239      STD	Y+1,R3
    02F51 8228      ST	Y,R2
(0226) 			Uart0ReEnable;
    02F52 EB2D      LDI	R18,0xBD
    02F53 E13A      LDI	R19,0x1A
    02F54 E102      LDI	R16,0x12
    02F55 E015      LDI	R17,5
    02F56 940E A90D CALL	_uart_Printf
    02F58 9180 00C1 LDS	R24,0xC1
    02F5A 6180      ORI	R24,0x10
    02F5B 9380 00C1 STS	0xC1,R24
    02F5D C089      RJMP	0x2FE7
    02F5E E082      LDI	R24,2
(0227) 		}
(0228) 	}
(0229) 	// 发送液路模块信息
(0230) 	i = 13;
    02F5F 1784      CP	R24,R20
    02F60 F408      BCC	0x2F62
(0231) 	for(n=0; n<3; n++)
    02F61 E042      LDI	R20,2
    02F62 EB83      LDI	R24,0xB3
(0232) 	{
(0233) 		if(LiquidState[n][0] == INFO_LIQ_FULL)
    02F63 E195      LDI	R25,0x15
    02F64 2FE4      MOV	R30,R20
    02F65 27FF      CLR	R31
    02F66 0FEE      LSL	R30
    02F67 1FFF      ROL	R31
    02F68 0FE8      ADD	R30,R24
    02F69 1FF9      ADC	R31,R25
    02F6A 8180      LD	R24,Z
    02F6B 308F      CPI	R24,0xF
    02F6C F411      BNE	0x2F6F
    02F6D E061      LDI	R22,1
(0234) 			f = 1;
    02F6E C001      RJMP	0x2F70
    02F6F 2766      CLR	R22
(0235) 		else
(0236) 			f = 0;
    02F70 9180 00C1 LDS	R24,0xC1
(0237) 		Uart0ReUnable;
    02F72 7E8F      ANDI	R24,0xEF
    02F73 9380 00C1 STS	0xC1,R24
    02F75 01CE      MOVW	R24,R28
(0238) 		uart_Printf(" $%c",s[f][0]);
    02F76 9606      ADIW	R24,6
    02F77 2FE6      MOV	R30,R22
    02F78 27FF      CLR	R31
    02F79 0FEE      LSL	R30
    02F7A 1FFF      ROL	R31
    02F7B 0FE8      ADD	R30,R24
    02F7C 1FF9      ADC	R31,R25
    02F7D 8020      LD	R2,Z
    02F7E 2433      CLR	R3
    02F7F 823D      STD	Y+5,R3
    02F80 822C      STD	Y+4,R2
    02F81 2E24      MOV	R2,R20
    02F82 2433      CLR	R3
(0239) 		Uart0ReEnable;
    02F83 823B      STD	Y+3,R3
    02F84 822A      STD	Y+2,R2
    02F85 2C2A      MOV	R2,R10
    02F86 2433      CLR	R3
    02F87 8239      STD	Y+1,R3
    02F88 8228      ST	Y,R2
    02F89 EB2D      LDI	R18,0xBD
    02F8A E13A      LDI	R19,0x1A
(0240) 	}
(0241) 	// 发送片仓模块信息
(0242) 	i = 14;
    02F8B E102      LDI	R16,0x12
    02F8C E015      LDI	R17,5
(0243) 	for(n=0; n<5; n++){
    02F8D 940E A90D CALL	_uart_Printf
(0244) 		if(CardStoretate[n] == INFO_STORE_OPEN)
    02F8F 9180 00C1 LDS	R24,0xC1
    02F91 6180      ORI	R24,0x10
    02F92 9380 00C1 STS	0xC1,R24
    02F94 C052      RJMP	0x2FE7
    02F95 E084      LDI	R24,4
    02F96 1784      CP	R24,R20
    02F97 F408      BCC	0x2F99
(0245) 		{
(0246) 			Uart0ReUnable;
    02F98 E044      LDI	R20,4
    02F99 E486      LDI	R24,0x46
    02F9A E195      LDI	R25,0x15
    02F9B 2FE4      MOV	R30,R20
    02F9C 27FF      CLR	R31
(0247) 			uart_Printf(" $%2d",CardStoretate[n]);
    02F9D 0FE8      ADD	R30,R24
    02F9E 1FF9      ADC	R31,R25
    02F9F 8180      LD	R24,Z
    02FA0 3184      CPI	R24,0x14
    02FA1 F519      BNE	0x2FC5
    02FA2 9180 00C1 LDS	R24,0xC1
    02FA4 7E8F      ANDI	R24,0xEF
    02FA5 9380 00C1 STS	0xC1,R24
    02FA7 E486      LDI	R24,0x46
    02FA8 E195      LDI	R25,0x15
(0248) 			Uart0ReEnable;
    02FA9 2FE4      MOV	R30,R20
    02FAA 27FF      CLR	R31
    02FAB 0FE8      ADD	R30,R24
    02FAC 1FF9      ADC	R31,R25
    02FAD 8020      LD	R2,Z
(0249) 		}
    02FAE 2433      CLR	R3
(0250) 		else
(0251) 		{
(0252) 			Uart0ReUnable;
    02FAF 823D      STD	Y+5,R3
    02FB0 822C      STD	Y+4,R2
    02FB1 2E24      MOV	R2,R20
    02FB2 2433      CLR	R3
    02FB3 823B      STD	Y+3,R3
(0253) 			uart_Printf(" $%2d",CardSurplusState[n]);
    02FB4 822A      STD	Y+2,R2
    02FB5 2C2A      MOV	R2,R10
    02FB6 2433      CLR	R3
    02FB7 8239      STD	Y+1,R3
    02FB8 8228      ST	Y,R2
    02FB9 EB2D      LDI	R18,0xBD
    02FBA E13A      LDI	R19,0x1A
    02FBB EF0E      LDI	R16,0xFE
    02FBC E014      LDI	R17,4
    02FBD 940E A90D CALL	_uart_Printf
    02FBF 9180 00C1 LDS	R24,0xC1
(0254) 			Uart0ReEnable;
    02FC1 6180      ORI	R24,0x10
    02FC2 9380 00C1 STS	0xC1,R24
    02FC4 C022      RJMP	0x2FE7
    02FC5 9180 00C1 LDS	R24,0xC1
    02FC7 7E8F      ANDI	R24,0xEF
    02FC8 9380 00C1 STS	0xC1,R24
(0255) 		}
(0256) 	}
(0257) 	//发送其它模块信息
(0258) 	i = 0;
    02FCA E48C      LDI	R24,0x4C
    02FCB E195      LDI	R25,0x15
(0259) 	for(n=0; n<5; n++){
(0260) 		switch(n){
    02FCC 2FE4      MOV	R30,R20
    02FCD 27FF      CLR	R31
    02FCE 0FE8      ADD	R30,R24
    02FCF 1FF9      ADC	R31,R25
    02FD0 8020      LD	R2,Z
    02FD1 2433      CLR	R3
    02FD2 823D      STD	Y+5,R3
    02FD3 822C      STD	Y+4,R2
    02FD4 2E24      MOV	R2,R20
    02FD5 2433      CLR	R3
    02FD6 823B      STD	Y+3,R3
    02FD7 822A      STD	Y+2,R2
    02FD8 2C2A      MOV	R2,R10
    02FD9 2433      CLR	R3
    02FDA 8239      STD	Y+1,R3
    02FDB 8228      ST	Y,R2
    02FDC EB2D      LDI	R18,0xBD
    02FDD E13A      LDI	R19,0x1A
    02FDE EF0E      LDI	R16,0xFE
    02FDF E014      LDI	R17,4
    02FE0 940E A90D CALL	_uart_Printf
    02FE2 9180 00C1 LDS	R24,0xC1
    02FE4 6180      ORI	R24,0x10
    02FE5 9380 00C1 STS	0xC1,R24
(0261) 			case 0:		// J4 取片检测开关信号
(0262) 				f = (PINL & 0x04);
    02FE7 962A      ADIW	R28,0xA
    02FE8 940C AE9E JMP	pop_xgsetF00C
(0263) 				if(f!=0)
_GetMotorMonitorState:
    02FEA 940E AE97 CALL	push_xgsetF00C
(0264) 					f = 1;
    02FEC 2F42      MOV	R20,R18
    02FED 2F60      MOV	R22,R16
    02FEE 9722      SBIW	R28,2
    02FEF 2366      TST	R22
    02FF0 F021      BEQ	0x2FF5
(0265) 				Uart0ReUnable;
(0266) 				uart_Printf(" $%c",s[f][0]);
    02FF1 3066      CPI	R22,6
    02FF2 F011      BEQ	0x2FF5
    02FF3 3067      CPI	R22,7
    02FF4 F411      BNE	0x2FF7
    02FF5 EF0F      LDI	R16,0xFF
    02FF6 C0B2      RJMP	0x30A9
    02FF7 E081      LDI	R24,1
    02FF8 1784      CP	R24,R20
    02FF9 F408      BCC	0x2FFB
    02FFA E041      LDI	R20,1
    02FFB 9180 00C1 LDS	R24,0xC1
    02FFD 7E8F      ANDI	R24,0xEF
(0267) 				Uart0ReEnable;
    02FFE 9380 00C1 STS	0xC1,R24
    03000 E126      LDI	R18,0x16
    03001 E133      LDI	R19,0x13
    03002 EF0B      LDI	R16,0xFB
(0268) 				break;
    03003 E014      LDI	R17,4
(0269) 			case 1:		// J7 转盘干片检测光藕信号
(0270) 				f = PINK & 0x01;
    03004 940E A90D CALL	_uart_Printf
    03006 2EA6      MOV	R10,R22
(0271) 				if(f!=0)
    03007 24BB      CLR	R11
(0272) 					f = 1;
    03008 01C5      MOVW	R24,R10
(0273) 				Uart0ReUnable;
    03009 3081      CPI	R24,1
    0300A E0E0      LDI	R30,0
    0300B 079E      CPC	R25,R30
    0300C F409      BNE	0x300E
    0300D C038      RJMP	0x3046
(0274) 				uart_Printf(" $%c",s[f][0]);
    0300E 3082      CPI	R24,2
    0300F E0E0      LDI	R30,0
    03010 079E      CPC	R25,R30
    03011 F409      BNE	0x3013
    03012 C038      RJMP	0x304B
    03013 3083      CPI	R24,3
    03014 E0E0      LDI	R30,0
    03015 079E      CPC	R25,R30
    03016 F409      BNE	0x3018
    03017 C038      RJMP	0x3050
    03018 3084      CPI	R24,4
    03019 E0E0      LDI	R30,0
    0301A 079E      CPC	R25,R30
(0275) 				Uart0ReEnable;
    0301B F409      BNE	0x301D
    0301C C038      RJMP	0x3055
    0301D 3085      CPI	R24,5
    0301E E0E0      LDI	R30,0
    0301F 079E      CPC	R25,R30
(0276) 				break;
    03020 F409      BNE	0x3022
(0277) 			case 2:		// J8 废片盒开关信号
(0278) 				if(GetwasteCardState() == 0)
    03021 C038      RJMP	0x305A
    03022 3088      CPI	R24,0x8
    03023 E0E0      LDI	R30,0
    03024 079E      CPC	R25,R30
    03025 F409      BNE	0x3027
(0279) 				{
(0280) 					f = PINK & 0x02;
    03026 C038      RJMP	0x305F
    03027 3089      CPI	R24,0x9
    03028 E0E0      LDI	R30,0
(0281) 					if(f!=0)
    03029 079E      CPC	R25,R30
(0282) 						f = 1;
    0302A F409      BNE	0x302C
(0283) 					Uart0ReUnable;
    0302B C038      RJMP	0x3064
    0302C 308A      CPI	R24,0xA
    0302D E0E0      LDI	R30,0
    0302E 079E      CPC	R25,R30
    0302F F409      BNE	0x3031
(0284) 					uart_Printf(" $%c",s[f][0]);
    03030 C038      RJMP	0x3069
    03031 308B      CPI	R24,0xB
    03032 E0E0      LDI	R30,0
    03033 079E      CPC	R25,R30
    03034 F409      BNE	0x3036
    03035 C038      RJMP	0x306E
    03036 308C      CPI	R24,0xC
    03037 E0E0      LDI	R30,0
    03038 079E      CPC	R25,R30
    03039 F409      BNE	0x303B
    0303A C038      RJMP	0x3073
    0303B 308D      CPI	R24,0xD
    0303C E0E0      LDI	R30,0
(0285) 					Uart0ReEnable;
    0303D 079E      CPC	R25,R30
    0303E F409      BNE	0x3040
    0303F C038      RJMP	0x3078
    03040 308E      CPI	R24,0xE
    03041 E0E0      LDI	R30,0
(0286) 				}
(0287) 				break;
    03042 079E      CPC	R25,R30
(0288) 			case 3:		// J10 液面传感器信号
(0289) 				Uart0ReUnable;
    03043 F409      BNE	0x3045
    03044 C038      RJMP	_SlaveEventAssignProcess
    03045 C03B      RJMP	0x3081
    03046 EE0B      LDI	R16,0xEB
    03047 E014      LDI	R17,4
(0290) 				uart_Printf(" $%4d",getLiqDetADC(NeedleChannel));
    03048 940E A90D CALL	_uart_Printf
    0304A C036      RJMP	0x3081
    0304B ED0C      LDI	R16,0xDC
    0304C E014      LDI	R17,4
    0304D 940E A90D CALL	_uart_Printf
    0304F C031      RJMP	0x3081
(0291) 				Uart0ReEnable;
    03050 EC0B      LDI	R16,0xCB
    03051 E014      LDI	R17,4
    03052 940E A90D CALL	_uart_Printf
    03054 C02C      RJMP	0x3081
(0292) 				break;
    03055 EB0C      LDI	R16,0xBC
(0293) 			case 4:		// J12 吸样开关信号
(0294) 				f = PINJ & 0x40;
    03056 E014      LDI	R17,4
    03057 940E A90D CALL	_uart_Printf
(0295) 				if(f!=0)
    03059 C027      RJMP	0x3081
(0296) 					f = 1;
    0305A EA0B      LDI	R16,0xAB
(0297) 				Uart0ReUnable;
    0305B E014      LDI	R17,4
    0305C 940E A90D CALL	_uart_Printf
    0305E C022      RJMP	0x3081
    0305F E906      LDI	R16,0x96
(0298) 				uart_Printf(" $%c",s[f][0]);
    03060 E014      LDI	R17,4
    03061 940E A90D CALL	_uart_Printf
    03063 C01D      RJMP	0x3081
    03064 E809      LDI	R16,0x89
    03065 E014      LDI	R17,4
    03066 940E A90D CALL	_uart_Printf
    03068 C018      RJMP	0x3081
    03069 E70E      LDI	R16,0x7E
    0306A E014      LDI	R17,4
    0306B 940E A90D CALL	_uart_Printf
(0299) 				Uart0ReEnable;
    0306D C013      RJMP	0x3081
    0306E E700      LDI	R16,0x70
    0306F E014      LDI	R17,4
    03070 940E A90D CALL	_uart_Printf
    03072 C00E      RJMP	0x3081
    03073 E601      LDI	R16,0x61
    03074 E014      LDI	R17,4
    03075 940E A90D CALL	_uart_Printf
(0300) 				break;
(0301) 			}
(0302) 		}
(0303) 	uart_Printf("\r\n");	// 发送结束
    03077 C009      RJMP	0x3081
    03078 E501      LDI	R16,0x51
    03079 E014      LDI	R17,4
    0307A 940E A90D CALL	_uart_Printf
    0307C C004      RJMP	0x3081
_SlaveEventAssignProcess:
  j                    --> Y,+5
  p                    --> Y,+5
  infoLen              --> Y,+5
  pos                  --> R22
  i                    --> R22
  curSlave             --> R14
  pInfo                --> R20
  even                 --> R12
  pInfoEvent           --> R10
    0307D E402      LDI	R16,0x42
    0307E E014      LDI	R17,4
    0307F 940E A90D CALL	_uart_Printf
(0304) }
(0305) 
(0306) // 从机事件处理和分配
(0307) void SlaveEventAssignProcess(INFO_EVENT * pInfoEvent){
(0308) 	// 事件分配处理
(0309) 	unsigned char curSlave, infoLen;
(0310) 	unsigned char * pInfo, *p;
(0311) 	int pos;
(0312) 	unsigned char even;
(0313) 	unsigned char i, j;
(0314) 	static unsigned char pieceState;
(0315) 
(0316) 	curSlave = pInfoEvent->slaveNum;
    03081 EB8B      LDI	R24,0xBB
    03082 E195      LDI	R25,0x15
(0317) 	even = pInfoEvent->event;
    03083 2E26      MOV	R2,R22
(0318) 	pInfo = &(pInfoEvent->info[0]);
    03084 2433      CLR	R3
    03085 0C22      LSL	R2
    03086 1C33      ROL	R3
(0319) 	
(0320) 	switch(even)
    03087 0E28      ADD	R2,R24
    03088 1E39      ADC	R3,R25
    03089 2FE4      MOV	R30,R20
    0308A 27FF      CLR	R31
    0308B 0DE2      ADD	R30,R2
    0308C 1DF3      ADC	R31,R3
    0308D 8020      LD	R2,Z
    0308E 2433      CLR	R3
    0308F 8239      STD	Y+1,R3
    03090 8228      ST	Y,R2
    03091 2F24      MOV	R18,R20
    03092 2733      CLR	R19
    03093 E306      LDI	R16,0x36
    03094 E014      LDI	R17,4
    03095 940E A90D CALL	_uart_Printf
    03097 9180 00C1 LDS	R24,0xC1
    03099 6180      ORI	R24,0x10
    0309A 9380 00C1 STS	0xC1,R24
    0309C EB8B      LDI	R24,0xBB
    0309D E195      LDI	R25,0x15
    0309E 2E26      MOV	R2,R22
    0309F 2433      CLR	R3
(0321) 	{
(0322) 		case STA_CHANGE_POS:
(0323) 		case STA_INFO_POS:
(0324) 			pos = *(pInfo+1);
    030A0 0C22      LSL	R2
    030A1 1C33      ROL	R3
    030A2 0E28      ADD	R2,R24
(0325) 			pos = pos << 8;
    030A3 1E39      ADC	R3,R25
    030A4 2FE4      MOV	R30,R20
(0326) 			pos += *(pInfo+2);
    030A5 27FF      CLR	R31
    030A6 0DE2      ADD	R30,R2
    030A7 1DF3      ADC	R31,R3
    030A8 8100      LD	R16,Z
(0327) 			MotorPosition[curSlave].defPosNum = *(pInfo);
    030A9 9622      ADIW	R28,2
    030AA 940C AE9E JMP	pop_xgsetF00C
_UpLoadingAllSensorState:
    030AC 940E AE97 CALL	push_xgsetF00C
    030AE 9724      SBIW	R28,4
    030AF EF83      LDI	R24,0xF3
    030B0 E093      LDI	R25,3
    030B1 01FE      MOVW	R30,R28
    030B2 E004      LDI	R16,4
    030B3 E010      LDI	R17,0
(0328) 			MotorPosition[curSlave].stepPos = pos;
    030B4 93FA      ST	-Y,R31
    030B5 93EA      ST	-Y,R30
    030B6 939A      ST	-Y,R25
    030B7 938A      ST	-Y,R24
    030B8 940E AEFC CALL	asgnblk
    030BA 9180 00C1 LDS	R24,0xC1
(0329) 			if(EvenPosChangeProcess){
    030BC 7E8F      ANDI	R24,0xEF
    030BD 9380 00C1 STS	0xC1,R24
    030BF EC2F      LDI	R18,0xCF
    030C0 E13A      LDI	R19,0x1A
    030C1 EF0B      LDI	R16,0xFB
    030C2 E014      LDI	R17,4
    030C3 940E A90D CALL	_uart_Printf
(0330) 				i = EvenPosChangeProcess(pInfoEvent);
    030C5 9180 00C1 LDS	R24,0xC1
    030C7 6180      ORI	R24,0x10
    030C8 9380 00C1 STS	0xC1,R24
(0331) 				if(i)
    030CA 24AA      CLR	R10
    030CB 94A3      INC	R10
    030CC C033      RJMP	0x3100
(0332) 					EvenPosChangeProcess = 0;
    030CD 2D8A      MOV	R24,R10
    030CE 3086      CPI	R24,6
    030CF F011      BEQ	0x30D2
    030D0 3087      CPI	R24,7
    030D1 F409      BNE	0x30D3
    030D2 C02C      RJMP	0x30FF
(0333) 				}
(0334) 			break;
    030D3 2744      CLR	R20
(0335) 		case STA_MOT_PHO:	// 电机模块光藕状态改变信息
(0336) 			MotModulePhoSta[curSlave][*(pInfo)] = *(pInfo+1);
    030D4 C028      RJMP	0x30FD
    030D5 EB8B      LDI	R24,0xBB
    030D6 E195      LDI	R25,0x15
    030D7 2C2A      MOV	R2,R10
    030D8 2433      CLR	R3
    030D9 0C22      LSL	R2
    030DA 1C33      ROL	R3
    030DB 0E28      ADD	R2,R24
    030DC 1E39      ADC	R3,R25
    030DD 2FE4      MOV	R30,R20
    030DE 27FF      CLR	R31
    030DF 0DE2      ADD	R30,R2
    030E0 1DF3      ADC	R31,R3
    030E1 8160      LD	R22,Z
    030E2 2366      TST	R22
    030E3 F009      BEQ	0x30E5
    030E4 E061      LDI	R22,1
(0337) 			break;
    030E5 9180 00C1 LDS	R24,0xC1
(0338) 
(0339) 		case INFO_LIQ_EMPTY:		// 液路空
(0340) 		case INFO_LIQ_FULL:			// 液路满
(0341) 			i = *pInfo;
    030E7 7E8F      ANDI	R24,0xEF
(0342) 			if(i<4){
    030E8 9380 00C1 STS	0xC1,R24
    030EA 01CE      MOVW	R24,R28
(0343) 				LiquidState[i][0] = even;
    030EB 2FE6      MOV	R30,R22
    030EC 27FF      CLR	R31
    030ED 0FEE      LSL	R30
    030EE 1FFF      ROL	R31
    030EF 0FE8      ADD	R30,R24
    030F0 1FF9      ADC	R31,R25
    030F1 8120      LD	R18,Z
    030F2 2733      CLR	R19
    030F3 E301      LDI	R16,0x31
(0344) 				LiquidState[i][1] = 0;
    030F4 E014      LDI	R17,4
    030F5 940E A90D CALL	_uart_Printf
    030F7 9180 00C1 LDS	R24,0xC1
    030F9 6180      ORI	R24,0x10
    030FA 9380 00C1 STS	0xC1,R24
    030FC 9543      INC	R20
    030FD 3042      CPI	R20,2
(0345) 				}
(0346) 			break;
    030FE F2B0      BCS	0x30D5
(0347) 		case INFO_LIQ_BUBBLE:		// 有气泡
(0348) 		case INFO_LIQ_FLOW:			// 有液段
(0349) 			i = *pInfo;
    030FF 94A3      INC	R10
    03100 E08C      LDI	R24,0xC
(0350) 			if(i<4){
    03101 158A      CP	R24,R10
    03102 F008      BCS	0x3104
    03103 CFC9      RJMP	0x30CD
(0351) 				LiquidState[i][0] = even;
    03104 E08D      LDI	R24,0xD
    03105 2EA8      MOV	R10,R24
    03106 2744      CLR	R20
    03107 C026      RJMP	0x312E
    03108 EB83      LDI	R24,0xB3
    03109 E195      LDI	R25,0x15
    0310A 2FE4      MOV	R30,R20
    0310B 27FF      CLR	R31
    0310C 0FEE      LSL	R30
(0352) 				LiquidState[i][1] = *(pInfo+1);
    0310D 1FFF      ROL	R31
    0310E 0FE8      ADD	R30,R24
    0310F 1FF9      ADC	R31,R25
    03110 8180      LD	R24,Z
    03111 308F      CPI	R24,0xF
    03112 F411      BNE	0x3115
    03113 E061      LDI	R22,1
    03114 C001      RJMP	0x3116
    03115 2766      CLR	R22
    03116 9180 00C1 LDS	R24,0xC1
    03118 7E8F      ANDI	R24,0xEF
(0353) 				}
(0354) 			break;
    03119 9380 00C1 STS	0xC1,R24
(0355) 		case INFO_LIQ_PHO_ON:		// 液路检测光耦检测到液体
(0356) 		case INFO_LIQ_PHO_OFF:		// 液路检测光耦检测到空
(0357) 		case INFO_LIQ_PHO_VAL:		// 液路光耦输出信号值
(0358) 		case INFO_LIQ_PHO_ADJ:		// 液路光耦调整结果
(0359) 			switch(WorkProcessStep){
    0311B 01CE      MOVW	R24,R28
    0311C 2FE6      MOV	R30,R22
    0311D 27FF      CLR	R31
    0311E 0FEE      LSL	R30
    0311F 1FFF      ROL	R31
    03120 0FE8      ADD	R30,R24
    03121 1FF9      ADC	R31,R25
    03122 8120      LD	R18,Z
    03123 2733      CLR	R19
    03124 E301      LDI	R16,0x31
    03125 E014      LDI	R17,4
    03126 940E A90D CALL	_uart_Printf
    03128 9180 00C1 LDS	R24,0xC1
    0312A 6180      ORI	R24,0x10
    0312B 9380 00C1 STS	0xC1,R24
    0312D 9543      INC	R20
    0312E 3043      CPI	R20,3
    0312F F2C0      BCS	0x3108
    03130 E08E      LDI	R24,0xE
    03131 2EA8      MOV	R10,R24
    03132 2744      CLR	R20
(0360) 				case 0:		// 空闲
(0361) 					break;
(0362) 				case 1:		// 机械自检
(0363) 					break;
(0364) 				case 2:		// 液路自检
(0365) 					DiluteStartCheck(pInfoEvent);
    03133 C037      RJMP	0x316B
    03134 E486      LDI	R24,0x46
    03135 E195      LDI	R25,0x15
(0366) 					break;
    03136 2FE4      MOV	R30,R20
(0367) 				case 3:		// 正常测试
(0368) 					DiluteProcess(pInfoEvent);
    03137 27FF      CLR	R31
    03138 0FE8      ADD	R30,R24
    03139 1FF9      ADC	R31,R25
(0369) 					break;
(0370) 				case 4:		// 调试维护
(0371) 					break;
(0372) 				}
(0373) 			if(EvenLiquidProcess){
    0313A 8180      LD	R24,Z
    0313B 3184      CPI	R24,0x14
    0313C F4B9      BNE	0x3154
    0313D 9180 00C1 LDS	R24,0xC1
    0313F 7E8F      ANDI	R24,0xEF
    03140 9380 00C1 STS	0xC1,R24
    03142 E486      LDI	R24,0x46
(0374) 				i = EvenLiquidProcess(pInfoEvent);
    03143 E195      LDI	R25,0x15
    03144 2FE4      MOV	R30,R20
    03145 27FF      CLR	R31
    03146 0FE8      ADD	R30,R24
    03147 1FF9      ADC	R31,R25
(0375) 				if(i)
    03148 8120      LD	R18,Z
    03149 2733      CLR	R19
    0314A E20B      LDI	R16,0x2B
(0376) 					EvenLiquidProcess = 0;
    0314B E014      LDI	R17,4
    0314C 940E A90D CALL	_uart_Printf
    0314E 9180 00C1 LDS	R24,0xC1
    03150 6180      ORI	R24,0x10
(0377) 				}
(0378) 			break;
    03151 9380 00C1 STS	0xC1,R24
(0379) 		case INFO_STORE_OPEN:		// 片仓打开
(0380) 		case INFO_STORE_CLOSE:		// 片仓关闭
(0381) 		case INFO_STORE_FULL:		// 片仓满
(0382) 		case INFO_STORE_LITTLE:		// 片仓少量
(0383) 		case INFO_STORE_EMPTY:		// 片仓空
(0384) 		case INFO_STORE_ERROR:		// 片仓状态错误
(0385) 		case INFO_STORE_CAL:		// 片仓光路校准信息
(0386) 		case INFO_STORE_PHO_VOL:
(0387) 		case INFO_STORE_STATE_ALL:	// 全部片仓状态信息
(0388) 		case INFO_STORE_STATE_SPC:	// 指定片仓状态信息
(0389) 			CardStoreSteteProcess(pInfoEvent);
    03153 C016      RJMP	0x316A
    03154 9180 00C1 LDS	R24,0xC1
(0390) 			if(EvenCardStoreProcess)
    03156 7E8F      ANDI	R24,0xEF
    03157 9380 00C1 STS	0xC1,R24
    03159 E48C      LDI	R24,0x4C
    0315A E195      LDI	R25,0x15
    0315B 2FE4      MOV	R30,R20
    0315C 27FF      CLR	R31
    0315D 0FE8      ADD	R30,R24
(0391) 			{
(0392) 				i = EvenCardStoreProcess(pInfoEvent);
    0315E 1FF9      ADC	R31,R25
    0315F 8120      LD	R18,Z
    03160 2733      CLR	R19
    03161 E20B      LDI	R16,0x2B
    03162 E014      LDI	R17,4
    03163 940E A90D CALL	_uart_Printf
(0393) 				if(i)
    03165 9180 00C1 LDS	R24,0xC1
(0394) 					EvenCardStoreProcess = 0;
    03167 6180      ORI	R24,0x10
    03168 9380 00C1 STS	0xC1,R24
    0316A 9543      INC	R20
    0316B 3045      CPI	R20,5
    0316C F408      BCC	0x316E
(0395) 			}
(0396) 			break;
    0316D CFC6      RJMP	0x3134
(0397) 		case INFO_STORE_HUMITURE:	// 片仓温湿度
(0398) 			StoreHumi = *pInfo;
    0316E 24AA      CLR	R10
    0316F 2744      CLR	R20
    03170 C0A7      RJMP	0x3218
    03171 2EA4      MOV	R10,R20
(0399) 			StoreTemp = *(pInfo+1);
    03172 24BB      CLR	R11
    03173 20AA      TST	R10
    03174 F411      BNE	0x3177
(0400) 			Uart0ReUnable;
    03175 20BB      TST	R11
    03176 F0A9      BEQ	0x318C
    03177 01C5      MOVW	R24,R10
    03178 3081      CPI	R24,1
    03179 E0E0      LDI	R30,0
(0401) 			uart_Printf("%s $%4d $%4d\r\n",strM0111, StoreHumi, StoreTemp);
    0317A 079E      CPC	R25,R30
    0317B F169      BEQ	0x31A9
    0317C 3082      CPI	R24,2
    0317D E0E0      LDI	R30,0
    0317E 079E      CPC	R25,R30
    0317F F409      BNE	0x3181
    03180 C045      RJMP	0x31C6
    03181 3083      CPI	R24,3
    03182 E0E0      LDI	R30,0
    03183 079E      CPC	R25,R30
    03184 F409      BNE	0x3186
    03185 C062      RJMP	0x31E8
    03186 3084      CPI	R24,4
    03187 E0E0      LDI	R30,0
(0402) 			Uart0ReEnable;
    03188 079E      CPC	R25,R30
    03189 F409      BNE	0x318B
    0318A C070      RJMP	0x31FB
    0318B C08B      RJMP	0x3217
    0318C 9160 0109 LDS	R22,0x109
(0403) 			break;
    0318E 7064      ANDI	R22,4
    0318F F009      BEQ	0x3191
    03190 E061      LDI	R22,1
    03191 9180 00C1 LDS	R24,0xC1
(0404) 		case INFO_STORE_OPEN_ERR:	// 片仓开启超时错误
(0405) 			Uart0ReUnable;
(0406) 			uart_Printf("%s $%4d\r\n",strE0910, *pInfo);
    03193 7E8F      ANDI	R24,0xEF
    03194 9380 00C1 STS	0xC1,R24
    03196 01CE      MOVW	R24,R28
    03197 2FE6      MOV	R30,R22
    03198 27FF      CLR	R31
    03199 0FEE      LSL	R30
    0319A 1FFF      ROL	R31
    0319B 0FE8      ADD	R30,R24
    0319C 1FF9      ADC	R31,R25
    0319D 8120      LD	R18,Z
(0407) 			Uart0ReEnable;
    0319E 2733      CLR	R19
    0319F E301      LDI	R16,0x31
    031A0 E014      LDI	R17,4
    031A1 940E A90D CALL	_uart_Printf
(0408) 			break;
(0409) 		default:
(0410) 			break;
    031A3 9180 00C1 LDS	R24,0xC1
    031A5 6180      ORI	R24,0x10
_MachinePositionInit:
    031A6 9380 00C1 STS	0xC1,R24
    031A8 C06E      RJMP	0x3217
(0411) 		}
(0412) 
(0413) }
(0414) 
(0415) /*********************************************************************************************/
(0416) 
(0417) 
(0418) 
(0419) /****************************************************************************************************/
(0420) // 机械运行初始化
(0421) /*
(0422) unsigned char MachinePositionInit(void){
(0423) 	// 机械位置初始化
(0424) 	static unsigned char mainStep;		
(0425) 	static unsigned char waitMotSampTurn,waitMotSampNeedle, waitMotSampPump;
(0426) 	static unsigned char waitMotCardTrolley, waitMotCardLoad, waitMotCardUnLoad, waitMotTurnPlate;
(0427) 	static unsigned char waitMotLifterA, waitMotLifterB;
(0428) 	static unsigned char i, n, m;
(0429) 
(0430) 
(0431) 	if(WaitDelayTime(MOT_SAMP_PUMP))		return 0;
(0432) 	if(WaitDelayTime(MOT_SAMP_TRUN))		return 0;
(0433) 	if(WaitDelayTime(MOT_SAMP_NEEDLE))		return 0;
(0434) 	if(WaitDelayTime(MOT_EFFLUENT))			return 0;
(0435) 		
(0436) 	if(waitMotSampTurn){	if(GetMotState(MOT_SAMP_TRUN)!=STA_SLAVE_FREE)		return 0;	waitMotSampTurn = 0;	}
(0437) 	if(waitMotSampNeedle){	if(GetMotState(MOT_SAMP_NEEDLE)!=STA_SLAVE_FREE)	return 0;	waitMotSampNeedle = 0;	}
(0438) 	if(waitMotSampPump){	if(GetMotState(MOT_SAMP_PUMP)!=STA_SLAVE_FREE)		return 0;	waitMotSampPump = 0;	}
(0439) 	if(waitMotCardLoad){	if(GetMotState(MOT_CARD_LOAD)!=STA_SLAVE_FREE)		return 0;	waitMotCardLoad = 0;	}
(0440) 	if(waitMotCardUnLoad){	if(GetMotState(MOT_CARD_UNLOAD)!=STA_SLAVE_FREE)	return 0;	waitMotCardUnLoad = 0;	}
(0441) 	if(waitMotTurnPlate){	if(GetMotState(MOT_TURN_PLATE)!=STA_SLAVE_FREE)		return 0;	waitMotTurnPlate = 0;	}
(0442) 	if(waitMotCardTrolley){	if(GetMotState(MOT_STORE_CARD_MOVE)!=STA_SLAVE_FREE)	return 0;	waitMotCardTrolley = 0;	}
(0443) 	
(0444) 	switch(mainStep){
(0445) 		case 0:		// 设置运行参数
(0446) 			SetMotRunPam(MOT_SAMP_NEEDLE,240,10,CURRENT_SAMP_NEEDLE);
(0447) 			SetMotRunPam(MOT_CARD_LOAD,160,20,CURRENT_CARD_LOAD);
(0448) 			SetMotRunPam(MOT_CARD_UNLOAD,160,20,CURRENT_CARD_UNLOAD);
(0449) 			SetMotRunPam(MOT_SAMP_PUMP,180,10,CURRENT_SAMP_PUMP);
(0450) 			
(0451) 			MotInitCheck(MOT_SAMP_NEEDLE);
(0452) 			MotInitCheck(MOT_CARD_UNLOAD);
(0453) 			MotInitCheck(MOT_CARD_LOAD);
(0454) 			MotInitCheck(MOT_SAMP_PUMP);
(0455) 			SetCardTrolleyState(0);
(0456) 			SetEValve(EV1, EV_OPEN);
(0457) 			SetMotRunPam(MOT_EFFLUENT, 180, 2, CURRENT_EFFLUENT);
(0458) 			MotRun(MOT_EFFLUENT, 2500);			// 开启废液泵
(0459) 			waitMotCardUnLoad = 1;
(0460) 			mainStep = 1;
(0461) 			break;
(0462) 		case 1:		// 转盘位置初始化
(0463) 			SetMotRunPam(MOT_TURN_PLATE,240,20,CURRENT_TURN_PLATE);
(0464) 			MotInitCheck(MOT_TURN_PLATE);
(0465) 			waitMotTurnPlate = 1;
(0466) 			mainStep = 2;
(0467) 			break;
(0468) 		case 2:		// 转盘运行到0位
(0469) 			MotRunToSite(MOT_TURN_PLATE,0);
(0470) 			waitMotTurnPlate = 1;
(0471) 			waitMotSampNeedle = 1;
(0472) 			mainStep = 3;
(0473) 			break;
(0474) 		case 3:		// 片仓小车运行到起始位
(0475) 			SetMotRunPam(MOT_STORE_CARD_MOVE,200,10,CURRENT_STORE_MOVE);
(0476) 			MotInitCheck(MOT_STORE_CARD_MOVE);
(0477) 			waitMotSampNeedle = 1;
(0478) 			mainStep = 100;
(0479) 			break;
(0480) 		case 100:		// 取样针回零经常出现在运转时给出空闲信号, 此处从新运行以避免错误
(0481) 			MotRunTo(MOT_SAMP_NEEDLE, 0);
(0482) 			waitMotSampNeedle = 1;
(0483) 			mainStep = 4;
(0484) 			break;
(0485) 		case 4:		// 取样臂回到起始位
(0486) 			SetEValve(EV_ALL, EV_CLOSE);
(0487) 			SetMotRunPam(MOT_SAMP_TRUN,200,5,CURRENT_SAMP_TRUN);
(0488) 			MotInitCheck(MOT_SAMP_TRUN);
(0489) 			SetEValve(EV1, EV_CLOSE);
(0490) 			waitMotSampTurn = 1;
(0491) 			waitMotSampPump = 1;
(0492) 			waitMotTurnPlate = 1;
(0493) 			//mainStep = 5;
(0494) 			mainStep = 7;
(0495) 			i = 0;
(0496) 			break;
(0497) 		case 5:	// 取样臂旋转试运行
(0498) 			MotRunTo(MOT_SAMP_TRUN,_POS_SAMPTURN_SAMP+200);
(0499) 			waitMotSampTurn = 1;
(0500) 			mainStep = 6;
(0501) 			break;
(0502) 		case 6:
(0503) 			MotRunTo(MOT_SAMP_TRUN,0);
(0504) 			waitMotSampTurn = 1;
(0505) 			i++;
(0506) 			if(i<1){
(0507) 				mainStep = 5;
(0508) 				SetDelayTime(MOT_SAMP_TRUN, 10);
(0509) 				}
(0510) 			else{	
(0511) 				mainStep = 7;	
(0512) 				i = 0;	
(0513) 				}
(0514) 			break;
(0515) 		case 7:		// 扫描转盘上遗留干片	_RingPieceState
(0516) 			i++;
(0517) 			if(i>=RING_QUEUE_NUM)
(0518) 				i = 0;
(0519) 			m = PINK & 0x01;
(0520) 			_RingPieceState[i] = 0;
(0521) 			MotRunToSite(MOT_TURN_PLATE,i);
(0522) 			mainStep = 8;
(0523) 			break;
(0524) 		case 8:
(0525) 			n = PINK & 0x01;
(0526) 			if(m != n)
(0527) 				_RingPieceState[i] = 1;
(0528) 			if(GetMotState(MOT_TURN_PLATE)!=STA_SLAVE_FREE)	
(0529) 				break;
(0530) 			if(i==0)
(0531) 				mainStep = 9;
(0532) 			else
(0533) 				mainStep = 7;
(0534) 			break;
(0535) 		case 9:		// 扫描转盘
(0536) 			MotRunToSite(MOT_TURN_PLATE,10);	// 25 让转盘的0号转到卸片位置
(0537) 			waitMotTurnPlate = 1;
(0538) 			i = 0;
(0539) 			mainStep = 10;
(0540) 			break;
(0541) 		case 10:		// 按顺序寻找剩余干片
(0542) 			n = i + 10;
(0543) 			if(n>=RING_QUEUE_NUM)
(0544) 				n -= RING_QUEUE_NUM;
(0545) 			if(GetRingPieceState(i)==1){	// 转盘上有剩余干片
(0546) 				MotRunToSite(MOT_TURN_PLATE,n);	// 转盘运行到当前位置
(0547) 				waitMotTurnPlate = 1;
(0548) 				mainStep = 11;
(0549) 				m = 0;		// 废片仓打开计时
(0550) 				}
(0551) 			else
(0552) 				mainStep = 14;		// 继续查找下一个
(0553) 			break;
(0554) 		case 11:		// 开始卸载转盘上的干片
(0555) 			if((PINK & 0x02) == 0){
(0556) 				SetDelayTime(MOT_TURN_PLATE, 10);
(0557) 				m ++;
(0558) 				if(m == 2){
(0559) 					uart_Printf("%s $   1\r\n",strM0200);
(0560) 					SetBeepWarning();
(0561) 					}
(0562) 				if(m == 25){
(0563) 					SetBeepWarning();
(0564) 					m = 5;
(0565) 					}
(0566) 				
(0567) 				break;
(0568) 				}
(0569) 			SetMotRunPam(MOT_CARD_UNLOAD,200,20,CURRENT_CARD_UNLOAD);
(0570) 			MotRunTo(MOT_CARD_UNLOAD,_POS_UNLOAD_OUT);
(0571) 			waitMotCardUnLoad = 1;
(0572) 			mainStep = 12;
(0573) 			break;
(0574) 		case 12:
(0575) 			SetDelayTime(MOT_SAMP_TRUN, 10);
(0576) 			mainStep = 13;
(0577) 			break;
(0578) 		case 13:	// 卸片小车回到起始点
(0579) 			MotRunTo(MOT_CARD_UNLOAD,0);
(0580) 			waitMotCardUnLoad = 1;
(0581) 			mainStep = 14;
(0582) 			break;
(0583) 		case 14:
(0584) 			i++;
(0585) 			if(i < RING_QUEUE_NUM)	// 未完继续
(0586) 				mainStep = 10;
(0587) 			else
(0588) 				mainStep = 15;	// 检查结束
(0589) 			break;
(0590) 		case 15:	// 检查片仓小车上是否有干片
(0591) 			SetMotRunPam(MOT_STORE_CARD_MOVE,64,10,CURRENT_STORE_MOVE);
(0592) 			MotRunTo(MOT_STORE_CARD_MOVE,100);
(0593) 			waitMotCardTrolley = 1;
(0594) 			mainStep = 16;
(0595) 			break;
(0596) 		case 16:
(0597) 			i = PINL & 0x04;		// 读取取片检测传感器空闲状态
(0598) 			MotRunTo(MOT_STORE_CARD_MOVE,0);	// 取片小车运行到零位
(0599) 			waitMotCardTrolley = 1;
(0600) 			mainStep = 17;
(0601) 			break;
(0602) 		case 17:
(0603) 			n = PINL & 0x04;		// 读取取片检测传感器状态
(0604) 			if(i != n){		// 取片小车上有剩余干片
(0605) 				MotRunToSite(MOT_TURN_PLATE,0);	// 转盘运行到0号位置
(0606) 				waitMotTurnPlate = 1;
(0607) 				mainStep = 18;
(0608) 				}
(0609) 			else
(0610) 				mainStep = 26;		// 取片小车上没有干片, 跳过
(0611) 			break;
(0612) 		case 18:		// 干片推入转盘
(0613) 			SetMotRunPam(MOT_CARD_LOAD,160,10,CURRENT_CARD_LOAD);
(0614) 			MotRunTo(MOT_CARD_LOAD,_POS_CARDLOAD_RING);		// 装片行程94mm/0.08128 = 1156
(0615) 			waitMotCardLoad = 1;
(0616) 			mainStep = 20;
(0617) 			break;
(0618) 		case 19:		// 干片推入转盘步骤2
(0619) 		//	SetMotRunPam(MOT_CARD_LOAD,64,2,2);
(0620) 			MotRunTo(MOT_CARD_LOAD,_POS_CARDLOAD_RING);		// 装片行程94mm/0.08128 = 1156
(0621) 			waitMotCardLoad = 1;
(0622) 			mainStep = 20;
(0623) 			break;
(0624) 		case 20:
(0625) 			SetDelayTime(MOT_SAMP_TRUN, 10);
(0626) 			mainStep = 21;
(0627) 			break;
(0628) 		case 21:		// 干片推入复位
(0629) 			SetMotRunPam(MOT_CARD_LOAD,200,10,CURRENT_CARD_LOAD);
(0630) 			MotRunTo(MOT_CARD_LOAD,0);
(0631) 			waitMotCardLoad = 1;
(0632) 			mainStep = 22;
(0633) 			break;
(0634) 		case 22:		// 转盘0号转到卸片位置
(0635) 		//	SetMotRunPam(MOT_TURN_PLATE,240,10,2);
(0636) 			MotRunToSite(MOT_TURN_PLATE,25);
(0637) 			waitMotTurnPlate = 1;
(0638) 			mainStep = 23;
(0639) 			break;
(0640) 		case 23:		// 开始卸片
(0641) 			SetMotRunPam(MOT_CARD_UNLOAD,200,20,CURRENT_CARD_UNLOAD);
(0642) 			MotRunTo(MOT_CARD_UNLOAD,_POS_UNLOAD_OUT);
(0643) 			waitMotCardUnLoad = 1;
(0644) 			mainStep = 24;
(0645) 			break;
(0646) 		case 24:
(0647) 			SetDelayTime(MOT_SAMP_TRUN,10);
(0648) 			mainStep = 25;
(0649) 			break;
(0650) 		case 25:		// 卸片小车回到起始位
(0651) 			SetMotRunPam(MOT_CARD_UNLOAD,200,20,2);
(0652) 			MotRunTo(MOT_CARD_UNLOAD,_POS_UNLOAD_HOME);
(0653) 			waitMotCardUnLoad = 1;
(0654) 			mainStep = 26;
(0655) 			break;
(0656) 		case 26:		// 转盘运转到初始状态
(0657) 			MotRunToSite(MOT_TURN_PLATE,29);
(0658) 			waitMotTurnPlate = 1;
(0659) 			MotRunTo(MOT_STORE_CARD_MOVE,432);
(0660) 			waitMotCardTrolley = 1;
(0661) 			mainStep = 27;
(0662) 			break;
(0663) 		case 27:
(0664) 			uart_Printf("%s\r\n", strM1101);
(0665) 			mainStep = 0;
(0666) 			return 1;
(0667) 			break;
(0668) 		}
(0669) 	return 0;
(0670) }
(0671) */
(0672) 
(0673) unsigned char MachinePositionInit(void){
(0674) 	// 机械位置初始化
(0675) 	static unsigned char mainStep;		
(0676) 	static unsigned char waitMotSampTurn,waitMotSampNeedle, waitMotSampPump;
(0677) 	static unsigned char waitMotCardTrolley, waitMotCardLoad, waitMotCardUnLoad, waitMotTurnPlate;
(0678) 	static unsigned char waitMotLifterA, waitMotLifterB;
(0679) 	static unsigned char i, n, m;
(0680) 
(0681) 
(0682) 	if(WaitDelayTime(MOT_SAMP_PUMP))		return 0;
    031A9 9160 0106 LDS	R22,0x106
    031AB 7061      ANDI	R22,1
    031AC F009      BEQ	0x31AE
    031AD E061      LDI	R22,1
    031AE 9180 00C1 LDS	R24,0xC1
(0683) 	if(WaitDelayTime(MOT_SAMP_TRUN))		return 0;
    031B0 7E8F      ANDI	R24,0xEF
    031B1 9380 00C1 STS	0xC1,R24
    031B3 01CE      MOVW	R24,R28
    031B4 2FE6      MOV	R30,R22
    031B5 27FF      CLR	R31
    031B6 0FEE      LSL	R30
(0684) 	if(WaitDelayTime(MOT_SAMP_NEEDLE))		return 0;
    031B7 1FFF      ROL	R31
    031B8 0FE8      ADD	R30,R24
    031B9 1FF9      ADC	R31,R25
    031BA 8120      LD	R18,Z
    031BB 2733      CLR	R19
    031BC E301      LDI	R16,0x31
    031BD E014      LDI	R17,4
    031BE 940E A90D CALL	_uart_Printf
(0685) 	if(WaitDelayTime(MOT_EFFLUENT))			return 0;
    031C0 9180 00C1 LDS	R24,0xC1
    031C2 6180      ORI	R24,0x10
    031C3 9380 00C1 STS	0xC1,R24
    031C5 C051      RJMP	0x3217
    031C6 940E A99B CALL	_GetwasteCardState
(0686) 		
(0687) 	if(waitMotSampTurn){	if(GetMotState(MOT_SAMP_TRUN)!=STA_SLAVE_FREE)		return 0;	waitMotSampTurn = 0;	}
    031C8 2300      TST	R16
    031C9 F009      BEQ	0x31CB
    031CA C04C      RJMP	0x3217
    031CB 9160 0106 LDS	R22,0x106
    031CD 7062      ANDI	R22,2
    031CE F009      BEQ	0x31D0
    031CF E061      LDI	R22,1
    031D0 9180 00C1 LDS	R24,0xC1
    031D2 7E8F      ANDI	R24,0xEF
    031D3 9380 00C1 STS	0xC1,R24
    031D5 01CE      MOVW	R24,R28
(0688) 	if(waitMotSampNeedle){	if(GetMotState(MOT_SAMP_NEEDLE)!=STA_SLAVE_FREE)	return 0;	waitMotSampNeedle = 0;	}
    031D6 2FE6      MOV	R30,R22
    031D7 27FF      CLR	R31
    031D8 0FEE      LSL	R30
    031D9 1FFF      ROL	R31
    031DA 0FE8      ADD	R30,R24
    031DB 1FF9      ADC	R31,R25
    031DC 8120      LD	R18,Z
    031DD 2733      CLR	R19
    031DE E301      LDI	R16,0x31
    031DF E014      LDI	R17,4
    031E0 940E A90D CALL	_uart_Printf
    031E2 9180 00C1 LDS	R24,0xC1
    031E4 6180      ORI	R24,0x10
(0689) 	if(waitMotSampPump){	if(GetMotState(MOT_SAMP_PUMP)!=STA_SLAVE_FREE)		return 0;	waitMotSampPump = 0;	}
    031E5 9380 00C1 STS	0xC1,R24
    031E7 C02F      RJMP	0x3217
    031E8 9180 00C1 LDS	R24,0xC1
    031EA 7E8F      ANDI	R24,0xEF
    031EB 9380 00C1 STS	0xC1,R24
    031ED 2700      CLR	R16
    031EE 940E 9A52 CALL	_getLiqDetADC
    031F0 0198      MOVW	R18,R16
    031F1 E205      LDI	R16,0x25
    031F2 E014      LDI	R17,4
    031F3 940E A90D CALL	_uart_Printf
(0690) 	if(waitMotCardLoad){	if(GetMotState(MOT_CARD_LOAD)!=STA_SLAVE_FREE)		return 0;	waitMotCardLoad = 0;	}
    031F5 9180 00C1 LDS	R24,0xC1
    031F7 6180      ORI	R24,0x10
    031F8 9380 00C1 STS	0xC1,R24
    031FA C01C      RJMP	0x3217
    031FB 9160 0103 LDS	R22,0x103
    031FD 7460      ANDI	R22,0x40
    031FE F009      BEQ	0x3200
    031FF E061      LDI	R22,1
    03200 9180 00C1 LDS	R24,0xC1
    03202 7E8F      ANDI	R24,0xEF
(0691) 	if(waitMotCardUnLoad){	if(GetMotState(MOT_CARD_UNLOAD)!=STA_SLAVE_FREE)	return 0;	waitMotCardUnLoad = 0;	}
    03203 9380 00C1 STS	0xC1,R24
    03205 01CE      MOVW	R24,R28
    03206 2FE6      MOV	R30,R22
    03207 27FF      CLR	R31
    03208 0FEE      LSL	R30
    03209 1FFF      ROL	R31
    0320A 0FE8      ADD	R30,R24
    0320B 1FF9      ADC	R31,R25
    0320C 8120      LD	R18,Z
    0320D 2733      CLR	R19
    0320E E301      LDI	R16,0x31
    0320F E014      LDI	R17,4
    03210 940E A90D CALL	_uart_Printf
(0692) 	if(waitMotTurnPlate){	if(GetMotState(MOT_TURN_PLATE)!=STA_SLAVE_FREE)		return 0;	waitMotTurnPlate = 0;	}
    03212 9180 00C1 LDS	R24,0xC1
    03214 6180      ORI	R24,0x10
    03215 9380 00C1 STS	0xC1,R24
    03217 9543      INC	R20
    03218 3045      CPI	R20,5
    03219 F408      BCC	0x321B
    0321A CF56      RJMP	0x3171
    0321B E202      LDI	R16,0x22
    0321C E014      LDI	R17,4
    0321D 940E A90D CALL	_uart_Printf
    0321F 9624      ADIW	R28,4
    03220 940C AE9E JMP	pop_xgsetF00C
(0693) 	if(waitMotCardTrolley){	if(GetMotState(MOT_STORE_CARD_MOVE)!=STA_SLAVE_FREE)	return 0;	waitMotCardTrolley = 0;	}
_SlaveEventAssignProcess:
    03222 940E AE78 CALL	push_xgsetF0FC
    03224 0158      MOVW	R10,R16
    03225 9724      SBIW	R28,4
    03226 01F5      MOVW	R30,R10
    03227 80E0      LD	R14,Z
    03228 80C1      LDD	R12,Z+1
    03229 01AF      MOVW	R20,R30
    0322A 5F4E      SUBI	R20,0xFE
    0322B 4F5F      SBCI	R21,0xFF
    0322C 2D6C      MOV	R22,R12
    0322D 2777      CLR	R23
    0322E 3061      CPI	R22,1
    0322F E0E0      LDI	R30,0
(0694) 	
(0695) 	switch(mainStep){
    03230 077E      CPC	R23,R30
    03231 F40C      BGE	0x3233
    03232 C115      RJMP	0x3348
    03233 E280      LDI	R24,0x20
    03234 E090      LDI	R25,0
    03235 1786      CP	R24,R22
    03236 0797      CPC	R25,R23
    03237 F40C      BGE	0x3239
    03238 C10F      RJMP	0x3348
    03239 E780      LDI	R24,0x70
    0323A E091      LDI	R25,1
    0323B 01FB      MOVW	R30,R22
    0323C 9731      SBIW	R30,1
    0323D 0FEE      LSL	R30
    0323E 1FFF      ROL	R31
    0323F 0FE8      ADD	R30,R24
    03240 1FF9      ADC	R31,R25
    03241 9027      ELPM	R2,Z+
    03242 9036      ELPM	R3,Z
    03243 01F1      MOVW	R30,R2
    03244 9409      IJMP
    03245 01FA      MOVW	R30,R20
    03246 8161      LDD	R22,Z+1
    03247 2777      CLR	R23
    03248 2F76      MOV	R23,R22
(0696) 		case 0:		// 设置运行参数
(0697) 			SetMotRunPam(MOT_SAMP_NEEDLE,240,10,CURRENT_SAMP_NEEDLE);
    03249 2766      CLR	R22
    0324A 8022      LDD	R2,Z+2
    0324B 2433      CLR	R3
    0324C 0D62      ADD	R22,R2
    0324D 1D73      ADC	R23,R3
    0324E E003      LDI	R16,3
    0324F 2D1E      MOV	R17,R14
    03250 0301      MULSU	R16,R17
(0698) 			SetMotRunPam(MOT_CARD_LOAD,160,20,CURRENT_CARD_LOAD);
    03251 ED89      LDI	R24,0xD9
    03252 E195      LDI	R25,0x15
    03253 01F0      MOVW	R30,R0
    03254 0FE8      ADD	R30,R24
    03255 1FF9      ADC	R31,R25
    03256 01DA      MOVW	R26,R20
    03257 902C      LD	R2,X
    03258 8220      ST	Z,R2
(0699) 			SetMotRunPam(MOT_CARD_UNLOAD,160,20,CURRENT_CARD_UNLOAD);
    03259 0301      MULSU	R16,R17
    0325A ED8A      LDI	R24,0xDA
    0325B E195      LDI	R25,0x15
    0325C 01F0      MOVW	R30,R0
    0325D 0FE8      ADD	R30,R24
    0325E 1FF9      ADC	R31,R25
    0325F 8371      STD	Z+1,R23
    03260 8360      ST	Z,R22
(0700) 			SetMotRunPam(MOT_SAMP_PUMP,180,10,CURRENT_SAMP_PUMP);
    03261 9020 160A LDS	R2,EvenPosChangeProcess
    03263 9030 160B LDS	R3,EvenPosChangeProcess+1
    03265 2022      TST	R2
    03266 F419      BNE	0x326A
    03267 2033      TST	R3
    03268 F409      BNE	0x326A
(0701) 			
(0702) 			MotInitCheck(MOT_SAMP_NEEDLE);
    03269 C0DE      RJMP	0x3348
    0326A 0185      MOVW	R16,R10
    0326B 01F1      MOVW	R30,R2
(0703) 			MotInitCheck(MOT_CARD_UNLOAD);
    0326C 940E AEC5 CALL	xicallx
    0326E 2F60      MOV	R22,R16
(0704) 			MotInitCheck(MOT_CARD_LOAD);
    0326F 2300      TST	R16
    03270 F409      BNE	0x3272
    03271 C0D6      RJMP	0x3348
(0705) 			MotInitCheck(MOT_SAMP_PUMP);
    03272 2422      CLR	R2
    03273 2433      CLR	R3
    03274 9230 160B STS	EvenPosChangeProcess+1,R3
(0706) 			SetCardTrolleyState(0);
    03276 9220 160A STS	EvenPosChangeProcess,R2
(0707) 			SetEValve(EV1, EV_OPEN);
    03278 C0CF      RJMP	0x3348
    03279 EB8B      LDI	R24,0xBB
    0327A E195      LDI	R25,0x15
    0327B 2C2E      MOV	R2,R14
(0708) 			SetMotRunPam(MOT_EFFLUENT, 180, 2, CURRENT_EFFLUENT);
    0327C 2433      CLR	R3
    0327D 0C22      LSL	R2
    0327E 1C33      ROL	R3
    0327F 0E28      ADD	R2,R24
    03280 1E39      ADC	R3,R25
    03281 01FA      MOVW	R30,R20
    03282 81E0      LD	R30,Z
    03283 27FF      CLR	R31
(0709) 			MotRun(MOT_EFFLUENT, 2500);			// 开启废液泵
    03284 0DE2      ADD	R30,R2
    03285 1DF3      ADC	R31,R3
    03286 01DA      MOVW	R26,R20
    03287 9611      ADIW	R26,1
    03288 902C      LD	R2,X
(0710) 			waitMotCardUnLoad = 1;
    03289 8220      ST	Z,R2
    0328A C0BD      RJMP	0x3348
    0328B 01FA      MOVW	R30,R20
(0711) 			mainStep = 1;
    0328C 8160      LD	R22,Z
    0328D 3064      CPI	R22,4
(0712) 			break;
    0328E F008      BCS	0x3290
(0713) 		case 1:
(0714) 			Uart0ReUnable;
    0328F C0B8      RJMP	0x3348
    03290 EB83      LDI	R24,0xB3
    03291 E195      LDI	R25,0x15
    03292 2FE6      MOV	R30,R22
    03293 27FF      CLR	R31
(0715) 			uart_Printf("%s\r\n",strM2103);
    03294 0FEE      LSL	R30
    03295 1FFF      ROL	R31
    03296 0FE8      ADD	R30,R24
    03297 1FF9      ADC	R31,R25
    03298 82C0      ST	Z,R12
    03299 EB84      LDI	R24,0xB4
(0716) 			Uart0ReEnable;
    0329A E195      LDI	R25,0x15
    0329B 2FE6      MOV	R30,R22
    0329C 27FF      CLR	R31
    0329D 0FEE      LSL	R30
    0329E 1FFF      ROL	R31
(0717) 			mainStep = 2;
    0329F 0FE8      ADD	R30,R24
    032A0 1FF9      ADC	R31,R25
    032A1 2422      CLR	R2
(0718) 			break;
    032A2 8220      ST	Z,R2
(0719) 		case 2:		// 转盘位置初始化
(0720) 			SetMotRunPam(MOT_TURN_PLATE,240,20,CURRENT_TURN_PLATE);
    032A3 C0A4      RJMP	0x3348
    032A4 01FA      MOVW	R30,R20
    032A5 8160      LD	R22,Z
    032A6 3064      CPI	R22,4
    032A7 F008      BCS	0x32A9
    032A8 C09F      RJMP	0x3348
    032A9 EB83      LDI	R24,0xB3
    032AA E195      LDI	R25,0x15
(0721) 			MotInitCheck(MOT_TURN_PLATE);
    032AB 2FE6      MOV	R30,R22
    032AC 27FF      CLR	R31
    032AD 0FEE      LSL	R30
(0722) 			waitMotTurnPlate = 1;
    032AE 1FFF      ROL	R31
    032AF 0FE8      ADD	R30,R24
    032B0 1FF9      ADC	R31,R25
(0723) 			mainStep = 3;
    032B1 82C0      ST	Z,R12
    032B2 EB84      LDI	R24,0xB4
    032B3 E195      LDI	R25,0x15
(0724) 			break;
    032B4 2FE6      MOV	R30,R22
(0725) 		case 3:
(0726) 			Uart0ReUnable;
    032B5 27FF      CLR	R31
    032B6 0FEE      LSL	R30
    032B7 1FFF      ROL	R31
    032B8 0FE8      ADD	R30,R24
    032B9 1FF9      ADC	R31,R25
(0727) 			uart_Printf("%s\r\n",strM2104);
    032BA 01DA      MOVW	R26,R20
    032BB 9611      ADIW	R26,1
    032BC 902C      LD	R2,X
    032BD 8220      ST	Z,R2
    032BE C089      RJMP	0x3348
    032BF 90C0 17D7 LDS	R12,WorkProcessStep
(0728) 			Uart0ReEnable;
    032C1 24DD      CLR	R13
    032C2 20CC      TST	R12
    032C3 F411      BNE	0x32C6
    032C4 20DD      TST	R13
(0729) 			mainStep = 4;
    032C5 F0C9      BEQ	0x32DF
    032C6 01C6      MOVW	R24,R12
    032C7 3081      CPI	R24,1
(0730) 			break;
    032C8 E0E0      LDI	R30,0
(0731) 		case 4:		// 转盘运行到0位
(0732) 			MotRunToSite(MOT_TURN_PLATE,0);
    032C9 079E      CPC	R25,R30
    032CA F0A1      BEQ	0x32DF
    032CB 3082      CPI	R24,2
    032CC E0E0      LDI	R30,0
(0733) 			waitMotTurnPlate = 1;
    032CD 079E      CPC	R25,R30
    032CE F049      BEQ	0x32D8
    032CF 3083      CPI	R24,3
(0734) 			waitMotSampNeedle = 1;
    032D0 E0E0      LDI	R30,0
    032D1 079E      CPC	R25,R30
(0735) 			mainStep = 5;
    032D2 F049      BEQ	0x32DC
    032D3 3084      CPI	R24,4
    032D4 E0E0      LDI	R30,0
(0736) 			break;
    032D5 079E      CPC	R25,R30
(0737) 		case 5:
(0738) 			Uart0ReUnable;
    032D6 F041      BEQ	0x32DF
    032D7 C007      RJMP	0x32DF
    032D8 0185      MOVW	R16,R10
    032D9 940E 56BD CALL	_DiluteStartCheck
(0739) 			uart_Printf("%s\r\n",strM2107);
    032DB C003      RJMP	0x32DF
    032DC 0185      MOVW	R16,R10
    032DD 940E 395D CALL	_DiluteProcess
    032DF 9020 1608 LDS	R2,EvenLiquidProcess
(0740) 			Uart0ReEnable;
    032E1 9030 1609 LDS	R3,EvenLiquidProcess+1
    032E3 2022      TST	R2
    032E4 F419      BNE	0x32E8
    032E5 2033      TST	R3
(0741) 			mainStep = 6;
    032E6 F409      BNE	0x32E8
    032E7 C060      RJMP	0x3348
    032E8 0185      MOVW	R16,R10
(0742) 			break;
    032E9 01F1      MOVW	R30,R2
(0743) 		case 6:		// 片仓小车运行到起始位
(0744) 			SetMotRunPam(MOT_STORE_CARD_MOVE,200,10,CURRENT_STORE_MOVE);
    032EA 940E AEC5 CALL	xicallx
    032EC 2F60      MOV	R22,R16
    032ED 2300      TST	R16
    032EE F409      BNE	0x32F0
    032EF C058      RJMP	0x3348
    032F0 2422      CLR	R2
(0745) 			MotInitCheck(MOT_STORE_CARD_MOVE);
    032F1 2433      CLR	R3
    032F2 9230 1609 STS	EvenLiquidProcess+1,R3
(0746) 			waitMotSampNeedle = 1;
    032F4 9220 1608 STS	EvenLiquidProcess,R2
    032F6 C051      RJMP	0x3348
(0747) 			mainStep = 7;
    032F7 0185      MOVW	R16,R10
    032F8 940E 194F CALL	_CardStoreSteteProcess
(0748) 			break;
    032FA 9020 1606 LDS	R2,EvenCardStoreProcess
(0749) 		case 7:
(0750) 			Uart0ReUnable;
    032FC 9030 1607 LDS	R3,EvenCardStoreProcess+1
    032FE 2022      TST	R2
    032FF F419      BNE	0x3303
(0751) 			uart_Printf("%s\r\n",strM2108);
    03300 2033      TST	R3
    03301 F409      BNE	0x3303
    03302 C045      RJMP	0x3348
    03303 0185      MOVW	R16,R10
    03304 01F1      MOVW	R30,R2
    03305 940E AEC5 CALL	xicallx
(0752) 			Uart0ReEnable;
    03307 2EA0      MOV	R10,R16
    03308 2D6A      MOV	R22,R10
    03309 2300      TST	R16
    0330A F409      BNE	0x330C
(0753) 			mainStep = 8;
    0330B C03C      RJMP	0x3348
    0330C 2422      CLR	R2
    0330D 2433      CLR	R3
(0754) 			break;
    0330E 9230 1607 STS	EvenCardStoreProcess+1,R3
(0755) 		case 8:		// 取样针回零经常出现在运转时给出空闲信号, 此处从新运行以避免错误
(0756) 			MotRunTo(MOT_SAMP_NEEDLE, 0);
    03310 9220 1606 STS	EvenCardStoreProcess,R2
    03312 C035      RJMP	0x3348
    03313 01FA      MOVW	R30,R20
(0757) 			waitMotSampNeedle = 1;
    03314 8020      LD	R2,Z
    03315 9220 15B2 STS	StoreHumi,R2
(0758) 			mainStep = 9;
    03317 8021      LDD	R2,Z+1
    03318 9220 15B1 STS	StoreTemp,R2
(0759) 			break;
    0331A 9180 00C1 LDS	R24,0xC1
(0760) 		case 9:
(0761) 			Uart0ReUnable;
    0331C 7E8F      ANDI	R24,0xEF
    0331D 9380 00C1 STS	0xC1,R24
    0331F 2433      CLR	R3
(0762) 			uart_Printf("%s\r\n",strM2109);
    03320 823B      STD	Y+3,R3
    03321 822A      STD	Y+2,R2
    03322 9020 15B2 LDS	R2,StoreHumi
    03324 2433      CLR	R3
    03325 8239      STD	Y+1,R3
(0763) 			Uart0ReEnable;
    03326 8228      ST	Y,R2
    03327 EC21      LDI	R18,0xC1
    03328 E035      LDI	R19,5
    03329 E103      LDI	R16,0x13
    0332A E014      LDI	R17,4
(0764) 			mainStep = 10;
    0332B 940E A90D CALL	_uart_Printf
    0332D 9180 00C1 LDS	R24,0xC1
(0765) 			break;
    0332F 6180      ORI	R24,0x10
    03330 9380 00C1 STS	0xC1,R24
    03332 C015      RJMP	0x3348
(0766) 		case 10:		// 取样臂回到起始位
(0767) 			SetEValve(EV_ALL, EV_CLOSE);
(0768) 			SetMotRunPam(MOT_SAMP_TRUN,200,5,CURRENT_SAMP_TRUN);
    03333 9180 00C1 LDS	R24,0xC1
    03335 7E8F      ANDI	R24,0xEF
    03336 9380 00C1 STS	0xC1,R24
    03338 01FA      MOVW	R30,R20
    03339 8020      LD	R2,Z
    0333A 2433      CLR	R3
(0769) 			MotInitCheck(MOT_SAMP_TRUN);
    0333B 8239      STD	Y+1,R3
    0333C 8228      ST	Y,R2
    0333D E42E      LDI	R18,0x4E
(0770) 			SetEValve(EV1, EV_CLOSE);
    0333E E036      LDI	R19,6
    0333F E009      LDI	R16,0x9
    03340 E014      LDI	R17,4
    03341 940E A90D CALL	_uart_Printf
(0771) 			waitMotSampTurn = 1;
    03343 9180 00C1 LDS	R24,0xC1
(0772) 			waitMotSampPump = 1;
    03345 6180      ORI	R24,0x10
    03346 9380 00C1 STS	0xC1,R24
(0773) 			waitMotTurnPlate = 1;
    03348 9624      ADIW	R28,4
(0774) 			mainStep = 11;
    03349 940C AE6D JMP	pop_xgsetF0FC
_MachinePositionInit:
    0334B 940E AE83 CALL	push_xgset300C
(0775) 			i = 0;
    0334D 9723      SBIW	R28,3
    0334E E00C      LDI	R16,0xC
(0776) 			break;
    0334F 940E 97C6 CALL	_WaitDelayTime
(0777) 		case 11:
(0778) 			Uart0ReUnable;
    03351 2300      TST	R16
    03352 F011      BEQ	0x3355
    03353 2700      CLR	R16
    03354 C3B3      RJMP	0x3708
(0779) 			uart_Printf("%s\r\n",strM2113);
    03355 E002      LDI	R16,2
    03356 940E 97C6 CALL	_WaitDelayTime
    03358 2300      TST	R16
    03359 F011      BEQ	0x335C
    0335A 2700      CLR	R16
(0780) 			uart_Printf("%s\r\n",strM2118);
    0335B C3AC      RJMP	0x3708
    0335C E003      LDI	R16,3
    0335D 940E 97C6 CALL	_WaitDelayTime
    0335F 2EA0      MOV	R10,R16
    03360 2300      TST	R16
(0781) 			Uart0ReEnable;
    03361 F011      BEQ	0x3364
    03362 2700      CLR	R16
    03363 C3A4      RJMP	0x3708
    03364 E00B      LDI	R16,0xB
    03365 940E 97C6 CALL	_WaitDelayTime
(0782) 			mainStep = 12;
    03367 2EA0      MOV	R10,R16
    03368 2300      TST	R16
(0783) 			break;
    03369 F011      BEQ	0x336C
(0784) 		case 12:		// 扫描转盘上遗留干片	_RingPieceState
(0785) 			i++;
    0336A 2700      CLR	R16
    0336B C39C      RJMP	0x3708
    0336C 9020 1580 LDS	R2,ControlCmd+26
    0336E 2022      TST	R2
(0786) 			if(i >= RING_QUEUE_NUM)
    0336F F059      BEQ	0x337B
    03370 E002      LDI	R16,2
(0787) 				i = 0;
    03371 940E 6A0C CALL	_GetMotState
    03373 2F40      MOV	R20,R16
(0788) 			m = PINK & 0x01;
    03374 3001      CPI	R16,1
    03375 F011      BEQ	0x3378
    03376 2700      CLR	R16
    03377 C390      RJMP	0x3708
    03378 2422      CLR	R2
(0789) 			_RingPieceState[i] = 0;
    03379 9220 1580 STS	ControlCmd+26,R2
    0337B 9020 1581 LDS	R2,ControlCmd+27
    0337D 2022      TST	R2
    0337E F059      BEQ	0x338A
    0337F E003      LDI	R16,3
    03380 940E 6A0C CALL	_GetMotState
(0790) 			MotRunToSite(MOT_TURN_PLATE,i);
    03382 2F40      MOV	R20,R16
    03383 3001      CPI	R16,1
    03384 F011      BEQ	0x3387
    03385 2700      CLR	R16
    03386 C381      RJMP	0x3708
(0791) 			mainStep = 13;
    03387 2422      CLR	R2
    03388 9220 1581 STS	ControlCmd+27,R2
(0792) 			break;
    0338A 9020 1582 LDS	R2,ControlCmd+28
(0793) 		case 13:
(0794) 			n = PINK & 0x01;
    0338C 2022      TST	R2
    0338D F059      BEQ	0x3399
    0338E E00C      LDI	R16,0xC
    0338F 940E 6A0C CALL	_GetMotState
(0795) 			if(m != n)
    03391 2F40      MOV	R20,R16
    03392 3001      CPI	R16,1
    03393 F011      BEQ	0x3396
(0796) 				_RingPieceState[i] = 1;
    03394 2700      CLR	R16
    03395 C372      RJMP	0x3708
    03396 2422      CLR	R2
    03397 9220 1582 STS	ControlCmd+28,R2
    03399 9020 1584 LDS	R2,ControlCmd+30
    0339B 2022      TST	R2
    0339C F059      BEQ	0x33A8
(0797) 			if(GetMotState(MOT_TURN_PLATE)!=STA_SLAVE_FREE)	
    0339D E004      LDI	R16,4
    0339E 940E 6A0C CALL	_GetMotState
    033A0 2F40      MOV	R20,R16
    033A1 3001      CPI	R16,1
    033A2 F011      BEQ	0x33A5
(0798) 				break;
    033A3 2700      CLR	R16
(0799) 			if(i == 0)
    033A4 C363      RJMP	0x3708
    033A5 2422      CLR	R2
    033A6 9220 1584 STS	ControlCmd+30,R2
(0800) 				mainStep = 14;
    033A8 9020 1585 LDS	R2,ControlCmd+31
    033AA 2022      TST	R2
    033AB F059      BEQ	0x33B7
(0801) 			else
(0802) 				mainStep = 12;
    033AC E005      LDI	R16,5
    033AD 940E 6A0C CALL	_GetMotState
(0803) 			break;
    033AF 2F40      MOV	R20,R16
(0804) 		case 14:		// 扫描转盘
(0805) 			MotRunToSite(MOT_TURN_PLATE,10);	// 25 让转盘的0号转到卸片位置
    033B0 3001      CPI	R16,1
    033B1 F011      BEQ	0x33B4
    033B2 2700      CLR	R16
    033B3 C354      RJMP	0x3708
(0806) 			waitMotTurnPlate = 1;
    033B4 2422      CLR	R2
    033B5 9220 1585 STS	ControlCmd+31,R2
(0807) 			i = 0;
    033B7 9020 1586 LDS	R2,ControlCmd+32
    033B9 2022      TST	R2
(0808) 			mainStep = 15;
    033BA F059      BEQ	0x33C6
    033BB E001      LDI	R16,1
    033BC 940E 6A0C CALL	_GetMotState
(0809) 			break;
    033BE 2F40      MOV	R20,R16
    033BF 3001      CPI	R16,1
    033C0 F011      BEQ	0x33C3
    033C1 2700      CLR	R16
    033C2 C345      RJMP	0x3708
(0810) 		case 15:		// 按顺序寻找剩余干片
(0811) 			n = i + 10;
(0812) 			if(n>=RING_QUEUE_NUM)
    033C3 2422      CLR	R2
    033C4 9220 1586 STS	ControlCmd+32,R2
(0813) 				n -= RING_QUEUE_NUM;
    033C6 9020 1583 LDS	R2,ControlCmd+29
(0814) 			if(GetRingPieceState(i) == 1)	// 转盘上有剩余干片
    033C8 2022      TST	R2
    033C9 F059      BEQ	0x33D5
    033CA E008      LDI	R16,0x8
    033CB 940E 6A0C CALL	_GetMotState
    033CD 2F40      MOV	R20,R16
(0815) 			{
(0816) 				MotRunToSite(MOT_TURN_PLATE,n);	// 转盘运行到当前位置
    033CE 3001      CPI	R16,1
    033CF F011      BEQ	0x33D2
    033D0 2700      CLR	R16
    033D1 C336      RJMP	0x3708
    033D2 2422      CLR	R2
(0817) 				waitMotTurnPlate = 1;
    033D3 9220 1583 STS	ControlCmd+29,R2
    033D5 9140 157F LDS	R20,ControlCmd+25
(0818) 				mainStep = 16;
    033D7 2755      CLR	R21
    033D8 3040      CPI	R20,0
(0819) 				m = 0;		// 废片仓打开计时
    033D9 E0E0      LDI	R30,0
    033DA 075E      CPC	R21,R30
    033DB F40C      BGE	0x33DD
(0820) 			}
    033DC C32A      RJMP	0x3707
(0821) 			else
(0822) 				mainStep = 19;		// 继续查找下一个
    033DD E281      LDI	R24,0x21
    033DE E090      LDI	R25,0
    033DF 1784      CP	R24,R20
(0823) 			break;
    033E0 0795      CPC	R25,R21
(0824) 		case 16:		// 开始卸载转盘上的干片
(0825) 			if(GetwasteCardState() == 0)
    033E1 F40C      BGE	0x33E3
    033E2 C324      RJMP	0x3707
    033E3 EB80      LDI	R24,0xB0
    033E4 E091      LDI	R25,1
    033E5 01FA      MOVW	R30,R20
(0826) 			{
(0827) 				if((PINK & 0x02) == 0)
    033E6 0FEE      LSL	R30
    033E7 1FFF      ROL	R31
    033E8 0FE8      ADD	R30,R24
    033E9 1FF9      ADC	R31,R25
(0828) 				{
(0829) 					SetDelayTime(MOT_TURN_PLATE, 10);
    033EA 9027      ELPM	R2,Z+
    033EB 9036      ELPM	R3,Z
    033EC 01F1      MOVW	R30,R2
    033ED 9409      IJMP
    033EE E083      LDI	R24,3
(0830) 					m ++;
    033EF 838A      STD	Y+2,R24
    033F0 E08A      LDI	R24,0xA
    033F1 8388      ST	Y,R24
    033F2 EF20      LDI	R18,0xF0
    033F3 E003      LDI	R16,3
(0831) 					if(m == 2)
    033F4 940E 6A9F CALL	_SetMotRunPam
(0832) 					{
(0833) 						Uart0ReUnable;
    033F6 E084      LDI	R24,4
    033F7 838A      STD	Y+2,R24
    033F8 E184      LDI	R24,0x14
    033F9 8388      ST	Y,R24
    033FA EA20      LDI	R18,0xA0
(0834) 						uart_Printf("%s $   1\r\n",strM0200);
    033FB E004      LDI	R16,4
    033FC 940E 6A9F CALL	_SetMotRunPam
    033FE E084      LDI	R24,4
    033FF 838A      STD	Y+2,R24
    03400 E184      LDI	R24,0x14
(0835) 						Uart0ReEnable;
    03401 8388      ST	Y,R24
    03402 EA20      LDI	R18,0xA0
    03403 E005      LDI	R16,5
    03404 940E 6A9F CALL	_SetMotRunPam
(0836) 						SetBeepWarning();
    03406 E086      LDI	R24,6
(0837) 					}
(0838) 					if(m == 25)
    03407 838A      STD	Y+2,R24
    03408 E08A      LDI	R24,0xA
    03409 8388      ST	Y,R24
    0340A EB24      LDI	R18,0xB4
    0340B E00C      LDI	R16,0xC
(0839) 					{
(0840) 						SetBeepWarning();
    0340C 940E 6A9F CALL	_SetMotRunPam
(0841) 						m = 5;
    0340E E003      LDI	R16,3
    0340F 940E 6AFA CALL	_MotInitCheck
(0842) 					}
(0843) 					break;
    03411 E005      LDI	R16,5
    03412 940E 6AFA CALL	_MotInitCheck
    03414 E004      LDI	R16,4
    03415 940E 6AFA CALL	_MotInitCheck
    03417 E00C      LDI	R16,0xC
    03418 940E 6AFA CALL	_MotInitCheck
(0844) 				}
(0845) 			}
(0846) 			SetMotRunPam(MOT_CARD_UNLOAD,200,20,CURRENT_CARD_UNLOAD);
(0847) 			MotRunTo(MOT_CARD_UNLOAD,_POS_UNLOAD_OUT);
    0341A 2700      CLR	R16
    0341B 940E 18A0 CALL	_SetCardTrolleyState
    0341D E021      LDI	R18,1
(0848) 			waitMotCardUnLoad = 1;
    0341E E001      LDI	R16,1
    0341F 940E 6B81 CALL	_SetEValve
(0849) 			mainStep = 17;
    03421 E084      LDI	R24,4
    03422 838A      STD	Y+2,R24
    03423 E082      LDI	R24,2
(0850) 			break;
    03424 8388      ST	Y,R24
(0851) 		case 17:
(0852) 			SetDelayTime(MOT_SAMP_TRUN, 10);
    03425 EB24      LDI	R18,0xB4
    03426 E00B      LDI	R16,0xB
    03427 940E 6A9F CALL	_SetMotRunPam
    03429 EC24      LDI	R18,0xC4
(0853) 			mainStep = 18;
    0342A E039      LDI	R19,0x9
    0342B E00B      LDI	R16,0xB
    0342C 940E 6A2C CALL	_MotRun
(0854) 			break;
    0342E E081      LDI	R24,1
    0342F 9380 1585 STS	ControlCmd+31,R24
    03431 9380 157F STS	ControlCmd+25,R24
(0855) 		case 18:	// 卸片小车回到起始点
(0856) 			MotRunTo(MOT_CARD_UNLOAD,0);
(0857) 			waitMotCardUnLoad = 1;
    03433 C2D3      RJMP	0x3707
    03434 9180 00C1 LDS	R24,0xC1
(0858) 			mainStep = 19;
    03436 7E8F      ANDI	R24,0xEF
    03437 9380 00C1 STS	0xC1,R24
(0859) 			break;
    03439 E722      LDI	R18,0x72
(0860) 		case 19:
(0861) 			i++;
    0343A E039      LDI	R19,0x9
    0343B E004      LDI	R16,4
    0343C E014      LDI	R17,4
    0343D 940E A90D CALL	_uart_Printf
(0862) 			if(i < RING_QUEUE_NUM)	// 未完继续
    0343F 9180 00C1 LDS	R24,0xC1
(0863) 				mainStep = 15;
    03441 6180      ORI	R24,0x10
    03442 9380 00C1 STS	0xC1,R24
    03444 E082      LDI	R24,2
(0864) 			else
(0865) 			{
(0866) 				mainStep = 20;	// 检查结束
    03445 9380 157F STS	ControlCmd+25,R24
    03447 C2BF      RJMP	0x3707
(0867) 				Uart0ReUnable;
    03448 E081      LDI	R24,1
    03449 838A      STD	Y+2,R24
    0344A E184      LDI	R24,0x14
    0344B 8388      ST	Y,R24
    0344C EF20      LDI	R18,0xF0
(0868) 				uart_Printf("%s\r\n",strM2114);
    0344D E001      LDI	R16,1
    0344E 940E 6A9F CALL	_SetMotRunPam
    03450 E001      LDI	R16,1
    03451 940E 6AFA CALL	_MotInitCheck
(0869) 				Uart0ReEnable;
    03453 E081      LDI	R24,1
    03454 9380 1586 STS	ControlCmd+32,R24
    03456 E083      LDI	R24,3
    03457 9380 157F STS	ControlCmd+25,R24
(0870) 			}
(0871) 			break;
    03459 C2AD      RJMP	0x3707
    0345A 9180 00C1 LDS	R24,0xC1
    0345C 7E8F      ANDI	R24,0xEF
    0345D 9380 00C1 STS	0xC1,R24
    0345F E82B      LDI	R18,0x8B
(0872) 		case 20:	// 检查片仓小车上是否有干片
(0873) 			SetMotRunPam(MOT_STORE_CARD_MOVE,64,10,CURRENT_STORE_MOVE);
(0874) 			MotRunTo(MOT_STORE_CARD_MOVE,100);
    03460 E039      LDI	R19,0x9
    03461 E004      LDI	R16,4
    03462 E014      LDI	R17,4
    03463 940E A90D CALL	_uart_Printf
(0875) 			waitMotCardTrolley = 1;
    03465 9180 00C1 LDS	R24,0xC1
    03467 6180      ORI	R24,0x10
(0876) 			mainStep = 21;
    03468 9380 00C1 STS	0xC1,R24
    0346A E084      LDI	R24,4
(0877) 			break;
    0346B 9380 157F STS	ControlCmd+25,R24
(0878) 		case 21:
(0879) 			i = PINL & 0x04;					// 读取取片检测传感器空闲状态
    0346D C299      RJMP	0x3707
    0346E 2722      CLR	R18
    0346F E001      LDI	R16,1
    03470 940E 6A7F CALL	_MotRunToSite
(0880) 			MotRunTo(MOT_STORE_CARD_MOVE,0);	// 取片小车运行到零位
    03472 E081      LDI	R24,1
    03473 9380 1586 STS	ControlCmd+32,R24
    03475 9380 1581 STS	ControlCmd+27,R24
(0881) 			waitMotCardTrolley = 1;
    03477 E085      LDI	R24,5
    03478 9380 157F STS	ControlCmd+25,R24
(0882) 			mainStep = 22;
    0347A C28C      RJMP	0x3707
    0347B 9180 00C1 LDS	R24,0xC1
(0883) 			break;
    0347D 7E8F      ANDI	R24,0xEF
    0347E 9380 00C1 STS	0xC1,R24
    03480 EC2A      LDI	R18,0xCA
    03481 E039      LDI	R19,0x9
(0884) 		case 22:
(0885) 			n = PINL & 0x04;					// 读取取片检测传感器状态
(0886) 			if(i != n)		// 取片小车上有剩余干片
    03482 E004      LDI	R16,4
    03483 E014      LDI	R17,4
    03484 940E A90D CALL	_uart_Printf
(0887) 			{
(0888) 				MotRunToSite(MOT_TURN_PLATE,0);	// 转盘运行到0号位置
    03486 9180 00C1 LDS	R24,0xC1
    03488 6180      ORI	R24,0x10
    03489 9380 00C1 STS	0xC1,R24
(0889) 				waitMotTurnPlate = 1;
    0348B E086      LDI	R24,6
    0348C 9380 157F STS	ControlCmd+25,R24
(0890) 				mainStep = 23;
    0348E C278      RJMP	0x3707
    0348F E08A      LDI	R24,0xA
(0891) 				Uart0ReUnable;
    03490 838A      STD	Y+2,R24
    03491 8388      ST	Y,R24
    03492 EC28      LDI	R18,0xC8
    03493 E008      LDI	R16,0x8
    03494 940E 6A9F CALL	_SetMotRunPam
(0892) 				uart_Printf("%s\r\n",strM2115);
    03496 E008      LDI	R16,0x8
    03497 940E 6AFA CALL	_MotInitCheck
    03499 E081      LDI	R24,1
    0349A 9380 1581 STS	ControlCmd+27,R24
(0893) 				Uart0ReEnable;
    0349C E087      LDI	R24,7
    0349D 9380 157F STS	ControlCmd+25,R24
    0349F C267      RJMP	0x3707
(0894) 			}
    034A0 9180 00C1 LDS	R24,0xC1
(0895) 			else
(0896) 				mainStep = 31;		// 取片小车上没有干片, 跳过
    034A2 7E8F      ANDI	R24,0xEF
    034A3 9380 00C1 STS	0xC1,R24
(0897) 			break;
    034A5 EE22      LDI	R18,0xE2
    034A6 E039      LDI	R19,0x9
    034A7 E004      LDI	R16,4
    034A8 E014      LDI	R17,4
    034A9 940E A90D CALL	_uart_Printf
    034AB 9180 00C1 LDS	R24,0xC1
(0898) 		case 23:		// 干片推入转盘
(0899) 			SetMotRunPam(MOT_CARD_LOAD,160,10,CURRENT_CARD_LOAD);
(0900) 			MotRunTo(MOT_CARD_LOAD,_POS_CARDLOAD_RING);		// 装片行程94mm/0.08128 = 1156
    034AD 6180      ORI	R24,0x10
    034AE 9380 00C1 STS	0xC1,R24
    034B0 E088      LDI	R24,0x8
    034B1 9380 157F STS	ControlCmd+25,R24
(0901) 			waitMotCardLoad = 1;
    034B3 C253      RJMP	0x3707
    034B4 2722      CLR	R18
(0902) 			mainStep = 24;
    034B5 2733      CLR	R19
    034B6 E003      LDI	R16,3
    034B7 940E 6A5B CALL	_MotRunTo
(0903) 			break;
    034B9 E081      LDI	R24,1
    034BA 9380 1581 STS	ControlCmd+27,R24
    034BC E089      LDI	R24,0x9
    034BD 9380 157F STS	ControlCmd+25,R24
(0904) 		case 24:
(0905) 			SetDelayTime(MOT_SAMP_TRUN, 10);
(0906) 			mainStep = 25;
    034BF C247      RJMP	0x3707
    034C0 9180 00C1 LDS	R24,0xC1
(0907) 			break;
    034C2 7E8F      ANDI	R24,0xEF
    034C3 9380 00C1 STS	0xC1,R24
    034C5 EF2E      LDI	R18,0xFE
    034C6 E039      LDI	R19,0x9
    034C7 E004      LDI	R16,4
    034C8 E014      LDI	R17,4
    034C9 940E A90D CALL	_uart_Printf
(0908) 		case 25:		// 干片推入复位
(0909) 			SetMotRunPam(MOT_CARD_LOAD,200,10,CURRENT_CARD_LOAD);
(0910) 			MotRunTo(MOT_CARD_LOAD,0);
    034CB 9180 00C1 LDS	R24,0xC1
    034CD 6180      ORI	R24,0x10
    034CE 9380 00C1 STS	0xC1,R24
(0911) 			waitMotCardLoad = 1;
    034D0 E08A      LDI	R24,0xA
    034D1 9380 157F STS	ControlCmd+25,R24
(0912) 			mainStep = 26;
    034D3 C233      RJMP	0x3707
    034D4 2722      CLR	R18
(0913) 			break;
    034D5 2700      CLR	R16
(0914) 		case 26:		// 转盘0号转到卸片位置
(0915) 		//	SetMotRunPam(MOT_TURN_PLATE,240,10,2);
(0916) 			MotRunToSite(MOT_TURN_PLATE,25);
    034D6 940E 6B81 CALL	_SetEValve
    034D8 E084      LDI	R24,4
    034D9 838A      STD	Y+2,R24
(0917) 			waitMotTurnPlate = 1;
    034DA E085      LDI	R24,5
    034DB 8388      ST	Y,R24
    034DC EC28      LDI	R18,0xC8
(0918) 			mainStep = 27;
    034DD E002      LDI	R16,2
    034DE 940E 6A9F CALL	_SetMotRunPam
(0919) 			break;
    034E0 E002      LDI	R16,2
(0920) 		case 27:		// 开始卸片
(0921) 			SetMotRunPam(MOT_CARD_UNLOAD,200,20,CURRENT_CARD_UNLOAD);
    034E1 940E 6AFA CALL	_MotInitCheck
    034E3 2722      CLR	R18
    034E4 E001      LDI	R16,1
    034E5 940E 6B81 CALL	_SetEValve
    034E7 E081      LDI	R24,1
    034E8 9380 1580 STS	ControlCmd+26,R24
(0922) 			MotRunTo(MOT_CARD_UNLOAD,_POS_UNLOAD_OUT);
    034EA 9380 1582 STS	ControlCmd+28,R24
    034EC 9380 1586 STS	ControlCmd+32,R24
(0923) 			waitMotCardUnLoad = 1;
    034EE E08B      LDI	R24,0xB
    034EF 9380 157F STS	ControlCmd+25,R24
(0924) 			mainStep = 28;
    034F1 2422      CLR	R2
    034F2 9220 1589 STS	ControlCmd+35,R2
(0925) 			break;
    034F4 C212      RJMP	0x3707
(0926) 		case 28:
(0927) 			SetDelayTime(MOT_SAMP_TRUN,10);
    034F5 9180 00C1 LDS	R24,0xC1
    034F7 7E8F      ANDI	R24,0xEF
    034F8 9380 00C1 STS	0xC1,R24
(0928) 			mainStep = 29;
    034FA E62D      LDI	R18,0x6D
    034FB E03A      LDI	R19,0xA
    034FC E004      LDI	R16,4
(0929) 			break;
    034FD E014      LDI	R17,4
(0930) 		case 29:		// 卸片小车回到起始位
(0931) 			SetMotRunPam(MOT_CARD_UNLOAD,200,20,2);
    034FE 940E A90D CALL	_uart_Printf
    03500 EE2F      LDI	R18,0xEF
    03501 E03A      LDI	R19,0xA
    03502 E004      LDI	R16,4
    03503 E014      LDI	R17,4
    03504 940E A90D CALL	_uart_Printf
(0932) 			MotRunTo(MOT_CARD_UNLOAD,_POS_UNLOAD_HOME);
    03506 9180 00C1 LDS	R24,0xC1
    03508 6180      ORI	R24,0x10
    03509 9380 00C1 STS	0xC1,R24
(0933) 			waitMotCardUnLoad = 1;
    0350B E08C      LDI	R24,0xC
    0350C 9380 157F STS	ControlCmd+25,R24
(0934) 			mainStep = 30;
    0350E C1F8      RJMP	0x3707
    0350F 9180 1589 LDS	R24,ControlCmd+35
(0935) 			break;
    03511 5F8F      SUBI	R24,0xFF
(0936) 		case 30:
(0937) 			Uart0ReUnable;
    03512 9380 1589 STS	ControlCmd+35,R24
    03514 318E      CPI	R24,0x1E
    03515 F018      BCS	0x3519
    03516 2422      CLR	R2
(0938) 			uart_Printf("%s\r\n",strM2116);
    03517 9220 1589 STS	ControlCmd+35,R2
    03519 9180 0106 LDS	R24,0x106
    0351B 7081      ANDI	R24,1
    0351C 9380 158B STS	ControlCmd+37,R24
(0939) 			Uart0ReEnable;
    0351E E983      LDI	R24,0x93
    0351F E195      LDI	R25,0x15
    03520 91E0 1589 LDS	R30,ControlCmd+35
(0940) 			mainStep = 31;
    03522 27FF      CLR	R31
    03523 0FE8      ADD	R30,R24
    03524 1FF9      ADC	R31,R25
(0941) 			break;
    03525 2422      CLR	R2
(0942) 		case 31:		// 转盘运转到初始状态
(0943) 			MotRunToSite(MOT_TURN_PLATE,29);
    03526 8220      ST	Z,R2
    03527 9120 1589 LDS	R18,ControlCmd+35
    03529 E001      LDI	R16,1
(0944) 			waitMotTurnPlate = 1;
    0352A 940E 6A7F CALL	_MotRunToSite
    0352C E08D      LDI	R24,0xD
(0945) 			MotRunTo(MOT_STORE_CARD_MOVE,432);
    0352D 9380 157F STS	ControlCmd+25,R24
    0352F C1D7      RJMP	0x3707
    03530 9180 0106 LDS	R24,0x106
(0946) 			waitMotCardTrolley = 1;
    03532 7081      ANDI	R24,1
    03533 9380 158A STS	ControlCmd+36,R24
(0947) 			mainStep = 32;
    03535 9030 158B LDS	R3,ControlCmd+37
    03537 1638      CP	R3,R24
(0948) 			break;
    03538 F049      BEQ	0x3542
(0949) 		case 32:
(0950) 			Uart0ReUnable;
    03539 E983      LDI	R24,0x93
    0353A E195      LDI	R25,0x15
    0353B 91E0 1589 LDS	R30,ControlCmd+35
    0353D 27FF      CLR	R31
(0951) 			uart_Printf("%s\r\n",strM2117);
    0353E 0FE8      ADD	R30,R24
    0353F 1FF9      ADC	R31,R25
    03540 E081      LDI	R24,1
    03541 8380      ST	Z,R24
    03542 E001      LDI	R16,1
    03543 940E 6A0C CALL	_GetMotState
(0952) 			Uart0ReEnable;
    03545 2F40      MOV	R20,R16
    03546 3001      CPI	R16,1
    03547 F009      BEQ	0x3549
    03548 C1BE      RJMP	0x3707
(0953) 			mainStep = 33;
    03549 9020 1589 LDS	R2,ControlCmd+35
    0354B 2022      TST	R2
(0954) 			break;
    0354C F421      BNE	0x3551
(0955) 		case 33:
(0956) 			Uart0ReUnable;
    0354D E08E      LDI	R24,0xE
    0354E 9380 157F STS	ControlCmd+25,R24
    03550 C1B6      RJMP	0x3707
    03551 E08C      LDI	R24,0xC
(0957) 			uart_Printf("%s\r\n", strM1101);
    03552 9380 157F STS	ControlCmd+25,R24
    03554 C1B2      RJMP	0x3707
    03555 E02A      LDI	R18,0xA
    03556 E001      LDI	R16,1
    03557 940E 6A7F CALL	_MotRunToSite
(0958) 			Uart0ReEnable;
    03559 E081      LDI	R24,1
    0355A 9380 1586 STS	ControlCmd+32,R24
    0355C 2422      CLR	R2
(0959) 			mainStep = 0;
    0355D 9220 1589 STS	ControlCmd+35,R2
    0355F E08F      LDI	R24,0xF
(0960) 			return 1;
    03560 9380 157F STS	ControlCmd+25,R24
(0961) 			break;
(0962) 		}
(0963) 	return 0;
    03562 C1A4      RJMP	0x3707
    03563 9180 1589 LDS	R24,ControlCmd+35
    03565 5F86      SUBI	R24,0xF6
(0964) }
(0965) 
(0966) // 等待吸样按键
(0967) unsigned char WaitStartKey(void){
(0968) 	// 等待启动按键按下
(0969) 	static unsigned char callCnt;
(0970) 	unsigned char key;
(0971) 	
(0972) 	key = (PINJ & 0x40);
_WaitStartKey:
  key                  --> R16
    03566 9380 158A STS	ControlCmd+36,R24
    03568 318E      CPI	R24,0x1E
(0973) 	if(callCnt == 0){
    03569 F018      BCS	0x356D
    0356A 518E      SUBI	R24,0x1E
    0356B 9380 158A STS	ControlCmd+36,R24
(0974) 		if(key == 0)	// 按键在松开是启动，如果按键一直按着视为无动作
    0356D 9100 1589 LDS	R16,ControlCmd+35
(0975) 			callCnt = 1;
    0356F D810      RCALL	_GetRingPieceState
    03570 2F40      MOV	R20,R16
    03571 3001      CPI	R16,1
(0976) 		}
    03572 F479      BNE	0x3582
(0977) 	else {
(0978) 		if(key == 0x40){	// 按键按下
    03573 9120 158A LDS	R18,ControlCmd+36
(0979) 			callCnt = 0;
    03575 E001      LDI	R16,1
    03576 940E 6A7F CALL	_MotRunToSite
(0980) 			return 1;
    03578 E081      LDI	R24,1
    03579 9380 1586 STS	ControlCmd+32,R24
(0981) 			}
(0982) 		}
(0983) 	return 0;
    0357B E180      LDI	R24,0x10
(0984) }
(0985) 
(0986) /********************************************* 蜂鸣提示音 **********************************************/
(0987) static unsigned char BeepNum=0;
(0988) static unsigned char BeepState=0;
(0989) static unsigned int BeepCnt;
(0990) 
(0991) void SetBeepBusy(void){
(0992) 	// 1短 1长
(0993) 	BeepState=1;
_SetBeepBusy:
    0357C 9380 157F STS	ControlCmd+25,R24
    0357E 2422      CLR	R2
(0994) 	BeepNum = 0;
    0357F 9220 158B STS	ControlCmd+37,R2
    03581 C185      RJMP	0x3707
(0995) 	BeepCnt=0;
    03582 E183      LDI	R24,0x13
    03583 9380 157F STS	ControlCmd+25,R24
    03585 C181      RJMP	0x3707
    03586 940E A99B CALL	_GetwasteCardState
(0996) }
(0997) void SetBeepWarning(void){
(0998) 	// 1长音
(0999) 	BeepState=2;
_SetBeepWarning:
    03588 2EA0      MOV	R10,R16
    03589 2300      TST	R16
    0358A F559      BNE	0x35B6
(1000) 	BeepNum = 0;
    0358B 9020 0106 LDS	R2,0x106
    0358D FC21      SBRC	R2,1
(1001) 	BeepCnt=0;
    0358E C027      RJMP	0x35B6
    0358F E02A      LDI	R18,0xA
    03590 E030      LDI	R19,0
    03591 E001      LDI	R16,1
    03592 940E 97B7 CALL	_SetDelayTime
(1002) }
(1003) void SetBeepAck(void){
(1004) 	// 1短音
(1005) 	BeepState=3;
_SetBeepAck:
    03594 9180 158B LDS	R24,ControlCmd+37
    03596 5F8F      SUBI	R24,0xFF
(1006) 	BeepNum = 0;
    03597 9380 158B STS	ControlCmd+37,R24
    03599 3082      CPI	R24,2
(1007) 	BeepCnt=0;
    0359A F489      BNE	0x35AC
    0359B 9180 00C1 LDS	R24,0xC1
    0359D 7E8F      ANDI	R24,0xEF
    0359E 9380 00C1 STS	0xC1,R24
(1008) 	
(1009) }
(1010) void SetBeepPrompt(void){
(1011) 	// 2短音
(1012) 	BeepState=4;
_SetBeepPrompt:
    035A0 EF27      LDI	R18,0xF7
    035A1 E035      LDI	R19,5
    035A2 EF09      LDI	R16,0xF9
(1013) 	BeepNum = 0;
    035A3 E013      LDI	R17,3
    035A4 940E A90D CALL	_uart_Printf
(1014) 	BeepCnt=0;
    035A6 9180 00C1 LDS	R24,0xC1
    035A8 6180      ORI	R24,0x10
    035A9 9380 00C1 STS	0xC1,R24
    035AB D181      RCALL	_SetBeepWarning
(1015) }
(1016) void SetBeepError(void){
(1017) 	// 连续长音
(1018) 	BeepState=5;
_SetBeepError:
    035AC 9180 158B LDS	R24,ControlCmd+37
    035AE 3189      CPI	R24,0x19
(1019) 	BeepNum = 0;
    035AF F009      BEQ	0x35B1
    035B0 C156      RJMP	0x3707
    035B1 D17B      RCALL	_SetBeepWarning
(1020) 	BeepCnt=0;
    035B2 E085      LDI	R24,5
    035B3 9380 158B STS	ControlCmd+37,R24
    035B5 C151      RJMP	0x3707
    035B6 E084      LDI	R24,4
    035B7 838A      STD	Y+2,R24
(1021) }
(1022) void SetBeep(unsigned char n){
(1023) 	BeepState=0;
_SetBeep:
  n                    --> R16
    035B8 E184      LDI	R24,0x14
    035B9 8388      ST	Y,R24
    035BA EC28      LDI	R18,0xC8
(1024) 	BeepNum = n;
    035BB E005      LDI	R16,5
    035BC 940E 6A9F CALL	_SetMotRunPam
(1025) 	BeepCnt=0;
    035BE E420      LDI	R18,0x40
    035BF E036      LDI	R19,6
    035C0 E005      LDI	R16,5
    035C1 940E 6A5B CALL	_MotRunTo
(1026) }
(1027) void BeepStop(void){
(1028) 	BeepState=0;
_BeepStop:
    035C3 E081      LDI	R24,1
    035C4 9380 1585 STS	ControlCmd+31,R24
(1029) 	BeepNum = 0;
    035C6 E181      LDI	R24,0x11
    035C7 9380 157F STS	ControlCmd+25,R24
(1030) 	BeepCnt=0;
    035C9 C13D      RJMP	0x3707
    035CA E02A      LDI	R18,0xA
    035CB E030      LDI	R19,0
    035CC E002      LDI	R16,2
    035CD 940E 97B7 CALL	_SetDelayTime
(1031) }
(1032) 
(1033) void Beep(void){
(1034) 	BeepCnt ++;
    035CF E182      LDI	R24,0x12
    035D0 9380 157F STS	ControlCmd+25,R24
    035D2 C134      RJMP	0x3707
    035D3 2722      CLR	R18
    035D4 2733      CLR	R19
    035D5 E005      LDI	R16,5
    035D6 940E 6A5B CALL	_MotRunTo
(1035) 	switch(BeepState){
    035D8 E081      LDI	R24,1
    035D9 9380 1585 STS	ControlCmd+31,R24
    035DB E183      LDI	R24,0x13
    035DC 9380 157F STS	ControlCmd+25,R24
    035DE C128      RJMP	0x3707
    035DF 9180 1589 LDS	R24,ControlCmd+35
    035E1 5F8F      SUBI	R24,0xFF
    035E2 9380 1589 STS	ControlCmd+35,R24
    035E4 318E      CPI	R24,0x1E
    035E5 F420      BCC	0x35EA
    035E6 E08F      LDI	R24,0xF
    035E7 9380 157F STS	ControlCmd+25,R24
    035E9 C11D      RJMP	0x3707
    035EA E184      LDI	R24,0x14
    035EB 9380 157F STS	ControlCmd+25,R24
    035ED 9180 00C1 LDS	R24,0xC1
    035EF 7E8F      ANDI	R24,0xEF
    035F0 9380 00C1 STS	0xC1,R24
    035F2 E826      LDI	R18,0x86
    035F3 E03A      LDI	R19,0xA
    035F4 E004      LDI	R16,4
    035F5 E014      LDI	R17,4
    035F6 940E A90D CALL	_uart_Printf
(1036) 		case 0:
(1037) 			if(BeepNum){
    035F8 9180 00C1 LDS	R24,0xC1
    035FA 6180      ORI	R24,0x10
    035FB 9380 00C1 STS	0xC1,R24
(1038) 				switch(BeepCnt){
    035FD C109      RJMP	0x3707
    035FE E08A      LDI	R24,0xA
    035FF 838A      STD	Y+2,R24
    03600 8388      ST	Y,R24
    03601 E420      LDI	R18,0x40
    03602 E008      LDI	R16,0x8
    03603 940E 6A9F CALL	_SetMotRunPam
    03605 E624      LDI	R18,0x64
    03606 E030      LDI	R19,0
    03607 E008      LDI	R16,0x8
    03608 940E 6A5B CALL	_MotRunTo
    0360A E081      LDI	R24,1
    0360B 9380 1583 STS	ControlCmd+29,R24
    0360D E185      LDI	R24,0x15
    0360E 9380 157F STS	ControlCmd+25,R24
    03610 C0F6      RJMP	0x3707
    03611 9180 0109 LDS	R24,0x109
    03613 7084      ANDI	R24,4
    03614 9380 1589 STS	ControlCmd+35,R24
    03616 2722      CLR	R18
    03617 2733      CLR	R19
    03618 E008      LDI	R16,0x8
    03619 940E 6A5B CALL	_MotRunTo
    0361B E081      LDI	R24,1
(1039) 					case 10:	DDRB  |= 0x80;				break;
    0361C 9380 1583 STS	ControlCmd+29,R24
(1040) 					case 200:	DDRB  &= 0x7f;				break;
    0361E E186      LDI	R24,0x16
    0361F 9380 157F STS	ControlCmd+25,R24
    03621 C0E5      RJMP	0x3707
(1041) 					case 500:	BeepCnt = 0;	BeepNum --;	break;
    03622 9180 0109 LDS	R24,0x109
    03624 7084      ANDI	R24,4
    03625 9380 158A STS	ControlCmd+36,R24
    03627 9030 1589 LDS	R3,ControlCmd+35
    03629 1638      CP	R3,R24
    0362A F0D9      BEQ	0x3646
    0362B 2722      CLR	R18
    0362C E001      LDI	R16,1
(1042) 					default:	break;
(1043) 				}
(1044) 			}
(1045) 			break;
    0362D 940E 6A7F CALL	_MotRunToSite
(1046) 		case 1:// 提示忙 1短 1长
(1047) 			switch(BeepCnt){
    0362F E081      LDI	R24,1
    03630 9380 1586 STS	ControlCmd+32,R24
    03632 E187      LDI	R24,0x17
    03633 9380 157F STS	ControlCmd+25,R24
    03635 9180 00C1 LDS	R24,0xC1
    03637 7E8F      ANDI	R24,0xEF
    03638 9380 00C1 STS	0xC1,R24
    0363A EA20      LDI	R18,0xA0
    0363B E03A      LDI	R19,0xA
    0363C E004      LDI	R16,4
    0363D E014      LDI	R17,4
    0363E 940E A90D CALL	_uart_Printf
    03640 9180 00C1 LDS	R24,0xC1
    03642 6180      ORI	R24,0x10
    03643 9380 00C1 STS	0xC1,R24
    03645 C0C1      RJMP	0x3707
    03646 E18F      LDI	R24,0x1F
    03647 9380 157F STS	ControlCmd+25,R24
    03649 C0BD      RJMP	0x3707
    0364A E084      LDI	R24,4
    0364B 838A      STD	Y+2,R24
    0364C E08A      LDI	R24,0xA
    0364D 8388      ST	Y,R24
    0364E EA20      LDI	R18,0xA0
    0364F E004      LDI	R16,4
    03650 940E 6A9F CALL	_SetMotRunPam
    03652 E420      LDI	R18,0x40
    03653 E036      LDI	R19,6
    03654 E004      LDI	R16,4
    03655 940E 6A5B CALL	_MotRunTo
    03657 E081      LDI	R24,1
    03658 9380 1584 STS	ControlCmd+30,R24
    0365A E188      LDI	R24,0x18
    0365B 9380 157F STS	ControlCmd+25,R24
    0365D C0A9      RJMP	0x3707
    0365E E02A      LDI	R18,0xA
    0365F E030      LDI	R19,0
    03660 E002      LDI	R16,2
    03661 940E 97B7 CALL	_SetDelayTime
    03663 E189      LDI	R24,0x19
    03664 9380 157F STS	ControlCmd+25,R24
    03666 C0A0      RJMP	0x3707
    03667 E084      LDI	R24,4
(1048) 					case 10:	DDRB  |= 0x80;				break;
    03668 838A      STD	Y+2,R24
    03669 E08A      LDI	R24,0xA
(1049) 					case 200:	DDRB  &= 0x7f;				break;
    0366A 8388      ST	Y,R24
    0366B EC28      LDI	R18,0xC8
    0366C E004      LDI	R16,4
    0366D 940E 6A9F CALL	_SetMotRunPam
(1050) 					case 500:	DDRB  |= 0x80;				break;
    0366F 2722      CLR	R18
(1051) 					case 2000:	DDRB  &= 0x7f;				break;
    03670 2733      CLR	R19
    03671 E004      LDI	R16,4
    03672 940E 6A5B CALL	_MotRunTo
(1052) 					case 2500:	BeepCnt = 0; BeepState = 0;	break;
    03674 E081      LDI	R24,1
    03675 9380 1584 STS	ControlCmd+30,R24
    03677 E18A      LDI	R24,0x1A
    03678 9380 157F STS	ControlCmd+25,R24
    0367A C08C      RJMP	0x3707
    0367B E129      LDI	R18,0x19
(1053) 					default:	break;
(1054) 				}
(1055) 			break;
    0367C E001      LDI	R16,1
(1056) 		case 2:// 提示警告  1长音
(1057) 			switch(BeepCnt){
    0367D 940E 6A7F CALL	_MotRunToSite
    0367F E081      LDI	R24,1
    03680 9380 1586 STS	ControlCmd+32,R24
    03682 E18B      LDI	R24,0x1B
    03683 9380 157F STS	ControlCmd+25,R24
    03685 C081      RJMP	0x3707
    03686 E084      LDI	R24,4
    03687 838A      STD	Y+2,R24
    03688 E184      LDI	R24,0x14
    03689 8388      ST	Y,R24
    0368A EC28      LDI	R18,0xC8
    0368B E005      LDI	R16,5
    0368C 940E 6A9F CALL	_SetMotRunPam
    0368E E420      LDI	R18,0x40
    0368F E036      LDI	R19,6
    03690 E005      LDI	R16,5
    03691 940E 6A5B CALL	_MotRunTo
    03693 E081      LDI	R24,1
    03694 9380 1585 STS	ControlCmd+31,R24
    03696 E18C      LDI	R24,0x1C
    03697 9380 157F STS	ControlCmd+25,R24
    03699 C06D      RJMP	0x3707
    0369A E02A      LDI	R18,0xA
    0369B E030      LDI	R19,0
(1058) 					case 10:	DDRB  |= 0x80;				break;
    0369C E002      LDI	R16,2
    0369D 940E 97B7 CALL	_SetDelayTime
(1059) 					case 2500:	DDRB  &= 0x7f;				break;
    0369F E18D      LDI	R24,0x1D
    036A0 9380 157F STS	ControlCmd+25,R24
(1060) 					case 3000:	BeepCnt = 0; BeepState = 0;	break;
    036A2 C064      RJMP	0x3707
    036A3 E082      LDI	R24,2
    036A4 838A      STD	Y+2,R24
    036A5 E184      LDI	R24,0x14
    036A6 8388      ST	Y,R24
    036A7 EC28      LDI	R18,0xC8
    036A8 E005      LDI	R16,5
    036A9 940E 6A9F CALL	_SetMotRunPam
(1061) 					default:	break;
(1062) 				}
(1063) 			break;
    036AB 2722      CLR	R18
    036AC 2733      CLR	R19
    036AD E005      LDI	R16,5
    036AE 940E 6A5B CALL	_MotRunTo
    036B0 E081      LDI	R24,1
    036B1 9380 1585 STS	ControlCmd+31,R24
    036B3 E18E      LDI	R24,0x1E
    036B4 9380 157F STS	ControlCmd+25,R24
    036B6 C050      RJMP	0x3707
    036B7 9180 00C1 LDS	R24,0xC1
    036B9 7E8F      ANDI	R24,0xEF
    036BA 9380 00C1 STS	0xC1,R24
    036BC EB26      LDI	R18,0xB6
    036BD E03A      LDI	R19,0xA
    036BE E004      LDI	R16,4
    036BF E014      LDI	R17,4
    036C0 940E A90D CALL	_uart_Printf
    036C2 9180 00C1 LDS	R24,0xC1
    036C4 6180      ORI	R24,0x10
    036C5 9380 00C1 STS	0xC1,R24
    036C7 E18F      LDI	R24,0x1F
    036C8 9380 157F STS	ControlCmd+25,R24
(1064) 		case 3:	// 操作应答  1短音
(1065) 			switch(BeepCnt){
(1066) 					case 10:	DDRB  |= 0x80;				break;
    036CA C03C      RJMP	0x3707
    036CB E12D      LDI	R18,0x1D
(1067) 					case 200:	DDRB  &= 0x7f;				break;
    036CC E001      LDI	R16,1
    036CD 940E 6A7F CALL	_MotRunToSite
    036CF E081      LDI	R24,1
(1068) 					case 500:	BeepCnt = 0; BeepState = 0;	break;
    036D0 9380 1586 STS	ControlCmd+32,R24
    036D2 EB20      LDI	R18,0xB0
    036D3 E031      LDI	R19,1
    036D4 E008      LDI	R16,0x8
    036D5 940E 6A5B CALL	_MotRunTo
    036D7 E081      LDI	R24,1
(1069) 					default:	break;
(1070) 				}
(1071) 			break;
    036D8 9380 1583 STS	ControlCmd+29,R24
(1072) 		case 4:	// 输出提示  2短音
(1073) 			switch(BeepCnt){
    036DA E280      LDI	R24,0x20
    036DB 9380 157F STS	ControlCmd+25,R24
    036DD C029      RJMP	0x3707
    036DE 9180 00C1 LDS	R24,0xC1
    036E0 7E8F      ANDI	R24,0xEF
    036E1 9380 00C1 STS	0xC1,R24
    036E3 ED23      LDI	R18,0xD3
    036E4 E03A      LDI	R19,0xA
    036E5 E004      LDI	R16,4
    036E6 E014      LDI	R17,4
    036E7 940E A90D CALL	_uart_Printf
    036E9 9180 00C1 LDS	R24,0xC1
    036EB 6180      ORI	R24,0x10
    036EC 9380 00C1 STS	0xC1,R24
    036EE E281      LDI	R24,0x21
    036EF 9380 157F STS	ControlCmd+25,R24
    036F1 C015      RJMP	0x3707
    036F2 9180 00C1 LDS	R24,0xC1
    036F4 7E8F      ANDI	R24,0xEF
    036F5 9380 00C1 STS	0xC1,R24
    036F7 E623      LDI	R18,0x63
    036F8 E036      LDI	R19,6
    036F9 E004      LDI	R16,4
    036FA E014      LDI	R17,4
    036FB 940E A90D CALL	_uart_Printf
    036FD 9180 00C1 LDS	R24,0xC1
    036FF 6180      ORI	R24,0x10
    03700 9380 00C1 STS	0xC1,R24
    03702 2422      CLR	R2
    03703 9220 157F STS	ControlCmd+25,R2
    03705 E001      LDI	R16,1
    03706 C001      RJMP	0x3708
    03707 2700      CLR	R16
    03708 9623      ADIW	R28,3
    03709 940C AE88 JMP	pop_xgset300C
_WaitStartKey:
    0370B 9100 0103 LDS	R16,0x103
    0370D 7400      ANDI	R16,0x40
    0370E 9020 158C LDS	R2,ControlCmd+38
    03710 2022      TST	R2
    03711 F431      BNE	0x3718
(1074) 					case 10:	DDRB  |= 0x80;				break;
    03712 2300      TST	R16
    03713 F459      BNE	0x371F
(1075) 					case 200:	DDRB  &= 0x7f;				break;
    03714 E081      LDI	R24,1
    03715 9380 158C STS	ControlCmd+38,R24
    03717 C007      RJMP	0x371F
(1076) 					case 500:	DDRB  |= 0x80;				break;
    03718 3400      CPI	R16,0x40
    03719 F429      BNE	0x371F
(1077) 					case 700:	DDRB  &= 0x7f;				break;
    0371A 2422      CLR	R2
    0371B 9220 158C STS	ControlCmd+38,R2
    0371D E001      LDI	R16,1
(1078) 					case 1000:	BeepCnt = 0; BeepState = 0;	break;
    0371E C001      RJMP	0x3720
    0371F 2700      CLR	R16
    03720 9508      RET
_SetBeepBusy:
    03721 E081      LDI	R24,1
    03722 9380 03F8 STS	BeepState+1,R24
    03724 2422      CLR	R2
    03725 9220 03F7 STS	BeepState,R2
(1079) 					default:	break;
(1080) 				}
(1081) 			break;
    03727 2433      CLR	R3
    03728 9230 158E STS	ControlCmd+40,R3
    0372A 9220 158D STS	ControlCmd+39,R2
    0372C 9508      RET
_SetBeepWarning:
    0372D E082      LDI	R24,2
    0372E 9380 03F8 STS	BeepState+1,R24
    03730 2422      CLR	R2
    03731 9220 03F7 STS	BeepState,R2
    03733 2433      CLR	R3
    03734 9230 158E STS	ControlCmd+40,R3
    03736 9220 158D STS	ControlCmd+39,R2
    03738 9508      RET
_SetBeepAck:
    03739 E083      LDI	R24,3
    0373A 9380 03F8 STS	BeepState+1,R24
    0373C 2422      CLR	R2
    0373D 9220 03F7 STS	BeepState,R2
    0373F 2433      CLR	R3
    03740 9230 158E STS	ControlCmd+40,R3
    03742 9220 158D STS	ControlCmd+39,R2
    03744 9508      RET
_SetBeepPrompt:
    03745 E084      LDI	R24,4
(1082) 		case 5:	// 错误 连续长音
(1083) 			switch(BeepCnt){
(1084) 					case 10:	DDRB  |= 0x80;				break;
    03746 9380 03F8 STS	BeepState+1,R24
(1085) 					case 2500:	DDRB  &= 0x7f;				break;
    03748 2422      CLR	R2
    03749 9220 03F7 STS	BeepState,R2
    0374B 2433      CLR	R3
(1086) 					case 3000:	BeepCnt = 0; 				break;
    0374C 9230 158E STS	ControlCmd+40,R3
    0374E 9220 158D STS	ControlCmd+39,R2
    03750 9508      RET
_SetBeepError:
    03751 E085      LDI	R24,5
(1087) 					default:	break;
(1088) 				}
(1089) 			break;
(1090) 		default:
(1091) 			break;
    03752 9380 03F8 STS	BeepState+1,R24
(1092) 		}
(1093) }
(1094) 
(1095) // 设置状态指示灯
(1096) void SetStateLedBusy(void){
(1097) 	DDRE |= 0x30;
    03754 2422      CLR	R2
    03755 9220 03F7 STS	BeepState,R2
(1098) 	PORTE |= 0x10;
    03757 2433      CLR	R3
    03758 9230 158E STS	ControlCmd+40,R3
    0375A 9220 158D STS	ControlCmd+39,R2
(1099) 	PORTE &= 0xdf;
(1100) }
(1101) void SetStateLedFree(void){
(1102) 	DDRE |= 0x30;
    0375C 9508      RET
_SetBeep:
    0375D 2422      CLR	R2
(1103) 	PORTE |= 0x20;
    0375E 9220 03F8 STS	BeepState+1,R2
(1104) 	PORTE &= 0xef;
    03760 9300 03F7 STS	BeepState,R16
    03762 2433      CLR	R3
FILE: D:\Work\主控软件\2032A2~1\diluteProcess.c
(0001) 
(0002) 
(0003) #include <iom1280v.h>
(0004) #include "B1404_LIB.h"
(0005) #include "Common.h"
(0006) #include "eeprom.h"
(0007) 
(0008) /* 本模块包含以下功能:
(0009) 1.液路自检
(0010) 2.泵定标
(0011) 3.稀释标本
(0012) 4.从干片仓提取新干片
(0013) 5.将滴完样本的干片放入转盘
(0014) 6.调用其它模块将测试任务加入任务队列
(0015) */
(0016) 
(0017) 
(0018) /*		稀释比例
(0019) 比例	标本(uL)		稀释液(uL)		混匀液(uL)
(0020) 				[一次混匀]
(0021) 1		100
(0022) 2		90				90	(4)			180
(0023) 5		90				360	(12)		450
(0024) 10		60				540	(18)		600
(0025) 
(0026) 20		30				570	(19)		600
(0027) 50		9.8				480	(16)		489.8		(做为二次混匀的一次稀释)
(0028) 100		10				990	(33)		1000		
(0029) 200		4.97			990	(33)		994.7
(0030) 				[二次混匀]
(0031) 10		60				540	(18)		600			X 50 = 500
(0032) 20		30				570	(19)		600			X 50 = 1000
(0033) 40		20				780	(26)		800			X 50 = 2000
(0034) 50		18.98			930	(31)		948.99		X 100 = 5000
(0035) 100		10				990	(33)		1000		X 100 = 10000
(0036) 二次稀释以100倍的一次稀释液为标本再次稀释
(0037) 
(0038) 
(0039) 稀释泵流量单位是：30uL，即每转过一个泵小轮的管道流量1
(0040) 柱塞泵步进行程：16 * 2.032mm = 32.512mm / 400 = 0.08128mm
(0041) 柱塞泵每步注射量：0.08128mm * （1*1*3.1416）mm2 = 0.255349248mm3 = 0.25535mm3
(0042) */
(0043) 
(0044) 
(0045) void _FluidMotRun(signed int n,unsigned char vel);
(0046) void _EffluentMotRun(signed int n,unsigned char vel);
(0047) void _DiluentMotRun(signed int n,unsigned char vel);
(0048) void _NewDiluentMotRun(signed int n,unsigned char vel);
(0049) void _NeedleMotRun(signed int n,unsigned char vel);
(0050) void _NeedleMotRunTo(signed int n,unsigned char vel);
(0051) void _SampPumpMotRun(signed int n,unsigned char vel);
(0052) void _SampPumpMotRunTo(signed int n,unsigned char vel);
(0053) 
(0054) //********************************************
(0055) extern unsigned char CardNoneUseful;
(0056) unsigned char InsertRingFlag = 0;
(0057) extern unsigned char insertflag[30];
(0058) unsigned char JudgeFlag;					// 如果设置吸样量,可通过此变量调节稀释倍数
(0059) unsigned char WithoutPuncture = 0;			// 默认为0 穿刺   1  不穿刺
(0060) extern unsigned char preCardStoreNum;
(0061) extern unsigned char CardStoreTestFlag;	
(0062) extern unsigned char LastCardGetState;
(0063) extern unsigned char primeProcessSW;		
(0064) extern unsigned char WorkProcessStep;		// 工作进程号
(0065) //********************************************
(0066) 
(0067) SAMP_INFO NewTestInfo;		// 新测试信息
(0068) 
(0069) // 工作参数
(0070) unsigned char CurInsertRingNum;			// 新测试卡要插入转盘的位置，0xff表示无效
(0071) unsigned char GetNewTestCard;			// 取新的测试卡，0:无, 1:取插入卡, 2:取仓1卡, 3:取仓2卡, 4:取仓3卡, 5:取仓4卡, 6:取仓5卡，
(0072) 										// 254:取卡完成等待滴样, 255:卡片滴样完成等待放入转盘, 250:提取卡片出错
(0073) 										// 222:取片准备抽打混匀, 233:抽打混匀结束,准备进入254取片完成准备滴样
(0074) unsigned long SecondCount = 0;			// 秒时钟计数，在定时中断计数
(0075) extern unsigned char TurnPlateUsedLock;	// 转盘使用锁
(0076) 
(0077) 
(0078) static unsigned char _DiluentQuitFlag = 0;
(0079) static unsigned int liqDetBaseAdc;
(0080) static unsigned char runNum;
(0081) static unsigned char waitMotSampTurn,waitMotSampNeedle, waitMotSampPump,waitMotFluid,waitMotDiluent,waitEffluent;
(0082) signed int _DropVolume;					// 滴样量
(0083) signed int _SamplingVolume;				// 吸样量
(0084) unsigned int _DropMode;					// 滴样模式 0 胶体金试剂片	1 荧光试剂片
(0085) unsigned char _MixtureMode;				// 1:1是否需要混匀 0 需要  1  不需要
(0086) unsigned int _ReMixNum = 5;				// 抽打次数
(0087) unsigned int _SleepTime;				// 休眠时间
(0088) unsigned char _SleepSwitch;				// 休眠开关
(0089) unsigned int _AutoTestCycleNum = 0;		// 自动测试次数
(0090) 
(0091) 
(0092) static signed int NeedleOnMixSidePos;	// 取样针到混匀池右边沿位置
(0093) static signed int NeedleOnMixCenterPos;	// 取样针到混匀池中间位置
(0094) static signed int DropHeight;			// 滴样高度
(0095) static signed int MixHeight;			// 抽打混匀高度
(0096) static unsigned char CleanMode = 0;		// 清洗模式  0:无清洗，1:普通清洗， 2:高浓度清洗
(0097) static unsigned char TestDebugMode = 0;	// 混匀测试模式 0:正常测试  1：混匀测试
(0098) static unsigned char _SampSW = 1;		// 按键判断
(0099) static unsigned char _WaitStartKey;		// 等待按键
(0100) 
(0101) // 新设置参数
(0102) unsigned char _NewCardStoreNum;			// 片仓号
(0103) unsigned char _NewMultipNum;			// 稀释比例编号
(0104) static unsigned int _NewReadTime0;		// 第一读数时间
(0105) static unsigned int _NewReadTime1;		// 第二读数时间
(0106) static unsigned char _NewTestType;		// 测试类型
(0107) 
(0108) 
(0109) unsigned char JumpMode = 0;		// 直接测试模式  0 需要机械自检和液路自检   1 直接进入测试  2 休眠接入液路自检 3 休眠模式完成3322液路自检
(0110) unsigned char stopTestFlag = 0; // 停止测试,废片仓连续开启时间超过20分钟
(0111) 
(0112) static unsigned char DiluteProcess_workStep;	
(0113) static unsigned char DiluteProcess_mainStep;	
(0114) 
(0115) /**********************************  稀释处理程序  *****************************************/
(0116) 
(0117) unsigned int CalMixingHeight(unsigned char multipNum, unsigned char diluteTime);
(0118) void _SetCurWorkParamter(void);
(0119) void _SetNewCardGet(unsigned char num);
(0120) unsigned char _CheckFluidSupply(void);
(0121) unsigned char _CheckDiluentSupply(void);
(0122) 
(0123) 
(0124) void SetDropVolume(unsigned int vol);
(0125) signed int CalSampVolume(unsigned char multipNum, unsigned char diluteTime);
(0126) signed int CalDiluteVolume(unsigned char multipNum, unsigned char diluteTime);
(0127) signed int CalDilute2Volume(unsigned char multipNum, unsigned char dilutetype);
(0128) unsigned char CalSampSyringSpeed(unsigned char multipNum, unsigned char diluteTime);
(0129) unsigned char CalDiluentInjectSpeed(unsigned char multipNum, unsigned char diluteTime);	
(0130) 
(0131) 
(0132) 
(0133) void SetTestDebugMode(unsigned char m)
(0134) {
(0135) 	// 设置测试状态下的调试模式	0:正常，1:混匀液测量
(0136) 	if(m>1)
_SetTestDebugMode:
  m                    --> R16
    03763 9230 158E STS	ControlCmd+40,R3
    03765 9220 158D STS	ControlCmd+39,R2
(0137) 		m = 0;
    03767 9508      RET
_BeepStop:
    03768 2422      CLR	R2
    03769 9220 03F8 STS	BeepState+1,R2
(0138) 	TestDebugMode = m;
(0139) }
(0140) 
(0141) unsigned char SamplingSwitch(unsigned char  sw)
(0142) {
(0143) 	_SampSW = sw;
    0376B 9220 03F7 STS	BeepState,R2
_printf_DiluteProcess_StepState:
    0376D 2433      CLR	R3
(0144) }
(0145) 
(0146) extern unsigned char _DiluteMainStep, _DiluteWorkStep;
(0147) extern unsigned char CardSurplusState[];		// 卡片剩余状态
(0148) extern unsigned char CardStoretate[];
(0149) extern RING_QUEUE	RingQueue;
(0150) 
(0151) 
(0152) 
(0153) 
(0154) 
(0155) void printf_DiluteProcess_StepState(void)
(0156) {
(0157) 	Uart0ReUnable;
    0376E 9230 158E STS	ControlCmd+40,R3
    03770 9220 158D STS	ControlCmd+39,R2
    03772 9508      RET
(0158) 	uart_Printf("%s $%2d $%2d\r\n",strM3201,DiluteProcess_mainStep,DiluteProcess_workStep);
_Beep:
    03773 9180 158D LDS	R24,ControlCmd+39
    03775 9190 158E LDS	R25,ControlCmd+40
    03777 9601      ADIW	R24,1
    03778 9390 158E STS	ControlCmd+40,R25
    0377A 9380 158D STS	ControlCmd+39,R24
    0377C 9100 03F8 LDS	R16,BeepState+1
    0377E 2711      CLR	R17
    0377F 3000      CPI	R16,0
    03780 0701      CPC	R16,R17
    03781 F0D1      BEQ	0x379C
    03782 3001      CPI	R16,1
(0159) 	Uart0ReEnable;
    03783 E0E0      LDI	R30,0
    03784 071E      CPC	R17,R30
    03785 F409      BNE	0x3787
    03786 C04C      RJMP	0x37D3
    03787 3002      CPI	R16,2
    03788 E0E0      LDI	R30,0
    03789 071E      CPC	R17,R30
_SetPunctureState:
  m                    --> R20
    0378A F409      BNE	0x378C
    0378B C096      RJMP	0x3822
    0378C 3003      CPI	R16,3
(0160) }
(0161) 
(0162) void SetPunctureState(unsigned char m)
(0163) {
(0164) 	if(m > 2)
    0378D E0E0      LDI	R30,0
    0378E 071E      CPC	R17,R30
    0378F F409      BNE	0x3791
(0165) 		m = 2;
    03790 C0BF      RJMP	0x3850
(0166) 	WithoutPuncture = m;
    03791 3004      CPI	R16,4
    03792 E0E0      LDI	R30,0
(0167) 	Uart0ReUnable;
    03793 071E      CPC	R17,R30
    03794 F409      BNE	0x3796
    03795 C0E8      RJMP	0x387E
    03796 3005      CPI	R16,5
    03797 E0E0      LDI	R30,0
(0168) 	uart_Printf("%s $%4d\r\n",strM3119,WithoutPuncture);
    03798 071E      CPC	R17,R30
    03799 F409      BNE	0x379B
    0379A C131      RJMP	0x38CC
    0379B C15B      RJMP	0x38F7
    0379C 9020 03F7 LDS	R2,BeepState
    0379E 2022      TST	R2
    0379F F409      BNE	0x37A1
    037A0 C156      RJMP	0x38F7
    037A1 9020 158D LDS	R2,ControlCmd+39
(0169) 	Uart0ReEnable;
    037A3 9030 158E LDS	R3,ControlCmd+40
    037A5 01C1      MOVW	R24,R2
    037A6 3C88      CPI	R24,0xC8
    037A7 E0E0      LDI	R30,0
    037A8 079E      CPC	R25,R30
    037A9 F0C9      BEQ	0x37C3
_DiluteProcess:
  siTmp1               --> R12
  siTmp                --> R10
  pInfoEvent           --> Y,+14
    037AA EC88      LDI	R24,0xC8
    037AB E090      LDI	R25,0
    037AC 1582      CP	R24,R2
    037AD 0593      CPC	R25,R3
    037AE F04C      BLT	0x37B8
(0170) }
(0171) 
(0172) unsigned char DiluteProcess(INFO_EVENT * pInfoEvent)
(0173) {
(0174) 	// 稀释运行处理程序
(0175) 	static unsigned char mainStep;		
(0176) 	static unsigned char workStep;
(0177) 	static unsigned char startKey;
(0178) 	static unsigned char  checkDiluent, checkFluid;
(0179) 	static unsigned char pos;
(0180) 	static unsigned char ucTmp;
(0181) 	static unsigned char Num;
(0182) 	signed int siTmp,siTmp1;
(0183) 	static signed char sc;
(0184) 	static unsigned int i;
(0185) 	static unsigned int theDifferenceOfStep,theDownPointAdc;
(0186) 	static long lastSampTime = 0;// 最后一次取样时间,用于待机判断
(0187) 	static unsigned char FindNum = 0;// 查找转盘次数
(0188) 	static unsigned char temp1,temp2;	
(0189) 
(0190) 
(0191) #ifdef Puncture
(0192) 	static unsigned char detRetry ;			// 穿刺使用
(0193) 	static unsigned char ErrorNum = 0;		// 传递穿刺模式下的错误,根据不同的错误发送不同的信息
(0194) #endif
(0195) 	
(0196) 	DiluteProcess_mainStep = mainStep;
    037AF 9180 158D LDS	R24,ControlCmd+39
    037B1 9190 158E LDS	R25,ControlCmd+40
(0197) 	DiluteProcess_workStep = workStep;
    037B3 308A      CPI	R24,0xA
    037B4 E0E0      LDI	R30,0
    037B5 079E      CPC	R25,R30
    037B6 F051      BEQ	0x37C1
(0198) 	
(0199) 	if(1 == checkDiluent)					// 检查稀释液
    037B7 C13F      RJMP	0x38F7
    037B8 9180 158D LDS	R24,ControlCmd+39
    037BA 9190 158E LDS	R25,ControlCmd+40
(0200) 	{	
(0201) 		if(_CheckDiluentSupply() == 1)
    037BC 3F84      CPI	R24,0xF4
    037BD E0E1      LDI	R30,1
    037BE 079E      CPC	R25,R30
(0202) 		{	
(0203) 			mainStep = 13;	
    037BF F039      BEQ	0x37C7
    037C0 C136      RJMP	0x38F7
    037C1 9A27      SBI	0x04,7
(0204) 			workStep = 0;	
    037C2 C134      RJMP	0x38F7
    037C3 B184      IN	R24,0x04
    037C4 778F      ANDI	R24,0x7F
(0205) 			checkDiluent = 0;
    037C5 B984      OUT	0x04,R24
    037C6 C130      RJMP	0x38F7
(0206) 		}	
(0207) 	}
(0208) 	if(1 == checkFluid)						// 检查清洗液
    037C7 2422      CLR	R2
    037C8 2433      CLR	R3
    037C9 9230 158E STS	ControlCmd+40,R3
(0209) 	{		
(0210) 		if(_CheckFluidSupply()==1)
    037CB 9220 158D STS	ControlCmd+39,R2
    037CD 9180 03F7 LDS	R24,BeepState
(0211) 		{	
(0212) 			mainStep = 12;	
    037CF 5081      SUBI	R24,1
    037D0 9380 03F7 STS	BeepState,R24
(0213) 			workStep = 0;	
    037D2 C124      RJMP	0x38F7
    037D3 9020 158D LDS	R2,ControlCmd+39
(0214) 			checkFluid = 0;
    037D5 9030 158E LDS	R3,ControlCmd+40
(0215) 		}
(0216) 	}
(0217) 	
(0218) 	if(WaitDelayTime(MOT_SAMP_PUMP))		return 0;
    037D7 01C1      MOVW	R24,R2
    037D8 3F84      CPI	R24,0xF4
    037D9 E0E1      LDI	R30,1
    037DA 079E      CPC	R25,R30
    037DB F1B9      BEQ	0x3813
    037DC EF84      LDI	R24,0xF4
    037DD E091      LDI	R25,1
    037DE 1582      CP	R24,R2
    037DF 0593      CPC	R25,R3
(0219) 	if(WaitDelayTime(MOT_SAMP_TRUN))		return 0;
    037E0 F0B4      BLT	0x37F7
    037E1 9100 158D LDS	R16,ControlCmd+39
    037E3 9110 158E LDS	R17,ControlCmd+40
    037E5 300A      CPI	R16,0xA
    037E6 E0E0      LDI	R30,0
    037E7 071E      CPC	R17,R30
    037E8 F121      BEQ	0x380D
(0220) 	if(WaitDelayTime(MOT_SAMP_NEEDLE))		return 0;
    037E9 300A      CPI	R16,0xA
    037EA E0E0      LDI	R30,0
    037EB 071E      CPC	R17,R30
    037EC F40C      BGE	0x37EE
    037ED C109      RJMP	0x38F7
    037EE 9180 158D LDS	R24,ControlCmd+39
    037F0 9190 158E LDS	R25,ControlCmd+40
(0221) 	if(WaitDelayTime(MOT_EFFLUENT))			return 0;
    037F2 3C88      CPI	R24,0xC8
    037F3 E0E0      LDI	R30,0
    037F4 079E      CPC	R25,R30
    037F5 F0C9      BEQ	0x380F
    037F6 C100      RJMP	0x38F7
    037F7 9100 158D LDS	R16,ControlCmd+39
    037F9 9110 158E LDS	R17,ControlCmd+40
(0222) 	if(WaitDelayTime(MOT_FLUID))			return 0;
    037FB 3D00      CPI	R16,0xD0
    037FC E0E7      LDI	R30,7
    037FD 071E      CPC	R17,R30
    037FE F0B1      BEQ	0x3815
    037FF 3D00      CPI	R16,0xD0
    03800 E0E7      LDI	R30,7
    03801 071E      CPC	R17,R30
    03802 F40C      BGE	0x3804
    03803 C0F3      RJMP	0x38F7
(0223) 	if(WaitDelayTime(MOT_DILUENT))			return 0;
    03804 9180 158D LDS	R24,ControlCmd+39
    03806 9190 158E LDS	R25,ControlCmd+40
    03808 3C84      CPI	R24,0xC4
    03809 E0E9      LDI	R30,0x9
    0380A 079E      CPC	R25,R30
    0380B F069      BEQ	0x3819
    0380C C0EA      RJMP	0x38F7
(0224) 	
(0225) 	if(waitMotSampTurn){	if(GetMotState(MOT_SAMP_TRUN)!=STA_SLAVE_FREE)		return 0;	waitMotSampTurn = 0;	}
    0380D 9A27      SBI	0x04,7
    0380E C0E8      RJMP	0x38F7
    0380F B184      IN	R24,0x04
    03810 778F      ANDI	R24,0x7F
    03811 B984      OUT	0x04,R24
    03812 C0E4      RJMP	0x38F7
    03813 9A27      SBI	0x04,7
    03814 C0E2      RJMP	0x38F7
    03815 B184      IN	R24,0x04
    03816 778F      ANDI	R24,0x7F
    03817 B984      OUT	0x04,R24
    03818 C0DE      RJMP	0x38F7
    03819 2422      CLR	R2
    0381A 2433      CLR	R3
    0381B 9230 158E STS	ControlCmd+40,R3
(0226) 	if(waitMotSampNeedle){	if(GetMotState(MOT_SAMP_NEEDLE)!=STA_SLAVE_FREE)	return 0;	waitMotSampNeedle = 0;	}
    0381D 9220 158D STS	ControlCmd+39,R2
    0381F 9220 03F8 STS	BeepState+1,R2
    03821 C0D5      RJMP	0x38F7
    03822 9100 158D LDS	R16,ControlCmd+39
    03824 9110 158E LDS	R17,ControlCmd+40
    03826 3C04      CPI	R16,0xC4
    03827 E0E9      LDI	R30,0x9
    03828 071E      CPC	R17,R30
    03829 F0C9      BEQ	0x3843
    0382A EC84      LDI	R24,0xC4
    0382B E099      LDI	R25,0x9
    0382C 1780      CP	R24,R16
(0227) 	if(waitMotSampPump){	if(GetMotState(MOT_SAMP_PUMP)!=STA_SLAVE_FREE)		return 0;	waitMotSampPump = 0;	}
    0382D 0791      CPC	R25,R17
    0382E F04C      BLT	0x3838
    0382F 9180 158D LDS	R24,ControlCmd+39
    03831 9190 158E LDS	R25,ControlCmd+40
    03833 308A      CPI	R24,0xA
    03834 E0E0      LDI	R30,0
    03835 079E      CPC	R25,R30
    03836 F051      BEQ	0x3841
    03837 C0BF      RJMP	0x38F7
    03838 9180 158D LDS	R24,ControlCmd+39
    0383A 9190 158E LDS	R25,ControlCmd+40
    0383C 3B88      CPI	R24,0xB8
(0228) 	if(waitMotFluid){		if(GetMotState(MOT_FLUID)!=STA_SLAVE_FREE)			return 0;	waitMotFluid = 0;	}
    0383D E0EB      LDI	R30,0xB
    0383E 079E      CPC	R25,R30
    0383F F039      BEQ	0x3847
    03840 C0B6      RJMP	0x38F7
    03841 9A27      SBI	0x04,7
    03842 C0B4      RJMP	0x38F7
    03843 B184      IN	R24,0x04
    03844 778F      ANDI	R24,0x7F
    03845 B984      OUT	0x04,R24
    03846 C0B0      RJMP	0x38F7
    03847 2422      CLR	R2
    03848 2433      CLR	R3
    03849 9230 158E STS	ControlCmd+40,R3
    0384B 9220 158D STS	ControlCmd+39,R2
(0229) 	if(waitMotDiluent){		if(GetMotState(MOT_DILUENT)!=STA_SLAVE_FREE)		return 0;	waitMotDiluent = 0;	}
    0384D 9220 03F8 STS	BeepState+1,R2
    0384F C0A7      RJMP	0x38F7
    03850 9100 158D LDS	R16,ControlCmd+39
    03852 9110 158E LDS	R17,ControlCmd+40
    03854 3C08      CPI	R16,0xC8
    03855 E0E0      LDI	R30,0
    03856 071E      CPC	R17,R30
    03857 F0C9      BEQ	0x3871
    03858 EC88      LDI	R24,0xC8
    03859 E090      LDI	R25,0
    0385A 1780      CP	R24,R16
    0385B 0791      CPC	R25,R17
    0385C F04C      BLT	0x3866
(0230) 	if(waitEffluent){		if(GetMotState(MOT_EFFLUENT)!=STA_SLAVE_FREE)		return 0;	waitEffluent = 0;	}
    0385D 9180 158D LDS	R24,ControlCmd+39
    0385F 9190 158E LDS	R25,ControlCmd+40
    03861 308A      CPI	R24,0xA
    03862 E0E0      LDI	R30,0
    03863 079E      CPC	R25,R30
    03864 F051      BEQ	0x386F
    03865 C091      RJMP	0x38F7
    03866 9180 158D LDS	R24,ControlCmd+39
    03868 9190 158E LDS	R25,ControlCmd+40
    0386A 3F84      CPI	R24,0xF4
    0386B E0E1      LDI	R30,1
    0386C 079E      CPC	R25,R30
(0231) 
(0232) 	if(_WaitStartKey)
    0386D F039      BEQ	0x3875
    0386E C088      RJMP	0x38F7
    0386F 9A27      SBI	0x04,7
    03870 C086      RJMP	0x38F7
    03871 B184      IN	R24,0x04
(0233) 	{
(0234) 		if(_DiluentQuitFlag != 0)	// 稀释程序退出处理
    03872 778F      ANDI	R24,0x7F
    03873 B984      OUT	0x04,R24
    03874 C082      RJMP	0x38F7
    03875 2422      CLR	R2
(0235) 		{
(0236) 			_DiluentQuitFlag = 0;
    03876 2433      CLR	R3
    03877 9230 158E STS	ControlCmd+40,R3
(0237) 			_WaitStartKey = 0;
    03879 9220 158D STS	ControlCmd+39,R2
(0238) 			mainStep = 10;		// 进入退出程序
    0387B 9220 03F8 STS	BeepState+1,R2
    0387D C079      RJMP	0x38F7
(0239) 			workStep = 0;
    0387E 9100 158D LDS	R16,ControlCmd+39
(0240) 			return 1;
    03880 9110 158E LDS	R17,ControlCmd+40
    03882 3F04      CPI	R16,0xF4
(0241) 		}
(0242) 		if(WaitStartKey() == 0)
    03883 E0E1      LDI	R30,1
    03884 071E      CPC	R17,R30
    03885 F1B9      BEQ	0x38BD
    03886 EF84      LDI	R24,0xF4
    03887 E091      LDI	R25,1
    03888 1780      CP	R24,R16
(0243) 		{		// 按键事件处理
(0244) 			if(mainStep == 1 && workStep == 1)
    03889 0791      CPC	R25,R17
    0388A F0B4      BLT	0x38A1
    0388B 9100 158D LDS	R16,ControlCmd+39
    0388D 9110 158E LDS	R17,ControlCmd+40
    0388F 300A      CPI	R16,0xA
    03890 E0E0      LDI	R30,0
    03891 071E      CPC	R17,R30
    03892 F121      BEQ	0x38B7
(0245) 			{		// 测试空闲状态下，处理休眠事件
(0246) 				if(_SleepTime)
    03893 300A      CPI	R16,0xA
    03894 E0E0      LDI	R30,0
    03895 071E      CPC	R17,R30
    03896 F40C      BGE	0x3898
    03897 C05F      RJMP	0x38F7
    03898 9180 158D LDS	R24,ControlCmd+39
    0389A 9190 158E LDS	R25,ControlCmd+40
(0247) 				{		// 休眠时间有效时
(0248) 					if((SecondCount - lastSampTime) > _SleepTime)
    0389C 3C88      CPI	R24,0xC8
    0389D E0E0      LDI	R30,0
    0389E 079E      CPC	R25,R30
    0389F F0C9      BEQ	0x38B9
    038A0 C056      RJMP	0x38F7
    038A1 9100 158D LDS	R16,ControlCmd+39
    038A3 9110 158E LDS	R17,ControlCmd+40
    038A5 3B0C      CPI	R16,0xBC
    038A6 E0E2      LDI	R30,2
    038A7 071E      CPC	R17,R30
    038A8 F0B1      BEQ	0x38BF
    038A9 3B0C      CPI	R16,0xBC
    038AA E0E2      LDI	R30,2
    038AB 071E      CPC	R17,R30
    038AC F40C      BGE	0x38AE
    038AD C049      RJMP	0x38F7
    038AE 9180 158D LDS	R24,ControlCmd+39
    038B0 9190 158E LDS	R25,ControlCmd+40
    038B2 3E88      CPI	R24,0xE8
    038B3 E0E3      LDI	R30,3
    038B4 079E      CPC	R25,R30
    038B5 F069      BEQ	0x38C3
    038B6 C040      RJMP	0x38F7
    038B7 9A27      SBI	0x04,7
    038B8 C03E      RJMP	0x38F7
    038B9 B184      IN	R24,0x04
    038BA 778F      ANDI	R24,0x7F
(0249) 					{		// 900秒待机
(0250) 						// 待机任务
(0251) 						TestALampClose();	// 关闭光源
    038BB B984      OUT	0x04,R24
    038BC C03A      RJMP	0x38F7
(0252) 						_WaitStartKey = 0;
    038BD 9A27      SBI	0x04,7
    038BE C038      RJMP	0x38F7
    038BF B184      IN	R24,0x04
(0253) 						EEPROM_READ(EEP_ADD_SLEEP_TIME,  _SleepTime);	// 重新读取休眠时间
    038C0 778F      ANDI	R24,0x7F
    038C1 B984      OUT	0x04,R24
    038C2 C034      RJMP	0x38F7
    038C3 2422      CLR	R2
    038C4 2433      CLR	R3
    038C5 9230 158E STS	ControlCmd+40,R3
    038C7 9220 158D STS	ControlCmd+39,R2
    038C9 9220 03F8 STS	BeepState+1,R2
(0254) 						_SleepTime &= 0x0fff;
    038CB C02B      RJMP	0x38F7
    038CC 9100 158D LDS	R16,ControlCmd+39
    038CE 9110 158E LDS	R17,ControlCmd+40
    038D0 3C04      CPI	R16,0xC4
    038D1 E0E9      LDI	R30,0x9
    038D2 071E      CPC	R17,R30
(0255) 						mainStep = 20;		// 进入待机程序
    038D3 F0C9      BEQ	0x38ED
    038D4 EC84      LDI	R24,0xC4
    038D5 E099      LDI	R25,0x9
(0256) 						workStep = 0;
    038D6 1780      CP	R24,R16
    038D7 0791      CPC	R25,R17
    038D8 F04C      BLT	0x38E2
(0257) 						return 0;
    038D9 9180 158D LDS	R24,ControlCmd+39
    038DB 9190 158E LDS	R25,ControlCmd+40
(0258) 					}
(0259) 				}
(0260) 			}
(0261) 			return 1;
    038DD 308A      CPI	R24,0xA
    038DE E0E0      LDI	R30,0
(0262) 		}
(0263) 
(0264) 		if(_SampSW)
    038DF 079E      CPC	R25,R30
    038E0 F051      BEQ	0x38EB
    038E1 C015      RJMP	0x38F7
    038E2 9180 158D LDS	R24,ControlCmd+39
(0265) 		{
(0266) 			Uart0ReUnable;
    038E4 9190 158E LDS	R25,ControlCmd+40
    038E6 3B88      CPI	R24,0xB8
    038E7 E0EB      LDI	R30,0xB
(0267) 			uart_Printf("%s\r\n",strM3200);	// 2016-10-10 发送按键信息
    038E8 079E      CPC	R25,R30
    038E9 F039      BEQ	0x38F1
    038EA C00C      RJMP	0x38F7
    038EB 9A27      SBI	0x04,7
    038EC C00A      RJMP	0x38F7
    038ED B184      IN	R24,0x04
(0268) 			Uart0ReEnable;
    038EE 778F      ANDI	R24,0x7F
    038EF B984      OUT	0x04,R24
    038F0 C006      RJMP	0x38F7
    038F1 2422      CLR	R2
    038F2 2433      CLR	R3
(0269) 			_WaitStartKey = 0;
    038F3 9230 158E STS	ControlCmd+40,R3
    038F5 9220 158D STS	ControlCmd+39,R2
(0270) 		}
    038F7 9508      RET
_SetStateLedBusy:
    038F8 B18D      IN	R24,0x0D
    038F9 6380      ORI	R24,0x30
(0271) 		else
(0272) 			return 1;
(0273) 	}
(0274) 	
(0275) 	switch(mainStep)
    038FA B98D      OUT	0x0D,R24
    038FB 9A74      SBI	0x0E,4
    038FC B18E      IN	R24,0x0E
    038FD 7D8F      ANDI	R24,0xDF
    038FE B98E      OUT	0x0E,R24
    038FF 9180 0532 LDS	R24,_SampSW
    03901 3081      CPI	R24,1
    03902 F419      BNE	0x3906
    03903 2422      CLR	R2
    03904 9220 03EE STS	_LEDSTATE,R2
    03906 9508      RET
_SetStateLedFree:
    03907 B18D      IN	R24,0x0D
    03908 6380      ORI	R24,0x30
    03909 B98D      OUT	0x0D,R24
    0390A 9A75      SBI	0x0E,5
    0390B B18E      IN	R24,0x0E
    0390C 7E8F      ANDI	R24,0xEF
    0390D B98E      OUT	0x0E,R24
    0390E 9180 0532 LDS	R24,_SampSW
    03910 3081      CPI	R24,1
    03911 F419      BNE	0x3915
    03912 E081      LDI	R24,1
    03913 9380 03EE STS	_LEDSTATE,R24
    03915 9508      RET
_SetTestDebugMode:
    03916 E081      LDI	R24,1
    03917 1780      CP	R24,R16
    03918 F408      BCC	0x391A
    03919 2700      CLR	R16
    0391A 9300 0531 STS	_AutoTestCycleNum+3,R16
    0391C 9508      RET
_SamplingSwitch:
    0391D 9300 0532 STS	_SampSW,R16
    0391F 9508      RET
_printf_DiluteProcess_StepState:
    03920 9724      SBIW	R28,4
    03921 9180 00C1 LDS	R24,0xC1
    03923 7E8F      ANDI	R24,0xEF
    03924 9380 00C1 STS	0xC1,R24
    03926 9020 1639 LDS	R2,EvenPosChangeProcess+47
    03928 2433      CLR	R3
    03929 823B      STD	Y+3,R3
    0392A 822A      STD	Y+2,R2
    0392B 9020 1638 LDS	R2,EvenPosChangeProcess+46
    0392D 2433      CLR	R3
    0392E 8239      STD	Y+1,R3
    0392F 8228      ST	Y,R2
    03930 EC24      LDI	R18,0xC4
    03931 E133      LDI	R19,0x13
    03932 E90E      LDI	R16,0x9E
    03933 E016      LDI	R17,6
    03934 940E A90D CALL	_uart_Printf
    03936 9180 00C1 LDS	R24,0xC1
    03938 6180      ORI	R24,0x10
    03939 9380 00C1 STS	0xC1,R24
    0393B 9624      ADIW	R28,4
    0393C 9508      RET
_SetPunctureState:
    0393D 934A      ST	-Y,R20
    0393E 2F40      MOV	R20,R16
    0393F 9722      SBIW	R28,2
    03940 E082      LDI	R24,2
    03941 1784      CP	R24,R20
    03942 F408      BCC	0x3944
    03943 E042      LDI	R20,2
    03944 9340 0526 STS	WithoutPuncture,R20
    03946 9180 00C1 LDS	R24,0xC1
    03948 7E8F      ANDI	R24,0xEF
    03949 9380 00C1 STS	0xC1,R24
    0394B 2E24      MOV	R2,R20
    0394C 2433      CLR	R3
    0394D 8239      STD	Y+1,R3
    0394E 8228      ST	Y,R2
    0394F E22B      LDI	R18,0x2B
    03950 E03E      LDI	R19,0xE
    03951 E904      LDI	R16,0x94
    03952 E016      LDI	R17,6
    03953 940E A90D CALL	_uart_Printf
(0276) 	{
(0277) 		case 0:
(0278) 		// 初始化准备
(0279) 			switch(workStep)
    03955 9180 00C1 LDS	R24,0xC1
    03957 6180      ORI	R24,0x10
    03958 9380 00C1 STS	0xC1,R24
    0395A 9622      ADIW	R28,2
    0395B 9149      LD	R20,Y+
    0395C 9508      RET
_DiluteProcess:
    0395D 931A      ST	-Y,R17
    0395E 930A      ST	-Y,R16
    0395F 940E AE78 CALL	push_xgsetF0FC
    03961 9724      SBIW	R28,4
    03962 9020 160C LDS	R2,EvenPosChangeProcess+2
    03964 9220 1638 STS	EvenPosChangeProcess+46,R2
    03966 9020 160D LDS	R2,EvenPosChangeProcess+3
    03968 9220 1639 STS	EvenPosChangeProcess+47,R2
    0396A 9180 160F LDS	R24,EvenPosChangeProcess+5
    0396C 3081      CPI	R24,1
    0396D F461      BNE	0x397A
    0396E 940E 6384 CALL	__CheckDiluentSupply
    03970 3001      CPI	R16,1
    03971 F441      BNE	0x397A
    03972 E08D      LDI	R24,0xD
    03973 9380 160C STS	EvenPosChangeProcess+2,R24
(0280) 			{
(0281) 				case 0:		// 等待用户按下吸样键后取样针运行到吸样位置
(0282) 					if(JumpMode == 1)	
    03975 2422      CLR	R2
    03976 9220 160D STS	EvenPosChangeProcess+3,R2
    03978 9220 160F STS	EvenPosChangeProcess+5,R2
(0283) 					{
(0284) 						_NeedleMotRunTo(0, 180);
    0397A 9180 1610 LDS	R24,EvenPosChangeProcess+6
    0397C 3081      CPI	R24,1
    0397D F461      BNE	0x398A
(0285) 						waitMotSampNeedle = 1;
    0397E 940E 6365 CALL	__CheckFluidSupply
    03980 3001      CPI	R16,1
(0286) 						workStep = 24;
    03981 F441      BNE	0x398A
    03982 E08C      LDI	R24,0xC
    03983 9380 160C STS	EvenPosChangeProcess+2,R24
(0287) 						JumpMode = 0;
    03985 2422      CLR	R2
    03986 9220 160D STS	EvenPosChangeProcess+3,R2
(0288) 						break;
    03988 9220 1610 STS	EvenPosChangeProcess+6,R2
(0289) 					}
(0290) 					if(MachinePositionInit())
    0398A 9180 0533 LDS	R24,JumpMode
    0398C 3083      CPI	R24,3
    0398D F471      BNE	0x399C
    0398E 2422      CLR	R2
    0398F 9220 0533 STS	JumpMode,R2
(0291) 					{
(0292) 						_DiluentQuitFlag = 0;
    03991 E081      LDI	R24,1
    03992 9380 160C STS	EvenPosChangeProcess+2,R24
(0293) 						Uart0ReUnable;
    03994 9380 160D STS	EvenPosChangeProcess+3,R24
    03996 9020 0532 LDS	R2,_SampSW
(0294) 						uart_Printf("%s\r\n",strM3191);		// 取样休眠状态
    03998 2022      TST	R2
    03999 F411      BNE	0x399C
    0399A 9380 0532 STS	_SampSW,R24
    0399C E00C      LDI	R16,0xC
    0399D 940E 97C6 CALL	_WaitDelayTime
(0295) 						uart_Printf("%s\r\n",strM3101);		// 请按吸样键开始
    0399F 2EA0      MOV	R10,R16
    039A0 2300      TST	R16
    039A1 F019      BEQ	0x39A5
    039A2 2700      CLR	R16
    039A3 940C 4FC5 JMP	0x4FC5
(0296) 						Uart0ReEnable;
    039A5 E002      LDI	R16,2
    039A6 940E 97C6 CALL	_WaitDelayTime
    039A8 2EA0      MOV	R10,R16
(0297) 						workStep = 1;
    039A9 2300      TST	R16
    039AA F019      BEQ	0x39AE
    039AB 2700      CLR	R16
(0298) 						TestDebugMode = 0;
    039AC 940C 4FC5 JMP	0x4FC5
    039AE E003      LDI	R16,3
(0299) 					}
(0300) 					break;
    039AF 940E 97C6 CALL	_WaitDelayTime
(0301) 				case 1:	// 等待用户按吸样键
(0302) 					_WaitStartKey = 1;	
    039B1 2EA0      MOV	R10,R16
    039B2 2300      TST	R16
    039B3 F019      BEQ	0x39B7
(0303) 					workStep = 2;
    039B4 2700      CLR	R16
    039B5 940C 4FC5 JMP	0x4FC5
(0304) 					if(CardNoneUseful == 0)
    039B7 E00B      LDI	R16,0xB
    039B8 940E 97C6 CALL	_WaitDelayTime
    039BA 2EA0      MOV	R10,R16
    039BB 2300      TST	R16
    039BC F019      BEQ	0x39C0
(0305) 						TestALampOpen();		
    039BD 2700      CLR	R16
    039BE 940C 4FC5 JMP	0x4FC5
(0306) 					break;
    039C0 E00A      LDI	R16,0xA
(0307) 				case 2:
(0308) 					if(JumpMode == 2)			// 正在休眠,此时按下吸样键,进行液路自检
    039C1 940E 97C6 CALL	_WaitDelayTime
    039C3 2EA0      MOV	R10,R16
    039C4 2300      TST	R16
(0309) 					{
(0310) 						primeProcessSW = 3;
    039C5 F019      BEQ	0x39C9
    039C6 2700      CLR	R16
    039C7 940C 4FC5 JMP	0x4FC5
(0311) 						mainStep = 1;
    039C9 E009      LDI	R16,0x9
    039CA 940E 97C6 CALL	_WaitDelayTime
(0312) 						workStep = 0;
    039CC 2EA0      MOV	R10,R16
    039CD 2300      TST	R16
(0313) 						JumpMode = 0;
    039CE F019      BEQ	0x39D2
    039CF 2700      CLR	R16
(0314) 						break;
    039D0 940C 4FC5 JMP	0x4FC5
(0315) 					}
(0316) 					else if(JumpMode == 3)		// 休眠模式下手动3322液路自检
    039D2 9020 165B LDS	R2,dustbinOldState+4
    039D4 2022      TST	R2
    039D5 F061      BEQ	0x39E2
(0317) 					{
(0318) 						JumpMode = 0;
    039D6 E002      LDI	R16,2
    039D7 940E 6A0C CALL	_GetMotState
(0319) 						mainStep = 1;
    039D9 2EA0      MOV	R10,R16
    039DA 3001      CPI	R16,1
    039DB F019      BEQ	0x39DF
(0320) 						workStep = 0;
    039DC 2700      CLR	R16
    039DD 940C 4FC5 JMP	0x4FC5
(0321) 						break;
    039DF 2422      CLR	R2
(0322) 					}
(0323) 					SetEValve(EV_ALL, EV_CLOSE);
    039E0 9220 165B STS	dustbinOldState+4,R2
    039E2 9020 165A LDS	R2,dustbinOldState+3
(0324) 					Uart0ReUnable;
    039E4 2022      TST	R2
    039E5 F061      BEQ	0x39F2
    039E6 E003      LDI	R16,3
    039E7 940E 6A0C CALL	_GetMotState
(0325) 					uart_Printf("%s\r\n",strM3100);		// 启动
    039E9 2EA0      MOV	R10,R16
    039EA 3001      CPI	R16,1
    039EB F019      BEQ	0x39EF
    039EC 2700      CLR	R16
    039ED 940C 4FC5 JMP	0x4FC5
(0326) 					Uart0ReEnable;
    039EF 2422      CLR	R2
    039F0 9220 165A STS	dustbinOldState+3,R2
    039F2 9020 1659 LDS	R2,dustbinOldState+2
(0327) 					lastSampTime = SecondCount;		// 计算待机时间用
    039F4 2022      TST	R2
    039F5 F061      BEQ	0x3A02
    039F6 E00C      LDI	R16,0xC
    039F7 940E 6A0C CALL	_GetMotState
    039F9 2EA0      MOV	R10,R16
    039FA 3001      CPI	R16,1
    039FB F019      BEQ	0x39FF
    039FC 2700      CLR	R16
    039FD 940C 4FC5 JMP	0x4FC5
    039FF 2422      CLR	R2
    03A00 9220 1659 STS	dustbinOldState+2,R2
    03A02 9020 1658 LDS	R2,dustbinOldState+1
(0328) 					// 读取取样针位置信息
(0329) 					NeedleOnMixCenterPos = GetNeedleOnMixCenterPos();
    03A04 2022      TST	R2
    03A05 F061      BEQ	0x3A12
    03A06 E00A      LDI	R16,0xA
    03A07 940E 6A0C CALL	_GetMotState
    03A09 2EA0      MOV	R10,R16
    03A0A 3001      CPI	R16,1
(0330) 					NeedleOnMixSidePos = GetNeedleOnMixSidePos();
    03A0B F019      BEQ	0x3A0F
    03A0C 2700      CLR	R16
    03A0D 940C 4FC5 JMP	0x4FC5
    03A0F 2422      CLR	R2
    03A10 9220 1658 STS	dustbinOldState+1,R2
(0331) 					DropHeight = GetDropHeight();
    03A12 9020 1657 LDS	R2,dustbinOldState
    03A14 2022      TST	R2
    03A15 F061      BEQ	0x3A22
    03A16 E009      LDI	R16,0x9
    03A17 940E 6A0C CALL	_GetMotState
(0332) 					SetMotRunPam(MOT_SAMP_TRUN,240,10,CURRENT_SAMP_TRUN);
    03A19 2EA0      MOV	R10,R16
    03A1A 3001      CPI	R16,1
    03A1B F019      BEQ	0x3A1F
    03A1C 2700      CLR	R16
    03A1D 940C 4FC5 JMP	0x4FC5
    03A1F 2422      CLR	R2
    03A20 9220 1657 STS	dustbinOldState,R2
(0333) 					MotRunTo(MOT_SAMP_TRUN, NeedleOnMixCenterPos);
    03A22 9020 1656 LDS	R2,CardScanfSW
    03A24 2022      TST	R2
    03A25 F061      BEQ	0x3A32
    03A26 E00B      LDI	R16,0xB
    03A27 940E 6A0C CALL	_GetMotState
(0334) 					waitMotSampTurn = 1;
    03A29 2EA0      MOV	R10,R16
    03A2A 3001      CPI	R16,1
(0335) 					workStep = 3;
    03A2B F019      BEQ	0x3A2F
    03A2C 2700      CLR	R16
    03A2D 940C 4FC5 JMP	0x4FC5
(0336) 					break;
    03A2F 2422      CLR	R2
(0337) 				case 3:		// 灌注清洗液
(0338) 					ucTmp = _PrimingFluid();
    03A30 9220 1656 STS	CardScanfSW,R2
    03A32 9020 1641 LDS	R2,_NewCardStoreNum+1
    03A34 2022      TST	R2
(0339) 					if(ucTmp == 1)	workStep = 4;		// 进入稀释液灌注
    03A35 F409      BNE	0x3A37
    03A36 C056      RJMP	0x3A8D
    03A37 9020 052B LDS	R2,SecondCount+4
    03A39 2022      TST	R2
    03A3A F069      BEQ	0x3A48
    03A3B 2422      CLR	R2
(0340) 					else if(ucTmp == 0xff)	
    03A3C 9220 052B STS	SecondCount+4,R2
    03A3E 9220 1641 STS	_NewCardStoreNum+1,R2
    03A40 E08A      LDI	R24,0xA
    03A41 9380 160C STS	EvenPosChangeProcess+2,R24
(0341) 					{	// 重新灌注
(0342) 						workStep = 1;	
    03A43 9220 160D STS	EvenPosChangeProcess+3,R2
(0343) 						Uart0ReUnable;
    03A45 E001      LDI	R16,1
    03A46 940C 4FC5 JMP	0x4FC5
    03A48 940E 370B CALL	_WaitStartKey
(0344) 						uart_Printf("%s\r\n",strE3902);	
    03A4A 2EA0      MOV	R10,R16
    03A4B 2300      TST	R16
    03A4C F529      BNE	0x3A72
    03A4D 9180 160C LDS	R24,EvenPosChangeProcess+2
    03A4F 3081      CPI	R24,1
(0345) 						Uart0ReEnable;
    03A50 F4F1      BNE	0x3A6F
    03A51 9180 160D LDS	R24,EvenPosChangeProcess+3
    03A53 3081      CPI	R24,1
    03A54 F4D1      BNE	0x3A6F
(0346) 					}
(0347) 					break;
    03A55 9180 164B LDS	R24,_SleepTime
(0348) 				case 4:		// 灌注稀释液
(0349) 					ucTmp = _PrimingDiluent();
    03A57 9190 164C LDS	R25,_SleepTime+1
    03A59 3081      CPI	R24,1
    03A5A E0E0      LDI	R30,0
    03A5B 079E      CPC	R25,R30
(0350) 					if(ucTmp == 1)	workStep = 5;		// 全部灌注完毕
    03A5C F491      BNE	0x3A6F
    03A5D 940E 9F1B CALL	_TestALampClose
    03A5F 2422      CLR	R2
    03A60 9220 1641 STS	_NewCardStoreNum+1,R2
    03A62 2433      CLR	R3
(0351) 					else if(ucTmp == 0xff)	
    03A63 9230 164C STS	_SleepTime+1,R3
    03A65 9220 164B STS	_SleepTime,R2
    03A67 E184      LDI	R24,0x14
    03A68 9380 160C STS	EvenPosChangeProcess+2,R24
(0352) 					{	// 重新灌注
(0353) 						Uart0ReUnable;
    03A6A 9220 160D STS	EvenPosChangeProcess+3,R2
    03A6C 2700      CLR	R16
    03A6D 940C 4FC5 JMP	0x4FC5
(0354) 						uart_Printf("%s\r\n", strE3904);
    03A6F E001      LDI	R16,1
    03A70 940C 4FC5 JMP	0x4FC5
    03A72 9020 0532 LDS	R2,_SampSW
(0355) 						Uart0ReEnable;
    03A74 2022      TST	R2
    03A75 F0A1      BEQ	0x3A8A
    03A76 9180 00C1 LDS	R24,0xC1
    03A78 7E8F      ANDI	R24,0xEF
(0356) 						workStep = 1;	
    03A79 9380 00C1 STS	0xC1,R24
    03A7B EA2C      LDI	R18,0xAC
(0357) 					}
(0358) 					break;
    03A7C E133      LDI	R19,0x13
    03A7D E80F      LDI	R16,0x8F
(0359) 				case 5:	// 清洗清洗头和取样针通道
(0360) 					// 建立负压
(0361) 					SetEValve(EV3, EV_OPEN);
    03A7E E016      LDI	R17,6
    03A7F 940E A90D CALL	_uart_Printf
    03A81 9180 00C1 LDS	R24,0xC1
(0362) 					_EffluentMotRun(100, 200);
    03A83 6180      ORI	R24,0x10
    03A84 9380 00C1 STS	0xC1,R24
    03A86 2422      CLR	R2
(0363) 					SetDelayTime(MOT_EFFLUENT, 5);
    03A87 9220 1641 STS	_NewCardStoreNum+1,R2
    03A89 C003      RJMP	0x3A8D
    03A8A E001      LDI	R16,1
    03A8B 940C 4FC5 JMP	0x4FC5
(0364) 					workStep = 6;
    03A8D 90A0 160C LDS	R10,EvenPosChangeProcess+2
(0365) 				case 6:	// 清洗
(0366) 					SetEValve(EV1, EV_OPEN);
    03A8F 24BB      CLR	R11
    03A90 01C5      MOVW	R24,R10
    03A91 3684      CPI	R24,0x64
    03A92 E0E0      LDI	R30,0
(0367) 					_FluidMotRun(30, 30);
    03A93 079E      CPC	R25,R30
    03A94 F411      BNE	0x3A97
    03A95 940C 4E03 JMP	0x4E03
    03A97 E684      LDI	R24,0x64
(0368) 					MotInitCheck(MOT_SAMP_NEEDLE);
    03A98 158A      CP	R24,R10
    03A99 059B      CPC	R25,R11
    03A9A F40C      BGE	0x3A9C
(0369) 					SetDelayTime(MOT_EFFLUENT, 10);
    03A9B C042      RJMP	0x3ADE
    03A9C 20AA      TST	R10
    03A9D F419      BNE	0x3AA1
    03A9E 20BB      TST	R11
    03A9F F409      BNE	0x3AA1
(0370) 					waitMotSampNeedle = 1;
    03AA0 C046      RJMP	0x3AE7
    03AA1 01C5      MOVW	R24,R10
    03AA2 3081      CPI	R24,1
(0371) 					workStep = 100;
    03AA3 E0E0      LDI	R30,0
    03AA4 079E      CPC	R25,R30
    03AA5 F409      BNE	0x3AA7
(0372) 					break;
    03AA6 C389      RJMP	0x3E30
    03AA7 3084      CPI	R24,4
(0373) 				case 100:
(0374) 					MotStop(MOT_FLUID);
    03AA8 E0E0      LDI	R30,0
    03AA9 079E      CPC	R25,R30
    03AAA F409      BNE	0x3AAC
(0375) 					waitMotFluid = 1;
    03AAB C626      RJMP	0x40D2
    03AAC 3085      CPI	R24,5
    03AAD E0E0      LDI	R30,0
(0376) 					SetDelayTime(MOT_EFFLUENT, 10);
    03AAE 079E      CPC	R25,R30
    03AAF F411      BNE	0x3AB2
    03AB0 940C 4324 JMP	0x4324
    03AB2 3088      CPI	R24,0x8
(0377) 					MotRunTo(MOT_SAMP_TRUN, 0);
    03AB3 E0E0      LDI	R30,0
    03AB4 079E      CPC	R25,R30
    03AB5 F411      BNE	0x3AB8
    03AB6 940C 44AD JMP	0x44AD
(0378) 					waitMotSampNeedle = 1;
    03AB8 3089      CPI	R24,0x9
    03AB9 E0E0      LDI	R30,0
    03ABA 079E      CPC	R25,R30
(0379) 					workStep = 7;
    03ABB F411      BNE	0x3ABE
    03ABC 940C 4704 JMP	0x4704
(0380) 					break;
    03ABE 308A      CPI	R24,0xA
    03ABF E0E0      LDI	R30,0
(0381) 				case 7:	// 先关闭清洗液
(0382) 					_FluidMotRun(-2, 80);
    03AC0 079E      CPC	R25,R30
    03AC1 F411      BNE	0x3AC4
    03AC2 940C 4AC6 JMP	0x4AC6
    03AC4 308B      CPI	R24,0xB
(0383) 					MotRunTo(MOT_SAMP_TRUN, NeedleOnMixCenterPos);
    03AC5 E0E0      LDI	R30,0
    03AC6 079E      CPC	R25,R30
    03AC7 F411      BNE	0x3ACA
    03AC8 940C 4B0A JMP	0x4B0A
    03ACA 308C      CPI	R24,0xC
    03ACB E0E0      LDI	R30,0
(0384) 					waitMotFluid = 1;
    03ACC 079E      CPC	R25,R30
    03ACD F411      BNE	0x3AD0
    03ACE 940C 4B95 JMP	0x4B95
(0385) 					waitMotSampNeedle = 1;
    03AD0 308D      CPI	R24,0xD
(0386) 					workStep = 8;
    03AD1 E0E0      LDI	R30,0
    03AD2 079E      CPC	R25,R30
    03AD3 F411      BNE	0x3AD6
(0387) 					break;
    03AD4 940C 4CB7 JMP	0x4CB7
(0388) 				case 8:	// 关闭负压
(0389) 					SetEValve(EV_ALL, EV_CLOSE);
    03AD6 3184      CPI	R24,0x14
    03AD7 E0E0      LDI	R30,0
    03AD8 079E      CPC	R25,R30
    03AD9 F411      BNE	0x3ADC
(0390) 					MotStop(MOT_EFFLUENT);
    03ADA 940C 4DAE JMP	0x4DAE
    03ADC 940C 4FC4 JMP	_SetReadTime0
(0391) 					_NeedleMotRunTo(_POS_MIX_BUTTOM, 180);//240
    03ADE 01C5      MOVW	R24,R10
    03ADF 3689      CPI	R24,0x69
    03AE0 E0E0      LDI	R30,0
    03AE1 079E      CPC	R25,R30
(0392) 					waitMotSampNeedle = 1;
    03AE2 F411      BNE	0x3AE5
    03AE3 940C 4F6D JMP	0x4F6D
(0393) 					sc = 3;		// 设置清洗次数
    03AE5 940C 4FC4 JMP	_SetReadTime0
    03AE7 90A0 160D LDS	R10,EvenPosChangeProcess+3
(0394) 					workStep = 9;
    03AE9 24BB      CLR	R11
    03AEA 01C5      MOVW	R24,R10
(0395) 					break;
    03AEB 3080      CPI	R24,0
    03AEC E0E0      LDI	R30,0
(0396) 				case 9:	// 清洗和灌注取样针通道
(0397) 					sc --;
    03AED 079E      CPC	R25,R30
    03AEE F414      BGE	0x3AF1
    03AEF 940C 4FC4 JMP	_SetReadTime0
    03AF1 E18C      LDI	R24,0x1C
(0398) 					SetEValve(EV2, EV_OPEN);
    03AF2 158A      CP	R24,R10
    03AF3 059B      CPC	R25,R11
    03AF4 F05C      BLT	0x3B00
    03AF5 EF84      LDI	R24,0xF4
(0399) 					MotInitCheck(MOT_SAMP_PUMP);
    03AF6 E091      LDI	R25,1
    03AF7 01F5      MOVW	R30,R10
    03AF8 0FEE      LSL	R30
(0400) 					_FluidMotRun(12, 64);		// 注入1mL清洗液
    03AF9 1FFF      ROL	R31
    03AFA 0FE8      ADD	R30,R24
    03AFB 1FF9      ADC	R31,R25
    03AFC 9027      ELPM	R2,Z+
    03AFD 9036      ELPM	R3,Z
(0401) 					waitMotFluid = 1;
    03AFE 01F1      MOVW	R30,R2
    03AFF 9409      IJMP
    03B00 01C5      MOVW	R24,R10
(0402) 					SetDelayTime(MOT_FLUID, 40);
    03B01 3684      CPI	R24,0x64
    03B02 E0E0      LDI	R30,0
    03B03 079E      CPC	R25,R30
    03B04 F409      BNE	0x3B06
    03B05 C121      RJMP	0x3C27
(0403) 					workStep = 10;
    03B06 940C 4FC4 JMP	_SetReadTime0
    03B08 9180 0533 LDS	R24,JumpMode
(0404) 					break;
    03B0A 3081      CPI	R24,1
(0405) 				case 10:
(0406) 					_EffluentMotRun(20, 200);
    03B0B F481      BNE	0x3B1C
    03B0C EB24      LDI	R18,0xB4
    03B0D 2700      CLR	R16
    03B0E 2711      CLR	R17
    03B0F 940E 62FB CALL	__NeedleMotRunTo
(0407) 					SetDelayTime(MOT_FLUID, 20);
    03B11 E081      LDI	R24,1
    03B12 9380 165A STS	dustbinOldState+3,R24
    03B14 E188      LDI	R24,0x18
(0408) 					waitEffluent = 1;
    03B15 9380 160D STS	EvenPosChangeProcess+3,R24
    03B17 2422      CLR	R2
(0409) 					workStep = 11;
    03B18 9220 0533 STS	JumpMode,R2
    03B1A 940C 4FC4 JMP	_SetReadTime0
(0410) 					break;
    03B1C 940E 334B CALL	_MachinePositionInit
(0411) 				case 11:
(0412) 					if(sc != 0){
    03B1E 2EA0      MOV	R10,R16
    03B1F 2300      TST	R16
    03B20 F411      BNE	0x3B23
(0413) 						workStep = 9;
    03B21 940C 4FC4 JMP	_SetReadTime0
    03B23 2422      CLR	R2
(0414) 						}
    03B24 9220 052B STS	SecondCount+4,R2
(0415) 					else{
(0416) 						workStep = 15;
    03B26 9180 00C1 LDS	R24,0xC1
    03B28 7E8F      ANDI	R24,0xEF
(0417) 						}
(0418) 					break;
    03B29 9380 00C1 STS	0xC1,R24
(0419) 				case 15:	// 清洗完毕，抽清洗头残留水
(0420) 					SetEValve(EV_ALL, EV_CLOSE);
    03B2B ED28      LDI	R18,0xD8
    03B2C E03C      LDI	R19,0xC
    03B2D E80F      LDI	R16,0x8F
    03B2E E016      LDI	R17,6
(0421) 					SetEValve(EV3, EV_OPEN);
    03B2F 940E A90D CALL	_uart_Printf
    03B31 9180 00C1 LDS	R24,0xC1
(0422) 					_NeedleMotRunTo(0, 180);//240
    03B33 6180      ORI	R24,0x10
    03B34 9380 00C1 STS	0xC1,R24
    03B36 E081      LDI	R24,1
    03B37 9380 160D STS	EvenPosChangeProcess+3,R24
(0423) 					_EffluentMotRun(30, 200);
    03B39 2422      CLR	R2
    03B3A 9220 0531 STS	_AutoTestCycleNum+3,R2
    03B3C 940C 4FC4 JMP	_SetReadTime0
(0424) 					waitMotSampNeedle = 1;
    03B3E E081      LDI	R24,1
    03B3F 9380 1641 STS	_NewCardStoreNum+1,R24
(0425) 					waitEffluent = 1;
    03B41 E082      LDI	R24,2
(0426) 					workStep = 16;
    03B42 9380 160D STS	EvenPosChangeProcess+3,R24
    03B44 9020 06F6 LDS	R2,CardNoneUseful
(0427) 					break;
    03B46 2022      TST	R2
(0428) 				case 16:	// 排干混匀池水
(0429) 					SetEValve(EV_ALL, EV_CLOSE);
    03B47 F011      BEQ	0x3B4A
    03B48 940C 4FC4 JMP	_SetReadTime0
    03B4A 940E 9F08 CALL	_TestALampOpen
(0430) 					_EffluentMotRun(20, 220);
    03B4C 940C 4FC4 JMP	_SetReadTime0
    03B4E 9180 0533 LDS	R24,JumpMode
(0431) 					waitEffluent = 1;
    03B50 3082      CPI	R24,2
    03B51 F469      BNE	0x3B5F
    03B52 E083      LDI	R24,3
(0432) 					workStep = 17;
    03B53 9380 17D6 STS	primeProcessSW,R24
    03B55 E081      LDI	R24,1
(0433) 					break;
    03B56 9380 160C STS	EvenPosChangeProcess+2,R24
(0434) 				case 17:			// 取样臂不在吸样位置，需先运行到吸样位
(0435) 					SetMotRunPam(MOT_SAMP_NEEDLE, 200, 5, CURRENT_SAMP_NEEDLE);
    03B58 2422      CLR	R2
    03B59 9220 160D STS	EvenPosChangeProcess+3,R2
    03B5B 9220 0533 STS	JumpMode,R2
    03B5D 940C 4FC4 JMP	_SetReadTime0
    03B5F 2722      CLR	R18
(0436) 					MotInitCheck(MOT_SAMP_NEEDLE);
    03B60 2700      CLR	R16
    03B61 940E 6B81 CALL	_SetEValve
(0437) 					SetMotRunPam(MOT_SAMP_PUMP,120,5,CURRENT_SAMP_PUMP);
    03B63 9180 00C1 LDS	R24,0xC1
    03B65 7E8F      ANDI	R24,0xEF
    03B66 9380 00C1 STS	0xC1,R24
    03B68 EC2A      LDI	R18,0xCA
    03B69 E03C      LDI	R19,0xC
    03B6A E80F      LDI	R16,0x8F
(0438) 					MotInitCheck(MOT_SAMP_PUMP);
    03B6B E016      LDI	R17,6
    03B6C 940E A90D CALL	_uart_Printf
(0439) 					waitMotSampNeedle = 1;
    03B6E 9180 00C1 LDS	R24,0xC1
    03B70 6180      ORI	R24,0x10
(0440) 					workStep = 18;
    03B71 9380 00C1 STS	0xC1,R24
    03B73 9040 0529 LDS	R4,SecondCount+2
(0441) 					SetBeepAck();
    03B75 9050 052A LDS	R5,SecondCount+3
(0442) 					break;
    03B77 9020 0527 LDS	R2,SecondCount
(0443) 				case 18:
(0444) 					SetMotRunPam(MOT_SAMP_TRUN,255,10,CURRENT_SAMP_TRUN);
    03B79 9030 0528 LDS	R3,SecondCount+1
    03B7B 9230 0536 STS	stopTestFlag+2,R3
    03B7D 9220 0535 STS	stopTestFlag+1,R2
    03B7F 9250 0538 STS	stopTestFlag+4,R5
(0445) 					MotInitCheck(MOT_SAMP_TRUN);
    03B81 9240 0537 STS	stopTestFlag+3,R4
(0446) 					waitMotSampTurn = 1;
    03B83 940E 82CB CALL	_GetNeedleOnMixCenterPos
    03B85 0158      MOVW	R10,R16
(0447) 					workStep = 19;
    03B86 92B0 1647 STS	_NewCardStoreNum+7,R11
    03B88 92A0 1646 STS	_NewCardStoreNum+6,R10
(0448) 					break;
    03B8A 940E 82F8 CALL	_GetNeedleOnMixSidePos
(0449) 				case 19:
(0450) 					MotRunTo(MOT_SAMP_TRUN,_POS_SAMPTURN_SAMP);
    03B8C 0158      MOVW	R10,R16
    03B8D 92B0 1649 STS	_NewCardStoreNum+9,R11
    03B8F 92A0 1648 STS	_NewCardStoreNum+8,R10
(0451) 					waitMotSampTurn = 1;
    03B91 940E 83A1 CALL	_GetDropHeight
(0452) 					workStep = 20;
    03B93 0158      MOVW	R10,R16
    03B94 92B0 1645 STS	_NewCardStoreNum+5,R11
(0453) 					break;
    03B96 92A0 1644 STS	_NewCardStoreNum+4,R10
(0454) 				case 20:
(0455) #ifndef Puncture				
(0456) 					_NeedleMotRunTo(_POS_SAMP_DOWN, 240);	//穿刺屏蔽
    03B98 E084      LDI	R24,4
    03B99 838A      STD	Y+2,R24
    03B9A E08A      LDI	R24,0xA
    03B9B 8388      ST	Y,R24
    03B9C EF20      LDI	R18,0xF0
(0457) 					waitMotSampNeedle = 1;
    03B9D E002      LDI	R16,2
    03B9E 940E 6A9F CALL	_SetMotRunPam
(0458) #endif					
(0459) 					_EffluentMotRun(100, 200);
    03BA0 9120 1646 LDS	R18,_NewCardStoreNum+6
    03BA2 9130 1647 LDS	R19,_NewCardStoreNum+7
    03BA4 E002      LDI	R16,2
(0460) 					SetEValve(EV3, EV_OPEN);
    03BA5 940E 6A5B CALL	_MotRunTo
    03BA7 E081      LDI	R24,1
    03BA8 9380 165B STS	dustbinOldState+4,R24
(0461) 					SetDelayTime(MOT_SAMP_TRUN, 30);
    03BAA E083      LDI	R24,3
    03BAB 9380 160D STS	EvenPosChangeProcess+3,R24
    03BAD 940C 4FC4 JMP	_SetReadTime0
(0462) 					workStep = 21;
    03BAF 940E 65D2 CALL	__PrimingFluid
(0463) 					break;
    03BB1 0158      MOVW	R10,R16
    03BB2 92A0 1612 STS	EvenPosChangeProcess+8,R10
(0464) 				case 21:		// 取样针在吸样位置，跳到吸样程序
(0465) 					SetBeepPrompt();
    03BB4 3001      CPI	R16,1
(0466) 					MotStop(MOT_EFFLUENT);
    03BB5 F429      BNE	0x3BBB
    03BB6 E084      LDI	R24,4
    03BB7 9380 160D STS	EvenPosChangeProcess+3,R24
(0467) 					SetEValve(EV_ALL,EV_CLOSE);
    03BB9 940C 4FC4 JMP	_SetReadTime0
    03BBB 9180 1612 LDS	R24,EvenPosChangeProcess+8
(0468) 					workStep = 22;	
    03BBD 3F8F      CPI	R24,0xFF
    03BBE F011      BEQ	0x3BC1
(0469) 					break;
    03BBF 940C 4FC4 JMP	_SetReadTime0
(0470) 				case 22:
(0471) 					MotRun(MOT_SAMP_PUMP, _SAMP_PUMP_INTERVAL+_SAMP_PUMP_AIR_ISOLATE);
    03BC1 E081      LDI	R24,1
    03BC2 9380 160D STS	EvenPosChangeProcess+3,R24
    03BC4 9180 00C1 LDS	R24,0xC1
(0472) 					waitMotSampPump = 1;
    03BC6 7E8F      ANDI	R24,0xEF
    03BC7 9380 00C1 STS	0xC1,R24
(0473) 					workStep = 23;
    03BC9 E626      LDI	R18,0x66
    03BCA E134      LDI	R19,0x14
    03BCB E80F      LDI	R16,0x8F
(0474) 					break;
    03BCC E016      LDI	R17,6
    03BCD 940E A90D CALL	_uart_Printf
(0475) 				case 23:
(0476) 					SetStateLedFree();
    03BCF 9180 00C1 LDS	R24,0xC1
(0477) 					mainStep = 1;
    03BD1 6180      ORI	R24,0x10
    03BD2 9380 00C1 STS	0xC1,R24
(0478) 					workStep = 0;
    03BD4 940C 4FC4 JMP	_SetReadTime0
(0479) 					if(CleanMode != 0)
    03BD6 940E 639F CALL	__PrimingDiluent
    03BD8 0158      MOVW	R10,R16
    03BD9 92A0 1612 STS	EvenPosChangeProcess+8,R10
(0480) 					{
(0481) 						if(1 == CleanMode)
    03BDB 3001      CPI	R16,1
    03BDC F429      BNE	0x3BE2
    03BDD E085      LDI	R24,5
(0482) 						{
(0483) 							Uart0ReUnable;
    03BDE 9380 160D STS	EvenPosChangeProcess+3,R24
    03BE0 940C 4FC4 JMP	_SetReadTime0
    03BE2 9180 1612 LDS	R24,EvenPosChangeProcess+8
(0484) 							uart_Printf("%s\r\n", strM3167);
    03BE4 3F8F      CPI	R24,0xFF
    03BE5 F011      BEQ	0x3BE8
    03BE6 940C 4FC4 JMP	_SetReadTime0
    03BE8 9180 00C1 LDS	R24,0xC1
(0485) 							Uart0ReEnable;
    03BEA 7E8F      ANDI	R24,0xEF
    03BEB 9380 00C1 STS	0xC1,R24
    03BED E825      LDI	R18,0x85
(0486) 						}
    03BEE E134      LDI	R19,0x14
(0487) 						else if(2 == CleanMode)
    03BEF E80F      LDI	R16,0x8F
    03BF0 E016      LDI	R17,6
    03BF1 940E A90D CALL	_uart_Printf
(0488) 						{
(0489) 							Uart0ReUnable;
    03BF3 9180 00C1 LDS	R24,0xC1
    03BF5 6180      ORI	R24,0x10
    03BF6 9380 00C1 STS	0xC1,R24
(0490) 							uart_Printf("%s\r\n", strM3168);
    03BF8 E081      LDI	R24,1
    03BF9 9380 160D STS	EvenPosChangeProcess+3,R24
    03BFB 940C 4FC4 JMP	_SetReadTime0
    03BFD E021      LDI	R18,1
(0491) 							Uart0ReEnable;
    03BFE E003      LDI	R16,3
    03BFF 940E 6B81 CALL	_SetEValve
    03C01 EC28      LDI	R18,0xC8
    03C02 E604      LDI	R16,0x64
(0492) 						}
    03C03 E010      LDI	R17,0
(0493) 						else if(250 == CleanMode)
    03C04 940E 6289 CALL	__EffluentMotRun
    03C06 E025      LDI	R18,5
    03C07 E030      LDI	R19,0
(0494) 						{
(0495) 							Uart0ReUnable;
    03C08 E00B      LDI	R16,0xB
    03C09 940E 97B7 CALL	_SetDelayTime
    03C0B E086      LDI	R24,6
    03C0C 9380 160D STS	EvenPosChangeProcess+3,R24
(0496) 							uart_Printf("%s\r\n", strM3169);
    03C0E E021      LDI	R18,1
    03C0F E001      LDI	R16,1
    03C10 940E 6B81 CALL	_SetEValve
    03C12 E12E      LDI	R18,0x1E
(0497) 							Uart0ReEnable;
    03C13 E10E      LDI	R16,0x1E
    03C14 E010      LDI	R17,0
    03C15 940E 6264 CALL	__FluidMotRun
    03C17 E003      LDI	R16,3
(0498) 						}
    03C18 940E 6AFA CALL	_MotInitCheck
(0499) 						else if(255 == CleanMode)
    03C1A E02A      LDI	R18,0xA
    03C1B E030      LDI	R19,0
    03C1C E00B      LDI	R16,0xB
(0500) 						{
(0501) 							Uart0ReUnable;
    03C1D 940E 97B7 CALL	_SetDelayTime
    03C1F E081      LDI	R24,1
    03C20 9380 165A STS	dustbinOldState+3,R24
(0502) 							uart_Printf("%s\r\n", strM3170);
    03C22 E684      LDI	R24,0x64
    03C23 9380 160D STS	EvenPosChangeProcess+3,R24
    03C25 940C 4FC4 JMP	_SetReadTime0
    03C27 E00A      LDI	R16,0xA
(0503) 							Uart0ReEnable;
    03C28 940E 6A13 CALL	_MotStop
    03C2A E081      LDI	R24,1
    03C2B 9380 1658 STS	dustbinOldState+1,R24
(0504) 						}
(0505) 						CleanMode = 0;
    03C2D E02A      LDI	R18,0xA
    03C2E E030      LDI	R19,0
    03C2F E00B      LDI	R16,0xB
(0506) 						checkFluid = 0;
    03C30 940E 97B7 CALL	_SetDelayTime
(0507) 					}
(0508) 					Uart0ReUnable;
    03C32 2722      CLR	R18
    03C33 2733      CLR	R19
    03C34 E002      LDI	R16,2
    03C35 940E 6A5B CALL	_MotRunTo
(0509) 					uart_Printf("%s\r\n",strM3102);
    03C37 E081      LDI	R24,1
    03C38 9380 165A STS	dustbinOldState+3,R24
    03C3A E087      LDI	R24,7
    03C3B 9380 160D STS	EvenPosChangeProcess+3,R24
(0510) 					Uart0ReEnable;
    03C3D 940C 4FC4 JMP	_SetReadTime0
    03C3F E520      LDI	R18,0x50
    03C40 EF0E      LDI	R16,0xFE
    03C41 EF1F      LDI	R17,0xFF
(0511) 					SetStateLedFree();
    03C42 940E 6264 CALL	__FluidMotRun
(0512) 					break;
    03C44 9120 1646 LDS	R18,_NewCardStoreNum+6
(0513) 				case 24:
(0514) 					MotRunTo(MOT_SAMP_TRUN, 0);
    03C46 9130 1647 LDS	R19,_NewCardStoreNum+7
    03C48 E002      LDI	R16,2
    03C49 940E 6A5B CALL	_MotRunTo
(0515) 					waitMotSampTurn = 1;
    03C4B E081      LDI	R24,1
    03C4C 9380 1658 STS	dustbinOldState+1,R24
(0516) 					workStep = 25;
    03C4E 9380 165A STS	dustbinOldState+3,R24
    03C50 E088      LDI	R24,0x8
(0517) 					break;
    03C51 9380 160D STS	EvenPosChangeProcess+3,R24
(0518) 				case 25:
(0519) 					MotRunTo(MOT_SAMP_TRUN, _POS_SAMPTURN_SAMP);
    03C53 940C 4FC4 JMP	_SetReadTime0
    03C55 2722      CLR	R18
    03C56 2700      CLR	R16
    03C57 940E 6B81 CALL	_SetEValve
(0520) 					waitMotSampTurn = 1;
    03C59 E00B      LDI	R16,0xB
    03C5A 940E 6A13 CALL	_MotStop
(0521) 					// 读取取样针位置信息 到混匀池中心  边缘  滴样高度
(0522) 					NeedleOnMixCenterPos = GetNeedleOnMixCenterPos();
    03C5C EB24      LDI	R18,0xB4
    03C5D E804      LDI	R16,0x84
    03C5E E013      LDI	R17,3
    03C5F 940E 62FB CALL	__NeedleMotRunTo
    03C61 E081      LDI	R24,1
(0523) 					NeedleOnMixSidePos = GetNeedleOnMixSidePos();
    03C62 9380 165A STS	dustbinOldState+3,R24
    03C64 E083      LDI	R24,3
    03C65 9380 1614 STS	EvenPosChangeProcess+10,R24
    03C67 E089      LDI	R24,0x9
    03C68 9380 160D STS	EvenPosChangeProcess+3,R24
(0524) 					DropHeight = GetDropHeight();
    03C6A 940C 4FC4 JMP	_SetReadTime0
    03C6C 9180 1614 LDS	R24,EvenPosChangeProcess+10
    03C6E 5081      SUBI	R24,1
    03C6F 9380 1614 STS	EvenPosChangeProcess+10,R24
(0525) #ifndef Puncture
(0526) 					workStep = 26;
    03C71 E021      LDI	R18,1
    03C72 E002      LDI	R16,2
(0527) #else
(0528) 					workStep = 21;
(0529) #endif
(0530) 					break;
    03C73 940E 6B81 CALL	_SetEValve
(0531) 				case 26:
(0532) 					_NeedleMotRunTo(_POS_SAMP_DOWN, 180);
    03C75 E00C      LDI	R16,0xC
    03C76 940E 6AFA CALL	_MotInitCheck
    03C78 E420      LDI	R18,0x40
    03C79 E00C      LDI	R16,0xC
(0533) 					waitMotSampNeedle = 1;
    03C7A E010      LDI	R17,0
    03C7B 940E 6264 CALL	__FluidMotRun
(0534) 					workStep = 21;
    03C7D E081      LDI	R24,1
    03C7E 9380 1658 STS	dustbinOldState+1,R24
(0535) 					break;
(0536) 			}
(0537) 			break;
    03C80 E228      LDI	R18,0x28
    03C81 E030      LDI	R19,0
(0538) 		case 1:	
(0539) // 吸取样本，清洗吸样针
(0540) 			switch(workStep)
    03C82 E00A      LDI	R16,0xA
    03C83 940E 97B7 CALL	_SetDelayTime
    03C85 E08A      LDI	R24,0xA
    03C86 9380 160D STS	EvenPosChangeProcess+3,R24
    03C88 940C 4FC4 JMP	_SetReadTime0
    03C8A EC28      LDI	R18,0xC8
    03C8B E104      LDI	R16,0x14
    03C8C E010      LDI	R17,0
    03C8D 940E 6289 CALL	__EffluentMotRun
    03C8F E124      LDI	R18,0x14
    03C90 E030      LDI	R19,0
    03C91 E00A      LDI	R16,0xA
    03C92 940E 97B7 CALL	_SetDelayTime
    03C94 E081      LDI	R24,1
    03C95 9380 1656 STS	CardScanfSW,R24
    03C97 E08B      LDI	R24,0xB
    03C98 9380 160D STS	EvenPosChangeProcess+3,R24
    03C9A 940C 4FC4 JMP	_SetReadTime0
    03C9C 9020 1614 LDS	R2,EvenPosChangeProcess+10
    03C9E 2022      TST	R2
    03C9F F029      BEQ	0x3CA5
    03CA0 E089      LDI	R24,0x9
    03CA1 9380 160D STS	EvenPosChangeProcess+3,R24
    03CA3 940C 4FC4 JMP	_SetReadTime0
    03CA5 E08F      LDI	R24,0xF
    03CA6 9380 160D STS	EvenPosChangeProcess+3,R24
    03CA8 940C 4FC4 JMP	_SetReadTime0
    03CAA 2722      CLR	R18
    03CAB 2700      CLR	R16
    03CAC 940E 6B81 CALL	_SetEValve
    03CAE E021      LDI	R18,1
    03CAF E003      LDI	R16,3
    03CB0 940E 6B81 CALL	_SetEValve
    03CB2 EB24      LDI	R18,0xB4
    03CB3 2700      CLR	R16
(0541) 			{
(0542) 				case 0:	// 等待用户按吸样键
(0543) 					if(_AutoTestCycleNum == 0)
    03CB4 2711      CLR	R17
    03CB5 940E 62FB CALL	__NeedleMotRunTo
    03CB7 EC28      LDI	R18,0xC8
    03CB8 E10E      LDI	R16,0x1E
    03CB9 E010      LDI	R17,0
    03CBA 940E 6289 CALL	__EffluentMotRun
(0544) 						_WaitStartKey = 1;
    03CBC E081      LDI	R24,1
    03CBD 9380 165A STS	dustbinOldState+3,R24
    03CBF 9380 1656 STS	CardScanfSW,R24
(0545) 					else
(0546) 					{
(0547) 						_AutoTestCycleNum --;
    03CC1 E180      LDI	R24,0x10
    03CC2 9380 160D STS	EvenPosChangeProcess+3,R24
    03CC4 940C 4FC4 JMP	_SetReadTime0
    03CC6 2722      CLR	R18
    03CC7 2700      CLR	R16
    03CC8 940E 6B81 CALL	_SetEValve
(0548) 						Uart0ReUnable;
    03CCA ED2C      LDI	R18,0xDC
    03CCB E104      LDI	R16,0x14
    03CCC E010      LDI	R17,0
    03CCD 940E 6289 CALL	__EffluentMotRun
(0549) 						uart_Printf("// AutoTestCyc: %d\r\n", _AutoTestCycleNum);
    03CCF E081      LDI	R24,1
    03CD0 9380 1656 STS	CardScanfSW,R24
    03CD2 E181      LDI	R24,0x11
    03CD3 9380 160D STS	EvenPosChangeProcess+3,R24
    03CD5 940C 4FC4 JMP	_SetReadTime0
(0550) 						Uart0ReEnable;
    03CD7 E083      LDI	R24,3
    03CD8 838A      STD	Y+2,R24
    03CD9 E085      LDI	R24,5
    03CDA 8388      ST	Y,R24
(0551) 					}
(0552) 					lastSampTime = SecondCount;		// 更新最后的取样时间
    03CDB EC28      LDI	R18,0xC8
    03CDC E003      LDI	R16,3
    03CDD 940E 6A9F CALL	_SetMotRunPam
    03CDF E003      LDI	R16,3
    03CE0 940E 6AFA CALL	_MotInitCheck
    03CE2 E086      LDI	R24,6
    03CE3 838A      STD	Y+2,R24
    03CE4 E085      LDI	R24,5
    03CE5 8388      ST	Y,R24
    03CE6 E728      LDI	R18,0x78
    03CE7 E00C      LDI	R16,0xC
    03CE8 940E 6A9F CALL	_SetMotRunPam
    03CEA E00C      LDI	R16,0xC
(0553) 					GetStoreState(0);				// 查看片仓信息
    03CEB 940E 6AFA CALL	_MotInitCheck
    03CED E081      LDI	R24,1
(0554) 					waitMotSampPump = 1;
    03CEE 9380 165A STS	dustbinOldState+3,R24
    03CF0 E182      LDI	R24,0x12
(0555) 					workStep = 1;	
    03CF1 9380 160D STS	EvenPosChangeProcess+3,R24
(0556) 					break;
    03CF3 940E 3739 CALL	_SetBeepAck
(0557) 				case 1:		
(0558) 					// 如果停止测试
(0559) 					if(1 == stopTestFlag)
    03CF5 940C 4FC4 JMP	_SetReadTime0
    03CF7 E084      LDI	R24,4
    03CF8 838A      STD	Y+2,R24
(0560) 					{
(0561) 						// 上报错误信息,提示必须关闭废片仓
(0562) 						Uart0ReUnable;
    03CF9 E08A      LDI	R24,0xA
    03CFA 8388      ST	Y,R24
    03CFB EF2F      LDI	R18,0xFF
    03CFC E002      LDI	R16,2
    03CFD 940E 6A9F CALL	_SetMotRunPam
(0563) 						uart_Printf("%s\r\n", strE3906);
    03CFF E002      LDI	R16,2
    03D00 940E 6AFA CALL	_MotInitCheck
    03D02 E081      LDI	R24,1
    03D03 9380 165B STS	dustbinOldState+4,R24
(0564) 						Uart0ReEnable;
    03D05 E183      LDI	R24,0x13
    03D06 9380 160D STS	EvenPosChangeProcess+3,R24
    03D08 940C 4FC4 JMP	_SetReadTime0
(0565) 						SetBeepWarning();
    03D0A ED24      LDI	R18,0xD4
(0566) 						workStep = 0;
    03D0B E033      LDI	R19,3
    03D0C E002      LDI	R16,2
    03D0D 940E 6A5B CALL	_MotRunTo
(0567) 						return 1;
    03D0F E081      LDI	R24,1
    03D10 9380 165B STS	dustbinOldState+4,R24
(0568) 					}
(0569) 					
(0570) 					if(CleanMode == 1)
    03D12 E184      LDI	R24,0x14
    03D13 9380 160D STS	EvenPosChangeProcess+3,R24
(0571) 					{	// 普通清洗模式
(0572) 						Uart0ReUnable;
    03D15 940C 4FC4 JMP	_SetReadTime0
    03D17 EF20      LDI	R18,0xF0
    03D18 EA08      LDI	R16,0xA8
    03D19 E017      LDI	R17,7
(0573) 						uart_Printf("%s\r\n", strM3157);
    03D1A 940E 62FB CALL	__NeedleMotRunTo
    03D1C E081      LDI	R24,1
    03D1D 9380 165A STS	dustbinOldState+3,R24
    03D1F EC28      LDI	R18,0xC8
(0574) 						Uart0ReEnable;
    03D20 E604      LDI	R16,0x64
    03D21 E010      LDI	R17,0
    03D22 940E 6289 CALL	__EffluentMotRun
    03D24 E021      LDI	R18,1
(0575) 						mainStep = 105;
    03D25 E003      LDI	R16,3
    03D26 940E 6B81 CALL	_SetEValve
(0576) 						workStep = 0;
    03D28 E12E      LDI	R18,0x1E
    03D29 E030      LDI	R19,0
    03D2A E002      LDI	R16,2
(0577) 						SetStateLedBusy();
    03D2B 940E 97B7 CALL	_SetDelayTime
(0578) 						break;
    03D2D E185      LDI	R24,0x15
    03D2E 9380 160D STS	EvenPosChangeProcess+3,R24
(0579) 					}
(0580) 					else if(2 == CleanMode)
    03D30 940C 4FC4 JMP	_SetReadTime0
    03D32 940E 3745 CALL	_SetBeepPrompt
(0581) 					{	// 强力清洗模式
(0582) 						Uart0ReUnable;
    03D34 E00B      LDI	R16,0xB
    03D35 940E 6A13 CALL	_MotStop
    03D37 2722      CLR	R18
(0583) 						uart_Printf("%s\r\n", strM3158);
    03D38 2700      CLR	R16
    03D39 940E 6B81 CALL	_SetEValve
    03D3B E186      LDI	R24,0x16
    03D3C 9380 160D STS	EvenPosChangeProcess+3,R24
(0584) 						Uart0ReEnable;
    03D3E 940C 4FC4 JMP	_SetReadTime0
    03D40 E628      LDI	R18,0x68
    03D41 E031      LDI	R19,1
    03D42 E00C      LDI	R16,0xC
(0585) 						mainStep = 100;
    03D43 940E 6A2C CALL	_MotRun
    03D45 E081      LDI	R24,1
(0586) 						workStep = 0;
    03D46 9380 1659 STS	dustbinOldState+2,R24
    03D48 E187      LDI	R24,0x17
(0587) 						SetStateLedBusy();
    03D49 9380 160D STS	EvenPosChangeProcess+3,R24
(0588) 						break;
    03D4B 940C 4FC4 JMP	_SetReadTime0
(0589) 					}
(0590) 					// 如果是取片测试
(0591) 					if(0 != CardStoreTestFlag)
    03D4D 940E 3907 CALL	_SetStateLedFree
    03D4F E081      LDI	R24,1
    03D50 9380 160C STS	EvenPosChangeProcess+2,R24
(0592) 					{	
(0593) 						if(0 == LastCardGetState)					// 取片测试模式下,前一个没有完成,无法执行下一次取片动作
    03D52 2422      CLR	R2
    03D53 9220 160D STS	EvenPosChangeProcess+3,R2
(0594) 							return;
    03D55 9020 0530 LDS	R2,_AutoTestCycleNum+2
    03D57 2022      TST	R2
(0595) 						//LastCardGetState = 0;
(0596) 						if(_NewCardStoreNum != preCardStoreNum)
    03D58 F409      BNE	0x3D5A
    03D59 C057      RJMP	0x3DB1
    03D5A 2D82      MOV	R24,R2
    03D5B 3081      CPI	R24,1
    03D5C F489      BNE	0x3D6E
    03D5D 9180 00C1 LDS	R24,0xC1
(0597) 						{
(0598) 							SetWorkStoreNum(preCardStoreNum);
    03D5F 7E8F      ANDI	R24,0xEF
    03D60 9380 00C1 STS	0xC1,R24
(0599) 						}
(0600) 					}
(0601) 					// 先检查片仓是否被开启
(0602) 					if(CardStoretate[_NewCardStoreNum - 1] == INFO_STORE_OPEN)
    03D62 E42B      LDI	R18,0x4B
    03D63 E132      LDI	R19,0x12
    03D64 E80F      LDI	R16,0x8F
    03D65 E016      LDI	R17,6
    03D66 940E A90D CALL	_uart_Printf
    03D68 9180 00C1 LDS	R24,0xC1
    03D6A 6180      ORI	R24,0x10
(0603) 					{
(0604) 						Uart0ReUnable;
    03D6B 9380 00C1 STS	0xC1,R24
    03D6D C03E      RJMP	0x3DAC
    03D6E 9180 0530 LDS	R24,_AutoTestCycleNum+2
(0605) 						uart_Printf("!3521 $%4d\r\n", _NewCardStoreNum);
    03D70 3082      CPI	R24,2
    03D71 F489      BNE	0x3D83
    03D72 9180 00C1 LDS	R24,0xC1
    03D74 7E8F      ANDI	R24,0xEF
    03D75 9380 00C1 STS	0xC1,R24
(0606) 						Uart0ReEnable;
    03D77 E52E      LDI	R18,0x5E
    03D78 E132      LDI	R19,0x12
    03D79 E80F      LDI	R16,0x8F
    03D7A E016      LDI	R17,6
    03D7B 940E A90D CALL	_uart_Printf
(0607) 						_WaitStartKey = 1;
    03D7D 9180 00C1 LDS	R24,0xC1
(0608) 						SetDelayTime(MOT_SAMP_NEEDLE, 10);
    03D7F 6180      ORI	R24,0x10
    03D80 9380 00C1 STS	0xC1,R24
    03D82 C029      RJMP	0x3DAC
    03D83 9180 0530 LDS	R24,_AutoTestCycleNum+2
(0609) 						SetBeepWarning();
    03D85 3F8A      CPI	R24,0xFA
(0610) 						break;
    03D86 F489      BNE	0x3D98
    03D87 9180 00C1 LDS	R24,0xC1
(0611) 					}
(0612) 					// 检查片仓是否有干片
(0613) 					if(CardNoneUseful == 0)
    03D89 7E8F      ANDI	R24,0xEF
    03D8A 9380 00C1 STS	0xC1,R24
    03D8C E726      LDI	R18,0x76
(0614) 					{
(0615) 						
(0616) 						if(CardSurplusState[_NewCardStoreNum - 1] == INFO_STORE_EMPTY)
    03D8D E132      LDI	R19,0x12
    03D8E E80F      LDI	R16,0x8F
    03D8F E016      LDI	R17,6
    03D90 940E A90D CALL	_uart_Printf
    03D92 9180 00C1 LDS	R24,0xC1
    03D94 6180      ORI	R24,0x10
    03D95 9380 00C1 STS	0xC1,R24
(0617) 						{
(0618) 							Uart0ReUnable;
    03D97 C014      RJMP	0x3DAC
    03D98 9180 0530 LDS	R24,_AutoTestCycleNum+2
    03D9A 3F8F      CPI	R24,0xFF
    03D9B F481      BNE	0x3DAC
(0619) 							uart_Printf("!3520 $%4d\r\n", _NewCardStoreNum);
    03D9C 9180 00C1 LDS	R24,0xC1
    03D9E 7E8F      ANDI	R24,0xEF
    03D9F 9380 00C1 STS	0xC1,R24
    03DA1 E82B      LDI	R18,0x8B
    03DA2 E132      LDI	R19,0x12
(0620) 							Uart0ReEnable;
    03DA3 E80F      LDI	R16,0x8F
    03DA4 E016      LDI	R17,6
    03DA5 940E A90D CALL	_uart_Printf
    03DA7 9180 00C1 LDS	R24,0xC1
(0621) 							_WaitStartKey = 1;
    03DA9 6180      ORI	R24,0x10
    03DAA 9380 00C1 STS	0xC1,R24
(0622) 							SetDelayTime(MOT_SAMP_NEEDLE, 10);
    03DAC 2422      CLR	R2
    03DAD 9220 0530 STS	_AutoTestCycleNum+2,R2
    03DAF 9220 1610 STS	EvenPosChangeProcess+6,R2
(0623) 							SetBeepWarning();
    03DB1 9180 00C1 LDS	R24,0xC1
(0624) 							break;
    03DB3 7E8F      ANDI	R24,0xEF
(0625) 						}
(0626) 						if(CardSurplusState[_NewCardStoreNum - 1] == INFO_STORE_ERROR)
    03DB4 9380 00C1 STS	0xC1,R24
    03DB6 EF22      LDI	R18,0xF2
    03DB7 E03C      LDI	R19,0xC
    03DB8 E80F      LDI	R16,0x8F
    03DB9 E016      LDI	R17,6
    03DBA 940E A90D CALL	_uart_Printf
    03DBC 9180 00C1 LDS	R24,0xC1
(0627) 						{
(0628) 							Uart0ReUnable;
    03DBE 6180      ORI	R24,0x10
    03DBF 9380 00C1 STS	0xC1,R24
    03DC1 940E 3907 CALL	_SetStateLedFree
(0629) 							uart_Printf("!3522 $%4d\r\n", _NewCardStoreNum);
    03DC3 940C 4FC4 JMP	_SetReadTime0
    03DC5 E02A      LDI	R18,0xA
    03DC6 E030      LDI	R19,0
    03DC7 E003      LDI	R16,3
    03DC8 940E 97B7 CALL	_SetDelayTime
(0630) 							Uart0ReEnable;
    03DCA E189      LDI	R24,0x19
    03DCB 9380 160D STS	EvenPosChangeProcess+3,R24
    03DCD 940C 4FC4 JMP	_SetReadTime0
(0631) 							_WaitStartKey = 1;
    03DCF 2722      CLR	R18
    03DD0 E003      LDI	R16,3
    03DD1 940E 2FEA CALL	_GetMotorMonitorState
(0632) 							SetDelayTime(MOT_SAMP_NEEDLE, 10);
    03DD3 2EA0      MOV	R10,R16
    03DD4 3001      CPI	R16,1
    03DD5 F469      BNE	0x3DE3
    03DD6 2722      CLR	R18
(0633) 							SetBeepWarning();
    03DD7 2733      CLR	R19
    03DD8 E002      LDI	R16,2
(0634) 							break;
    03DD9 940E 6A5B CALL	_MotRunTo
(0635) 						}
(0636) 					}
(0637) #ifndef Puncture
(0638) 					// 开始测试，保存本次测试的测试卡类型和稀释比例	
(0639) 					_SetCurWorkParamter();
    03DDB E081      LDI	R24,1
    03DDC 9380 165B STS	dustbinOldState+4,R24
(0640) 					_SetNewCardGet(NewTestInfo.cardStoreNum);
    03DDE E18A      LDI	R24,0x1A
    03DDF 9380 160D STS	EvenPosChangeProcess+3,R24
(0641) #endif
(0642) 					SetBeepAck();
    03DE1 940C 4FC4 JMP	_SetReadTime0
(0643) 					SetEValve(EV_ALL,EV_CLOSE);
    03DE3 2422      CLR	R2
    03DE4 9220 160D STS	EvenPosChangeProcess+3,R2
    03DE6 E081      LDI	R24,1
(0644) 					SetDelayTime(MOT_SAMP_NEEDLE, 2);  // 2017-05-22 5 -> 2 
    03DE7 9380 0533 STS	JumpMode,R24
    03DE9 940C 4FC4 JMP	_SetReadTime0
    03DEB E02A      LDI	R18,0xA
(0645) 					workStep = 2;
    03DEC E030      LDI	R19,0
    03DED E002      LDI	R16,2
    03DEE 940E 97B7 CALL	_SetDelayTime
(0646) 					break;
    03DF0 E18B      LDI	R24,0x1B
(0647) 				case 2:
(0648) #ifdef Puncture		
(0649) 					if(0 == WithoutPuncture)
(0650) 					{		
(0651) 						MotRunTo(MOT_SAMP_TRUN,_POS_SAMPTURN_SAMP);
(0652) 						waitMotSampTurn = 1;
(0653) 						workStep = 30;
(0654) 					}
(0655) 					else
(0656) 					{
(0657) 						if(1 == WithoutPuncture)
(0658) 						{
(0659) 							_WaitStartKey = 1;
(0660) 							_NeedleMotRunTo(2380, 240);	//_POS_SAMP_DOWN - 1420
(0661) 							waitMotSampNeedle = 1;
(0662) 							workStep = 41;
(0663) 						}
(0664) 						else if(2 == WithoutPuncture)
(0665) 						{
(0666) 							_NeedleMotRunTo(_POS_SAMP_DOWN, 240);	
(0667) 							waitMotSampNeedle = 1;
(0668) 							workStep = 40;
(0669) 						}
(0670) 					}
(0671) 					break;
(0672) 				case 30:				// 开始穿刺
(0673) #ifndef HalfCircle
(0674) 					_NeedleMotRunTo(300 * 2, 180);	
(0675) #else
(0676) 					_NeedleMotRunTo(300, 180);			
(0677) #endif
(0678) 					waitMotSampNeedle = 1;
(0679) 					//workStep = 31;
(0680) 					detRetry = 0;
(0681) 					workStep = 35;
(0682) 					break;
(0683) 				case 35:
(0684) 					liqDetBaseAdc = getLiqDetADC(NeedleChannel);      //采样电压的base值
(0685) 					//if(liqDetBaseAdc < 400)
(0686) 					if(liqDetBaseAdc < 300)
(0687) 					{
(0688) 						workStep = 60;
(0689) 						//SetEValve(EV_ALL,EV_CLOSE);
(0690) 						//SetEValve(EV1,EV_OPEN);    //清洗液供给3号管
(0691) 						SetEValve(EV3,EV_OPEN);    //废液连接清洗池
(0692) 						_EffluentMotRun(12, 240);
(0693) 						//废液排空清洗头的水
(0694) 						waitEffluent = 1;
(0695) 						SetDelayTime(MOT_SAMP_NEEDLE, 5); 
(0696) 						if(detRetry >= 3)
(0697) 						{
(0698) 							detRetry = 0;
(0699) 							workStep = 50;
(0700) 							ErrorNum = 4;	// 3928
(0701) 						}
(0702) 						else
(0703) 							detRetry++;
(0704) 						break;
(0705) 					}
(0706) 					detRetry = 0;
(0707) 					SetEValve(EV_ALL,EV_CLOSE);
(0708) 					Uart0ReUnable;
(0709) 					uart_Printf("// LiqDetBaseAdc:%d\r\n", liqDetBaseAdc);
(0710) 					Uart0ReEnable;
(0711) 					//workStep = 31;
(0712) 					workStep = 36;
(0713) 					break;
(0714) 				case 36:
(0715) #ifndef HalfCircle
(0716) 					_NeedleMotRunTo(560 * 2, 180);	
(0717) #else
(0718) 					_NeedleMotRunTo(560, 180);
(0719) #endif
(0720) 					waitMotSampNeedle = 1;
(0721) 					workStep = 31;
(0722) 					break;
(0723) 				case 60:
(0724) 					//_FluidMotRun(20, 40);           //清洗泵改成倒吸
(0725) 					SetEValve(EV1,EV_OPEN);
(0726) 					_FluidMotRun(-2, 40);
(0727) 					//waitMotSampNeedle = 1;
(0728) 					//waitEffluent = 1;
(0729) 					waitMotFluid = 1;
(0730) 					workStep = 35;
(0731) 					break;
(0732) 					
(0733) 					
(0734) 				case 31:				// 穿刺到达穿刺光藕位置
(0735) 					SetMotRunPam(MOT_SAMP_NEEDLE, 120, 10, 10); 	// 60
(0736) #ifndef HalfCircle
(0737) 					MotRun(MOT_SAMP_NEEDLE, 320 * 2);
(0738) #else
(0739) 					MotRun(MOT_SAMP_NEEDLE, 320);
(0740) #endif
(0741) 					waitMotSampNeedle = 1;
(0742) 					workStep = 32;
(0743) 					break;
(0744) 				case 32:				// 判断穿刺结果 (PINA & 0x40):穿刺感应传感器
(0745) 					//ucTmp = PINA;
(0746) 					//if((ucTmp & 0x40) == 0)	// 穿刺压力(试管)感应
(0747) 					{
(0748) 						Uart0ReUnable;
(0749) 						uart_Printf("%s\r\n",strM3225);
(0750) 						Uart0ReEnable;
(0751) 						workStep = 33;
(0752) 						break;
(0753) 					}
(0754) 					/*
(0755) 					else	// 未探测到试管,取消测试
(0756) 					{
(0757) 						// 撤销吸样
(0758) 						ErrorNum = 1;	// 3925
(0759) 						workStep = 50;
(0760) 						break;
(0761) 					}
(0762) 					*/
(0763) 					break;
(0764) 				case 33:	//  (PINA & 0x80):穿刺到位传感器
(0765) 					//ucTmp = PINA;
(0766) 					//if((ucTmp & 0x80) != 0)	// 穿刺到位感应
(0767) 					{
(0768) 						Uart0ReUnable;
(0769) 						uart_Printf("%s\r\n",strM3226);
(0770) 						Uart0ReEnable;
(0771) 						workStep = 34;
(0772) 					}
(0773) 					/*
(0774) 					else	// 未穿刺到位
(0775) 					{
(0776) 						ErrorNum = 1;	// 3926
(0777) 						// 撤销吸样
(0778) 						workStep = 50;
(0779) 						break;
(0780) 					}
(0781) 					*/
(0782) 					break;
(0783) 				case 34:				// 液面探测初始化并启动取样针下降
(0784) 					SetMotRunPam(MOT_SAMP_NEEDLE, 180, 5, 10);	// 110
(0785) 					MotRunTo(MOT_SAMP_NEEDLE, _POS_SAMP_DOWN);
(0786) 					detRetry = 0;
(0787) 					workStep = 37;
(0788) 					break;
(0789) 				case 37:		// 液面探测
(0790) 					i = getLiqDetADC(NeedleChannel);// 0-200
(0791) 					if(GetMotState(MOT_SAMP_NEEDLE) == STA_SLAVE_FREE)
(0792) 					{
(0793) 						// 电机运行到最大行程处,未探测到液面
(0794) 						MotStop(MOT_SAMP_NEEDLE);
(0795) 						SetBeepWarning();
(0796) 						// 退出处理
(0797) 						ErrorNum = 3;	// 3927
(0798) 						Uart0ReUnable;
(0799) 						uart_Printf("// LiqNotPassAdc:%d\r\n", i);
(0800) 						Uart0ReEnable;
(0801) 						workStep = 50;
(0802) 						break;
(0803) 					}
(0804) 					if(i < liqDetBaseAdc)// 350
(0805) 					{
(0806) 						i = liqDetBaseAdc - i;//100+
(0807) 						Num = liqDetBaseAdc / 5;
(0808) 						//Num = liqDetBaseAdc / 8;//>25
(0809) 						//if(Num > 25)
(0810) 						//	Num = 25;
(0811) 						if(i > Num)		// 设置液面感应灵敏度  16  25
(0812) 						{
(0813) 							if(detRetry < 3)  // 1
(0814) 							{
(0815) 								detRetry ++;	
(0816) 								break;	
(0817) 							}
(0818) 							
(0819) 							MotStop(MOT_SAMP_NEEDLE);   //先将小针停止	
(0820) 							Uart0ReUnable;
(0821) 					        uart_Printf("// theNeedleMotIsStop\r\n");	
(0822) 					        Uart0ReEnable;
(0823) 							SetDelayTime(MOT_SAMP_NEEDLE, 4);  // 探测到液面停止延时
(0824) 							SetBeepAck();
(0825) 							workStep = 38;
(0826) 						}
(0827) 						else
(0828) 							detRetry = 0;
(0829) 					}
(0830) 					break;
(0831) 				case 38:	
(0832) 				//	MotStop(MOT_SAMP_NEEDLE);
(0833) 					theDifferenceOfStep = (unsigned int)GetMotPositionOfStep(MOT_SAMP_NEEDLE);
(0834) 					Uart0ReUnable;
(0835) 					//uart_Printf("%s $%4d\r\n", strM3227,i);	
(0836) 					uart_Printf("// theWaterLevelStep:%d\r\n", theDifferenceOfStep);	
(0837) 					Uart0ReEnable;
(0838) 					waitMotSampNeedle = 1;
(0839) 					SetEValve(EV2,EV_CLOSE);  // 吸样前关闭EV2
(0840) 				//	SetDelayTime(MOT_SAMP_NEEDLE, 5);
(0841) 					workStep = 39;
(0842) 					break;
(0843) 				case 39:		// 探测到液面并停止电机运行
(0844) 				
(0845) 					theDownPointAdc=getLiqDetADC(NeedleChannel);
(0846) 					
(0847) 				    Uart0ReUnable;
(0848) 					uart_Printf("// theDownPointAdc:%d\r\n", theDownPointAdc);	
(0849) 					Uart0ReEnable;
(0850) 					
(0851) 					Uart0ReUnable;
(0852) 					uart_Printf("// LiqChangeAdc:%d\r\n", i);	// 差值
(0853) 					Uart0ReEnable;
(0854) 					//i = (unsigned int)GetMotPositionOfStep(MOT_SAMP_NEEDLE);         //pan20170503
(0855) 					theDifferenceOfStep=_POS_SAMP_DOWN - theDifferenceOfStep;
(0856) 					Uart0ReUnable;
(0857) 					uart_Printf("// theDifferenceOfStep :%d\r\n", theDifferenceOfStep);	// 报告液面探测结果
(0858) 					Uart0ReEnable;
(0859) 					SetDelayTime(MOT_SAMP_NEEDLE, 5);
(0860) 					
(0861) 					if (theDifferenceOfStep >= 120)                     //留3mm的余量
(0862) 					{
(0863) 						workStep = 41;
(0864) 					}
(0865) 					else
(0866) 					{
(0867) 						ErrorNum = 3;	// 3927
(0868) 						Uart0ReUnable;
(0869) 						uart_Printf("// theDifferenceOfStepisTooSmall:%d\r\n", theDifferenceOfStep);
(0870) 						Uart0ReEnable;
(0871) 						workStep = 50;
(0872) 					}
(0873) 					break;
(0874) 				case 41:
(0875) 					_NeedleMotRunTo(_POS_SAMP_DOWN, 180);	
(0876) 					waitMotSampNeedle = 1;
(0877) 					workStep = 40;
(0878) 					break;
(0879) 				case 40:
(0880) 					_SetCurWorkParamter();
(0881) 					_SetNewCardGet(NewTestInfo.cardStoreNum);
(0882) #endif				
(0883) 					siTmp = CalSampVolume(NewTestInfo.sampDiluteMult, 0);
    03DF1 9380 160D STS	EvenPosChangeProcess+3,R24
    03DF3 940C 4FC4 JMP	_SetReadTime0
    03DF5 2722      CLR	R18
    03DF6 E002      LDI	R16,2
(0884) 					siTmp += 45;
    03DF7 940E 2FEA CALL	_GetMotorMonitorState
    03DF9 2EA0      MOV	R10,R16
(0885) 					Uart0ReUnable;
    03DFA 3001      CPI	R16,1
    03DFB F511      BNE	0x3E1E
    03DFC ED24      LDI	R18,0xD4
    03DFD E033      LDI	R19,3
    03DFE E002      LDI	R16,2
(0886) 					uart_Printf("%s $%4d $%4d\r\n", strM3121, siTmp,NewTestInfo.sampDiluteMult);	// 显示当前吸样量
    03DFF 940E 6A5B CALL	_MotRunTo
    03E01 E081      LDI	R24,1
    03E02 9380 165B STS	dustbinOldState+4,R24
    03E04 940E 82CB CALL	_GetNeedleOnMixCenterPos
    03E06 0158      MOVW	R10,R16
    03E07 92B0 1647 STS	_NewCardStoreNum+7,R11
    03E09 92A0 1646 STS	_NewCardStoreNum+6,R10
    03E0B 940E 82F8 CALL	_GetNeedleOnMixSidePos
(0887) 					Uart0ReEnable;
    03E0D 0158      MOVW	R10,R16
    03E0E 92B0 1649 STS	_NewCardStoreNum+9,R11
    03E10 92A0 1648 STS	_NewCardStoreNum+8,R10
(0888) #ifdef Puncture
(0889) 					if(NewTestInfo.sampDiluteMult == 9)
(0890) 					{
(0891) 						if(WithoutPuncture == 0)	// 如果需要经过穿刺
(0892) 							siTmp += 1955;
(0893) 						else
(0894) 							siTmp += 400 ;    
(0895) 					}
(0896) #else
(0897) 					if(NewTestInfo.sampDiluteMult == 9)
    03E12 940E 83A1 CALL	_GetDropHeight
    03E14 0158      MOVW	R10,R16
(0898) 						siTmp += 400 ;    
    03E15 92B0 1645 STS	_NewCardStoreNum+5,R11
    03E17 92A0 1644 STS	_NewCardStoreNum+4,R10
(0899) #endif
(0900) 					_SampPumpMotRun(siTmp, 180);	// 2017-05-22  60 -> 180	
    03E19 E18C      LDI	R24,0x1C
    03E1A 9380 160D STS	EvenPosChangeProcess+3,R24
    03E1C 940C 4FC4 JMP	_SetReadTime0
(0901) 					_FluidMotRun(4, 64);
    03E1E E189      LDI	R24,0x19
    03E1F 9380 160D STS	EvenPosChangeProcess+3,R24
    03E21 940C 4FC4 JMP	_SetReadTime0
(0902) #if (DILUTE_TUBE == 14)
(0903) 					_DiluentMotRun(20, 180);		// 清洗稀释液管路和混匀池底部   
(0904) #elif (DILUTE_TUBE == 16)
(0905) 					_DiluentMotRun(6, 200);			// 清洗稀释液管路和混匀池底部	// 2017-05-22 160 -> 200
    03E23 EB24      LDI	R18,0xB4
    03E24 EA08      LDI	R16,0xA8
    03E25 E017      LDI	R17,7
    03E26 940E 62FB CALL	__NeedleMotRunTo
(0906) #endif
(0907) 					SetStateLedBusy();
    03E28 E081      LDI	R24,1
(0908) 					waitMotSampPump = 1;
    03E29 9380 165A STS	dustbinOldState+3,R24
    03E2B E185      LDI	R24,0x15
(0909) 					waitEffluent = 1;	// 如果上次排液未完毕，等待
    03E2C 9380 160D STS	EvenPosChangeProcess+3,R24
(0910) 					workStep = 3;
    03E2E 940C 4FC4 JMP	_SetReadTime0
    03E30 90A0 160D LDS	R10,EvenPosChangeProcess+3
(0911) 					break;
    03E32 24BB      CLR	R11
(0912) 				case 3:
(0913) 					waitMotFluid = 1;
    03E33 20AA      TST	R10
    03E34 F419      BNE	0x3E38
    03E35 20BB      TST	R11
(0914) 					waitMotDiluent = 1;
    03E36 F409      BNE	0x3E38
    03E37 C03C      RJMP	0x3E74
(0915) 					workStep = 4;
    03E38 01C5      MOVW	R24,R10
    03E39 3081      CPI	R24,1
    03E3A E0E0      LDI	R30,0
(0916) 					break;
    03E3B 079E      CPC	R25,R30
    03E3C F409      BNE	0x3E3E
(0917) 				case 4:		
(0918) 					SetEValve(EV3, EV_OPEN);
    03E3D C077      RJMP	0x3EB5
    03E3E 3082      CPI	R24,2
    03E3F E0E0      LDI	R30,0
    03E40 079E      CPC	R25,R30
(0919) 					SetEValve(EV1, EV_OPEN);
    03E41 F409      BNE	0x3E43
    03E42 C16E      RJMP	0x3FB1
    03E43 3083      CPI	R24,3
    03E44 E0E0      LDI	R30,0
(0920) 					SetBeepPrompt();
    03E45 079E      CPC	R25,R30
    03E46 F409      BNE	0x3E48
(0921) #ifndef HalfCircle
(0922) 					_EffluentMotRun(112, 240);		// 2017-05-22 140 -> 112  
(0923) #else
(0924) 					_EffluentMotRun(56, 240);		// 2017-05-22 70 -> 56
    03E47 C1AD      RJMP	0x3FF5
    03E48 3084      CPI	R24,4
    03E49 E0E0      LDI	R30,0
    03E4A 079E      CPC	R25,R30
    03E4B F409      BNE	0x3E4D
(0925) #endif
(0926) 					SetDelayTime(MOT_EFFLUENT, 2);	// 延迟一段时间，先建立负压
    03E4C C1B2      RJMP	0x3FFF
    03E4D 3085      CPI	R24,5
    03E4E E0E0      LDI	R30,0
    03E4F 079E      CPC	R25,R30
    03E50 F409      BNE	0x3E52
(0927) 					workStep = 5;
    03E51 C1ED      RJMP	0x403F
    03E52 3087      CPI	R24,7
    03E53 E0E0      LDI	R30,0
(0928) 					break;
    03E54 079E      CPC	R25,R30
    03E55 F409      BNE	0x3E57
(0929) 				case 5:				// 开启洗液泵，清洗针外壁
(0930) 					_FluidMotRun(20, 40);
    03E56 C1FA      RJMP	0x4051
    03E57 3088      CPI	R24,0x8
    03E58 E0E0      LDI	R30,0
    03E59 079E      CPC	R25,R30
    03E5A F409      BNE	0x3E5C
(0931) 					waitMotSampNeedle = 1;
    03E5B C230      RJMP	0x408C
    03E5C 3089      CPI	R24,0x9
    03E5D E0E0      LDI	R30,0
(0932) 					_NeedleMotRunTo(0, 200);	// 取样针上升
    03E5E 079E      CPC	R25,R30
    03E5F F409      BNE	0x3E61
    03E60 C237      RJMP	0x4098
    03E61 3080      CPI	R24,0
    03E62 E0E0      LDI	R30,0
(0933) 					workStep = 7;	
    03E63 079E      CPC	R25,R30
    03E64 F414      BGE	0x3E67
    03E65 940C 4FC4 JMP	_SetReadTime0
(0934) 					break;
    03E67 01C5      MOVW	R24,R10
(0935) 				case 7:				// 取样针已经上升到最高点，外壁清洗结束,取样针回到起始位
(0936) #ifndef UartSendLong
(0937) 					Uart0ReUnable;
(0938) 					uart_Printf("%s $%8d\r\n",strM3104 ,NewTestInfo.testSerial);
(0939) 					Uart0ReEnable;
(0940) #else
(0941) 					Uart0ReUnable;
    03E68 3685      CPI	R24,0x65
    03E69 E0E0      LDI	R30,0
    03E6A 079E      CPC	R25,R30
    03E6B F409      BNE	0x3E6D
    03E6C C1A7      RJMP	0x4014
(0942) 					uart_Printf("%s $ ",strM3104);
    03E6D 3686      CPI	R24,0x66
    03E6E E0E0      LDI	R30,0
    03E6F 079E      CPC	R25,R30
    03E70 F409      BNE	0x3E72
    03E71 C1B6      RJMP	0x4028
    03E72 940C 4FC4 JMP	_SetReadTime0
(0943) 					uart0SendInt(NewTestInfo.testSerial);
    03E74 9020 052E LDS	R2,_AutoTestCycleNum
    03E76 9030 052F LDS	R3,_AutoTestCycleNum+1
    03E78 2022      TST	R2
    03E79 F431      BNE	0x3E80
    03E7A 2033      TST	R3
    03E7B F421      BNE	0x3E80
    03E7C E081      LDI	R24,1
(0944) 					uart_Printf("\r\n");
    03E7D 9380 1641 STS	_NewCardStoreNum+1,R24
    03E7F C01B      RJMP	0x3E9B
    03E80 9180 052E LDS	R24,_AutoTestCycleNum
(0945) 					Uart0ReEnable;
    03E82 9190 052F LDS	R25,_AutoTestCycleNum+1
    03E84 9701      SBIW	R24,1
    03E85 9390 052F STS	_AutoTestCycleNum+1,R25
(0946) #endif
(0947) 					MotStop(MOT_FLUID);
    03E87 9380 052E STS	_AutoTestCycleNum,R24
(0948) 					SetMotRunPam(MOT_SAMP_TRUN,255,10,CURRENT_SAMP_TRUN);
    03E89 9180 00C1 LDS	R24,0xC1
    03E8B 7E8F      ANDI	R24,0xEF
    03E8C 9380 00C1 STS	0xC1,R24
    03E8E 9120 052E LDS	R18,_AutoTestCycleNum
    03E90 9130 052F LDS	R19,_AutoTestCycleNum+1
(0949) 					MotRunTo(MOT_SAMP_TRUN,0);
    03E92 E70A      LDI	R16,0x7A
    03E93 E016      LDI	R17,6
    03E94 940E A90D CALL	_uart_Printf
(0950) 					checkFluid = 0;
    03E96 9180 00C1 LDS	R24,0xC1
    03E98 6180      ORI	R24,0x10
(0951) 					SetDelayTime(MOT_SAMP_TRUN, 5);  // 2017-05-22  10->5
    03E99 9380 00C1 STS	0xC1,R24
    03E9B 9040 0529 LDS	R4,SecondCount+2
    03E9D 9050 052A LDS	R5,SecondCount+3
(0952) 					workStep = 8;
    03E9F 9020 0527 LDS	R2,SecondCount
(0953) 					break;
    03EA1 9030 0528 LDS	R3,SecondCount+1
(0954) 				case 8:		// 延迟1秒后停止清洗头吸空, 转换到混匀池排空
(0955) 					SetEValve(EV_ALL,EV_CLOSE);
    03EA3 9230 0536 STS	stopTestFlag+2,R3
    03EA5 9220 0535 STS	stopTestFlag+1,R2
(0956) 					waitMotSampTurn = 1;
    03EA7 9250 0538 STS	stopTestFlag+4,R5
    03EA9 9240 0537 STS	stopTestFlag+3,R4
(0957) 					workStep = 9;
    03EAB 2700      CLR	R16
    03EAC 940E 6C2D CALL	_GetStoreState
(0958) 					break;
    03EAE E081      LDI	R24,1
(0959) 				case 9:				// 标本吸取完毕
(0960) 					if(NewTestInfo.sampDiluteMult != 1)
    03EAF 9380 1659 STS	dustbinOldState+2,R24
    03EB1 9380 160D STS	EvenPosChangeProcess+3,R24
(0961) 					{
(0962) 						MotRunTo(MOT_SAMP_TRUN, NeedleOnMixSidePos);		// 取样臂运行到混匀池壁上方
    03EB3 940C 4FC4 JMP	_SetReadTime0
    03EB5 9180 0534 LDS	R24,stopTestFlag
    03EB7 3081      CPI	R24,1
    03EB8 F4C1      BNE	0x3ED1
    03EB9 9180 00C1 LDS	R24,0xC1
(0963) 						waitMotSampTurn = 1;
    03EBB 7E8F      ANDI	R24,0xEF
    03EBC 9380 00C1 STS	0xC1,R24
(0964) 						mainStep = 4;		
    03EBE EC20      LDI	R18,0xC0
    03EBF E134      LDI	R19,0x14
(0965) 						workStep = 0;	// 进入一次稀释程序
    03EC0 E80F      LDI	R16,0x8F
    03EC1 E016      LDI	R17,6
    03EC2 940E A90D CALL	_uart_Printf
(0966) 					}
    03EC4 9180 00C1 LDS	R24,0xC1
    03EC6 6180      ORI	R24,0x10
    03EC7 9380 00C1 STS	0xC1,R24
    03EC9 940E 372D CALL	_SetBeepWarning
    03ECB 2422      CLR	R2
(0967) 					else
(0968) 					{
(0969) 						if(_DropMode == 0)
(0970) 						{
(0971) 							mainStep = 9;		
    03ECC 9220 160D STS	EvenPosChangeProcess+3,R2
    03ECE E001      LDI	R16,1
(0972) 							workStep = 0;		// 直接跳到滴样程序
    03ECF 940C 4FC5 JMP	0x4FC5
    03ED1 9180 0530 LDS	R24,_AutoTestCycleNum+2
(0973) 						}
    03ED3 3081      CPI	R24,1
    03ED4 F4D1      BNE	0x3EEF
    03ED5 9180 00C1 LDS	R24,0xC1
(0974) 						else 
(0975) 						{	// 1:1需要抽打混匀,直接跳到抽打混匀
(0976) 							if(0 == _MixtureMode)
(0977) 							{
(0978) 								mainStep = 8;
    03ED7 7E8F      ANDI	R24,0xEF
    03ED8 9380 00C1 STS	0xC1,R24
(0979) 								workStep = 11;
    03EDA E825      LDI	R18,0x85
    03EDB E131      LDI	R19,0x11
    03EDC E80F      LDI	R16,0x8F
(0980) 							}
    03EDD E016      LDI	R17,6
(0981) 							// 1:1不需要抽打混匀,直接滴样至有小杯子的试剂片
(0982) 							else
(0983) 							{
(0984) 								mainStep = 8;
    03EDE 940E A90D CALL	_uart_Printf
    03EE0 9180 00C1 LDS	R24,0xC1
(0985) 								workStep = 18;
    03EE2 6180      ORI	R24,0x10
    03EE3 9380 00C1 STS	0xC1,R24
(0986) 							}
(0987) 						}
(0988) 					}
(0989) 					waitEffluent = 1;
    03EE5 E689      LDI	R24,0x69
    03EE6 9380 160C STS	EvenPosChangeProcess+2,R24
(0990) 					break;
(0991) #ifdef Puncture			
(0992) 				case 50:	// 穿刺失败退出处理
(0993) 					SetMotRunPam(MOT_SAMP_NEEDLE, 100, 5, 10);		// 100
(0994) 					MotRunTo(MOT_SAMP_NEEDLE, 0);
(0995) 					workStep = 51;
(0996) 					break;
(0997) 				case 51:
(0998) 					SetEValve(EV3, EV_OPEN);
(0999) 					SetEValve(EV1, EV_OPEN);
(1000) #ifndef HalfCircle
(1001) 					_EffluentMotRun(140, 240);  
(1002) #else
(1003) 					_EffluentMotRun(70, 240);
(1004) #endif
(1005) 					SetDelayTime(MOT_EFFLUENT, 2);	// 延迟一段时间，先建立负压
(1006) 					workStep = 52;
(1007) 					break;
(1008) 				case 52:
(1009) 					_FluidMotRun(20, 40);
(1010) 					waitMotSampNeedle = 1;
(1011) 					workStep = 53;
(1012) 					break;
(1013) 				case 53:
(1014) 					MotStop(MOT_FLUID);
(1015) 					_FluidMotRun(-1, 40);
(1016) 					SetDelayTime(MOT_EFFLUENT, 10);
(1017) 					waitMotFluid = 1;
(1018) 					if(ErrorNum == 1)
(1019) 					{
(1020) 						ErrorNum = 0;
(1021) 						Uart0ReUnable;
(1022) 						uart_Printf("%s\r\n",strE3925);
(1023) 						Uart0ReEnable;
(1024) 					}
(1025) 					else if(ErrorNum == 2)
(1026) 					{
(1027) 						ErrorNum = 0;
(1028) 						Uart0ReUnable;
(1029) 						uart_Printf("%s\r\n",strE3926);
(1030) 						Uart0ReEnable;
(1031) 					}
(1032) 					else if(ErrorNum == 3)
(1033) 					{
(1034) 						ErrorNum = 0;
(1035) 						Uart0ReUnable;
(1036) 						uart_Printf("%s\r\n",strE3927);
(1037) 						Uart0ReEnable;
(1038) 					}
(1039) 					else if(ErrorNum == 4)
(1040) 					{
(1041) 						ErrorNum = 0;
(1042) 						Uart0ReUnable;
(1043) 						uart_Printf("%s  $ %4d\r\n",strE3928,liqDetBaseAdc);
(1044) 						Uart0ReEnable;
(1045) 					}
(1046) 					workStep = 54;
(1047) 					break;
(1048) 				case 54:
(1049) 					SetEValve(EV_ALL,EV_CLOSE);
(1050) 					MotStop(MOT_EFFLUENT);
(1051) 					workStep = 0;
(1052) 					break;
(1053) #endif
(1054) 				}
(1055) 			break;
    03EE8 2422      CLR	R2
(1056) 		case 4:				// 一次混匀
(1057) 			switch(workStep)
    03EE9 9220 160D STS	EvenPosChangeProcess+3,R2
    03EEB 940E 38F8 CALL	_SetStateLedBusy
    03EED 940C 4FC4 JMP	_SetReadTime0
    03EEF 9180 0530 LDS	R24,_AutoTestCycleNum+2
    03EF1 3082      CPI	R24,2
    03EF2 F4D1      BNE	0x3F0D
    03EF3 9180 00C1 LDS	R24,0xC1
    03EF5 7E8F      ANDI	R24,0xEF
    03EF6 9380 00C1 STS	0xC1,R24
    03EF8 E929      LDI	R18,0x99
    03EF9 E131      LDI	R19,0x11
    03EFA E80F      LDI	R16,0x8F
    03EFB E016      LDI	R17,6
    03EFC 940E A90D CALL	_uart_Printf
    03EFE 9180 00C1 LDS	R24,0xC1
    03F00 6180      ORI	R24,0x10
    03F01 9380 00C1 STS	0xC1,R24
    03F03 E684      LDI	R24,0x64
    03F04 9380 160C STS	EvenPosChangeProcess+2,R24
    03F06 2422      CLR	R2
    03F07 9220 160D STS	EvenPosChangeProcess+3,R2
(1058) 			{
(1059) 				case 0:		// 取样针下降到混匀高度
(1060) 					_FluidMotRun(-1, 80);
    03F09 940E 38F8 CALL	_SetStateLedBusy
    03F0B 940C 4FC4 JMP	_SetReadTime0
    03F0D 9020 1559 LDS	R2,CardStoreTestFlag
(1061) 					_EffluentMotRun(8, 240);
    03F0F 2022      TST	R2
    03F10 F081      BEQ	0x3F21
    03F11 9020 1553 LDS	R2,LastCardGetState
(1062) 					_NeedleMotRunTo(_POS_MIX_NEEDLE, 180);
    03F13 2022      TST	R2
    03F14 F419      BNE	0x3F18
    03F15 2700      CLR	R16
    03F16 940C 4FC5 JMP	0x4FC5
(1063) 					waitMotSampNeedle = 1;
    03F18 9020 02E1 LDS	R2,preCardStoreNum
    03F1A 9030 1640 LDS	R3,_NewCardStoreNum
(1064) 					waitEffluent = 1;
    03F1C 1432      CP	R3,R2
(1065) 					waitMotDiluent = 1;
    03F1D F019      BEQ	0x3F21
    03F1E 2D02      MOV	R16,R2
(1066) 					if(NewTestInfo.sampDiluteMult == 9)		// 1:500
    03F1F 940E 525D CALL	_SetWorkStoreNum
    03F21 E485      LDI	R24,0x45
    03F22 E195      LDI	R25,0x15
(1067) 						workStep = 110;						// 需要打出多余的量
    03F23 91E0 1640 LDS	R30,_NewCardStoreNum
    03F25 27FF      CLR	R31
    03F26 0FE8      ADD	R30,R24
(1068) 					else
(1069) 						workStep = 1;						// 直接预混匀					
    03F27 1FF9      ADC	R31,R25
    03F28 8180      LD	R24,Z
    03F29 3184      CPI	R24,0x14
(1070) 					SetEValve(EV_ALL,EV_CLOSE);
    03F2A F4E9      BNE	0x3F48
    03F2B 9180 00C1 LDS	R24,0xC1
    03F2D 7E8F      ANDI	R24,0xEF
(1071) 					break;
    03F2E 9380 00C1 STS	0xC1,R24
(1072) 				case 110:		// 1:500模式下才有效
(1073) #ifdef Puncture					
(1074) 					if(WithoutPuncture == 0)			// 先排1000
(1075) 						_SampPumpMotRun(-1000, 180);	// 注入标本
(1076) 					else
(1077) 						_SampPumpMotRun(-200, 180);		// 先吐出来大概5uL
(1078) #else
(1079) 					_SampPumpMotRun(-200, 180);			// 先吐出来大概5uL
    03F30 9120 1640 LDS	R18,_NewCardStoreNum
    03F32 2733      CLR	R19
    03F33 E60D      LDI	R16,0x6D
    03F34 E016      LDI	R17,6
(1080) #endif
(1081) 					_FluidMotRun(6, 80);
    03F35 940E A90D CALL	_uart_Printf
    03F37 9180 00C1 LDS	R24,0xC1
    03F39 6180      ORI	R24,0x10
(1082) 					_DiluentMotRun(4, 140);	
    03F3A 9380 00C1 STS	0xC1,R24
    03F3C E081      LDI	R24,1
    03F3D 9380 1641 STS	_NewCardStoreNum+1,R24
(1083) 					_EffluentMotRun(18, 200);
    03F3F E02A      LDI	R18,0xA
    03F40 E030      LDI	R19,0
    03F41 E003      LDI	R16,3
    03F42 940E 97B7 CALL	_SetDelayTime
(1084) 					waitMotFluid = 1;
    03F44 940E 372D CALL	_SetBeepWarning
    03F46 940C 4FC4 JMP	_SetReadTime0
(1085) 					waitMotDiluent = 1;
    03F48 9020 06F6 LDS	R2,CardNoneUseful
(1086) 					waitMotSampPump = 1;
    03F4A 2022      TST	R2
(1087) 					waitEffluent = 1;
    03F4B F009      BEQ	0x3F4D
    03F4C C04E      RJMP	0x3F9B
(1088) 					workStep = 1;
    03F4D E48B      LDI	R24,0x4B
    03F4E E195      LDI	R25,0x15
(1089) 					break;
    03F4F 91E0 1640 LDS	R30,_NewCardStoreNum
(1090) 				case 1:		// 预混匀
(1091) 					_SampPumpMotRun(-63 - _SAMP_PUMP_INTERVAL, 120);	// 注入标本  3ul预混匀	 2017-05-22 80 -> 120
    03F51 27FF      CLR	R31
    03F52 0FE8      ADD	R30,R24
    03F53 1FF9      ADC	R31,R25
    03F54 8180      LD	R24,Z
    03F55 3188      CPI	R24,0x18
(1092) #if 	(DILUTE_TUBE == 14)
(1093) 					_DiluentMotRun(10, 200);
(1094) #elif	(DILUTE_TUBE == 16)
(1095) 					_DiluentMotRun(4, 200);		// 2017-05-22 140->200
    03F56 F4E9      BNE	0x3F74
    03F57 9180 00C1 LDS	R24,0xC1
    03F59 7E8F      ANDI	R24,0xEF
    03F5A 9380 00C1 STS	0xC1,R24
(1096) #endif
(1097) 					waitMotDiluent = 1;
    03F5C 9120 1640 LDS	R18,_NewCardStoreNum
(1098) 					waitMotSampPump = 1;
    03F5E 2733      CLR	R19
    03F5F E600      LDI	R16,0x60
(1099) 					workStep = 2;
    03F60 E016      LDI	R17,6
    03F61 940E A90D CALL	_uart_Printf
(1100) 					break;
    03F63 9180 00C1 LDS	R24,0xC1
(1101) 				case 2:		// 排空混匀池
(1102) 					SetEValve(EV_ALL, EV_CLOSE);
    03F65 6180      ORI	R24,0x10
    03F66 9380 00C1 STS	0xC1,R24
    03F68 E081      LDI	R24,1
(1103) 					_EffluentMotRun(10, 220);
    03F69 9380 1641 STS	_NewCardStoreNum+1,R24
    03F6B E02A      LDI	R18,0xA
    03F6C E030      LDI	R19,0
    03F6D E003      LDI	R16,3
(1104) 					SetMotRunPam(MOT_SAMP_TRUN,64,5,CURRENT_SAMP_TRUN);
    03F6E 940E 97B7 CALL	_SetDelayTime
    03F70 940E 372D CALL	_SetBeepWarning
    03F72 940C 4FC4 JMP	_SetReadTime0
    03F74 E48B      LDI	R24,0x4B
    03F75 E195      LDI	R25,0x15
(1105) 					MotRunTo(MOT_SAMP_TRUN, NeedleOnMixCenterPos);
    03F76 91E0 1640 LDS	R30,_NewCardStoreNum
    03F78 27FF      CLR	R31
    03F79 0FE8      ADD	R30,R24
    03F7A 1FF9      ADC	R31,R25
    03F7B 8180      LD	R24,Z
    03F7C 3189      CPI	R24,0x19
(1106) 					waitEffluent = 1;
    03F7D F4E9      BNE	0x3F9B
    03F7E 9180 00C1 LDS	R24,0xC1
(1107) 					waitMotSampTurn = 1;
    03F80 7E8F      ANDI	R24,0xEF
    03F81 9380 00C1 STS	0xC1,R24
(1108) 					workStep = 3;
    03F83 9120 1640 LDS	R18,_NewCardStoreNum
(1109) 					break;
    03F85 2733      CLR	R19
    03F86 E503      LDI	R16,0x53
(1110) 				case 3:		// 取样针运行到混匀池壁位置准备稀释
(1111) 					MotRunTo(MOT_SAMP_TRUN, NeedleOnMixSidePos);
    03F87 E016      LDI	R17,6
    03F88 940E A90D CALL	_uart_Printf
    03F8A 9180 00C1 LDS	R24,0xC1
    03F8C 6180      ORI	R24,0x10
    03F8D 9380 00C1 STS	0xC1,R24
(1112) 					waitMotSampTurn = 1;
    03F8F E081      LDI	R24,1
    03F90 9380 1641 STS	_NewCardStoreNum+1,R24
(1113) 					workStep = 4;
    03F92 E02A      LDI	R18,0xA
    03F93 E030      LDI	R19,0
(1114) 					break;
    03F94 E003      LDI	R16,3
    03F95 940E 97B7 CALL	_SetDelayTime
(1115) 				case 4:		// 开启样本柱塞泵和稀释液泵，开始混匀
(1116) 					siTmp = CalSampVolume(NewTestInfo.sampDiluteMult, 0);
    03F97 940E 372D CALL	_SetBeepWarning
    03F99 940C 4FC4 JMP	_SetReadTime0
    03F9B 940E 5462 CALL	__SetCurWorkParamter
(1117) 					ucTmp = CalSampSyringSpeed(NewTestInfo.sampDiluteMult, 0);
    03F9D 9100 1667 LDS	R16,i
    03F9F 940E 54CC CALL	__SetNewCardGet
    03FA1 940E 3739 CALL	_SetBeepAck
    03FA3 2722      CLR	R18
    03FA4 2700      CLR	R16
(1118) 					if(siTmp)
    03FA5 940E 6B81 CALL	_SetEValve
    03FA7 E022      LDI	R18,2
    03FA8 E030      LDI	R19,0
(1119) 					{
(1120) 						if(NewTestInfo.sampDiluteMult == 9)			// 1:500直接排指定量
    03FA9 E003      LDI	R16,3
    03FAA 940E 97B7 CALL	_SetDelayTime
    03FAC E082      LDI	R24,2
(1121) 							_SampPumpMotRun(-siTmp, ucTmp);
    03FAD 9380 160D STS	EvenPosChangeProcess+3,R24
    03FAF 940C 4FC4 JMP	_SetReadTime0
    03FB1 2722      CLR	R18
    03FB2 9100 1668 LDS	R16,j
    03FB4 940E 4FCA CALL	_CalSampVolume
(1122) 						else										// 非1:500需要
(1123) 							_SampPumpMotRun(-siTmp - 200, ucTmp);	// 多排200步空气
    03FB6 0158      MOVW	R10,R16
    03FB7 01C5      MOVW	R24,R10
    03FB8 968D      ADIW	R24,0x2D
    03FB9 015C      MOVW	R10,R24
    03FBA 9180 00C1 LDS	R24,0xC1
    03FBC 7E8F      ANDI	R24,0xEF
    03FBD 9380 00C1 STS	0xC1,R24
    03FBF 9020 1668 LDS	R2,j
(1124) 					}
(1125) 					siTmp1 = CalDiluteVolume(NewTestInfo.sampDiluteMult, 0);
    03FC1 2433      CLR	R3
    03FC2 823B      STD	Y+3,R3
    03FC3 822A      STD	Y+2,R2
    03FC4 82B9      STD	Y+1,R11
    03FC5 82A8      ST	Y,R10
    03FC6 E526      LDI	R18,0x56
(1126) 					ucTmp = CalDiluentInjectSpeed(NewTestInfo.sampDiluteMult, 0);
    03FC7 E03E      LDI	R19,0xE
    03FC8 E404      LDI	R16,0x44
    03FC9 E016      LDI	R17,6
    03FCA 940E A90D CALL	_uart_Printf
    03FCC 9180 00C1 LDS	R24,0xC1
    03FCE 6180      ORI	R24,0x10
(1127) 					if(siTmp1)
    03FCF 9380 00C1 STS	0xC1,R24
    03FD1 9180 1668 LDS	R24,j
(1128) 						_DiluentMotRun(siTmp1, ucTmp);		// 根据注液量来设置稀释液注入速度
    03FD3 3089      CPI	R24,0x9
    03FD4 F421      BNE	0x3FD9
    03FD5 01C5      MOVW	R24,R10
    03FD6 5780      SUBI	R24,0x70
(1129) #ifndef UartSendLong
(1130) 					Uart0ReUnable;
(1131) 					uart_Printf("%s $%8d\r\n",strM3107 ,NewTestInfo.testSerial);
(1132) 					Uart0ReEnable;
(1133) #else
(1134) 					Uart0ReUnable;
    03FD7 4F9E      SBCI	R25,0xFE
    03FD8 015C      MOVW	R10,R24
    03FD9 EB24      LDI	R18,0xB4
    03FDA 0185      MOVW	R16,R10
    03FDB 940E 631B CALL	__SampPumpMotRun
(1135) 					uart_Printf("%s $ ",strM3107);
    03FDD 9180 1668 LDS	R24,j
    03FDF 308D      CPI	R24,0xD
    03FE0 F029      BEQ	0x3FE6
    03FE1 E420      LDI	R18,0x40
(1136) 					uart0SendInt(NewTestInfo.testSerial);
    03FE2 E004      LDI	R16,4
    03FE3 E010      LDI	R17,0
    03FE4 940E 6264 CALL	__FluidMotRun
    03FE6 EC28      LDI	R18,0xC8
    03FE7 E006      LDI	R16,6
    03FE8 E010      LDI	R17,0
    03FE9 940E 62A2 CALL	__DiluentMotRun
    03FEB E081      LDI	R24,1
(1137) 					uart_Printf("\r\n");
    03FEC 9380 1659 STS	dustbinOldState+2,R24
    03FEE 9380 1656 STS	CardScanfSW,R24
(1138) 					Uart0ReEnable;
    03FF0 E083      LDI	R24,3
    03FF1 9380 160D STS	EvenPosChangeProcess+3,R24
    03FF3 940C 4FC4 JMP	_SetReadTime0
(1139) #endif
(1140) 					checkDiluent = 1;
    03FF5 E081      LDI	R24,1
    03FF6 9380 1658 STS	dustbinOldState+1,R24
(1141) 					waitMotDiluent = 1;
    03FF8 9380 1657 STS	dustbinOldState,R24
(1142) 					waitMotSampPump = 1;
    03FFA E084      LDI	R24,4
    03FFB 9380 160D STS	EvenPosChangeProcess+3,R24
(1143) 					workStep = 5;
    03FFD 940C 4FC4 JMP	_SetReadTime0
(1144) 					break;
    03FFF 940E 3745 CALL	_SetBeepPrompt
(1145) 				case 5:		// 根据混匀次数执行不同程序
(1146) 					MotRunTo(MOT_SAMP_TRUN, NeedleOnMixCenterPos);
    04001 940E 38F8 CALL	_SetStateLedBusy
    04003 2722      CLR	R18
    04004 2700      CLR	R16
    04005 940E 6B81 CALL	_SetEValve
    04007 EA20      LDI	R18,0xA0
(1147) 					waitMotSampTurn = 1;
    04008 E104      LDI	R16,0x14
    04009 E010      LDI	R17,0
    0400A 940E 6289 CALL	__EffluentMotRun
(1148) 					//2016-05-24 添加 > 11,稀释比列1:3,1:4,...,1:40不需要进行2次稀释
(1149) 					if(NewTestInfo.sampDiluteMult < 9 || NewTestInfo.sampDiluteMult > 11) 
    0400C E081      LDI	R24,1
    0400D 9380 1656 STS	CardScanfSW,R24
    0400F E685      LDI	R24,0x65
    04010 9380 160D STS	EvenPosChangeProcess+3,R24
    04012 940C 4FC4 JMP	_SetReadTime0
(1150) 						workStep = 7;
    04014 EA20      LDI	R18,0xA0
    04015 E109      LDI	R16,0x19
    04016 E010      LDI	R17,0
    04017 940E 62A2 CALL	__DiluentMotRun
(1151) 					else
(1152) 						workStep = 6;
    04019 EC28      LDI	R18,0xC8
    0401A E10E      LDI	R16,0x1E
    0401B E010      LDI	R17,0
(1153) 					break;
    0401C 940E 6289 CALL	__EffluentMotRun
(1154) 				case 6:		// 跳往二次稀释
(1155) 					MotRunTo(MOT_SAMP_NEEDLE, _POS_MIX_TOP);
    0401E E081      LDI	R24,1
    0401F 9380 1656 STS	CardScanfSW,R24
    04021 9380 1657 STS	dustbinOldState,R24
(1156) 					waitMotSampNeedle = 1;
    04023 E686      LDI	R24,0x66
    04024 9380 160D STS	EvenPosChangeProcess+3,R24
(1157) 					workStep = 0;
    04026 940C 4FC4 JMP	_SetReadTime0
    04028 E021      LDI	R18,1
(1158) 					mainStep = 5;
    04029 E003      LDI	R16,3
    0402A 940E 6B81 CALL	_SetEValve
(1159) 					break;
    0402C E021      LDI	R18,1
    0402D E001      LDI	R16,1
(1160) 				case 7:
(1161) 					MotRunTo(MOT_SAMP_NEEDLE, _POS_MIX_NEEDLE + 30);	// 多下降
    0402E 940E 6B81 CALL	_SetEValve
    04030 EF20      LDI	R18,0xF0
    04031 E308      LDI	R16,0x38
    04032 E010      LDI	R17,0
(1162) 					waitMotSampNeedle = 1;
    04033 940E 6289 CALL	__EffluentMotRun
    04035 E022      LDI	R18,2
(1163) 					switch(NewTestInfo.sampDiluteMult)
    04036 E030      LDI	R19,0
    04037 E00B      LDI	R16,0xB
    04038 940E 97B7 CALL	_SetDelayTime
    0403A E085      LDI	R24,5
    0403B 9380 160D STS	EvenPosChangeProcess+3,R24
    0403D 940C 4FC4 JMP	_SetReadTime0
    0403F E228      LDI	R18,0x28
    04040 E104      LDI	R16,0x14
    04041 E010      LDI	R17,0
    04042 940E 6264 CALL	__FluidMotRun
    04044 E081      LDI	R24,1
    04045 9380 165A STS	dustbinOldState+3,R24
    04047 EC28      LDI	R18,0xC8
    04048 2700      CLR	R16
    04049 2711      CLR	R17
    0404A 940E 62FB CALL	__NeedleMotRunTo
    0404C E087      LDI	R24,7
    0404D 9380 160D STS	EvenPosChangeProcess+3,R24
    0404F 940C 4FC4 JMP	_SetReadTime0
(1164) 					{
(1165) 						case 2:		workStep = 10;break;		// 1:2
    04051 9180 00C1 LDS	R24,0xC1
    04053 7E8F      ANDI	R24,0xEF
    04054 9380 00C1 STS	0xC1,R24
(1166) 						case 12:	workStep = 14;break;		// 1:3
    04056 E126      LDI	R18,0x16
    04057 E03D      LDI	R19,0xD
    04058 E30E      LDI	R16,0x3E
    04059 E016      LDI	R17,6
(1167) 						case 13:	workStep = 14;break;		// 1:4
    0405A 940E A90D CALL	_uart_Printf
    0405C 9120 1664 LDS	R18,LiquidPhoNum
    0405E 9130 1665 LDS	R19,timeOut
(1168) 						case 14:	workStep = 18;break;		// 1:40
    04060 9100 1662 LDS	R16,NewTestInfo|liqDetBaseAdc+1
    04062 9110 1663 LDS	R17,CardStorePhoNum
(1169) 						default:	workStep = 18;break;
    04064 940E A940 CALL	_uart0SendInt
    04066 E30B      LDI	R16,0x3B
(1170) 							
(1171) 					}
(1172) 					break;
    04067 E016      LDI	R17,6
    04068 940E A90D CALL	_uart_Printf
(1173) 				case 10:		// 2016-10-31 增加吸样针抽打混匀
(1174) 					MotRunTo(MOT_SAMP_NEEDLE, _POS_MIX_BUTTOM + 25);
    0406A 9180 00C1 LDS	R24,0xC1
    0406C 6180      ORI	R24,0x10
    0406D 9380 00C1 STS	0xC1,R24
(1175) 					waitMotSampNeedle = 1;
    0406F E00A      LDI	R16,0xA
    04070 940E 6A13 CALL	_MotStop
(1176) 					workStep = 11;
    04072 E084      LDI	R24,4
    04073 838A      STD	Y+2,R24
(1177) 					break;
    04074 E08A      LDI	R24,0xA
    04075 8388      ST	Y,R24
(1178) 				case 11:
(1179) 					workStep = 16;
    04076 EF2F      LDI	R18,0xFF
    04077 E002      LDI	R16,2
    04078 940E 6A9F CALL	_SetMotRunPam
(1180) 					SetDelayTime(MOT_SAMP_NEEDLE, 2);	// 延迟一段时间
    0407A 2722      CLR	R18
    0407B 2733      CLR	R19
    0407C E002      LDI	R16,2
    0407D 940E 6A5B CALL	_MotRunTo
(1181) 					break;
    0407F 2422      CLR	R2
(1182) 				case 14:
(1183) 					_SampPumpMotRun(4244, 220);   // 100 / 0.023563 = 4244
    04080 9220 1610 STS	EvenPosChangeProcess+6,R2
    04082 E025      LDI	R18,5
    04083 E030      LDI	R19,0
    04084 E002      LDI	R16,2
(1184) 					waitMotSampPump = 1;
    04085 940E 97B7 CALL	_SetDelayTime
    04087 E088      LDI	R24,0x8
(1185) 					workStep = 15;
    04088 9380 160D STS	EvenPosChangeProcess+3,R24
    0408A 940C 4FC4 JMP	_SetReadTime0
(1186) 					Num++;
    0408C 2722      CLR	R18
    0408D 2700      CLR	R16
    0408E 940E 6B81 CALL	_SetEValve
(1187) 					break;
    04090 E081      LDI	R24,1
    04091 9380 165B STS	dustbinOldState+4,R24
(1188) 				case 15:
(1189) 					_SampPumpMotRun(-4032, 240); // 95 / 0.023563 = 4032
    04093 E089      LDI	R24,0x9
    04094 9380 160D STS	EvenPosChangeProcess+3,R24
    04096 940C 4FC4 JMP	_SetReadTime0
(1190) 					waitMotSampPump = 1;
    04098 9180 1668 LDS	R24,j
(1191) 					workStep = 16;
    0409A 3081      CPI	R24,1
    0409B F089      BEQ	0x40AD
    0409C 9120 1648 LDS	R18,_NewCardStoreNum+8
(1192) 					break;
    0409E 9130 1649 LDS	R19,_NewCardStoreNum+9
(1193) 				case 16:
(1194) 					Num++;
    040A0 E002      LDI	R16,2
    040A1 940E 6A5B CALL	_MotRunTo
    040A3 E081      LDI	R24,1
(1195) 					if(Num > 5)
    040A4 9380 165B STS	dustbinOldState+4,R24
    040A6 E084      LDI	R24,4
    040A7 9380 160C STS	EvenPosChangeProcess+2,R24
(1196) 					{
(1197) 						Num = 0;
    040A9 2422      CLR	R2
    040AA 9220 160D STS	EvenPosChangeProcess+3,R2
(1198) 					//	_SampPumpMotRun(3395, 240); // 80 / 0.02353 = 3395
(1199) 						workStep = 18;
    040AC C020      RJMP	0x40CD
    040AD 9020 164E LDS	R2,_DropMode
(1200) 					}
    040AF 9030 164F LDS	R3,_DropMode+1
(1201) 					else
(1202) 					{
(1203) 						_SampPumpMotRun(3820, 240); // 90 / 0.02353 = 3820
    040B1 2022      TST	R2
    040B2 F449      BNE	0x40BC
    040B3 2033      TST	R3
    040B4 F439      BNE	0x40BC
(1204) 						workStep = 17;
    040B5 E089      LDI	R24,0x9
    040B6 9380 160C STS	EvenPosChangeProcess+2,R24
(1205) 					}
(1206) 					waitMotSampPump = 1;
    040B8 2422      CLR	R2
    040B9 9220 160D STS	EvenPosChangeProcess+3,R2
(1207) 					break;
    040BB C011      RJMP	0x40CD
    040BC 9020 164D LDS	R2,_MixtureMode
(1208) 				case 17:
(1209) 					_SampPumpMotRun(-3820, 240);	// 90 / 0.02353 = 3820
    040BE 2022      TST	R2
    040BF F439      BNE	0x40C7
    040C0 E088      LDI	R24,0x8
    040C1 9380 160C STS	EvenPosChangeProcess+2,R24
(1210) 					waitMotSampPump = 1;
    040C3 E08B      LDI	R24,0xB
    040C4 9380 160D STS	EvenPosChangeProcess+3,R24
(1211) 					workStep = 16;
    040C6 C006      RJMP	0x40CD
    040C7 E088      LDI	R24,0x8
(1212) 					break;
    040C8 9380 160C STS	EvenPosChangeProcess+2,R24
(1213) 				case 18:
(1214) 					MotRunTo(MOT_SAMP_NEEDLE, 0);
    040CA E182      LDI	R24,0x12
    040CB 9380 160D STS	EvenPosChangeProcess+3,R24
    040CD E081      LDI	R24,1
    040CE 9380 1656 STS	CardScanfSW,R24
(1215) 					waitMotSampNeedle = 1;
    040D0 940C 4FC4 JMP	_SetReadTime0
(1216) 					if(TestDebugMode == 1)
    040D2 90C0 160D LDS	R12,EvenPosChangeProcess+3
    040D4 24DD      CLR	R13
    040D5 01C6      MOVW	R24,R12
(1217) 					{
(1218) 						workStep = 19;
    040D6 3080      CPI	R24,0
    040D7 E0E0      LDI	R30,0
    040D8 079E      CPC	R25,R30
(1219) 						break;
    040D9 F414      BGE	0x40DC
    040DA 940C 4FC4 JMP	_SetReadTime0
(1220) 					}
(1221) 					  workStep = 9;  //changed by pan 20161110	吸取一段空气柱		
    040DC E185      LDI	R24,0x15
    040DD 158C      CP	R24,R12
(1222) 					  break;
    040DE 059D      CPC	R25,R13
    040DF F05C      BLT	0x40EB
(1223) 				case 19:
(1224) 					MotRunTo(MOT_SAMP_TRUN, 0);
    040E0 E28E      LDI	R24,0x2E
    040E1 E092      LDI	R25,2
    040E2 01F6      MOVW	R30,R12
    040E3 0FEE      LSL	R30
    040E4 1FFF      ROL	R31
(1225) 					waitMotSampTurn = 1;
    040E5 0FE8      ADD	R30,R24
    040E6 1FF9      ADC	R31,R25
    040E7 9027      ELPM	R2,Z+
(1226) 					workStep = 20;
    040E8 9036      ELPM	R3,Z
    040E9 01F1      MOVW	R30,R2
    040EA 9409      IJMP
(1227) 					_WaitStartKey = 1;
    040EB 01C6      MOVW	R24,R12
    040EC 368E      CPI	R24,0x6E
    040ED E0E0      LDI	R30,0
(1228) 					break;
    040EE 079E      CPC	R25,R30
    040EF F149      BEQ	0x4119
(1229) 				case 20:
(1230) 					MotRunTo(MOT_SAMP_TRUN, NeedleOnMixCenterPos);
    040F0 940C 4FC4 JMP	_SetReadTime0
    040F2 E520      LDI	R18,0x50
    040F3 EF0F      LDI	R16,0xFF
    040F4 EF1F      LDI	R17,0xFF
    040F5 940E 6264 CALL	__FluidMotRun
(1231) 					waitMotSampTurn = 1;
    040F7 EF20      LDI	R18,0xF0
    040F8 E008      LDI	R16,0x8
    040F9 E010      LDI	R17,0
(1232) 					workStep = 21;
    040FA 940E 6289 CALL	__EffluentMotRun
    040FC EB24      LDI	R18,0xB4
(1233) 					break;		
    040FD E700      LDI	R16,0x70
    040FE E013      LDI	R17,3
(1234) 				case 21:
(1235) 					SetEValve(EV3, EV_CLOSE);
    040FF 940E 62FB CALL	__NeedleMotRunTo
    04101 E081      LDI	R24,1
    04102 9380 165A STS	dustbinOldState+3,R24
(1236) 					MotRun(MOT_SAMP_PUMP, 82);		// 吸入空气段
    04104 9380 1656 STS	CardScanfSW,R24
    04106 9380 1657 STS	dustbinOldState,R24
(1237) 					waitMotSampPump = 1;
    04108 9180 1668 LDS	R24,j
    0410A 3089      CPI	R24,0x9
(1238) 					workStep = 0;
    0410B F421      BNE	0x4110
    0410C E68E      LDI	R24,0x6E
    0410D 9380 160D STS	EvenPosChangeProcess+3,R24
(1239) 					mainStep = 8;
    0410F C003      RJMP	0x4113
    04110 E081      LDI	R24,1
(1240) 					break;			
    04111 9380 160D STS	EvenPosChangeProcess+3,R24
(1241) 				case 8:		// 在清洗头中清洗取样针内壁
(1242) 					_EffluentMotRun(10, 180);
    04113 2722      CLR	R18
    04114 2700      CLR	R16
    04115 940E 6B81 CALL	_SetEValve
    04117 940C 4FC4 JMP	_SetReadTime0
(1243) 					_FluidMotRun(2, 32);		// 清洗针内壁
    04119 EB24      LDI	R18,0xB4
    0411A E308      LDI	R16,0x38
    0411B EF1F      LDI	R17,0xFF
    0411C 940E 631B CALL	__SampPumpMotRun
(1244) 					waitMotFluid = 1;
    0411E E520      LDI	R18,0x50
    0411F E006      LDI	R16,6
(1245) 					waitEffluent = 1;
    04120 E010      LDI	R17,0
    04121 940E 6264 CALL	__FluidMotRun
(1246) 					workStep = 9;
    04123 E82C      LDI	R18,0x8C
    04124 E004      LDI	R16,4
(1247) 					break;				
    04125 E010      LDI	R17,0
    04126 940E 62A2 CALL	__DiluentMotRun
(1248) 				case 9:		// 样针吸取一段隔离空气
(1249) 					SetEValve(EV_ALL,EV_CLOSE);
    04128 EF20      LDI	R18,0xF0
    04129 E102      LDI	R16,0x12
    0412A E010      LDI	R17,0
(1250) 					MotRun(MOT_SAMP_PUMP, _SAMP_PUMP_AIR_ISOLATE);
    0412B 940E 6289 CALL	__EffluentMotRun
    0412D E081      LDI	R24,1
    0412E 9380 1658 STS	dustbinOldState+1,R24
(1251) 					waitMotSampPump = 1;
    04130 9380 1657 STS	dustbinOldState,R24
    04132 9380 1659 STS	dustbinOldState+2,R24
(1252) 					workStep = 0;
    04134 9380 1656 STS	CardScanfSW,R24
(1253) 					mainStep = 8;
    04136 9380 160D STS	EvenPosChangeProcess+3,R24
    04138 940C 4FC4 JMP	_SetReadTime0
(1254) 					break;
(1255) 				}
(1256) 			break;
    0413A E728      LDI	R18,0x78
(1257) 		case 5:				// 二次混匀
(1258) 			switch(workStep){
    0413B E805      LDI	R16,0x85
    0413C EF1F      LDI	R17,0xFF
    0413D 940E 631B CALL	__SampPumpMotRun
    0413F EC28      LDI	R18,0xC8
    04140 E004      LDI	R16,4
    04141 E010      LDI	R17,0
    04142 940E 62A2 CALL	__DiluentMotRun
    04144 E081      LDI	R24,1
    04145 9380 1657 STS	dustbinOldState,R24
    04147 9380 1659 STS	dustbinOldState+2,R24
    04149 E082      LDI	R24,2
    0414A 9380 160D STS	EvenPosChangeProcess+3,R24
    0414C 940C 4FC4 JMP	_SetReadTime0
    0414E 2722      CLR	R18
    0414F 2700      CLR	R16
    04150 940E 6B81 CALL	_SetEValve
    04152 ED2C      LDI	R18,0xDC
    04153 E00A      LDI	R16,0xA
    04154 E010      LDI	R17,0
    04155 940E 6289 CALL	__EffluentMotRun
    04157 E084      LDI	R24,4
    04158 838A      STD	Y+2,R24
    04159 E085      LDI	R24,5
    0415A 8388      ST	Y,R24
    0415B E420      LDI	R18,0x40
    0415C E002      LDI	R16,2
    0415D 940E 6A9F CALL	_SetMotRunPam
    0415F 9120 1646 LDS	R18,_NewCardStoreNum+6
    04161 9130 1647 LDS	R19,_NewCardStoreNum+7
    04163 E002      LDI	R16,2
    04164 940E 6A5B CALL	_MotRunTo
    04166 E081      LDI	R24,1
    04167 9380 1656 STS	CardScanfSW,R24
    04169 9380 165B STS	dustbinOldState+4,R24
    0416B E083      LDI	R24,3
    0416C 9380 160D STS	EvenPosChangeProcess+3,R24
    0416E 940C 4FC4 JMP	_SetReadTime0
    04170 9120 1648 LDS	R18,_NewCardStoreNum+8
    04172 9130 1649 LDS	R19,_NewCardStoreNum+9
    04174 E002      LDI	R16,2
    04175 940E 6A5B CALL	_MotRunTo
    04177 E081      LDI	R24,1
    04178 9380 165B STS	dustbinOldState+4,R24
    0417A E084      LDI	R24,4
    0417B 9380 160D STS	EvenPosChangeProcess+3,R24
    0417D 940C 4FC4 JMP	_SetReadTime0
    0417F 2722      CLR	R18
    04180 9100 1668 LDS	R16,j
    04182 940E 4FCA CALL	_CalSampVolume
    04184 0168      MOVW	R12,R16
    04185 0156      MOVW	R10,R12
    04186 2722      CLR	R18
    04187 9100 1668 LDS	R16,j
    04189 940E 51E9 CALL	_CalSampSyringSpeed
    0418B 2EC0      MOV	R12,R16
    0418C 92C0 1612 STS	EvenPosChangeProcess+8,R12
    0418E 20AA      TST	R10
    0418F F411      BNE	0x4192
    04190 20BB      TST	R11
    04191 F0C1      BEQ	0x41AA
    04192 9180 1668 LDS	R24,j
    04194 3089      CPI	R24,0x9
    04195 F449      BNE	0x419F
    04196 2D2C      MOV	R18,R12
    04197 0185      MOVW	R16,R10
    04198 9500      COM	R16
(1259) 				case 0:
(1260) 					SetDelayTime(MOT_SAMP_NEEDLE,5);	// 2017-05-22  20->5
    04199 9510      COM	R17
    0419A 5F0F      SUBI	R16,0xFF
    0419B 4F1F      SBCI	R17,0xFF
    0419C 940E 631B CALL	__SampPumpMotRun
(1261) 					workStep = 200;
    0419E C00B      RJMP	0x41AA
    0419F 9120 1612 LDS	R18,EvenPosChangeProcess+8
(1262) 					break;
    041A1 0185      MOVW	R16,R10
    041A2 9500      COM	R16
(1263) 				case 200:// 由稀释液泵吸取二次混匀原液
(1264) 					siTmp = CalDilute2Volume(NewTestInfo.sampDiluteMult, 0);
    041A3 9510      COM	R17
    041A4 5F0F      SUBI	R16,0xFF
    041A5 4F1F      SBCI	R17,0xFF
    041A6 5C08      SUBI	R16,0xC8
    041A7 4010      SBCI	R17,0
    041A8 940E 631B CALL	__SampPumpMotRun
(1265) 					siTmp = siTmp + 3;				
    041AA 2722      CLR	R18
    041AB 9100 1668 LDS	R16,j
(1266) #if 	(DILUTE_TUBE == 14)
(1267) 					_DiluentMotRun(-siTmp, 160);
(1268) #elif	 (DILUTE_TUBE == 16)
(1269) 					_DiluentMotRun(-siTmp, 200);			// 2017-05-22 120->200
    041AD 940E 5137 CALL	_CalDiluteVolume
    041AF 0168      MOVW	R12,R16
    041B0 2722      CLR	R18
    041B1 9100 1668 LDS	R16,j
    041B3 940E 5224 CALL	_CalDiluentInjectSpeed
(1270) #endif
(1271) 					waitMotDiluent = 1;
    041B5 2EE0      MOV	R14,R16
    041B6 92E0 1612 STS	EvenPosChangeProcess+8,R14
(1272) 					workStep = 1;
    041B8 20CC      TST	R12
    041B9 F411      BNE	0x41BC
(1273) 					break;
    041BA 20DD      TST	R13
    041BB F021      BEQ	0x41C0
(1274) 				case 1:
(1275) 				  _EffluentMotRun(15, 240);					// 2017-05-22 200->240
    041BC 2D2E      MOV	R18,R14
    041BD 0186      MOVW	R16,R12
    041BE 940E 62A2 CALL	__DiluentMotRun
    041C0 9180 00C1 LDS	R24,0xC1
(1276) #ifndef Puncture
(1277) 					MotRunTo(MOT_SAMP_NEEDLE, _POS_MIX_TOP + 200);
    041C2 7E8F      ANDI	R24,0xEF
    041C3 9380 00C1 STS	0xC1,R24
    041C5 E42B      LDI	R18,0x4B
(1278) #else
(1279) 					MotRunTo(MOT_SAMP_NEEDLE, _POS_MIX_TOP + 400);
(1280) #endif
(1281) 					waitEffluent = 1;
    041C6 E03D      LDI	R19,0xD
    041C7 E30E      LDI	R16,0x3E
    041C8 E016      LDI	R17,6
(1282) 					waitMotSampNeedle = 1;
    041C9 940E A90D CALL	_uart_Printf
(1283) 					SetEValve(EV2, EV_CLOSE);	// 取样针通道关闭
    041CB 9120 1664 LDS	R18,LiquidPhoNum
    041CD 9130 1665 LDS	R19,timeOut
(1284) 					SetEValve(EV1, EV_OPEN);	// 开启清洗头洗液供应
    041CF 9100 1662 LDS	R16,NewTestInfo|liqDetBaseAdc+1
    041D1 9110 1663 LDS	R17,CardStorePhoNum
(1285) 					workStep = 2;
    041D3 940E A940 CALL	_uart0SendInt
    041D5 E30B      LDI	R16,0x3B
(1286) 					break;
    041D6 E016      LDI	R17,6
    041D7 940E A90D CALL	_uart_Printf
(1287) 				case 2:	// 清洗取样针外臂，即时排液
(1288) 					_FluidMotRun(8, 80);		// 开启清洗液洗混匀池,注入1.0mL清洗液(12, 180) //180
    041D9 9180 00C1 LDS	R24,0xC1
    041DB 6180      ORI	R24,0x10
    041DC 9380 00C1 STS	0xC1,R24
(1289) 					_EffluentMotRun(10, 100);	
    041DE E081      LDI	R24,1
    041DF 9380 160F STS	EvenPosChangeProcess+5,R24
    041E1 9380 1657 STS	dustbinOldState,R24
(1290) 					waitMotFluid = 1;
    041E3 9380 1659 STS	dustbinOldState+2,R24
(1291) 					waitEffluent = 1;
    041E5 E085      LDI	R24,5
    041E6 9380 160D STS	EvenPosChangeProcess+3,R24
(1292) 					workStep = 3;
    041E8 940C 4FC4 JMP	_SetReadTime0
(1293) 					break;
    041EA 9120 1646 LDS	R18,_NewCardStoreNum+6
(1294) 				case 3:
(1295) 					SetEValve(EV2, EV_OPEN);	// 开启取样针洗液供应
    041EC 9130 1647 LDS	R19,_NewCardStoreNum+7
    041EE E002      LDI	R16,2
    041EF 940E 6A5B CALL	_MotRunTo
(1296) 					workStep = 4;
    041F1 E081      LDI	R24,1
    041F2 9380 165B STS	dustbinOldState+4,R24
(1297) 					ucTmp = 0;
    041F4 9180 1668 LDS	R24,j
(1298) 					break;
    041F6 3089      CPI	R24,0x9
    041F7 F028      BCS	0x41FD
(1299) 				case 4:		// 清洗取样针内壁，即时排空
(1300) #ifndef Puncture
(1301) 					_FluidMotRun(16, 80);		// 清洗针内壁(12, 80)
    041F8 E08B      LDI	R24,0xB
    041F9 9020 1668 LDS	R2,j
    041FB 1582      CP	R24,R2
    041FC F428      BCC	0x4202
(1302) #else
(1303) 					_FluidMotRun(16, 40);		// 清洗针内壁(12, 40)
(1304) #endif
(1305) 					_EffluentMotRun(20, 100);	
    041FD E087      LDI	R24,7
    041FE 9380 160D STS	EvenPosChangeProcess+3,R24
    04200 940C 4FC4 JMP	_SetReadTime0
(1306) 					waitMotFluid = 1;
    04202 E086      LDI	R24,6
    04203 9380 160D STS	EvenPosChangeProcess+3,R24
(1307) 					waitEffluent = 1;
    04205 940C 4FC4 JMP	_SetReadTime0
(1308) 					ucTmp ++;
    04207 E628      LDI	R18,0x68
    04208 E031      LDI	R19,1
    04209 E003      LDI	R16,3
    0420A 940E 6A5B CALL	_MotRunTo
(1309) 					if(ucTmp < 2)		// 设置清洗次数 2016-08-22 再增加一次
    0420C E081      LDI	R24,1
    0420D 9380 165A STS	dustbinOldState+3,R24
(1310) 						workStep = 4;
    0420F 2422      CLR	R2
    04210 9220 160D STS	EvenPosChangeProcess+3,R2
    04212 E085      LDI	R24,5
(1311) 					else
(1312) 						workStep = 5;
    04213 9380 160C STS	EvenPosChangeProcess+2,R24
    04215 940C 4FC4 JMP	_SetReadTime0
(1313) 					break;
    04217 E82E      LDI	R18,0x8E
(1314) 				case 5:		// 清洗取样针外壁
(1315) 					SetEValve(EV2, EV_CLOSE);	// 取样针通道关闭
    04218 E033      LDI	R19,3
    04219 E003      LDI	R16,3
    0421A 940E 6A5B CALL	_MotRunTo
(1316) 					SetEValve(EV1, EV_OPEN);	// 开启清洗头洗液供应
    0421C E081      LDI	R24,1
    0421D 9380 165A STS	dustbinOldState+3,R24
    0421F 90C0 1668 LDS	R12,j
(1317) 					_FluidMotRun(8, 80);		// _FluidMotRun(12, 180);		// 开启清洗液洗混匀池,注入1.0mL清洗液(12, 180)//(12,120)
    04221 24DD      CLR	R13
    04222 01C6      MOVW	R24,R12
    04223 3082      CPI	R24,2
    04224 E0E0      LDI	R30,0
(1318) 					waitMotFluid = 1;
    04225 079E      CPC	R25,R30
    04226 F091      BEQ	0x4239
    04227 3082      CPI	R24,2
(1319) 					waitEffluent = 1;
    04228 E0E0      LDI	R30,0
    04229 079E      CPC	R25,R30
(1320) 					SetEValve(EV3, EV_OPEN);	// 清洗头排液打开
    0422A F114      BLT	0x424D
    0422B 01C6      MOVW	R24,R12
    0422C 308C      CPI	R24,0xC
    0422D E0E0      LDI	R30,0
(1321) 					workStep = 6;
    0422E 079E      CPC	R25,R30
    0422F F071      BEQ	0x423E
    04230 308D      CPI	R24,0xD
(1322) 					break;
    04231 E0E0      LDI	R30,0
    04232 079E      CPC	R25,R30
(1323) 				case 6:		// 抽干清洗头
(1324) 					_FluidMotRun(-1, 160);
    04233 F079      BEQ	0x4243
    04234 308E      CPI	R24,0xE
    04235 E0E0      LDI	R30,0
    04236 079E      CPC	R25,R30
    04237 F081      BEQ	0x4248
(1325) 					_EffluentMotRun(24, 240);
    04238 C014      RJMP	0x424D
    04239 E08A      LDI	R24,0xA
    0423A 9380 160D STS	EvenPosChangeProcess+3,R24
    0423C 940C 4FC4 JMP	_SetReadTime0
(1326) 					SetDelayTime(MOT_SAMP_NEEDLE, 5);
    0423E E08E      LDI	R24,0xE
    0423F 9380 160D STS	EvenPosChangeProcess+3,R24
    04241 940C 4FC4 JMP	_SetReadTime0
(1327) 					workStep = 7;
    04243 E08E      LDI	R24,0xE
    04244 9380 160D STS	EvenPosChangeProcess+3,R24
(1328) 					break;
    04246 940C 4FC4 JMP	_SetReadTime0
(1329) 				case 7:		// 排空混匀池
(1330) 					SetEValve(EV_ALL,EV_CLOSE);
    04248 E182      LDI	R24,0x12
    04249 9380 160D STS	EvenPosChangeProcess+3,R24
(1331) 					waitEffluent = 1;
    0424B 940C 4FC4 JMP	_SetReadTime0
    0424D E182      LDI	R24,0x12
(1332) 					waitMotFluid = 1;
    0424E 9380 160D STS	EvenPosChangeProcess+3,R24
(1333) 					workStep = 80;
    04250 940C 4FC4 JMP	_SetReadTime0
    04252 E92D      LDI	R18,0x9D
(1334) 					break;
    04253 E033      LDI	R19,3
    04254 E003      LDI	R16,3
(1335) 				case 80:
(1336) 					_DiluentMotRun(3, 120); 	
    04255 940E 6A5B CALL	_MotRunTo
    04257 E081      LDI	R24,1
    04258 9380 165A STS	dustbinOldState+3,R24
(1337) 					waitMotDiluent = 1;
    0425A E08B      LDI	R24,0xB
    0425B 9380 160D STS	EvenPosChangeProcess+3,R24
(1338) 					workStep = 81;
    0425D 940C 4FC4 JMP	_SetReadTime0
    0425F E180      LDI	R24,0x10
(1339) 					break;
    04260 9380 160D STS	EvenPosChangeProcess+3,R24
(1340) 				case 81:
(1341) 					SetDelayTime(MOT_SAMP_NEEDLE, 2);	// 2017-05-22 10->2
    04262 E022      LDI	R18,2
    04263 E030      LDI	R19,0
    04264 E003      LDI	R16,3
    04265 940E 97B7 CALL	_SetDelayTime
(1342) 					workStep = 82;
    04267 940C 4FC4 JMP	_SetReadTime0
    04269 ED2C      LDI	R18,0xDC
(1343) 					break;
    0426A E904      LDI	R16,0x94
    0426B E110      LDI	R17,0x10
(1344) 				case 82:
(1345) 					_EffluentMotRun(10, 180);	// 2017-05-22 100->180
    0426C 940E 631B CALL	__SampPumpMotRun
    0426E E081      LDI	R24,1
    0426F 9380 1659 STS	dustbinOldState+2,R24
(1346) 					waitEffluent = 1;
    04271 E08F      LDI	R24,0xF
    04272 9380 160D STS	EvenPosChangeProcess+3,R24
(1347) 					workStep = 83;
    04274 9180 1613 LDS	R24,EvenPosChangeProcess+9
    04276 5F8F      SUBI	R24,0xFF
(1348) 					break;
    04277 9380 1613 STS	EvenPosChangeProcess+9,R24
(1349) 				case 83:
(1350) 					SetEValve(EV3, EV_OPEN);	// 清洗头排液打开
    04279 940C 4FC4 JMP	_SetReadTime0
    0427B EF20      LDI	R18,0xF0
    0427C E400      LDI	R16,0x40
(1351) 					_EffluentMotRun(15, 240);	// 抽干清洗头
    0427D EF10      LDI	R17,0xF0
    0427E 940E 631B CALL	__SampPumpMotRun
    04280 E081      LDI	R24,1
    04281 9380 1659 STS	dustbinOldState+2,R24
(1352) 					MotRunTo(MOT_SAMP_NEEDLE, 0);
    04283 E180      LDI	R24,0x10
    04284 9380 160D STS	EvenPosChangeProcess+3,R24
    04286 940C 4FC4 JMP	_SetReadTime0
(1353) 					waitMotSampNeedle = 1;
    04288 9180 1613 LDS	R24,EvenPosChangeProcess+9
(1354) 					workStep = 8;
    0428A 5F8F      SUBI	R24,0xFF
    0428B 9380 1613 STS	EvenPosChangeProcess+9,R24
(1355) 					break;
    0428D E085      LDI	R24,5
    0428E 9020 1613 LDS	R2,EvenPosChangeProcess+9
(1356) 				case 8:		//  开始二次混匀
(1357) 					siTmp = CalDilute2Volume(NewTestInfo.sampDiluteMult, 1);
    04290 1582      CP	R24,R2
    04291 F438      BCC	0x4299
    04292 2422      CLR	R2
    04293 9220 1613 STS	EvenPosChangeProcess+9,R2
    04295 E182      LDI	R24,0x12
(1358) #if 	(DILUTE_TUBE == 14)
(1359) 					_DiluentMotRun(siTmp, 160);	// 将稀释管道里的混匀液和稀释液注入混匀池中混匀
(1360) #elif 	(DILUTE_TUBE == 16)
(1361) 					_DiluentMotRun(siTmp, 240); // 2017-05-22 200->240
    04296 9380 160D STS	EvenPosChangeProcess+3,R24
    04298 C008      RJMP	0x42A1
(1362) #endif
(1363) 					waitMotDiluent = 1;
    04299 EF20      LDI	R18,0xF0
    0429A EE0C      LDI	R16,0xEC
    0429B E01E      LDI	R17,0xE
(1364) 					waitEffluent = 1;
    0429C 940E 631B CALL	__SampPumpMotRun
(1365) 					workStep = 9;
    0429E E181      LDI	R24,0x11
    0429F 9380 160D STS	EvenPosChangeProcess+3,R24
(1366) 					break;
    042A1 E081      LDI	R24,1
    042A2 9380 1659 STS	dustbinOldState+2,R24
(1367) 				case 9:
(1368) 					if(TestDebugMode == 1)
    042A4 940C 4FC4 JMP	_SetReadTime0
    042A6 EF20      LDI	R18,0xF0
(1369) 					{
(1370) 						MotRunTo(MOT_SAMP_NEEDLE, 0);
    042A7 E104      LDI	R16,0x14
    042A8 EF11      LDI	R17,0xF1
    042A9 940E 631B CALL	__SampPumpMotRun
    042AB E081      LDI	R24,1
(1371) 						waitMotSampNeedle = 1;
    042AC 9380 1659 STS	dustbinOldState+2,R24
    042AE E180      LDI	R24,0x10
(1372) 						workStep = 19;
    042AF 9380 160D STS	EvenPosChangeProcess+3,R24
    042B1 940C 4FC4 JMP	_SetReadTime0
(1373) 						mainStep = 4;
    042B3 2722      CLR	R18
    042B4 2733      CLR	R19
(1374) 						break;
    042B5 E003      LDI	R16,3
    042B6 940E 6A5B CALL	_MotRunTo
(1375) 					}
(1376) 					else
(1377) 						workStep = 10;
    042B8 E081      LDI	R24,1
    042B9 9380 165A STS	dustbinOldState+3,R24
(1378) 					break;
    042BB 9180 0531 LDS	R24,_AutoTestCycleNum+3
(1379) 				case 10:
(1380) 					SetEValve(EV3, EV_CLOSE);
    042BD 3081      CPI	R24,1
    042BE F429      BNE	0x42C4
    042BF E183      LDI	R24,0x13
(1381) 					MotRun(MOT_SAMP_PUMP, 200);		// 吸入空气段
    042C0 9380 160D STS	EvenPosChangeProcess+3,R24
    042C2 940C 4FC4 JMP	_SetReadTime0
    042C4 E089      LDI	R24,0x9
(1382) 					waitMotSampPump = 1;
    042C5 9380 160D STS	EvenPosChangeProcess+3,R24
    042C7 940C 4FC4 JMP	_SetReadTime0
(1383) 					workStep = 0;
    042C9 2722      CLR	R18
    042CA 2733      CLR	R19
(1384) 					mainStep = 8;
    042CB E002      LDI	R16,2
    042CC 940E 6A5B CALL	_MotRunTo
(1385) 					break;
(1386) 				}
(1387) 			break;
    042CE E081      LDI	R24,1
    042CF 9380 165B STS	dustbinOldState+4,R24
(1388) 		case 8:	
(1389) 		// 稀释结束，吸取检测用混匀液100uL，取样针上升到最高点，取样臂运行到起始位，准备滴样,同时清洗混匀池
(1390) 			checkDiluent = 0;// 2016-10-22 稀释完成,关闭稀释液检测
    042D1 E184      LDI	R24,0x14
    042D2 9380 160D STS	EvenPosChangeProcess+3,R24
(1391) 			switch(workStep){
    042D4 E081      LDI	R24,1
    042D5 9380 1641 STS	_NewCardStoreNum+1,R24
    042D7 940C 4FC4 JMP	_SetReadTime0
    042D9 9120 1646 LDS	R18,_NewCardStoreNum+6
    042DB 9130 1647 LDS	R19,_NewCardStoreNum+7
    042DD E002      LDI	R16,2
    042DE 940E 6A5B CALL	_MotRunTo
    042E0 E081      LDI	R24,1
    042E1 9380 165B STS	dustbinOldState+4,R24
    042E3 E185      LDI	R24,0x15
    042E4 9380 160D STS	EvenPosChangeProcess+3,R24
    042E6 940C 4FC4 JMP	_SetReadTime0
    042E8 2722      CLR	R18
    042E9 E003      LDI	R16,3
    042EA 940E 6B81 CALL	_SetEValve
    042EC E522      LDI	R18,0x52
    042ED E030      LDI	R19,0
(1392) 				case 0:	// 取样针运行到混匀高度
(1393) 					temp1 = getLiqDetADC(NeedleChannel);
    042EE E00C      LDI	R16,0xC
    042EF 940E 6A2C CALL	_MotRun
    042F1 E081      LDI	R24,1
    042F2 9380 1659 STS	dustbinOldState+2,R24
(1394) 					if(NewTestInfo.sampDiluteMult == 2 || NewTestInfo.sampDiluteMult == 12 || NewTestInfo.sampDiluteMult == 13)
    042F4 2422      CLR	R2
    042F5 9220 160D STS	EvenPosChangeProcess+3,R2
    042F7 E088      LDI	R24,0x8
    042F8 9380 160C STS	EvenPosChangeProcess+2,R24
    042FA 940C 4FC4 JMP	_SetReadTime0
(1395) 						MotRunTo(MOT_SAMP_NEEDLE, _POS_MIX_BUTTOM + 25);
    042FC EB24      LDI	R18,0xB4
    042FD E00A      LDI	R16,0xA
    042FE E010      LDI	R17,0
    042FF 940E 6289 CALL	__EffluentMotRun
    04301 E220      LDI	R18,0x20
(1396) 					else if(NewTestInfo.sampDiluteMult < 7 || NewTestInfo.sampDiluteMult == 14)
    04302 E002      LDI	R16,2
    04303 E010      LDI	R17,0
    04304 940E 6264 CALL	__FluidMotRun
    04306 E081      LDI	R24,1
    04307 9380 1658 STS	dustbinOldState+1,R24
(1397) 						MotRunTo(MOT_SAMP_NEEDLE, _POS_MIX_BUTTOM);
    04309 9380 1656 STS	CardScanfSW,R24
    0430B E089      LDI	R24,0x9
    0430C 9380 160D STS	EvenPosChangeProcess+3,R24
(1398) 					else
(1399) 						MotRunTo(MOT_SAMP_NEEDLE, _POS_MIX_BUTTOM - 150);
    0430E 940C 4FC4 JMP	_SetReadTime0
    04310 2722      CLR	R18
    04311 2700      CLR	R16
    04312 940E 6B81 CALL	_SetEValve
(1400) 					waitMotSampNeedle = 1;
    04314 E22C      LDI	R18,0x2C
    04315 E031      LDI	R19,1
(1401) 					workStep = 1;
    04316 E00C      LDI	R16,0xC
    04317 940E 6A2C CALL	_MotRun
(1402) 					break;
    04319 E081      LDI	R24,1
(1403) 				case 1:		// 吸取检测用混匀液,
(1404) 					temp2 = getLiqDetADC(NeedleChannel);
    0431A 9380 1659 STS	dustbinOldState+2,R24
    0431C 2422      CLR	R2
    0431D 9220 160D STS	EvenPosChangeProcess+3,R2
    0431F E088      LDI	R24,0x8
(1405) 					Uart0ReUnable;
    04320 9380 160C STS	EvenPosChangeProcess+2,R24
    04322 940C 4FC4 JMP	_SetReadTime0
    04324 90C0 160D LDS	R12,EvenPosChangeProcess+3
(1406) 					uart_Printf("%s $%4d $%4d\r\n",strM3188, temp1,temp2);
    04326 24DD      CLR	R13
    04327 01C6      MOVW	R24,R12
    04328 3580      CPI	R24,0x50
    04329 E0E0      LDI	R30,0
    0432A 079E      CPC	R25,R30
    0432B F409      BNE	0x432D
    0432C C105      RJMP	0x4432
    0432D 3581      CPI	R24,0x51
    0432E E0E0      LDI	R30,0
    0432F 079E      CPC	R25,R30
    04330 F409      BNE	0x4332
    04331 C10D      RJMP	0x443F
    04332 3582      CPI	R24,0x52
    04333 E0E0      LDI	R30,0
(1407) 					Uart0ReEnable;
    04334 079E      CPC	R25,R30
    04335 F409      BNE	0x4337
    04336 C112      RJMP	0x4449
    04337 3583      CPI	R24,0x53
    04338 E0E0      LDI	R30,0
(1408) 					siTmp = _DropVolume + GetDropVolumeFactor();
    04339 079E      CPC	R25,R30
    0433A F409      BNE	0x433C
    0433B C11A      RJMP	0x4456
    0433C E583      LDI	R24,0x53
    0433D 158C      CP	R24,R12
    0433E 059D      CPC	R25,R13
    0433F F40C      BGE	0x4341
    04340 C03A      RJMP	0x437B
    04341 20CC      TST	R12
(1409) 					_SampPumpMotRun(siTmp + _SAMP_PUMP_INTERVAL + 400 , 220);	
    04342 F419      BNE	0x4346
    04343 20DD      TST	R13
    04344 F409      BNE	0x4346
    04345 C03C      RJMP	0x4382
    04346 01C6      MOVW	R24,R12
    04347 3081      CPI	R24,1
(1410) 					waitMotSampPump = 1;
    04348 E0E0      LDI	R30,0
    04349 079E      CPC	R25,R30
    0434A F409      BNE	0x434C
(1411) 					workStep = 2;
    0434B C059      RJMP	0x43A5
    0434C 3082      CPI	R24,2
    0434D E0E0      LDI	R30,0
(1412) 					break;
    0434E 079E      CPC	R25,R30
    0434F F409      BNE	0x4351
(1413) 				case 2:
(1414) 					SetDelayTime(MOT_SAMP_PUMP, 1);
    04350 C070      RJMP	0x43C1
    04351 3083      CPI	R24,3
    04352 E0E0      LDI	R30,0
    04353 079E      CPC	R25,R30
    04354 F409      BNE	0x4356
(1415) 					workStep = 3;
    04355 C07F      RJMP	0x43D5
    04356 3084      CPI	R24,4
    04357 E0E0      LDI	R30,0
(1416) 					break;
    04358 079E      CPC	R25,R30
    04359 F409      BNE	0x435B
(1417) 				case 3:		// 消返程间隙
(1418) 					MotRun(MOT_SAMP_PUMP, -_SAMP_PUMP_INTERVAL);
    0435A C086      RJMP	0x43E1
    0435B 3085      CPI	R24,5
    0435C E0E0      LDI	R30,0
    0435D 079E      CPC	R25,R30
    0435E F409      BNE	0x4360
(1419) 					workStep = 4;	
    0435F C095      RJMP	0x43F5
    04360 3086      CPI	R24,6
    04361 E0E0      LDI	R30,0
(1420) 					break;
    04362 079E      CPC	R25,R30
    04363 F409      BNE	0x4365
(1421) 				case 4:		// 取样针离开液面 
(1422) 					_NeedleMotRun(-160,180);//240	
    04364 C0AB      RJMP	0x4410
    04365 3087      CPI	R24,7
    04366 E0E0      LDI	R30,0
    04367 079E      CPC	R25,R30
    04368 F409      BNE	0x436A
(1423) 					waitMotSampNeedle = 1;
    04369 C0BA      RJMP	0x4424
    0436A 3088      CPI	R24,0x8
    0436B E0E0      LDI	R30,0
(1424) 					waitMotSampPump = 1;
    0436C 079E      CPC	R25,R30
    0436D F409      BNE	0x436F
(1425) 					workStep = 5;
    0436E C0FD      RJMP	0x446C
    0436F 3089      CPI	R24,0x9
    04370 E0E0      LDI	R30,0
(1426) 					break;
    04371 079E      CPC	R25,R30
    04372 F409      BNE	0x4374
(1427) 				case 5:		// 取样针运行到最高点, 同时清洗针外壁
(1428) 					MotInitCheck(MOT_SAMP_NEEDLE);
    04373 C10C      RJMP	0x4480
    04374 308A      CPI	R24,0xA
    04375 E0E0      LDI	R30,0
(1429) 					SetEValve(EV1, EV_OPEN);	
    04376 079E      CPC	R25,R30
    04377 F409      BNE	0x4379
    04378 C120      RJMP	0x4499
    04379 940C 4FC4 JMP	_SetReadTime0
(1430) 					checkFluid = 1;				
    0437B 01C6      MOVW	R24,R12
    0437C 3C88      CPI	R24,0xC8
(1431) 					_EffluentMotRun(90, 220);	
    0437D E0E0      LDI	R30,0
    0437E 079E      CPC	R25,R30
    0437F F061      BEQ	0x438C
    04380 940C 4FC4 JMP	_SetReadTime0
(1432) 				//	_FluidMotRun(4, 80);		// 取消吸混匀液后的洗针步骤
(1433) 					waitMotSampNeedle = 1;
    04382 E025      LDI	R18,5
    04383 E030      LDI	R19,0
    04384 E003      LDI	R16,3
(1434) 					workStep = 6;
    04385 940E 97B7 CALL	_SetDelayTime
    04387 EC88      LDI	R24,0xC8
(1435) 					break;
    04388 9380 160D STS	EvenPosChangeProcess+3,R24
(1436) 				case 6:		// 取样针已经运行到最高点, 清洗结束
(1437) 				//	MotStop(MOT_FLUID);
(1438) 					SetDelayTime(MOT_FLUID, 1);
    0438A 940C 4FC4 JMP	_SetReadTime0
    0438C 2722      CLR	R18
    0438D 9100 1668 LDS	R16,j
(1439) 					checkFluid = 0;
    0438F 940E 5184 CALL	_CalDilute2Volume
    04391 0168      MOVW	R12,R16
(1440) 					workStep = 7;
    04392 0156      MOVW	R10,R12
    04393 01C5      MOVW	R24,R10
    04394 9603      ADIW	R24,3
(1441) 					break;
    04395 015C      MOVW	R10,R24
    04396 EC28      LDI	R18,0xC8
(1442) 				case 7:		// 启动负压，吸干针外壁
(1443) 					_FluidMotRun(-1, 80);
    04397 018C      MOVW	R16,R24
    04398 9500      COM	R16
    04399 9510      COM	R17
    0439A 5F0F      SUBI	R16,0xFF
    0439B 4F1F      SBCI	R17,0xFF
(1444) 					SetEValve(EV3, EV_OPEN);
    0439C 940E 62A2 CALL	__DiluentMotRun
    0439E E081      LDI	R24,1
    0439F 9380 1657 STS	dustbinOldState,R24
(1445) 					SetDelayTime(MOT_SAMP_NEEDLE, 2);	// 2016-09-18   // 2017-05-22  5->2
    043A1 9380 160D STS	EvenPosChangeProcess+3,R24
    043A3 940C 4FC4 JMP	_SetReadTime0
(1446) 					workStep = 8;
    043A5 EF20      LDI	R18,0xF0
    043A6 E00F      LDI	R16,0xF
    043A7 E010      LDI	R17,0
(1447) 					break;
    043A8 940E 6289 CALL	__EffluentMotRun
(1448) 				case 8:		// 取样针运行到滴样上方
(1449) 					SetMotRunPam(MOT_SAMP_TRUN,255,10,CURRENT_SAMP_TRUN);
    043AA E320      LDI	R18,0x30
    043AB E032      LDI	R19,2
    043AC E003      LDI	R16,3
    043AD 940E 6A5B CALL	_MotRunTo
    043AF E081      LDI	R24,1
    043B0 9380 1656 STS	CardScanfSW,R24
(1450) 					MotRunTo(MOT_SAMP_TRUN, 0);
    043B2 9380 165A STS	dustbinOldState+3,R24
    043B4 2722      CLR	R18
    043B5 E002      LDI	R16,2
    043B6 940E 6B81 CALL	_SetEValve
(1451) 					waitMotSampTurn = 1;
    043B8 E021      LDI	R18,1
    043B9 E001      LDI	R16,1
(1452) 					workStep = 9;
    043BA 940E 6B81 CALL	_SetEValve
    043BC E082      LDI	R24,2
(1453) 					break;
    043BD 9380 160D STS	EvenPosChangeProcess+3,R24
(1454) 				case 9:		// 清洗头吸干停止, 转换到混匀池排空
(1455) 					SetEValve(EV_ALL, EV_CLOSE);
    043BF 940C 4FC4 JMP	_SetReadTime0
    043C1 E520      LDI	R18,0x50
    043C2 E008      LDI	R16,0x8
(1456) 					SetDelayTime(MOT_EFFLUENT, 2);
    043C3 E010      LDI	R17,0
    043C4 940E 6264 CALL	__FluidMotRun
    043C6 E624      LDI	R18,0x64
    043C7 E00A      LDI	R16,0xA
(1457) 					workStep = 10;
    043C8 E010      LDI	R17,0
    043C9 940E 6289 CALL	__EffluentMotRun
(1458) 					break;
    043CB E081      LDI	R24,1
    043CC 9380 1658 STS	dustbinOldState+1,R24
(1459) 				case 10:		// 取样针在测试卡上方(起始位)，等待将液体滴入测试卡
(1460) 					SetEValve(EV3, EV_CLOSE);		// 废液切换到混匀池，继续抽废液
    043CE 9380 1656 STS	CardScanfSW,R24
    043D0 E083      LDI	R24,3
(1461) #ifndef UartSendLong
(1462) 					Uart0ReUnable;
(1463) 					uart_Printf("%s $%8d\r\n",strM3110 ,NewTestInfo.testSerial);
(1464) 					Uart0ReEnable;
(1465) #else
(1466) 					Uart0ReUnable;
    043D1 9380 160D STS	EvenPosChangeProcess+3,R24
    043D3 940C 4FC4 JMP	_SetReadTime0
    043D5 E021      LDI	R18,1
(1467) 					uart_Printf("%s $ ",strM3110);
    043D6 E002      LDI	R16,2
    043D7 940E 6B81 CALL	_SetEValve
    043D9 E084      LDI	R24,4
    043DA 9380 160D STS	EvenPosChangeProcess+3,R24
(1468) 					uart0SendInt(NewTestInfo.testSerial);
    043DC 2422      CLR	R2
    043DD 9220 1612 STS	EvenPosChangeProcess+8,R2
    043DF 940C 4FC4 JMP	_SetReadTime0
    043E1 E520      LDI	R18,0x50
    043E2 E100      LDI	R16,0x10
    043E3 E010      LDI	R17,0
    043E4 940E 6264 CALL	__FluidMotRun
(1469) 					uart_Printf("\r\n");
    043E6 EF20      LDI	R18,0xF0
    043E7 E104      LDI	R16,0x14
    043E8 E010      LDI	R17,0
    043E9 940E 6289 CALL	__EffluentMotRun
(1470) 					Uart0ReEnable;
    043EB E081      LDI	R24,1
    043EC 9380 1658 STS	dustbinOldState+1,R24
    043EE 9380 1656 STS	CardScanfSW,R24
(1471) #endif
(1472) 					if(_DropMode == 0)
    043F0 E085      LDI	R24,5
    043F1 9380 160D STS	EvenPosChangeProcess+3,R24
    043F3 940C 4FC4 JMP	_SetReadTime0
    043F5 2722      CLR	R18
    043F6 E002      LDI	R16,2
(1473) 					{
(1474) 						mainStep = 9;
    043F7 940E 6B81 CALL	_SetEValve
    043F9 E021      LDI	R18,1
(1475) 						workStep = 0;
    043FA E001      LDI	R16,1
    043FB 940E 6B81 CALL	_SetEValve
(1476) 					}
    043FD E520      LDI	R18,0x50
    043FE E008      LDI	R16,0x8
(1477) 					else
(1478) 						workStep = 11;
    043FF E010      LDI	R17,0
    04400 940E 6264 CALL	__FluidMotRun
(1479) 					break;
    04402 E081      LDI	R24,1
    04403 9380 1658 STS	dustbinOldState+1,R24
(1480) 				case 11:
(1481) 					if(GetNewTestCard == 222)				//抽打混匀准备
    04405 9380 1656 STS	CardScanfSW,R24
    04407 E021      LDI	R18,1
(1482) 					{
(1483) 						Uart0ReUnable;
    04408 E003      LDI	R16,3
    04409 940E 6B81 CALL	_SetEValve
    0440B E086      LDI	R24,6
    0440C 9380 160D STS	EvenPosChangeProcess+3,R24
(1484) 						uart_Printf("%s\r\n",strM3145);
    0440E 940C 4FC4 JMP	_SetReadTime0
    04410 EA20      LDI	R18,0xA0
    04411 EF0F      LDI	R16,0xFF
    04412 EF1F      LDI	R17,0xFF
(1485) 						Uart0ReEnable;
    04413 940E 6264 CALL	__FluidMotRun
    04415 EF20      LDI	R18,0xF0
    04416 E108      LDI	R16,0x18
    04417 E010      LDI	R17,0
(1486) 						MixHeight = GetMixHeight();
    04418 940E 6289 CALL	__EffluentMotRun
    0441A E025      LDI	R18,5
    0441B E030      LDI	R19,0
    0441C E003      LDI	R16,3
    0441D 940E 97B7 CALL	_SetDelayTime
(1487) 						_NeedleMotRunTo(MixHeight,240);
    0441F E087      LDI	R24,7
    04420 9380 160D STS	EvenPosChangeProcess+3,R24
(1488) 						waitMotSampNeedle = 1;
    04422 940C 4FC4 JMP	_SetReadTime0
    04424 2722      CLR	R18
(1489) 						workStep = 12;
    04425 2700      CLR	R16
    04426 940E 6B81 CALL	_SetEValve
(1490) 						break;
    04428 E081      LDI	R24,1
    04429 9380 1656 STS	CardScanfSW,R24
(1491) 					}
(1492) 					else if(GetNewTestCard == 250)			// 取片失败 	
    0442B 9380 1658 STS	dustbinOldState+1,R24
    0442D E580      LDI	R24,0x50
    0442E 9380 160D STS	EvenPosChangeProcess+3,R24
(1493) 					{
(1494) 						MotRunTo(MOT_SAMP_TRUN, NeedleOnMixCenterPos);
    04430 940C 4FC4 JMP	_SetReadTime0
    04432 E728      LDI	R18,0x78
    04433 E003      LDI	R16,3
    04434 E010      LDI	R17,0
    04435 940E 62A2 CALL	__DiluentMotRun
(1495) 						waitMotSampTurn = 1;
    04437 E081      LDI	R24,1
    04438 9380 1657 STS	dustbinOldState,R24
(1496) 						mainStep = 9;
    0443A E581      LDI	R24,0x51
    0443B 9380 160D STS	EvenPosChangeProcess+3,R24
(1497) 						workStep = 5;
    0443D 940C 4FC4 JMP	_SetReadTime0
    0443F E022      LDI	R18,2
(1498) 					}
(1499) 					break;
    04440 E030      LDI	R19,0
    04441 E003      LDI	R16,3
(1500) 				case 12:
(1501) 					_SampPumpMotRun(-4244, 240);	// 第一次吐100ul  100 / 0.023563 = 4244
    04442 940E 97B7 CALL	_SetDelayTime
    04444 E582      LDI	R24,0x52
    04445 9380 160D STS	EvenPosChangeProcess+3,R24
(1502) 					//_SampPumpMotRun(-4371, 240);	// 第一次吐103ul  103 / 0.023563 = 4371
(1503) 					Num++;
    04447 940C 4FC4 JMP	_SetReadTime0
    04449 EB24      LDI	R18,0xB4
    0444A E00A      LDI	R16,0xA
    0444B E010      LDI	R17,0
(1504) 					waitMotSampPump = 1;
    0444C 940E 6289 CALL	__EffluentMotRun
    0444E E081      LDI	R24,1
(1505) 					workStep = 13;
    0444F 9380 1656 STS	CardScanfSW,R24
    04451 E583      LDI	R24,0x53
(1506) 					break;
    04452 9380 160D STS	EvenPosChangeProcess+3,R24
(1507) 				case 13:	// 离开抽打混匀高度
(1508) 					_NeedleMotRunTo(MixHeight - 200,240);
    04454 940C 4FC4 JMP	_SetReadTime0
    04456 E021      LDI	R18,1
    04457 E003      LDI	R16,3
    04458 940E 6B81 CALL	_SetEValve
    0445A EF20      LDI	R18,0xF0
    0445B E00F      LDI	R16,0xF
    0445C E010      LDI	R17,0
(1509) 					waitMotSampNeedle = 1;
    0445D 940E 6289 CALL	__EffluentMotRun
    0445F 2722      CLR	R18
(1510) 					workStep = 14;
    04460 2733      CLR	R19
    04461 E003      LDI	R16,3
    04462 940E 6A5B CALL	_MotRunTo
(1511) 					break;
    04464 E081      LDI	R24,1
(1512) 				case 14:
(1513) 					_SampPumpMotRun(424, 120);		// 吸10ul空气   10 / 0.023563 = 424
    04465 9380 165A STS	dustbinOldState+3,R24
    04467 E088      LDI	R24,0x8
    04468 9380 160D STS	EvenPosChangeProcess+3,R24
(1514) 					waitMotSampPump = 1;
    0446A 940C 4FC4 JMP	_SetReadTime0
    0446C E021      LDI	R18,1
(1515) 					workStep = 15;
    0446D 9100 1668 LDS	R16,j
    0446F 940E 5184 CALL	_CalDilute2Volume
(1516) 					break;
    04471 0168      MOVW	R12,R16
(1517) 				case 15:	// 降低至抽打混匀高度
(1518) 					_NeedleMotRunTo(MixHeight,240);
    04472 0156      MOVW	R10,R12
    04473 EF20      LDI	R18,0xF0
    04474 940E 62A2 CALL	__DiluentMotRun
    04476 E081      LDI	R24,1
    04477 9380 1657 STS	dustbinOldState,R24
(1519) 					waitMotSampNeedle = 1;
    04479 9380 1656 STS	CardScanfSW,R24
    0447B E089      LDI	R24,0x9
(1520) 					workStep = 20;
    0447C 9380 160D STS	EvenPosChangeProcess+3,R24
    0447E 940C 4FC4 JMP	_SetReadTime0
(1521) 					break;
    04480 9180 0531 LDS	R24,_AutoTestCycleNum+3
(1522) //#ifndef _FluidPumMix 
(1523) 				// 微量注塞泵抽打混匀
(1524) 				case 20:
(1525) 					//_SampPumpMotRun(4032, 240);		// 吸95ul  95 / 0.023563 = 4032
(1526) 					_SampPumpMotRun(3820, 240);			// 吸90ul  90 / 0.023563 = 3820
    04482 3081      CPI	R24,1
    04483 F481      BNE	0x4494
    04484 2722      CLR	R18
    04485 2733      CLR	R19
(1527) 					waitMotSampPump = 1;
    04486 E003      LDI	R16,3
    04487 940E 6A5B CALL	_MotRunTo
(1528) 					workStep = 21;
    04489 E081      LDI	R24,1
    0448A 9380 165A STS	dustbinOldState+3,R24
(1529) 					break;
    0448C E183      LDI	R24,0x13
    0448D 9380 160D STS	EvenPosChangeProcess+3,R24
(1530) 				case 21:		// 注入90液体
(1531) 					_SampPumpMotRun(-3820, 240);	// 吐90 90/0.023563 = 3820
    0448F E084      LDI	R24,4
    04490 9380 160C STS	EvenPosChangeProcess+2,R24
    04492 940C 4FC4 JMP	_SetReadTime0
(1532) 					Num++;
    04494 E08A      LDI	R24,0xA
    04495 9380 160D STS	EvenPosChangeProcess+3,R24
    04497 940C 4FC4 JMP	_SetReadTime0
(1533) 					waitMotSampPump = 1;
    04499 2722      CLR	R18
    0449A E003      LDI	R16,3
(1534) 					workStep = 22;
    0449B 940E 6B81 CALL	_SetEValve
    0449D EC28      LDI	R18,0xC8
(1535) 					break;
    0449E E030      LDI	R19,0
    0449F E00C      LDI	R16,0xC
(1536) 				case 22:
(1537) 					_SampPumpMotRun(3820, 240);		// 吸90 90/0.023563 = 3820	
    044A0 940E 6A2C CALL	_MotRun
    044A2 E081      LDI	R24,1
    044A3 9380 1659 STS	dustbinOldState+2,R24
(1538) 					if(Num < _ReMixNum - 1)
    044A5 2422      CLR	R2
    044A6 9220 160D STS	EvenPosChangeProcess+3,R2
    044A8 E088      LDI	R24,0x8
    044A9 9380 160C STS	EvenPosChangeProcess+2,R24
    044AB 940C 4FC4 JMP	_SetReadTime0
    044AD 2422      CLR	R2
    044AE 9220 160F STS	EvenPosChangeProcess+5,R2
(1539) 						workStep = 21;
    044B0 90C0 160D LDS	R12,EvenPosChangeProcess+3
    044B2 24DD      CLR	R13
    044B3 01C6      MOVW	R24,R12
(1540) 					else
(1541) 						workStep = 23;
    044B4 3080      CPI	R24,0
    044B5 E0E0      LDI	R30,0
    044B6 079E      CPC	R25,R30
(1542) 					waitMotSampPump = 1;
    044B7 F414      BGE	0x44BA
    044B8 940C 4FC4 JMP	_SetReadTime0
(1543) 				   break;
    044BA E189      LDI	R24,0x19
    044BB 158C      CP	R24,R12
(1544) 				case 23:
(1545) 					//_SampPumpMotRun(-4032,240);			// 吐95 95/0.023563 = 4032
(1546) 					_SampPumpMotRun(-3820,240);				// 吐90 90/0.023563 = 3820
    044BC 059D      CPC	R25,R13
    044BD F414      BGE	0x44C0
    044BE 940C 4FC4 JMP	_SetReadTime0
    044C0 E58A      LDI	R24,0x5A
(1547) 					waitMotSampPump = 1;
    044C1 E092      LDI	R25,2
    044C2 01F6      MOVW	R30,R12
    044C3 0FEE      LSL	R30
(1548) 					workStep = 24;
    044C4 1FFF      ROL	R31
    044C5 0FE8      ADD	R30,R24
    044C6 1FF9      ADC	R31,R25
(1549) 					break;
    044C7 9027      ELPM	R2,Z+
    044C8 9036      ELPM	R3,Z
(1550) 				case 24:
(1551) 					_SampPumpMotRun(3395, 240);			// 吸80 80/0.023563 = 3395	
    044C9 01F1      MOVW	R30,R2
    044CA 9409      IJMP
    044CB 2700      CLR	R16
    044CC 940E 9A52 CALL	_getLiqDetADC
(1552) 					workStep = 25;
    044CE 0168      MOVW	R12,R16
    044CF 92C0 161B STS	EvenPosChangeProcess+17,R12
(1553) 					waitMotSampPump = 1;
    044D1 9180 1668 LDS	R24,j
    044D3 3082      CPI	R24,2
(1554) 				   break;
    044D4 F021      BEQ	0x44D9
(1555) 				case 25:
(1556) 				   SetDelayTime(MOT_SAMP_NEEDLE,2);
    044D5 308C      CPI	R24,0xC
    044D6 F011      BEQ	0x44D9
    044D7 308D      CPI	R24,0xD
    044D8 F431      BNE	0x44DF
    044D9 E92D      LDI	R18,0x9D
(1557) 				   workStep = 16;
    044DA E033      LDI	R19,3
    044DB E003      LDI	R16,3
    044DC 940E 6A5B CALL	_MotRunTo
(1558) 				   break;
    044DE C011      RJMP	0x44F0
    044DF 9180 1668 LDS	R24,j
(1559) 				case 16:
(1560) 				   Num = 0;
(1561) 				   workStep = 17;
    044E1 3087      CPI	R24,7
    044E2 F010      BCS	0x44E5
    044E3 308E      CPI	R24,0xE
(1562) 				   Uart0ReUnable;
    044E4 F431      BNE	0x44EB
    044E5 E824      LDI	R18,0x84
    044E6 E033      LDI	R19,3
    044E7 E003      LDI	R16,3
    044E8 940E 6A5B CALL	_MotRunTo
(1563) 				   uart_Printf("%s\r\n",strM3199);
    044EA C005      RJMP	0x44F0
    044EB EE2E      LDI	R18,0xEE
    044EC E032      LDI	R19,2
    044ED E003      LDI	R16,3
    044EE 940E 6A5B CALL	_MotRunTo
(1564) 				   Uart0ReEnable;
    044F0 E081      LDI	R24,1
    044F1 9380 165A STS	dustbinOldState+3,R24
    044F3 9380 160D STS	EvenPosChangeProcess+3,R24
(1565) 				   break;
    044F5 940C 4FC4 JMP	_SetReadTime0
    044F7 2700      CLR	R16
    044F8 940E 9A52 CALL	_getLiqDetADC
(1566) 				case 17:
(1567) 				   _NeedleMotRunTo(0,240);	//吸样针回到零位
(1568) 				   waitMotSampNeedle = 1;
    044FA 0168      MOVW	R12,R16
    044FB 92C0 161C STS	EvenPosChangeProcess+18,R12
(1569) 				   workStep = 18;
    044FD 9180 00C1 LDS	R24,0xC1
    044FF 7E8F      ANDI	R24,0xEF
(1570) 				   break;
    04500 9380 00C1 STS	0xC1,R24
(1571) 				case 18:		//抽打混匀结束
(1572) 				   SetDelayTime(MOT_SAMP_NEEDLE,3);
    04502 2C2C      MOV	R2,R12
    04503 2433      CLR	R3
    04504 823B      STD	Y+3,R3
    04505 822A      STD	Y+2,R2
(1573) 				   GetNewTestCard = 233;		// 设置取出测试卡标识,抽打混匀结束,准备滴样
    04506 9020 161B LDS	R2,EvenPosChangeProcess+17
    04508 2433      CLR	R3
(1574) 				   mainStep = 9;
    04509 8239      STD	Y+1,R3
    0450A 8228      ST	Y,R2
    0450B E320      LDI	R18,0x30
(1575) 				   workStep = 0;
    0450C E133      LDI	R19,0x13
    0450D E404      LDI	R16,0x44
    0450E E016      LDI	R17,6
(1576) 				   break;
(1577) 				}
(1578) 			break;
    0450F 940E A90D CALL	_uart_Printf
(1579) 		case 9:				// 等待混匀滴入干片中,然后清洗
(1580) 			switch(workStep){
    04511 9180 00C1 LDS	R24,0xC1
    04513 6180      ORI	R24,0x10
    04514 9380 00C1 STS	0xC1,R24
    04516 940E 5552 CALL	_GetDropVolumeFactor
    04518 0168      MOVW	R12,R16
    04519 90A0 1654 LDS	R10,_DropVolume|diluteProcessState
    0451B 90B0 1655 LDS	R11,GetNewPieceProcessState
    0451D 0EA0      ADD	R10,R16
    0451E 1EB1      ADC	R11,R17
    0451F ED2C      LDI	R18,0xDC
    04520 0185      MOVW	R16,R10
    04521 5304      SUBI	R16,0x34
    04522 4F1E      SBCI	R17,0xFE
    04523 940E 631B CALL	__SampPumpMotRun
    04525 9180 00C1 LDS	R24,0xC1
    04527 7E8F      ANDI	R24,0xEF
    04528 9380 00C1 STS	0xC1,R24
(1581) 				case 0:		// 准备滴样，检查测试队列是否有空位加入，否则等待	// 检测队列任务由此加入开始
(1582) 					if(GetNewTestCard == 254)	// 测试卡片已经准备完毕，下面开始将测试插入检测队列
    0452A 82B9      STD	Y+1,R11
    0452B 82A8      ST	Y,R10
    0452C EF28      LDI	R18,0xF8
    0452D E132      LDI	R19,0x12
(1583) 					{		
(1584) 						CurInsertRingNum = RingQueueInsertCalculate();	// 查找转盘位置						
    0452E E904      LDI	R16,0x94
    0452F E016      LDI	R17,6
    04530 940E A90D CALL	_uart_Printf
    04532 9180 00C1 LDS	R24,0xC1
(1585) 						if(CurInsertRingNum != 0xff)	// 如果转盘位置查找成功，测试队列插入
    04534 6180      ORI	R24,0x10
    04535 9380 00C1 STS	0xC1,R24
(1586) 						{	
(1587) 							FindNum = 0;
    04537 E081      LDI	R24,1
    04538 9380 1659 STS	dustbinOldState+2,R24
(1588) 							ucTmp = InsertNewTest(&NewTestInfo,CurInsertRingNum);	// 测试队列插入
    0453A E082      LDI	R24,2
    0453B 9380 160D STS	EvenPosChangeProcess+3,R24
    0453D 940C 4FC4 JMP	_SetReadTime0
    0453F E021      LDI	R18,1
    04540 E030      LDI	R19,0
    04541 E00C      LDI	R16,0xC
    04542 940E 97B7 CALL	_SetDelayTime
(1589) 							if(ucTmp == 0)	// 新测试插入计算成功
    04544 E083      LDI	R24,3
    04545 9380 160D STS	EvenPosChangeProcess+3,R24
(1590) 							{
(1591) 								// 将新测试插入上面计算出来的转盘位置
(1592) 								RingQueueInsert(CurInsertRingNum,&NewTestInfo);		
    04547 940C 4FC4 JMP	_SetReadTime0
    04549 EC24      LDI	R18,0xC4
    0454A EF3F      LDI	R19,0xFF
    0454B E00C      LDI	R16,0xC
    0454C 940E 6A2C CALL	_MotRun
(1593) 								insertflag[CurInsertRingNum] = 0;
    0454E E084      LDI	R24,4
    0454F 9380 160D STS	EvenPosChangeProcess+3,R24
    04551 940C 4FC4 JMP	_SetReadTime0
    04553 EB24      LDI	R18,0xB4
    04554 E600      LDI	R16,0x60
    04555 EF1F      LDI	R17,0xFF
(1594) 								// 加入卸片队列
(1595) 								if(NewTestInfo.testTime1)
    04556 940E 62DB CALL	__NeedleMotRun
    04558 E081      LDI	R24,1
    04559 9380 165A STS	dustbinOldState+3,R24
    0455B 9380 1659 STS	dustbinOldState+2,R24
    0455D E085      LDI	R24,5
(1596) 									UnloadQueueAdd(CurInsertRingNum, SecondCount+NewTestInfo.testTime1+TEST_CYCLE_TIME+25); 
    0455E 9380 160D STS	EvenPosChangeProcess+3,R24
    04560 940C 4FC4 JMP	_SetReadTime0
    04562 E003      LDI	R16,3
    04563 940E 6AFA CALL	_MotInitCheck
    04565 E021      LDI	R18,1
    04566 E001      LDI	R16,1
    04567 940E 6B81 CALL	_SetEValve
    04569 E081      LDI	R24,1
    0456A 9380 1610 STS	EvenPosChangeProcess+6,R24
    0456C ED2C      LDI	R18,0xDC
    0456D E50A      LDI	R16,0x5A
    0456E E010      LDI	R17,0
    0456F 940E 6289 CALL	__EffluentMotRun
    04571 E081      LDI	R24,1
    04572 9380 165A STS	dustbinOldState+3,R24
    04574 E086      LDI	R24,6
    04575 9380 160D STS	EvenPosChangeProcess+3,R24
    04577 940C 4FC4 JMP	_SetReadTime0
    04579 E021      LDI	R18,1
    0457A E030      LDI	R19,0
    0457B E00A      LDI	R16,0xA
    0457C 940E 97B7 CALL	_SetDelayTime
(1597) 								else
(1598) 									UnloadQueueAdd(CurInsertRingNum, SecondCount+NewTestInfo.testTime0+TEST_CYCLE_TIME+25);
    0457E 2422      CLR	R2
    0457F 9220 1610 STS	EvenPosChangeProcess+6,R2
    04581 E087      LDI	R24,7
    04582 9380 160D STS	EvenPosChangeProcess+3,R24
    04584 940C 4FC4 JMP	_SetReadTime0
    04586 E520      LDI	R18,0x50
    04587 EF0F      LDI	R16,0xFF
    04588 EF1F      LDI	R17,0xFF
    04589 940E 6264 CALL	__FluidMotRun
    0458B E021      LDI	R18,1
    0458C E003      LDI	R16,3
    0458D 940E 6B81 CALL	_SetEValve
    0458F E022      LDI	R18,2
    04590 E030      LDI	R19,0
    04591 E003      LDI	R16,3
    04592 940E 97B7 CALL	_SetDelayTime
    04594 E088      LDI	R24,0x8
    04595 9380 160D STS	EvenPosChangeProcess+3,R24
    04597 940C 4FC4 JMP	_SetReadTime0
    04599 E084      LDI	R24,4
    0459A 838A      STD	Y+2,R24
    0459B E08A      LDI	R24,0xA
    0459C 8388      ST	Y,R24
    0459D EF2F      LDI	R18,0xFF
    0459E E002      LDI	R16,2
(1599) 								workStep = 1;
    0459F 940E 6A9F CALL	_SetMotRunPam
    045A1 2722      CLR	R18
(1600) 							}
(1601) 						}
    045A2 2733      CLR	R19
(1602) 						else
(1603) 						{
(1604) 							// 如果转盘位置查找失败，5s之后重新查找
(1605) 							SetDelayTime(MOT_SAMP_NEEDLE,50);	
    045A3 E002      LDI	R16,2
    045A4 940E 6A5B CALL	_MotRunTo
    045A6 E081      LDI	R24,1
    045A7 9380 165B STS	dustbinOldState+4,R24
(1606) 							FindNum++;
    045A9 E089      LDI	R24,0x9
    045AA 9380 160D STS	EvenPosChangeProcess+3,R24
    045AC 940C 4FC4 JMP	_SetReadTime0
(1607) 							if(FindNum >= 3)	// 连续3次转盘位置查找失败,当前转盘位置为前一次+1
    045AE 2722      CLR	R18
    045AF 2700      CLR	R16
(1608) 							{
(1609) 								FindNum = 0;
    045B0 940E 6B81 CALL	_SetEValve
    045B2 E022      LDI	R18,2
(1610) 								//RingQueue.prevNum += 1;
(1611) 								CurInsertRingNum = RingQueue.prevNum++;
    045B3 E030      LDI	R19,0
    045B4 E00B      LDI	R16,0xB
    045B5 940E 97B7 CALL	_SetDelayTime
    045B7 E08A      LDI	R24,0xA
    045B8 9380 160D STS	EvenPosChangeProcess+3,R24
    045BA 940C 4FC4 JMP	_SetReadTime0
(1612) 								if(CurInsertRingNum >= RING_QUEUE_NUM)
    045BC 2722      CLR	R18
    045BD E003      LDI	R16,3
(1613) 									CurInsertRingNum -= RING_QUEUE_NUM;
    045BE 940E 6B81 CALL	_SetEValve
    045C0 9180 00C1 LDS	R24,0xC1
(1614) 								RingQueueInsert(CurInsertRingNum,&NewTestInfo);		
    045C2 7E8F      ANDI	R24,0xEF
    045C3 9380 00C1 STS	0xC1,R24
    045C5 E820      LDI	R18,0x80
    045C6 E03D      LDI	R19,0xD
    045C7 E30E      LDI	R16,0x3E
(1615) 								insertflag[CurInsertRingNum] = 0;
    045C8 E016      LDI	R17,6
    045C9 940E A90D CALL	_uart_Printf
    045CB 9120 1664 LDS	R18,LiquidPhoNum
    045CD 9130 1665 LDS	R19,timeOut
    045CF 9100 1662 LDS	R16,NewTestInfo|liqDetBaseAdc+1
(1616) 								// 加入卸片队列
(1617) 								if(NewTestInfo.testTime1)
    045D1 9110 1663 LDS	R17,CardStorePhoNum
    045D3 940E A940 CALL	_uart0SendInt
    045D5 E30B      LDI	R16,0x3B
    045D6 E016      LDI	R17,6
    045D7 940E A90D CALL	_uart_Printf
(1618) 									UnloadQueueAdd(CurInsertRingNum, SecondCount+NewTestInfo.testTime1+TEST_CYCLE_TIME+25);
    045D9 9180 00C1 LDS	R24,0xC1
    045DB 6180      ORI	R24,0x10
    045DC 9380 00C1 STS	0xC1,R24
    045DE 9020 164E LDS	R2,_DropMode
    045E0 9030 164F LDS	R3,_DropMode+1
    045E2 2022      TST	R2
    045E3 F451      BNE	0x45EE
    045E4 2033      TST	R3
    045E5 F441      BNE	0x45EE
    045E6 E089      LDI	R24,0x9
    045E7 9380 160C STS	EvenPosChangeProcess+2,R24
    045E9 2422      CLR	R2
    045EA 9220 160D STS	EvenPosChangeProcess+3,R2
    045EC 940C 4FC4 JMP	_SetReadTime0
    045EE E08B      LDI	R24,0xB
    045EF 9380 160D STS	EvenPosChangeProcess+3,R24
    045F1 940C 4FC4 JMP	_SetReadTime0
    045F3 9180 165F LDS	R24,GetNewTestCard
    045F5 3D8E      CPI	R24,0xDE
    045F6 F511      BNE	0x4619
    045F7 9180 00C1 LDS	R24,0xC1
(1619) 								else
(1620) 									UnloadQueueAdd(CurInsertRingNum, SecondCount+NewTestInfo.testTime0+TEST_CYCLE_TIME+25);
    045F9 7E8F      ANDI	R24,0xEF
    045FA 9380 00C1 STS	0xC1,R24
    045FC E924      LDI	R18,0x94
    045FD E130      LDI	R19,0x10
    045FE E80F      LDI	R16,0x8F
    045FF E016      LDI	R17,6
    04600 940E A90D CALL	_uart_Printf
    04602 9180 00C1 LDS	R24,0xC1
    04604 6180      ORI	R24,0x10
    04605 9380 00C1 STS	0xC1,R24
    04607 940E 8420 CALL	_GetMixHeight
    04609 0168      MOVW	R12,R16
    0460A 92D0 1643 STS	_NewCardStoreNum+3,R13
    0460C 92C0 1642 STS	_NewCardStoreNum+2,R12
    0460E EF20      LDI	R18,0xF0
    0460F 940E 62FB CALL	__NeedleMotRunTo
    04611 E081      LDI	R24,1
    04612 9380 165A STS	dustbinOldState+3,R24
    04614 E08C      LDI	R24,0xC
    04615 9380 160D STS	EvenPosChangeProcess+3,R24
    04617 940C 4FC4 JMP	_SetReadTime0
    04619 9180 165F LDS	R24,GetNewTestCard
(1621) 								workStep = 1;
    0461B 3F8A      CPI	R24,0xFA
    0461C F011      BEQ	0x461F
(1622) 							}
(1623) 						}
(1624) 					}
    0461D 940C 4FC4 JMP	_SetReadTime0
(1625) 					else if(GetNewTestCard == 250)
    0461F 9120 1646 LDS	R18,_NewCardStoreNum+6
    04621 9130 1647 LDS	R19,_NewCardStoreNum+7
(1626) 					{
(1627) 					//	GetNewTestCard = 0;
(1628) 						MotRunTo(MOT_SAMP_TRUN, NeedleOnMixCenterPos);
    04623 E002      LDI	R16,2
    04624 940E 6A5B CALL	_MotRunTo
    04626 E081      LDI	R24,1
    04627 9380 165B STS	dustbinOldState+4,R24
    04629 E089      LDI	R24,0x9
(1629) 						waitMotSampTurn = 1;
    0462A 9380 160C STS	EvenPosChangeProcess+2,R24
    0462C E085      LDI	R24,5
(1630) 						workStep = 5;
    0462D 9380 160D STS	EvenPosChangeProcess+3,R24
    0462F 940C 4FC4 JMP	_SetReadTime0
(1631) 					}
(1632) 					break;
    04631 EF20      LDI	R18,0xF0
    04632 E60C      LDI	R16,0x6C
    04633 EE1F      LDI	R17,0xEF
    04634 940E 631B CALL	__SampPumpMotRun
    04636 9180 1613 LDS	R24,EvenPosChangeProcess+9
(1633) 				case 1:		// 取样针下降到测试卡上方
(1634) 					_NeedleMotRunTo(DropHeight,180);	// 触碰到试剂片
(1635) 					waitMotSampNeedle = 1;
    04638 5F8F      SUBI	R24,0xFF
    04639 9380 1613 STS	EvenPosChangeProcess+9,R24
(1636) 					workStep = 2;
    0463B E081      LDI	R24,1
    0463C 9380 1659 STS	dustbinOldState+2,R24
(1637) 					break;
    0463E E08D      LDI	R24,0xD
(1638) 				case 2:		// 注入液体
(1639) 					if(_DropVolume != 0)	// 2016-05-19 添加滴样量为0处理
    0463F 9380 160D STS	EvenPosChangeProcess+3,R24
    04641 940C 4FC4 JMP	_SetReadTime0
    04643 EF20      LDI	R18,0xF0
    04644 9100 1642 LDS	R16,_NewCardStoreNum+2
    04646 9110 1643 LDS	R17,_NewCardStoreNum+3
(1640) 					{
(1641) 						siTmp = _DropVolume +  GetDropVolumeFactor();
    04648 5C08      SUBI	R16,0xC8
    04649 4010      SBCI	R17,0
    0464A 940E 62FB CALL	__NeedleMotRunTo
    0464C E081      LDI	R24,1
    0464D 9380 165A STS	dustbinOldState+3,R24
    0464F E08E      LDI	R24,0xE
(1642) 						_SampPumpMotRun(-siTmp, 180);
    04650 9380 160D STS	EvenPosChangeProcess+3,R24
    04652 940C 4FC4 JMP	_SetReadTime0
    04654 E728      LDI	R18,0x78
    04655 EA08      LDI	R16,0xA8
    04656 E011      LDI	R17,1
    04657 940E 631B CALL	__SampPumpMotRun
(1643) 						Uart0ReUnable;
    04659 E081      LDI	R24,1
    0465A 9380 1659 STS	dustbinOldState+2,R24
    0465C E08F      LDI	R24,0xF
(1644) 						uart_Printf("%s $%4d\r\n", strM3141, siTmp);
    0465D 9380 160D STS	EvenPosChangeProcess+3,R24
    0465F 940C 4FC4 JMP	_SetReadTime0
    04661 EF20      LDI	R18,0xF0
    04662 9100 1642 LDS	R16,_NewCardStoreNum+2
    04664 9110 1643 LDS	R17,_NewCardStoreNum+3
(1645) 						Uart0ReEnable;
    04666 940E 62FB CALL	__NeedleMotRunTo
    04668 E081      LDI	R24,1
    04669 9380 165A STS	dustbinOldState+3,R24
(1646) 						waitMotSampPump = 1;
    0466B E184      LDI	R24,0x14
    0466C 9380 160D STS	EvenPosChangeProcess+3,R24
(1647) 					}
(1648) 					workStep = 3;
    0466E 940C 4FC4 JMP	_SetReadTime0
(1649) 					break;
    04670 EF20      LDI	R18,0xF0
(1650) 				case 3:		// 取样针上升到最高点
(1651) 					SetBeepAck();
    04671 EE0C      LDI	R16,0xEC
    04672 E01E      LDI	R17,0xE
(1652) 					// 标本已加入，测试开始
(1653) #ifndef UartSendLong
(1654) 					Uart0ReUnable;
(1655) 					uart_Printf("%s $%8d",strM3111, NewTestInfo.testSerial);
(1656) 					uart_Printf(" $%8d\r\n",(unsigned long)SecondCount);
(1657) 					Uart0ReEnable;
(1658) #else		
(1659) 					Uart0ReUnable;
    04673 940E 631B CALL	__SampPumpMotRun
    04675 E081      LDI	R24,1
    04676 9380 1659 STS	dustbinOldState+2,R24
(1660) 					uart_Printf("%s $ ",strM3111);
    04678 E185      LDI	R24,0x15
    04679 9380 160D STS	EvenPosChangeProcess+3,R24
    0467B 940C 4FC4 JMP	_SetReadTime0
    0467D EF20      LDI	R18,0xF0
(1661) 					uart0SendInt(NewTestInfo.testSerial);
    0467E E104      LDI	R16,0x14
    0467F EF11      LDI	R17,0xF1
    04680 940E 631B CALL	__SampPumpMotRun
    04682 9180 1613 LDS	R24,EvenPosChangeProcess+9
    04684 5F8F      SUBI	R24,0xFF
    04685 9380 1613 STS	EvenPosChangeProcess+9,R24
    04687 E081      LDI	R24,1
(1662) 					uart_Printf(" $ ");
    04688 9380 1659 STS	dustbinOldState+2,R24
    0468A E186      LDI	R24,0x16
    0468B 9380 160D STS	EvenPosChangeProcess+3,R24
(1663) 					uart0SendInt(SecondCount);
    0468D 940C 4FC4 JMP	_SetReadTime0
    0468F EF20      LDI	R18,0xF0
    04690 EE0C      LDI	R16,0xEC
    04691 E01E      LDI	R17,0xE
    04692 940E 631B CALL	__SampPumpMotRun
    04694 9180 052C LDS	R24,_ReMixNum
(1664) 					uart_Printf("\r\n");
    04696 9190 052D LDS	R25,_ReMixNum+1
    04698 9701      SBIW	R24,1
    04699 9020 1613 LDS	R2,EvenPosChangeProcess+9
(1665) 					Uart0ReEnable;
    0469B 2433      CLR	R3
    0469C 1628      CP	R2,R24
    0469D 0639      CPC	R3,R25
    0469E F420      BCC	0x46A3
(1666) #endif
(1667) 					_NeedleMotRunTo(0,180);
    0469F E185      LDI	R24,0x15
    046A0 9380 160D STS	EvenPosChangeProcess+3,R24
    046A2 C003      RJMP	0x46A6
    046A3 E187      LDI	R24,0x17
(1668) 					GetNewTestCard = 255;		// 从case 4移动上来，保证滴样的样品可以测试
    046A4 9380 160D STS	EvenPosChangeProcess+3,R24
    046A6 E081      LDI	R24,1
(1669) 					_FluidMotRun(5, 64);		// 开启清洗液洗混匀池,注入1.4mL清洗液
    046A7 9380 1659 STS	dustbinOldState+2,R24
    046A9 940C 4FC4 JMP	_SetReadTime0
    046AB EF20      LDI	R18,0xF0
(1670) #if 	(DILUTE_TUBE == 14)
(1671) 					_DiluentMotRun(8, 160);		// 注入稀释液清洗
(1672) #elif 	(DILUTE_TUBE == 16)
(1673) 					_DiluentMotRun(3, 200);		
    046AC E104      LDI	R16,0x14
    046AD EF11      LDI	R17,0xF1
    046AE 940E 631B CALL	__SampPumpMotRun
    046B0 E081      LDI	R24,1
(1674) #endif
(1675) 					checkFluid = 1;
    046B1 9380 1659 STS	dustbinOldState+2,R24
    046B3 E188      LDI	R24,0x18
(1676) 					waitMotSampNeedle = 1;
    046B4 9380 160D STS	EvenPosChangeProcess+3,R24
(1677) 					workStep = 4;
    046B6 940C 4FC4 JMP	_SetReadTime0
    046B8 EF20      LDI	R18,0xF0
(1678) 					break;
    046B9 E403      LDI	R16,0x43
(1679) 				case 4:		// 取样臂运行到混匀池中部上方
(1680) 					_EffluentMotRun(5, 220);
    046BA E01D      LDI	R17,0xD
    046BB 940E 631B CALL	__SampPumpMotRun
    046BD E189      LDI	R24,0x19
    046BE 9380 160D STS	EvenPosChangeProcess+3,R24
(1681) 					_FluidMotRun(-1, 100);		// 回抽
    046C0 E081      LDI	R24,1
    046C1 9380 1659 STS	dustbinOldState+2,R24
    046C3 940C 4FC4 JMP	_SetReadTime0
(1682) 					MotRunTo(MOT_SAMP_TRUN, NeedleOnMixCenterPos);
    046C5 E022      LDI	R18,2
    046C6 E030      LDI	R19,0
    046C7 E003      LDI	R16,3
    046C8 940E 97B7 CALL	_SetDelayTime
    046CA E180      LDI	R24,0x10
(1683) 					waitMotSampTurn = 1;
    046CB 9380 160D STS	EvenPosChangeProcess+3,R24
    046CD 940C 4FC4 JMP	_SetReadTime0
(1684) 					workStep = 5;
    046CF 2422      CLR	R2
    046D0 9220 1613 STS	EvenPosChangeProcess+9,R2
(1685) 					break;
    046D2 E181      LDI	R24,0x11
    046D3 9380 160D STS	EvenPosChangeProcess+3,R24
(1686) 				case 5:		// 取样针下降到混匀池顶部
(1687) 					MotStop(MOT_EFFLUENT);		// 如果废液泵未停止，将其停止
(1688) 					MotRunTo(MOT_SAMP_NEEDLE, _POS_MIX_TOP);
    046D5 9180 00C1 LDS	R24,0xC1
    046D7 7E8F      ANDI	R24,0xEF
    046D8 9380 00C1 STS	0xC1,R24
(1689) 					waitMotSampNeedle = 1;
    046DA E92A      LDI	R18,0x9A
    046DB E133      LDI	R19,0x13
    046DC E80F      LDI	R16,0x8F
(1690) 					waitMotFluid = 1;	// 等待清洗液注入混匀池完毕
    046DD E016      LDI	R17,6
    046DE 940E A90D CALL	_uart_Printf
(1691) 					SetEValve(EV2,EV_OPEN);		// 开启取样针通道准备清洗取样针内壁
    046E0 9180 00C1 LDS	R24,0xC1
    046E2 6180      ORI	R24,0x10
(1692) 					SetEValve(EV3,EV_CLOSE);
    046E3 9380 00C1 STS	0xC1,R24
    046E5 940C 4FC4 JMP	_SetReadTime0
(1693) 					//workStep = 6;	// 2016-09-18
(1694) 					//if(NewTestInfo.sampDiluteMult == 1 || NewTestInfo.sampDiluteMult == 2 || NewTestInfo.sampDiluteMult == 6)
(1695) 					//add by pan 20161110稀释倍数是50的时候
(1696) 					if(NewTestInfo.sampDiluteMult < 7 || NewTestInfo.sampDiluteMult > 11)
    046E7 EF20      LDI	R18,0xF0
    046E8 2700      CLR	R16
    046E9 2711      CLR	R17
    046EA 940E 62FB CALL	__NeedleMotRunTo
    046EC E081      LDI	R24,1
    046ED 9380 165A STS	dustbinOldState+3,R24
    046EF E182      LDI	R24,0x12
(1697) 					// 稀释比例小于100,按原倍清洗模式
(1698) 					{
(1699) 						sc = 0;		// 原倍清洗次数
    046F0 9380 160D STS	EvenPosChangeProcess+3,R24
    046F2 940C 4FC4 JMP	_SetReadTime0
(1700) 						workStep = 6;
    046F4 E023      LDI	R18,3
    046F5 E030      LDI	R19,0
(1701) 					}
    046F6 E003      LDI	R16,3
(1702) 					else
(1703) 					{
(1704) 						workStep = 10;	
    046F7 940E 97B7 CALL	_SetDelayTime
    046F9 EE89      LDI	R24,0xE9
(1705) 					}
(1706) 					break;
    046FA 9380 165F STS	GetNewTestCard,R24
(1707) 				case 6:		// 原倍模式取样针内壁清洗
(1708) 					sc ++;
    046FC E089      LDI	R24,0x9
    046FD 9380 160C STS	EvenPosChangeProcess+2,R24
    046FF 2422      CLR	R2
(1709) 					SetEValve(EV2,EV_OPEN);	
    04700 9220 160D STS	EvenPosChangeProcess+3,R2
    04702 940C 4FC4 JMP	_SetReadTime0
(1710) 					_FluidMotRun(10, 100);		// 注入清洗液
    04704 90C0 160D LDS	R12,EvenPosChangeProcess+3
    04706 24DD      CLR	R13
    04707 01C6      MOVW	R24,R12
    04708 3080      CPI	R24,0
(1711) 					MotInitCheck(MOT_SAMP_PUMP);	// 样品注射器回零
    04709 E0E0      LDI	R30,0
    0470A 079E      CPC	R25,R30
    0470B F414      BGE	0x470E
(1712) 					waitMotFluid = 1;
    0470C 940C 4FC4 JMP	_SetReadTime0
    0470E E183      LDI	R24,0x13
(1713) 					workStep = 7;
    0470F 158C      CP	R24,R12
    04710 059D      CPC	R25,R13
    04711 F05C      BLT	0x471D
(1714) 					break;
    04712 E88E      LDI	R24,0x8E
(1715) 				case 7:
(1716) 					_EffluentMotRun(15, 240);		// 2017-05-22 220->240
    04713 E092      LDI	R25,2
    04714 01F6      MOVW	R30,R12
    04715 0FEE      LSL	R30
    04716 1FFF      ROL	R31
    04717 0FE8      ADD	R30,R24
(1717) 					waitEffluent = 1;
    04718 1FF9      ADC	R31,R25
    04719 9027      ELPM	R2,Z+
    0471A 9036      ELPM	R3,Z
(1718) 					if(sc < 3)			
    0471B 01F1      MOVW	R30,R2
    0471C 9409      IJMP
    0471D 01C6      MOVW	R24,R12
    0471E 3684      CPI	R24,0x64
(1719) 						workStep = 6;
    0471F E0E0      LDI	R30,0
    04720 079E      CPC	R25,R30
    04721 F409      BNE	0x4723
    04722 C288      RJMP	0x49AB
(1720) 					else
(1721) 						workStep = 10;
    04723 3685      CPI	R24,0x65
    04724 E0E0      LDI	R30,0
    04725 079E      CPC	R25,R30
(1722) 					break;
    04726 F409      BNE	0x4728
(1723) 				case 10:		// 稀释模式清洗取样针内壁
(1724) 					//if(NewTestInfo.sampDiluteMult == 1)	// 2016-09-18
(1725) 					//_SampPumpMotRunTo(0, 220);			// 2016-09-18
(1726) 					_FluidMotRun(8, 100);		// 注入清洗液
    04727 C29D      RJMP	0x49C5
    04728 3686      CPI	R24,0x66
    04729 E0E0      LDI	R30,0
    0472A 079E      CPC	R25,R30
    0472B F409      BNE	0x472D
(1727) 					MotInitCheck(MOT_SAMP_PUMP);	// 样品注射器回零
    0472C C2B1      RJMP	0x49DE
    0472D 3687      CPI	R24,0x67
    0472E E0E0      LDI	R30,0
(1728) 					waitMotSampPump = 1;
    0472F 079E      CPC	R25,R30
    04730 F409      BNE	0x4732
    04731 C2BD      RJMP	0x49EF
(1729) 					waitMotFluid = 1;
    04732 3688      CPI	R24,0x68
    04733 E0E0      LDI	R30,0
(1730) 					workStep = 11;
    04734 079E      CPC	R25,R30
    04735 F409      BNE	0x4737
    04736 C2C9      RJMP	0x4A00
(1731) 					break;
    04737 3689      CPI	R24,0x69
(1732) 				case 11:
(1733) 					SetEValve(EV2,EV_CLOSE);
    04738 E0E0      LDI	R30,0
    04739 079E      CPC	R25,R30
    0473A F409      BNE	0x473C
    0473B C2D8      RJMP	0x4A14
(1734) 					SetEValve(EV1,EV_OPEN);
    0473C 368A      CPI	R24,0x6A
    0473D E0E0      LDI	R30,0
    0473E 079E      CPC	R25,R30
    0473F F409      BNE	0x4741
(1735) 					SetDelayTime(MOT_SAMP_NEEDLE, 2); 
    04740 C302      RJMP	0x4A43
    04741 368B      CPI	R24,0x6B
    04742 E0E0      LDI	R30,0
    04743 079E      CPC	R25,R30
    04744 F409      BNE	0x4746
(1736) 					workStep = 12;
    04745 C312      RJMP	0x4A58
    04746 368C      CPI	R24,0x6C
    04747 E0E0      LDI	R30,0
(1737) 					break;
    04748 079E      CPC	R25,R30
(1738) 				case 12:		// 正常稀释模式 清洗取样针外壁
(1739) 					SetEValve(EV2,EV_CLOSE);
    04749 F409      BNE	0x474B
    0474A C31E      RJMP	0x4A69
    0474B 368D      CPI	R24,0x6D
    0474C E0E0      LDI	R30,0
(1740) 					SetEValve(EV1,EV_OPEN);
    0474D 079E      CPC	R25,R30
    0474E F409      BNE	0x4750
    0474F C2E2      RJMP	0x4A32
    04750 940C 4FC4 JMP	_SetReadTime0
(1741) 					_FluidMotRun(8,120);					
    04752 9180 165F LDS	R24,GetNewTestCard
    04754 3F8E      CPI	R24,0xFE
    04755 F009      BEQ	0x4757
(1742) 					waitMotFluid = 1;
    04756 C0F1      RJMP	0x4848
    04757 940E 9EA7 CALL	_RingQueueInsertCalculate
(1743) 					workStep = 13;
    04759 0168      MOVW	R12,R16
    0475A 92C0 1660 STS	CurInsertRingNum,R12
(1744) 					break;
    0475C 2D8C      MOV	R24,R12
(1745) 				case 13:		// 启动负压
(1746) 					checkFluid = 0;
    0475D 3F0F      CPI	R16,0xFF
    0475E F409      BNE	0x4760
    0475F C06D      RJMP	0x47CD
(1747) 					SetEValve(EV3, EV_OPEN);
    04760 2422      CLR	R2
    04761 9220 0539 STS	stopTestFlag+5,R2
    04763 2F28      MOV	R18,R24
(1748) 					_EffluentMotRun(55, 240);	
    04764 2733      CLR	R19
    04765 E601      LDI	R16,0x61
    04766 E116      LDI	R17,0x16
    04767 940E A135 CALL	_InsertNewTest
(1749) 					workStep = 14;
    04769 0168      MOVW	R12,R16
    0476A 92C0 1612 STS	EvenPosChangeProcess+8,R12
(1750) 					break;
    0476C 2300      TST	R16
(1751) 				case 14:		// 取样针上升，吸干清洗池
(1752) 					_FluidMotRun(-1, 160);
    0476D F011      BEQ	0x4770
    0476E 940C 4FC4 JMP	_SetReadTime0
    04770 E621      LDI	R18,0x61
    04771 E136      LDI	R19,0x16
(1753) 					MotInitCheck(MOT_SAMP_NEEDLE);
    04772 9100 1660 LDS	R16,CurInsertRingNum
    04774 2711      CLR	R17
(1754) 					waitMotSampNeedle = 1;
    04775 940E 9EE1 CALL	_RingQueueInsert
    04777 EC81      LDI	R24,0xC1
(1755) 					waitMotFluid = 1;
    04778 E19D      LDI	R25,0x1D
    04779 91E0 1660 LDS	R30,CurInsertRingNum
(1756) 					workStep = 15;
    0477B 27FF      CLR	R31
    0477C 0FE8      ADD	R30,R24
(1757) 					break;
    0477D 1FF9      ADC	R31,R25
(1758) 				case 15:	// 取样臂旋转到取样位
(1759) 					SetEValve(EV1,EV_CLOSE);
    0477E 2422      CLR	R2
    0477F 8220      ST	Z,R2
    04780 9020 166C LDS	R2,timeOut
(1760) 					SetMotRunPam(MOT_SAMP_TRUN,255,5,CURRENT_SAMP_TRUN);
    04782 9030 166D LDS	R3,timeOut+1
    04784 2022      TST	R2
    04785 F411      BNE	0x4788
    04786 2033      TST	R3
    04787 F0F9      BEQ	0x47A7
    04788 2444      CLR	R4
    04789 2455      CLR	R5
(1761) 					MotRunTo(MOT_SAMP_TRUN, _POS_SAMPTURN_SAMP);
    0478A 9080 0529 LDS	R8,SecondCount+2
    0478C 9090 052A LDS	R9,SecondCount+3
    0478E 9060 0527 LDS	R6,SecondCount
(1762) 					waitMotSampTurn = 1;
    04790 9070 0528 LDS	R7,SecondCount+1
(1763) 					workStep = 19;
    04792 0C62      ADD	R6,R2
    04793 1C73      ADC	R7,R3
    04794 1C84      ADC	R8,R4
(1764) 					break;
    04795 1C95      ADC	R9,R5
(1765) 				case 19:
(1766) 					SetEValve(EV3, EV_CLOSE);	// 废液泵转到排混匀池
    04796 E248      LDI	R20,0x28
    04797 E050      LDI	R21,0
    04798 E060      LDI	R22,0
    04799 E070      LDI	R23,0
(1767) 					workStep = 16;
    0479A 0E64      ADD	R6,R20
    0479B 1E75      ADC	R7,R21
    0479C 1E86      ADC	R8,R22
(1768) 					break;
    0479D 1E97      ADC	R9,R23
(1769) 				case 16:	// 取样针下降到取样位
(1770) 				//	if(InsertRingFlag == 0)		break;		// 试剂片未推进装盘
(1771) 					InsertRingFlag = 0;
    0479E 8288      ST	Y,R8
    0479F 8299      STD	Y+1,R9
    047A0 0193      MOVW	R18,R6
(1772) #ifndef Puncture				
(1773) 					_NeedleMotRunTo(_POS_SAMP_DOWN, 255);
    047A1 9100 1660 LDS	R16,CurInsertRingNum
    047A3 2711      CLR	R17
    047A4 940E A9CB CALL	_UnloadQueueAdd
(1774) #endif					
(1775) 					// 预吸空气段
(1776) 					MotRun(MOT_SAMP_PUMP, _SAMP_PUMP_INTERVAL + _SAMP_PUMP_AIR_ISOLATE);
    047A6 C022      RJMP	0x47C9
    047A7 9020 166A LDS	R2,checkLB
    047A9 9030 166B LDS	R3,checkHB
(1777) 					waitMotSampNeedle = 1;
    047AB 2444      CLR	R4
    047AC 2455      CLR	R5
    047AD 9080 0529 LDS	R8,SecondCount+2
(1778) 					workStep = 17;
    047AF 9090 052A LDS	R9,SecondCount+3
(1779) 					break;
    047B1 9060 0527 LDS	R6,SecondCount
(1780) 				case 17:	// 
(1781) 					SetBeepPrompt();
    047B3 9070 0528 LDS	R7,SecondCount+1
(1782) 					SetStateLedFree();
    047B5 0C62      ADD	R6,R2
(1783) 					workStep = 18;
    047B6 1C73      ADC	R7,R3
    047B7 1C84      ADC	R8,R4
    047B8 1C95      ADC	R9,R5
(1784) 					break;
    047B9 E248      LDI	R20,0x28
(1785) 				case 18:	// 结束
(1786) 					Uart0ReUnable;
    047BA E050      LDI	R21,0
    047BB E060      LDI	R22,0
    047BC E070      LDI	R23,0
    047BD 0E64      ADD	R6,R20
    047BE 1E75      ADC	R7,R21
(1787) 					uart_Printf("%s\r\n",strM3102);
    047BF 1E86      ADC	R8,R22
    047C0 1E97      ADC	R9,R23
    047C1 8288      ST	Y,R8
    047C2 8299      STD	Y+1,R9
    047C3 0193      MOVW	R18,R6
    047C4 9100 1660 LDS	R16,CurInsertRingNum
(1788) 					Uart0ReEnable;
    047C6 2711      CLR	R17
    047C7 940E A9CB CALL	_UnloadQueueAdd
    047C9 E081      LDI	R24,1
(1789) 					mainStep = 1;
    047CA 9380 160D STS	EvenPosChangeProcess+3,R24
    047CC C7F7      RJMP	_SetReadTime0
(1790) 					workStep = 0;
    047CD E322      LDI	R18,0x32
    047CE E030      LDI	R19,0
    047CF E003      LDI	R16,3
(1791) 					break;
(1792) 				}
(1793) 			break;
    047D0 940E 97B7 CALL	_SetDelayTime
(1794) 		case 10:	// 结束退出
(1795) 			switch(workStep){
    047D2 9180 0539 LDS	R24,stopTestFlag+5
    047D4 5F8F      SUBI	R24,0xFF
    047D5 9380 0539 STS	stopTestFlag+5,R24
    047D7 3083      CPI	R24,3
    047D8 F408      BCC	0x47DA
    047D9 C7EA      RJMP	_SetReadTime0
    047DA 2422      CLR	R2
    047DB 9220 0539 STS	stopTestFlag+5,R2
    047DD 90C0 1C17 LDS	R12,LampAState+356
    047DF 2D8C      MOV	R24,R12
    047E0 5F8F      SUBI	R24,0xFF
    047E1 9380 1C17 STS	LampAState+356,R24
(1796) 				case 0:
(1797) 					_EffluentMotRun(30, 220);
    047E3 92C0 1660 STS	CurInsertRingNum,R12
    047E5 2D8C      MOV	R24,R12
    047E6 318E      CPI	R24,0x1E
(1798) 					_NeedleMotRunTo(0, 180);//240
    047E7 F018      BCS	0x47EB
    047E8 518E      SUBI	R24,0x1E
    047E9 9380 1660 STS	CurInsertRingNum,R24
    047EB E621      LDI	R18,0x61
(1799) 					waitMotSampNeedle = 1;
    047EC E136      LDI	R19,0x16
    047ED 9100 1660 LDS	R16,CurInsertRingNum
(1800) 					workStep = 1;
    047EF 2711      CLR	R17
    047F0 940E 9EE1 CALL	_RingQueueInsert
(1801) 					TestALampClose();	// 关闭光源
    047F2 EC81      LDI	R24,0xC1
(1802) 					SetStateLedBusy();	// 状态指示灯为红
    047F3 E19D      LDI	R25,0x1D
    047F4 91E0 1660 LDS	R30,CurInsertRingNum
(1803) 					break;
    047F6 27FF      CLR	R31
    047F7 0FE8      ADD	R30,R24
    047F8 1FF9      ADC	R31,R25
    047F9 2422      CLR	R2
    047FA 8220      ST	Z,R2
    047FB 9020 166C LDS	R2,timeOut
    047FD 9030 166D LDS	R3,timeOut+1
(1804) 				case 1:
(1805) 					SetMotRunPam(MOT_SAMP_TRUN,255,10,CURRENT_SAMP_TRUN);
(1806) 					MotRunTo(MOT_SAMP_TRUN,0);
    047FF 2022      TST	R2
    04800 F411      BNE	0x4803
    04801 2033      TST	R3
    04802 F0F9      BEQ	0x4822
(1807) 					waitMotSampTurn = 1;
    04803 2444      CLR	R4
    04804 2455      CLR	R5
    04805 9080 0529 LDS	R8,SecondCount+2
(1808) 					waitEffluent = 1;
    04807 9090 052A LDS	R9,SecondCount+3
(1809) 					workStep = 2;
    04809 9060 0527 LDS	R6,SecondCount
(1810) 					break;
    0480B 9070 0528 LDS	R7,SecondCount+1
(1811) 				case 2:
(1812) 					mainStep = 0;
    0480D 0C62      ADD	R6,R2
    0480E 1C73      ADC	R7,R3
(1813) 					workStep = 0;
    0480F 1C84      ADC	R8,R4
    04810 1C95      ADC	R9,R5
(1814) 					return 2;
    04811 E248      LDI	R20,0x28
    04812 E050      LDI	R21,0
(1815) 					break;
(1816) 				default:
(1817) 					break;
(1818) 				}
(1819) 			return 1;
    04813 E060      LDI	R22,0
    04814 E070      LDI	R23,0
(1820) 			break;
(1821) 		case 11:	// 异常处理
(1822) 			switch(workStep){
    04815 0E64      ADD	R6,R20
    04816 1E75      ADC	R7,R21
    04817 1E86      ADC	R8,R22
    04818 1E97      ADC	R9,R23
    04819 8288      ST	Y,R8
    0481A 8299      STD	Y+1,R9
    0481B 0193      MOVW	R18,R6
    0481C 9100 1660 LDS	R16,CurInsertRingNum
    0481E 2711      CLR	R17
    0481F 940E A9CB CALL	_UnloadQueueAdd
    04821 C022      RJMP	0x4844
    04822 9020 166A LDS	R2,checkLB
    04824 9030 166B LDS	R3,checkHB
    04826 2444      CLR	R4
    04827 2455      CLR	R5
    04828 9080 0529 LDS	R8,SecondCount+2
    0482A 9090 052A LDS	R9,SecondCount+3
    0482C 9060 0527 LDS	R6,SecondCount
    0482E 9070 0528 LDS	R7,SecondCount+1
    04830 0C62      ADD	R6,R2
    04831 1C73      ADC	R7,R3
    04832 1C84      ADC	R8,R4
    04833 1C95      ADC	R9,R5
    04834 E248      LDI	R20,0x28
    04835 E050      LDI	R21,0
    04836 E060      LDI	R22,0
    04837 E070      LDI	R23,0
    04838 0E64      ADD	R6,R20
    04839 1E75      ADC	R7,R21
    0483A 1E86      ADC	R8,R22
    0483B 1E97      ADC	R9,R23
    0483C 8288      ST	Y,R8
    0483D 8299      STD	Y+1,R9
(1823) 				case 0:		// 停止当前运行
(1824) 					SetDelayTime(MOT_EFFLUENT, 30);
    0483E 0193      MOVW	R18,R6
    0483F 9100 1660 LDS	R16,CurInsertRingNum
    04841 2711      CLR	R17
    04842 940E A9CB CALL	_UnloadQueueAdd
(1825) 					workStep = 1;
    04844 E081      LDI	R24,1
    04845 9380 160D STS	EvenPosChangeProcess+3,R24
(1826) 					break;
    04847 C77C      RJMP	_SetReadTime0
    04848 9180 165F LDS	R24,GetNewTestCard
(1827) 				case 1:		// 废液泵延迟停止
(1828) 					MotStop(MOT_EFFLUENT);
(1829) 					workStep = 2;
    0484A 3F8A      CPI	R24,0xFA
    0484B F009      BEQ	0x484D
    0484C C777      RJMP	_SetReadTime0
(1830) 					break;
    0484D 9120 1646 LDS	R18,_NewCardStoreNum+6
(1831) 				case 2:		// 取样针回到起始点
(1832) 					_NeedleMotRunTo(0, 180);//240
    0484F 9130 1647 LDS	R19,_NewCardStoreNum+7
    04851 E002      LDI	R16,2
    04852 940E 6A5B CALL	_MotRunTo
(1833) 					waitMotSampNeedle = 1;
    04854 E081      LDI	R24,1
    04855 9380 165B STS	dustbinOldState+4,R24
(1834) 					workStep = 3;
    04857 E085      LDI	R24,5
    04858 9380 160D STS	EvenPosChangeProcess+3,R24
(1835) 					break;
    0485A C769      RJMP	_SetReadTime0
    0485B EB24      LDI	R18,0xB4
    0485C 9100 1644 LDS	R16,_NewCardStoreNum+4
(1836) 				case 3:		// 废液泵排液
(1837) 					SetEValve(EV_ALL, EV_CLOSE);
(1838) 					_EffluentMotRun(30, 200);
    0485E 9110 1645 LDS	R17,_NewCardStoreNum+5
    04860 940E 62FB CALL	__NeedleMotRunTo
    04862 E081      LDI	R24,1
(1839) 					waitEffluent = 1;
    04863 9380 165A STS	dustbinOldState+3,R24
    04865 E082      LDI	R24,2
(1840) 					workStep = 4;
    04866 9380 160D STS	EvenPosChangeProcess+3,R24
    04868 C75B      RJMP	_SetReadTime0
(1841) 					break;
    04869 9020 1654 LDS	R2,_DropVolume|diluteProcessState
(1842) 				case 4:		// 取样针运行到清洗池上方
(1843) 					MotInitCheck(MOT_SAMP_TRUN);
    0486B 9030 1655 LDS	R3,GetNewPieceProcessState
(1844) 				//	MotRunTo(MOT_SAMP_TRUN,0);
(1845) 					waitMotSampTurn = 1;
    0486D 2022      TST	R2
    0486E F411      BNE	0x4871
    0486F 2033      TST	R3
(1846) 					workStep = 5;
    04870 F131      BEQ	0x4897
    04871 940E 5552 CALL	_GetDropVolumeFactor
(1847) 					break;
    04873 0168      MOVW	R12,R16
(1848) 				case 5:
(1849) 					
(1850) 					MotRunTo(MOT_SAMP_TRUN, NeedleOnMixCenterPos);
    04874 90A0 1654 LDS	R10,_DropVolume|diluteProcessState
    04876 90B0 1655 LDS	R11,GetNewPieceProcessState
    04878 0EA0      ADD	R10,R16
    04879 1EB1      ADC	R11,R17
    0487A EB24      LDI	R18,0xB4
(1851) 					waitMotSampTurn = 1;
    0487B 0185      MOVW	R16,R10
    0487C 9500      COM	R16
    0487D 9510      COM	R17
(1852) 					workStep = 6;
    0487E 5F0F      SUBI	R16,0xFF
    0487F 4F1F      SBCI	R17,0xFF
    04880 940E 631B CALL	__SampPumpMotRun
(1853) 					break;
    04882 9180 00C1 LDS	R24,0xC1
    04884 7E8F      ANDI	R24,0xEF
    04885 9380 00C1 STS	0xC1,R24
(1854) 				case 6:		// 取样针下降到清洗池中准备清洗
(1855) 					_NeedleMotRunTo(_POS_MIX_TOP, 180);//240
(1856) 					waitMotSampNeedle = 1;
    04887 82B9      STD	Y+1,R11
    04888 82A8      ST	Y,R10
    04889 E32B      LDI	R18,0x3B
(1857) 					workStep = 7;
    0488A E130      LDI	R19,0x10
    0488B E904      LDI	R16,0x94
    0488C E016      LDI	R17,6
(1858) 					break;
    0488D 940E A90D CALL	_uart_Printf
(1859) 				case 7:		// 注入清洗液到混匀池中，然后跳转到正常的测试结束清洗程序，继续运行正常程序
(1860) 					_FluidMotRun(10, 80);		// 开启清洗液洗混匀池,注入1.4mL清洗液
    0488F 9180 00C1 LDS	R24,0xC1
    04891 6180      ORI	R24,0x10
    04892 9380 00C1 STS	0xC1,R24
(1861) 					waitMotFluid = 1;	// 等待清洗液注入混匀池完毕
    04894 E081      LDI	R24,1
    04895 9380 1659 STS	dustbinOldState+2,R24
(1862) 					mainStep = 9;		// 直接进入清洗
    04897 E083      LDI	R24,3
    04898 9380 160D STS	EvenPosChangeProcess+3,R24
(1863) 					workStep = 6;
    0489A C729      RJMP	_SetReadTime0
    0489B 940E 3739 CALL	_SetBeepAck
(1864) 					InsertRingFlag = 1;	// 保证吸样针下来
    0489D 9180 00C1 LDS	R24,0xC1
(1865) 					break;
(1866) 				default:
(1867) 					break;
(1868) 				}
(1869) 			break;
    0489F 7E8F      ANDI	R24,0xEF
(1870) 		case 12:	// 清洗液空
(1871) 			switch(workStep){
    048A0 9380 00C1 STS	0xC1,R24
    048A2 E927      LDI	R18,0x97
    048A3 E03D      LDI	R19,0xD
    048A4 E30E      LDI	R16,0x3E
    048A5 E016      LDI	R17,6
    048A6 940E A90D CALL	_uart_Printf
    048A8 9120 1664 LDS	R18,LiquidPhoNum
    048AA 9130 1665 LDS	R19,timeOut
    048AC 9100 1662 LDS	R16,NewTestInfo|liqDetBaseAdc+1
    048AE 9110 1663 LDS	R17,CardStorePhoNum
    048B0 940E A940 CALL	_uart0SendInt
    048B2 E307      LDI	R16,0x37
    048B3 E016      LDI	R17,6
    048B4 940E A90D CALL	_uart_Printf
    048B6 9120 0529 LDS	R18,SecondCount+2
    048B8 9130 052A LDS	R19,SecondCount+3
    048BA 9100 0527 LDS	R16,SecondCount
    048BC 9110 0528 LDS	R17,SecondCount+1
    048BE 940E A940 CALL	_uart0SendInt
    048C0 E30B      LDI	R16,0x3B
    048C1 E016      LDI	R17,6
    048C2 940E A90D CALL	_uart_Printf
    048C4 9180 00C1 LDS	R24,0xC1
    048C6 6180      ORI	R24,0x10
    048C7 9380 00C1 STS	0xC1,R24
    048C9 EB24      LDI	R18,0xB4
    048CA 2700      CLR	R16
    048CB 2711      CLR	R17
    048CC 940E 62FB CALL	__NeedleMotRunTo
    048CE EF8F      LDI	R24,0xFF
    048CF 9380 165F STS	GetNewTestCard,R24
    048D1 E420      LDI	R18,0x40
    048D2 E005      LDI	R16,5
    048D3 E010      LDI	R17,0
    048D4 940E 6264 CALL	__FluidMotRun
    048D6 EC28      LDI	R18,0xC8
(1872) 				case 0:
(1873) 					if(0 == CleanMode)
    048D7 E003      LDI	R16,3
    048D8 E010      LDI	R17,0
    048D9 940E 62A2 CALL	__DiluentMotRun
(1874) 					{
(1875) #ifndef UartSendLong
(1876) 					Uart0ReUnable;
(1877) 					uart_Printf("!3901 $%8d\r\n", NewTestInfo.testSerial);
(1878) 					Uart0ReEnable;
(1879) #else
(1880) 					Uart0ReUnable;
    048DB E081      LDI	R24,1
    048DC 9380 1610 STS	EvenPosChangeProcess+6,R24
    048DE 9380 165A STS	dustbinOldState+3,R24
(1881) 					uart_Printf("!3901 $ ");
    048E0 E084      LDI	R24,4
    048E1 9380 160D STS	EvenPosChangeProcess+3,R24
    048E3 C6E0      RJMP	_SetReadTime0
(1882) 					uart0SendInt(NewTestInfo.testSerial);
    048E4 ED2C      LDI	R18,0xDC
    048E5 E005      LDI	R16,5
    048E6 E010      LDI	R17,0
    048E7 940E 6289 CALL	__EffluentMotRun
    048E9 E624      LDI	R18,0x64
    048EA EF0F      LDI	R16,0xFF
    048EB EF1F      LDI	R17,0xFF
    048EC 940E 6264 CALL	__FluidMotRun
(1883) 					uart_Printf("\r\n");
    048EE 9120 1646 LDS	R18,_NewCardStoreNum+6
    048F0 9130 1647 LDS	R19,_NewCardStoreNum+7
(1884) 					Uart0ReEnable;
    048F2 E002      LDI	R16,2
    048F3 940E 6A5B CALL	_MotRunTo
    048F5 E081      LDI	R24,1
    048F6 9380 165B STS	dustbinOldState+4,R24
(1885) #endif	
(1886) 					}
    048F8 E085      LDI	R24,5
    048F9 9380 160D STS	EvenPosChangeProcess+3,R24
    048FB C6C8      RJMP	_SetReadTime0
(1887) 					else
(1888) 					{
(1889) 						if(1 == CleanMode)
(1890) 							CleanMode = 250;
    048FC E00B      LDI	R16,0xB
    048FD 940E 6A13 CALL	_MotStop
    048FF E628      LDI	R18,0x68
(1891) 						else if(2 == CleanMode)
    04900 E031      LDI	R19,1
    04901 E003      LDI	R16,3
    04902 940E 6A5B CALL	_MotRunTo
(1892) 							CleanMode = 255;
    04904 E081      LDI	R24,1
    04905 9380 165A STS	dustbinOldState+3,R24
(1893) 						Uart0ReUnable;
    04907 9380 1658 STS	dustbinOldState+1,R24
    04909 E021      LDI	R18,1
    0490A E002      LDI	R16,2
    0490B 940E 6B81 CALL	_SetEValve
(1894) 						uart_Printf("%s \r\n", strE3905);
    0490D 2722      CLR	R18
    0490E E003      LDI	R16,3
    0490F 940E 6B81 CALL	_SetEValve
    04911 9180 1668 LDS	R24,j
(1895) 						Uart0ReEnable;
    04913 3087      CPI	R24,7
    04914 F028      BCS	0x491A
    04915 E08B      LDI	R24,0xB
    04916 9020 1668 LDS	R2,j
(1896) 						mainStep = 0;
    04918 1582      CP	R24,R2
    04919 F438      BCC	0x4921
(1897) 						workStep = 16;
    0491A 2422      CLR	R2
    0491B 9220 1614 STS	EvenPosChangeProcess+10,R2
(1898) 						break;
    0491D E086      LDI	R24,6
(1899) 					}
(1900) 					MotStop(MOT_SAMP_NEEDLE);
    0491E 9380 160D STS	EvenPosChangeProcess+3,R24
    04920 C6A3      RJMP	_SetReadTime0
(1901) 					MotStop(MOT_FLUID);
    04921 E08A      LDI	R24,0xA
    04922 9380 160D STS	EvenPosChangeProcess+3,R24
(1902) 					SetDelayTime(MOT_EFFLUENT, 30);
    04924 C69F      RJMP	_SetReadTime0
    04925 9180 1614 LDS	R24,EvenPosChangeProcess+10
    04927 5F8F      SUBI	R24,0xFF
    04928 9380 1614 STS	EvenPosChangeProcess+10,R24
(1903) 					workStep = 1;
    0492A E021      LDI	R18,1
    0492B E002      LDI	R16,2
(1904) 					break;
    0492C 940E 6B81 CALL	_SetEValve
(1905) 				case 1:
(1906) 					MotStop(MOT_EFFLUENT);
    0492E E624      LDI	R18,0x64
    0492F E00A      LDI	R16,0xA
(1907) 					workStep = 2;
    04930 E010      LDI	R17,0
    04931 940E 6264 CALL	__FluidMotRun
(1908) 					break;
    04933 E00C      LDI	R16,0xC
(1909) 				case 2:
(1910) 					SetEValve(EV_ALL, EV_CLOSE);
    04934 940E 6AFA CALL	_MotInitCheck
    04936 E081      LDI	R24,1
    04937 9380 1658 STS	dustbinOldState+1,R24
(1911) 					_EffluentMotRun(30, 200);
    04939 E087      LDI	R24,7
    0493A 9380 160D STS	EvenPosChangeProcess+3,R24
    0493C C687      RJMP	_SetReadTime0
(1912) 					waitEffluent = 1;
    0493D EF20      LDI	R18,0xF0
    0493E E00F      LDI	R16,0xF
    0493F E010      LDI	R17,0
(1913) 					workStep = 3;
    04940 940E 6289 CALL	__EffluentMotRun
    04942 E081      LDI	R24,1
(1914) 					break;
    04943 9380 1656 STS	CardScanfSW,R24
(1915) 				case 3:
(1916) 					MotInitCheck(MOT_SAMP_NEEDLE);
    04945 E08A      LDI	R24,0xA
    04946 9380 160D STS	EvenPosChangeProcess+3,R24
(1917) 					waitMotSampNeedle = 1;
    04948 C67B      RJMP	_SetReadTime0
    04949 E624      LDI	R18,0x64
(1918) 					workStep = 4;
    0494A E008      LDI	R16,0x8
    0494B E010      LDI	R17,0
    0494C 940E 6264 CALL	__FluidMotRun
(1919) 					break;
    0494E E00C      LDI	R16,0xC
    0494F 940E 6AFA CALL	_MotInitCheck
    04951 E081      LDI	R24,1
    04952 9380 1659 STS	dustbinOldState+2,R24
(1920) 				case 4:	// 取样针回到起始点
(1921) 					MotRunTo(MOT_SAMP_TRUN,0);
(1922) 					waitMotSampTurn = 1;
    04954 9380 1658 STS	dustbinOldState+1,R24
(1923) 					workStep = 5;
    04956 E08B      LDI	R24,0xB
    04957 9380 160D STS	EvenPosChangeProcess+3,R24
(1924) 					break;
    04959 C66A      RJMP	_SetReadTime0
(1925) 				case 5:	// 取样针运行到混匀池中准备清洗针内壁
(1926) 					MotRunTo(MOT_SAMP_TRUN,NeedleOnMixCenterPos);
    0495A 2722      CLR	R18
    0495B E002      LDI	R16,2
    0495C 940E 6B81 CALL	_SetEValve
    0495E E021      LDI	R18,1
    0495F E001      LDI	R16,1
    04960 940E 6B81 CALL	_SetEValve
(1927) 					waitMotSampTurn = 1;
    04962 E022      LDI	R18,2
    04963 E030      LDI	R19,0
(1928) 					workStep = 6;
    04964 E003      LDI	R16,3
    04965 940E 97B7 CALL	_SetDelayTime
(1929) 					break;
    04967 E08C      LDI	R24,0xC
(1930) 				case 6:
(1931) 					_NeedleMotRunTo(_POS_MIX_TOP, 200);//240
    04968 9380 160D STS	EvenPosChangeProcess+3,R24
    0496A C659      RJMP	_SetReadTime0
    0496B 2722      CLR	R18
    0496C E002      LDI	R16,2
(1932) 					SetEValve(EV2, EV_OPEN);
    0496D 940E 6B81 CALL	_SetEValve
    0496F E021      LDI	R18,1
    04970 E001      LDI	R16,1
(1933) 					waitMotSampNeedle = 1;
    04971 940E 6B81 CALL	_SetEValve
    04973 E728      LDI	R18,0x78
(1934) 					workStep = 7;
    04974 E008      LDI	R16,0x8
    04975 E010      LDI	R17,0
    04976 940E 6264 CALL	__FluidMotRun
(1935) 					break;
    04978 E081      LDI	R24,1
    04979 9380 1658 STS	dustbinOldState+1,R24
    0497B E08D      LDI	R24,0xD
    0497C 9380 160D STS	EvenPosChangeProcess+3,R24
(1936) 				case 7:
(1937) 					_FluidMotRun(10, 60);		// 开启清洗液洗混匀池,注入1.4mL清洗液
(1938) 					_EffluentMotRun(20, 80);
    0497E C645      RJMP	_SetReadTime0
    0497F 2422      CLR	R2
    04980 9220 1610 STS	EvenPosChangeProcess+6,R2
(1939) 					waitMotFluid = 1;	// 等待清洗液注入混匀池完毕
    04982 E021      LDI	R18,1
    04983 E003      LDI	R16,3
    04984 940E 6B81 CALL	_SetEValve
(1940) 					waitEffluent = 1;
    04986 EF20      LDI	R18,0xF0
(1941) 					workStep = 8;
    04987 E307      LDI	R16,0x37
    04988 E010      LDI	R17,0
    04989 940E 6289 CALL	__EffluentMotRun
(1942) 					break;
    0498B E08E      LDI	R24,0xE
    0498C 9380 160D STS	EvenPosChangeProcess+3,R24
    0498E C635      RJMP	_SetReadTime0
(1943) 				case 8:
(1944) 					SetEValve(EV_ALL, EV_CLOSE);
(1945) 					workStep = 9;
    0498F EA20      LDI	R18,0xA0
    04990 EF0F      LDI	R16,0xFF
    04991 EF1F      LDI	R17,0xFF
(1946) 					break;
    04992 940E 6264 CALL	__FluidMotRun
(1947) 				case 9:
(1948) 					SetDelayTime(MOT_EFFLUENT, 2);
    04994 E003      LDI	R16,3
    04995 940E 6AFA CALL	_MotInitCheck
    04997 E081      LDI	R24,1
(1949) 					ucTmp = _PrimingFluid();
    04998 9380 165A STS	dustbinOldState+3,R24
    0499A 9380 1658 STS	dustbinOldState+1,R24
    0499C 9180 1668 LDS	R24,j
(1950) 					if(ucTmp == 1){	// 自动灌注完成
    0499E 308D      CPI	R24,0xD
(1951) 						workStep = 3;
    0499F F439      BNE	0x49A7
    049A0 E084      LDI	R24,4
    049A1 9380 1614 STS	EvenPosChangeProcess+10,R24
(1952) 						mainStep = 11;
    049A3 E684      LDI	R24,0x64
    049A4 9380 160D STS	EvenPosChangeProcess+3,R24
(1953) 						}
    049A6 C61D      RJMP	_SetReadTime0
    049A7 E08F      LDI	R24,0xF
    049A8 9380 160D STS	EvenPosChangeProcess+3,R24
    049AA C619      RJMP	_SetReadTime0
(1954) 					else if(ucTmp == 0xff){		// 自动灌注失败，进入程序开始阶段等待手动开始液体灌注
(1955) 					/*
(1956) #ifndef UartSendLong
(1957) 						Uart0ReUnable;
(1958) 						uart_Printf("%s $%8d\r\n", strE3902,NewTestInfo.testSerial);
(1959) 						Uart0ReEnable;
(1960) #else
(1961) 						Uart0ReUnable;
(1962) 						uart_Printf("%s $ ",strE3902);
(1963) 						uart0SendInt(NewTestInfo.testSerial);
(1964) 						uart_Printf("\r\n");
(1965) 						Uart0ReEnable;
(1966) #endif
(1967) 					*/
(1968) 						Uart0ReUnable;
    049AB 9180 1614 LDS	R24,EvenPosChangeProcess+10
    049AD 5081      SUBI	R24,1
    049AE 9380 1614 STS	EvenPosChangeProcess+10,R24
(1969) 						uart_Printf("%s\r\n", strE3902);
    049B0 2722      CLR	R18
    049B1 E003      LDI	R16,3
    049B2 940E 6B81 CALL	_SetEValve
    049B4 E82C      LDI	R18,0x8C
    049B5 E100      LDI	R16,0x10
(1970) 						Uart0ReEnable;
    049B6 E010      LDI	R17,0
    049B7 940E 62A2 CALL	__DiluentMotRun
    049B9 E685      LDI	R24,0x65
    049BA 9380 160D STS	EvenPosChangeProcess+3,R24
(1971) 						mainStep = 0;
    049BC E081      LDI	R24,1
    049BD 9380 1657 STS	dustbinOldState,R24
(1972) 						workStep = 1;
    049BF E022      LDI	R18,2
    049C0 E030      LDI	R19,0
(1973) 						}
(1974) 					break;
(1975) 				default:
(1976) 					break;
(1977) 				}
(1978) 			break;
    049C1 E00A      LDI	R16,0xA
(1979) 		case 13:	// 稀释液空
(1980) 			switch(workStep){
    049C2 940E 97B7 CALL	_SetDelayTime
    049C4 C5FF      RJMP	_SetReadTime0
    049C5 EF20      LDI	R18,0xF0
    049C6 E104      LDI	R16,0x14
    049C7 E010      LDI	R17,0
    049C8 940E 6289 CALL	__EffluentMotRun
    049CA E022      LDI	R18,2
    049CB E030      LDI	R19,0
    049CC E00A      LDI	R16,0xA
    049CD 940E 97B7 CALL	_SetDelayTime
    049CF E081      LDI	R24,1
    049D0 9380 1656 STS	CardScanfSW,R24
    049D2 9020 1614 LDS	R2,EvenPosChangeProcess+10
    049D4 2022      TST	R2
    049D5 F421      BNE	0x49DA
    049D6 E686      LDI	R24,0x66
    049D7 9380 160D STS	EvenPosChangeProcess+3,R24
    049D9 C5EA      RJMP	_SetReadTime0
    049DA E684      LDI	R24,0x64
    049DB 9380 160D STS	EvenPosChangeProcess+3,R24
    049DD C5E6      RJMP	_SetReadTime0
    049DE E82C      LDI	R18,0x8C
    049DF E100      LDI	R16,0x10
    049E0 E010      LDI	R17,0
    049E1 940E 62A2 CALL	__DiluentMotRun
    049E3 E081      LDI	R24,1
    049E4 9380 1657 STS	dustbinOldState,R24
    049E6 E022      LDI	R18,2
    049E7 E030      LDI	R19,0
    049E8 E00A      LDI	R16,0xA
    049E9 940E 97B7 CALL	_SetDelayTime
    049EB E687      LDI	R24,0x67
    049EC 9380 160D STS	EvenPosChangeProcess+3,R24
    049EE C5D5      RJMP	_SetReadTime0
    049EF EE2E      LDI	R18,0xEE
    049F0 E032      LDI	R19,2
    049F1 E003      LDI	R16,3
    049F2 940E 6A5B CALL	_MotRunTo
    049F4 E081      LDI	R24,1
    049F5 9380 165A STS	dustbinOldState+3,R24
    049F7 E022      LDI	R18,2
    049F8 E030      LDI	R19,0
(1981) 				case 0:
(1982) #ifndef UartSendLong
(1983) 					Uart0ReUnable;
(1984) 					uart_Printf("!3903 $%8d\r\n", NewTestInfo.testSerial);
(1985) 					Uart0ReEnable;
(1986) #else
(1987) 					Uart0ReUnable;
    049F9 E00A      LDI	R16,0xA
    049FA 940E 97B7 CALL	_SetDelayTime
    049FC E688      LDI	R24,0x68
    049FD 9380 160D STS	EvenPosChangeProcess+3,R24
(1988) 					uart_Printf("!3903 $ ");
    049FF C5C4      RJMP	_SetReadTime0
    04A00 2722      CLR	R18
    04A01 E001      LDI	R16,1
(1989) 					uart0SendInt(NewTestInfo.testSerial);
    04A02 940E 6B81 CALL	_SetEValve
    04A04 E021      LDI	R18,1
    04A05 E002      LDI	R16,2
    04A06 940E 6B81 CALL	_SetEValve
    04A08 E022      LDI	R18,2
    04A09 E030      LDI	R19,0
    04A0A E00A      LDI	R16,0xA
    04A0B 940E 97B7 CALL	_SetDelayTime
(1990) 					uart_Printf("\r\n");
    04A0D E086      LDI	R24,6
    04A0E 9380 1614 STS	EvenPosChangeProcess+10,R24
(1991) 					Uart0ReEnable;
    04A10 E689      LDI	R24,0x69
    04A11 9380 160D STS	EvenPosChangeProcess+3,R24
    04A13 C5B0      RJMP	_SetReadTime0
    04A14 9180 1614 LDS	R24,EvenPosChangeProcess+10
(1992) #endif
(1993) 					MotStop(MOT_SAMP_NEEDLE);
    04A16 5081      SUBI	R24,1
    04A17 9380 1614 STS	EvenPosChangeProcess+10,R24
(1994) 					MotStop(MOT_DILUENT);
    04A19 E62A      LDI	R18,0x6A
    04A1A EF3F      LDI	R19,0xFF
(1995) 					SetDelayTime(MOT_EFFLUENT, 30);
    04A1B E00A      LDI	R16,0xA
    04A1C 940E 6A2C CALL	_MotRun
    04A1E E081      LDI	R24,1
    04A1F 9380 1658 STS	dustbinOldState+1,R24
(1996) 					workStep = 1;
    04A21 E022      LDI	R18,2
    04A22 E030      LDI	R19,0
(1997) 					break;
    04A23 E00A      LDI	R16,0xA
(1998) 				case 1:
(1999) 					MotStop(MOT_EFFLUENT);
    04A24 940E 97B7 CALL	_SetDelayTime
    04A26 9020 1614 LDS	R2,EvenPosChangeProcess+10
(2000) 					workStep = 2;
    04A28 2022      TST	R2
    04A29 F421      BNE	0x4A2E
(2001) 					break;
    04A2A E68A      LDI	R24,0x6A
(2002) 				case 2:
(2003) 					SetEValve(EV_ALL, EV_CLOSE);
    04A2B 9380 160D STS	EvenPosChangeProcess+3,R24
    04A2D C596      RJMP	_SetReadTime0
    04A2E E68D      LDI	R24,0x6D
(2004) 					_EffluentMotRun(30, 200);
    04A2F 9380 160D STS	EvenPosChangeProcess+3,R24
    04A31 C592      RJMP	_SetReadTime0
    04A32 E82C      LDI	R18,0x8C
    04A33 E030      LDI	R19,0
(2005) 					waitEffluent = 1;
    04A34 E00A      LDI	R16,0xA
    04A35 940E 6A2C CALL	_MotRun
(2006) 					workStep = 3;
    04A37 E022      LDI	R18,2
    04A38 E030      LDI	R19,0
    04A39 E00A      LDI	R16,0xA
(2007) 					break;
    04A3A 940E 97B7 CALL	_SetDelayTime
(2008) 				case 3:
(2009) 					MotInitCheck(MOT_SAMP_NEEDLE);
    04A3C E081      LDI	R24,1
    04A3D 9380 1658 STS	dustbinOldState+1,R24
(2010) 				//	_NeedleMotRunTo(0, 240);
(2011) 					waitMotSampNeedle = 1;
    04A3F E689      LDI	R24,0x69
    04A40 9380 160D STS	EvenPosChangeProcess+3,R24
(2012) 					workStep = 4;
    04A42 C581      RJMP	_SetReadTime0
    04A43 2722      CLR	R18
(2013) 					break;
    04A44 E002      LDI	R16,2
(2014) 				case 4:	// 取样针回到起始点
(2015) 					MotRunTo(MOT_SAMP_TRUN,0);
    04A45 940E 6B81 CALL	_SetEValve
    04A47 2722      CLR	R18
    04A48 E001      LDI	R16,1
    04A49 940E 6B81 CALL	_SetEValve
(2016) 					waitMotSampTurn = 1;
    04A4B 2722      CLR	R18
    04A4C E003      LDI	R16,3
(2017) 					workStep = 5;
    04A4D 940E 6B81 CALL	_SetEValve
    04A4F E022      LDI	R18,2
(2018) 					break;
    04A50 E030      LDI	R19,0
(2019) 				case 5:	// 取样针运行到混匀池中准备清洗针内壁
(2020) 					MotRunTo(MOT_SAMP_TRUN,NeedleOnMixCenterPos);
    04A51 E00A      LDI	R16,0xA
    04A52 940E 97B7 CALL	_SetDelayTime
    04A54 E68B      LDI	R24,0x6B
    04A55 9380 160D STS	EvenPosChangeProcess+3,R24
    04A57 C56C      RJMP	_SetReadTime0
(2021) 					waitMotSampTurn = 1;
    04A58 EF20      LDI	R18,0xF0
    04A59 E104      LDI	R16,0x14
    04A5A E010      LDI	R17,0
(2022) 					workStep = 6;
    04A5B 940E 6289 CALL	__EffluentMotRun
    04A5D E081      LDI	R24,1
(2023) 					break;
    04A5E 9380 1656 STS	CardScanfSW,R24
(2024) 				case 6:
(2025) 					_NeedleMotRunTo(_POS_MIX_TOP, 180);//240
    04A60 E022      LDI	R18,2
    04A61 E030      LDI	R19,0
    04A62 E00A      LDI	R16,0xA
    04A63 940E 97B7 CALL	_SetDelayTime
(2026) 					SetEValve(EV2, EV_OPEN);
    04A65 E68C      LDI	R24,0x6C
    04A66 9380 160D STS	EvenPosChangeProcess+3,R24
(2027) 					waitMotSampNeedle = 1;
    04A68 C55B      RJMP	_SetReadTime0
    04A69 E003      LDI	R16,3
    04A6A 940E 6AFA CALL	_MotInitCheck
(2028) 					workStep = 7;
    04A6C E081      LDI	R24,1
    04A6D 9380 165A STS	dustbinOldState+3,R24
(2029) 					break;
    04A6F E08F      LDI	R24,0xF
    04A70 9380 160D STS	EvenPosChangeProcess+3,R24
    04A72 C551      RJMP	_SetReadTime0
    04A73 2722      CLR	R18
(2030) 				case 7:
(2031) 					_FluidMotRun(10, 60);		// 开启清洗液洗混匀池,注入1.4mL清洗液
(2032) 					_EffluentMotRun(20, 80);
    04A74 E001      LDI	R16,1
    04A75 940E 6B81 CALL	_SetEValve
    04A77 E084      LDI	R24,4
    04A78 838A      STD	Y+2,R24
(2033) 					waitMotFluid = 1;	// 等待清洗液注入混匀池完毕
    04A79 E085      LDI	R24,5
    04A7A 8388      ST	Y,R24
    04A7B EF2F      LDI	R18,0xFF
(2034) 					waitEffluent = 1;
    04A7C E002      LDI	R16,2
    04A7D 940E 6A9F CALL	_SetMotRunPam
(2035) 					workStep = 8;
    04A7F ED24      LDI	R18,0xD4
    04A80 E033      LDI	R19,3
(2036) 					break;
    04A81 E002      LDI	R16,2
(2037) 				case 8:
(2038) 					SetEValve(EV_ALL, EV_CLOSE);
    04A82 940E 6A5B CALL	_MotRunTo
    04A84 E081      LDI	R24,1
    04A85 9380 165B STS	dustbinOldState+4,R24
(2039) 					workStep = 9;
    04A87 E183      LDI	R24,0x13
    04A88 9380 160D STS	EvenPosChangeProcess+3,R24
(2040) 					break;
    04A8A C539      RJMP	_SetReadTime0
    04A8B 2722      CLR	R18
    04A8C E003      LDI	R16,3
    04A8D 940E 6B81 CALL	_SetEValve
(2041) 				case 9:
(2042) 					SetDelayTime(MOT_EFFLUENT, 2);
(2043) 					ucTmp = _PrimingDiluent();
    04A8F E180      LDI	R24,0x10
    04A90 9380 160D STS	EvenPosChangeProcess+3,R24
    04A92 C531      RJMP	_SetReadTime0
    04A93 2422      CLR	R2
(2044) 					if(ucTmp == 1){	// 灌注完成
    04A94 9220 0525 STS	InsertRingFlag,R2
(2045) 						workStep = 3;
    04A96 EF2F      LDI	R18,0xFF
    04A97 EA08      LDI	R16,0xA8
    04A98 E017      LDI	R17,7
(2046) 						mainStep = 11;
    04A99 940E 62FB CALL	__NeedleMotRunTo
    04A9B E628      LDI	R18,0x68
(2047) 						}
    04A9C E031      LDI	R19,1
(2048) 					else if(ucTmp == 0xff){		// 自动灌注失败，进入程序开始阶段等待手动开始液体灌注
    04A9D E00C      LDI	R16,0xC
    04A9E 940E 6A2C CALL	_MotRun
    04AA0 E081      LDI	R24,1
    04AA1 9380 165A STS	dustbinOldState+3,R24
(2049) 					/*
(2050) #ifndef UartSendLong
(2051) 						Uart0ReUnable;
(2052) 						uart_Printf("%s $%8d\r\n", strE3904,NewTestInfo.testSerial);
(2053) 						Uart0ReEnable;
(2054) #else
(2055) 						Uart0ReUnable;
(2056) 						uart_Printf("%s $ ",strE3904);
(2057) 						uart0SendInt(NewTestInfo.testSerial);
(2058) 						uart_Printf("\r\n");
(2059) 						Uart0ReEnable;
(2060) #endif
(2061) 					*/
(2062) 						Uart0ReUnable;
    04AA3 E181      LDI	R24,0x11
    04AA4 9380 160D STS	EvenPosChangeProcess+3,R24
    04AA6 C51D      RJMP	_SetReadTime0
(2063) 						uart_Printf("%s\r\n", strE3904);
    04AA7 940E 3745 CALL	_SetBeepPrompt
    04AA9 940E 3907 CALL	_SetStateLedFree
    04AAB E182      LDI	R24,0x12
    04AAC 9380 160D STS	EvenPosChangeProcess+3,R24
(2064) 						Uart0ReEnable;
    04AAE C515      RJMP	_SetReadTime0
    04AAF 9180 00C1 LDS	R24,0xC1
    04AB1 7E8F      ANDI	R24,0xEF
(2065) 						mainStep = 0;
    04AB2 9380 00C1 STS	0xC1,R24
    04AB4 EF22      LDI	R18,0xF2
(2066) 						workStep = 1;
    04AB5 E03C      LDI	R19,0xC
    04AB6 E80F      LDI	R16,0x8F
    04AB7 E016      LDI	R17,6
(2067) 						}
(2068) 					break;
(2069) 				default:
(2070) 					break;
(2071) 				}
(2072) 			break;
    04AB8 940E A90D CALL	_uart_Printf
(2073) 		case 20:	// 进入待机状态, 取样针回零位
(2074) 			switch(workStep)
    04ABA 9180 00C1 LDS	R24,0xC1
    04ABC 6180      ORI	R24,0x10
    04ABD 9380 00C1 STS	0xC1,R24
    04ABF E081      LDI	R24,1
    04AC0 9380 160C STS	EvenPosChangeProcess+2,R24
    04AC2 2422      CLR	R2
    04AC3 9220 160D STS	EvenPosChangeProcess+3,R2
    04AC5 C4FE      RJMP	_SetReadTime0
    04AC6 90A0 160D LDS	R10,EvenPosChangeProcess+3
    04AC8 24BB      CLR	R11
    04AC9 20AA      TST	R10
(2075) 			{
(2076) 				case 0:	// 取样针上升到最高点
(2077) 					SetStateLedBusy();
    04ACA F411      BNE	0x4ACD
    04ACB 20BB      TST	R11
(2078) 					_NeedleMotRunTo(0, 180);// 240
    04ACC F051      BEQ	0x4AD7
    04ACD 01C5      MOVW	R24,R10
    04ACE 3081      CPI	R24,1
    04ACF E0E0      LDI	R30,0
    04AD0 079E      CPC	R25,R30
(2079) 					waitMotSampNeedle = 1;
    04AD1 F0C9      BEQ	0x4AEB
    04AD2 3082      CPI	R24,2
    04AD3 E0E0      LDI	R30,0
(2080) 					Uart0ReUnable;
    04AD4 079E      CPC	R25,R30
    04AD5 F159      BEQ	0x4B01
    04AD6 C031      RJMP	0x4B08
    04AD7 ED2C      LDI	R18,0xDC
    04AD8 E10E      LDI	R16,0x1E
(2081) 					uart_Printf("%s\r\n",strM3190);
    04AD9 E010      LDI	R17,0
    04ADA 940E 6289 CALL	__EffluentMotRun
    04ADC EB24      LDI	R18,0xB4
    04ADD 2700      CLR	R16
    04ADE 2711      CLR	R17
(2082) 					Uart0ReEnable;
    04ADF 940E 62FB CALL	__NeedleMotRunTo
    04AE1 E081      LDI	R24,1
    04AE2 9380 165A STS	dustbinOldState+3,R24
(2083) 					workStep = 1;
    04AE4 9380 160D STS	EvenPosChangeProcess+3,R24
    04AE6 940E 9F1B CALL	_TestALampClose
(2084) 					break;
    04AE8 940E 38F8 CALL	_SetStateLedBusy
    04AEA C01D      RJMP	0x4B08
    04AEB E084      LDI	R24,4
    04AEC 838A      STD	Y+2,R24
(2085) 				case 1:	// 取样针旋转到起始位
(2086) 					MotRunTo(MOT_SAMP_TRUN,0);
(2087) 					waitMotSampTurn = 1;
    04AED E08A      LDI	R24,0xA
    04AEE 8388      ST	Y,R24
    04AEF EF2F      LDI	R18,0xFF
(2088) 					workStep = 2;
    04AF0 E002      LDI	R16,2
    04AF1 940E 6A9F CALL	_SetMotRunPam
(2089) 					break;
    04AF3 2722      CLR	R18
(2090) 				case 2:	// 进入待机
(2091) 					Uart0ReUnable;
    04AF4 2733      CLR	R19
    04AF5 E002      LDI	R16,2
    04AF6 940E 6A5B CALL	_MotRunTo
    04AF8 E081      LDI	R24,1
(2092) 					uart_Printf("%s\r\n",strM3191);		// 取样休眠状态
    04AF9 9380 165B STS	dustbinOldState+4,R24
    04AFB 9380 1656 STS	CardScanfSW,R24
    04AFD E082      LDI	R24,2
    04AFE 9380 160D STS	EvenPosChangeProcess+3,R24
(2093) 				//	uart_Printf("%s\r\n",strM3101);		// 请按吸样键开始
(2094) 					Uart0ReEnable;
    04B00 C007      RJMP	0x4B08
    04B01 2422      CLR	R2
    04B02 9220 160C STS	EvenPosChangeProcess+2,R2
(2095) 					JumpMode = 2;						// 休眠模式,按键之后应该进入液路自检
    04B04 9220 160D STS	EvenPosChangeProcess+3,R2
    04B06 E002      LDI	R16,2
(2096) 					mainStep = 0;
    04B07 C4BD      RJMP	0x4FC5
    04B08 E001      LDI	R16,1
    04B09 C4BB      RJMP	0x4FC5
(2097) 					workStep = 1;
    04B0A 90A0 160D LDS	R10,EvenPosChangeProcess+3
    04B0C 24BB      CLR	R11
(2098) 					break;
(2099) 				default:
(2100) 					break;
(2101) 			}
(2102) 			break;
    04B0D 20AA      TST	R10
(2103) 		case 100:	// 吸入高浓度清洗液清洗
(2104) 			switch(workStep)
    04B0E F411      BNE	0x4B11
    04B0F 20BB      TST	R11
    04B10 F111      BEQ	0x4B33
    04B11 01C5      MOVW	R24,R10
    04B12 3081      CPI	R24,1
    04B13 E0E0      LDI	R30,0
    04B14 079E      CPC	R25,R30
    04B15 F131      BEQ	0x4B3C
    04B16 3082      CPI	R24,2
    04B17 E0E0      LDI	R30,0
    04B18 079E      CPC	R25,R30
    04B19 F149      BEQ	0x4B43
    04B1A 3083      CPI	R24,3
    04B1B E0E0      LDI	R30,0
    04B1C 079E      CPC	R25,R30
    04B1D F189      BEQ	0x4B4F
    04B1E 3084      CPI	R24,4
    04B1F E0E0      LDI	R30,0
    04B20 079E      CPC	R25,R30
    04B21 F409      BNE	0x4B23
    04B22 C03C      RJMP	0x4B5F
    04B23 3085      CPI	R24,5
    04B24 E0E0      LDI	R30,0
    04B25 079E      CPC	R25,R30
    04B26 F409      BNE	0x4B28
    04B27 C041      RJMP	0x4B69
    04B28 3086      CPI	R24,6
    04B29 E0E0      LDI	R30,0
    04B2A 079E      CPC	R25,R30
    04B2B F409      BNE	0x4B2D
(2105) 			{
(2106) 				/*      //原先的强力清洗模式   deleted by pan  20161227
(2107) 				case 0:
(2108) 					SetEValve(EV2, EV_OPEN);	// 开启清洗液取样针通道，准备由清洗液泵吸入高浓度清洗液
(2109) 					SetDelayTime(MOT_FLUID, 2);
(2110) 					workStep = 1;
(2111) 					break;
(2112) 				case 1:
(2113) 					_FluidMotRun(-2, 120);		// 吸入高浓度清洗液
(2114) 					waitMotFluid = 1;
(2115) 					workStep = 2;
(2116) 					break;
(2117) 				case 2:
(2118) 					SetEValve(EV2, EV_CLOSE);
(2119) 					_NeedleMotRunTo(0, 180);	// 取样针上升	// 200
(2120) 					waitMotSampNeedle = 1;
(2121) 					workStep = 3;
(2122) 					break;
(2123) 				case 3:
(2124) 					SetMotRunPam(MOT_SAMP_TRUN,255,10,CURRENT_SAMP_TRUN);
(2125) 					MotRunTo(MOT_SAMP_TRUN,0);
(2126) 					waitMotSampTurn = 1;
(2127) 					workStep = 4;
(2128) 					break;
(2129) 				case 4:
(2130) 					MotRunTo(MOT_SAMP_TRUN, NeedleOnMixCenterPos);		// 取样臂运行到混匀池壁上方
(2131) 					waitMotSampTurn = 1;
(2132) 					SetDelayTime(MOT_SAMP_TRUN, 10*30);		// 浸泡30秒
(2133) 					workStep = 5;
(2134) 					break;
(2135) 				case 5:
(2136) 					_NeedleMotRunTo(_POS_MIX_BUTTOM, 200); // 240
(2137) 					waitMotSampNeedle = 1;
(2138) 					sc = 5;
(2139) 					mainStep = 0;
(2140) 					workStep = 9;
(2141) 					break;
(2142) 				default:
(2143) 					break;
(2144) 				}
(2145) 			break;
(2146) 			*/   //原先的强力清洗模式   deleted by pan  20161227
(2147) 				
(2148) 				case 0:
(2149) #ifdef Puncture
(2150) 					_NeedleMotRunTo(_POS_SAMP_DOWN, 180);
(2151) 					waitMotSampNeedle = 1;
(2152) 					_WaitStartKey = 1;
(2153) #endif
(2154) 					workStep = 100;
    04B2C C04A      RJMP	0x4B77
    04B2D 3087      CPI	R24,7
    04B2E E0E0      LDI	R30,0
(2155) 					break;
    04B2F 079E      CPC	R25,R30
(2156) 				case 100:
(2157) 					SetEValve(EV2, EV_OPEN);	// 开启清洗液取样针通道，准备由清洗液泵吸入高浓度清洗液
    04B30 F409      BNE	0x4B32
    04B31 C051      RJMP	0x4B83
    04B32 C491      RJMP	_SetReadTime0
    04B33 E12E      LDI	R18,0x1E
(2158) 					SetDelayTime(MOT_FLUID, 2);
    04B34 E030      LDI	R19,0
    04B35 E00B      LDI	R16,0xB
    04B36 940E 97B7 CALL	_SetDelayTime
    04B38 E081      LDI	R24,1
(2159) 					workStep = 1;
    04B39 9380 160D STS	EvenPosChangeProcess+3,R24
    04B3B C488      RJMP	_SetReadTime0
(2160) 					break;
    04B3C E00B      LDI	R16,0xB
(2161) 				case 1:
(2162) 					//_FluidMotRun(-2, 120);		// 吸入高浓度清洗液120uL
(2163) 					MotRun(MOT_FLUID, -120);
    04B3D 940E 6A13 CALL	_MotStop
    04B3F E082      LDI	R24,2
    04B40 9380 160D STS	EvenPosChangeProcess+3,R24
(2164) 					waitMotFluid = 1;
    04B42 C481      RJMP	_SetReadTime0
    04B43 EB24      LDI	R18,0xB4
    04B44 2700      CLR	R16
(2165) 					workStep = 2;
    04B45 2711      CLR	R17
    04B46 940E 62FB CALL	__NeedleMotRunTo
(2166) 					//workStep = 100;
(2167) 					break;
    04B48 E081      LDI	R24,1
(2168) 				/*
(2169) 				case 100:	
(2170) 					SetEValve(EV3, EV_OPEN);
(2171) 					SetEValve(EV1, EV_OPEN);
(2172) 					SetBeepPrompt();
(2173) 					_EffluentMotRun(70, 240);
(2174) 					SetDelayTime(MOT_EFFLUENT, 2);	// 延迟一段时间，先建立负压
(2175) 					workStep = 101;
(2176) 					break;
(2177) 				case 101:				// 开启洗液泵，清洗针外壁
(2178) 					_FluidMotRun(20, 40);
(2179) 					waitMotSampNeedle = 1;
(2180) 					_NeedleMotRunTo(0, 180);	// 取样针上升
(2181) 					//workStep = 6; //2016-09-18
(2182) 					workStep = 102;	//2016-09-18
(2183) 					break;
(2184) 				
(2185) 				case 102:		// 延迟1秒后停止清洗头吸空, 转换到混匀池排空
(2186) 					SetEValve(EV_ALL,EV_CLOSE);
(2187) 					//waitMotSampTurn = 1;
(2188) 					SetEValve(EV2, EV_OPEN);	
(2189) 					workStep = 3;
(2190) 					break;
(2191) 					*/
(2192) 				case 2:
(2193) 					//SetEValve(EV2, EV_CLOSE);
(2194) 					_NeedleMotRunTo(0, 180);	// 取样针上升	// 200
    04B49 9380 165A STS	dustbinOldState+3,R24
    04B4B E083      LDI	R24,3
    04B4C 9380 160D STS	EvenPosChangeProcess+3,R24
(2195) 					waitMotSampNeedle = 1;
    04B4E C475      RJMP	_SetReadTime0
    04B4F 2722      CLR	R18
    04B50 2700      CLR	R16
(2196) 					workStep = 3;
    04B51 940E 6B81 CALL	_SetEValve
    04B53 EC28      LDI	R18,0xC8
(2197) 					break;
    04B54 E10E      LDI	R16,0x1E
(2198) 				case 3:
(2199) 					SetMotRunPam(MOT_SAMP_TRUN,255,10,CURRENT_SAMP_TRUN);
    04B55 E010      LDI	R17,0
    04B56 940E 6289 CALL	__EffluentMotRun
    04B58 E081      LDI	R24,1
    04B59 9380 1656 STS	CardScanfSW,R24
    04B5B E084      LDI	R24,4
    04B5C 9380 160D STS	EvenPosChangeProcess+3,R24
(2200) 					MotRunTo(MOT_SAMP_TRUN,0);
    04B5E C465      RJMP	_SetReadTime0
    04B5F E002      LDI	R16,2
    04B60 940E 6AFA CALL	_MotInitCheck
(2201) 					waitMotSampTurn = 1;
    04B62 E081      LDI	R24,1
    04B63 9380 165B STS	dustbinOldState+4,R24
(2202) 					workStep = 4;
    04B65 E085      LDI	R24,5
    04B66 9380 160D STS	EvenPosChangeProcess+3,R24
(2203) 					break;
    04B68 C45B      RJMP	_SetReadTime0
(2204) 				case 4:
(2205) 					MotRunTo(MOT_SAMP_TRUN, NeedleOnMixCenterPos);		// 取样臂运行到混匀池壁上方
    04B69 9120 1646 LDS	R18,_NewCardStoreNum+6
    04B6B 9130 1647 LDS	R19,_NewCardStoreNum+7
    04B6D E002      LDI	R16,2
    04B6E 940E 6A5B CALL	_MotRunTo
(2206) 					waitMotSampTurn = 1;
    04B70 E081      LDI	R24,1
    04B71 9380 165B STS	dustbinOldState+4,R24
(2207) 					SetDelayTime(MOT_SAMP_TRUN, 10*3);		// 浸泡3秒    改成更长时间
    04B73 E086      LDI	R24,6
    04B74 9380 160D STS	EvenPosChangeProcess+3,R24
    04B76 C44D      RJMP	_SetReadTime0
    04B77 EB24      LDI	R18,0xB4
(2208) 					workStep = 5;
    04B78 E608      LDI	R16,0x68
    04B79 E011      LDI	R17,1
    04B7A 940E 62FB CALL	__NeedleMotRunTo
(2209) 					break;				
    04B7C E081      LDI	R24,1
    04B7D 9380 165A STS	dustbinOldState+3,R24
    04B7F E087      LDI	R24,7
    04B80 9380 160D STS	EvenPosChangeProcess+3,R24
(2210) 				case 5:
(2211) 					_NeedleMotRunTo(_POS_MIX_BUTTOM, 200); // 240
(2212) 					waitMotSampNeedle = 1;
    04B82 C441      RJMP	_SetReadTime0
    04B83 E520      LDI	R18,0x50
(2213) 					workStep = 7;
    04B84 E00A      LDI	R16,0xA
    04B85 E010      LDI	R17,0
    04B86 940E 6264 CALL	__FluidMotRun
(2214) 					break;	
    04B88 E081      LDI	R24,1
    04B89 9380 1658 STS	dustbinOldState+1,R24
    04B8B E089      LDI	R24,0x9
    04B8C 9380 160C STS	EvenPosChangeProcess+2,R24
(2215) 				case 7:
(2216) 					MotRun(MOT_FLUID, 1200);
(2217) 					checkFluid = 1;
    04B8E E086      LDI	R24,6
    04B8F 9380 160D STS	EvenPosChangeProcess+3,R24
(2218) 					waitMotFluid = 1;
    04B91 E081      LDI	R24,1
(2219) 					workStep = 8;
    04B92 9380 0525 STS	InsertRingFlag,R24
    04B94 C42F      RJMP	_SetReadTime0
(2220) 					sc = 125;
    04B95 90A0 160D LDS	R10,EvenPosChangeProcess+3
    04B97 24BB      CLR	R11
(2221) 					break;
    04B98 20AA      TST	R10
(2222) 				case 8:		
(2223) 				    sc--;		
    04B99 F419      BNE	0x4B9D
    04B9A 20BB      TST	R11
    04B9B F409      BNE	0x4B9D
    04B9C C02F      RJMP	0x4BCC
    04B9D 01C5      MOVW	R24,R10
(2224) 					MotRun(MOT_FLUID, -120);
    04B9E 3081      CPI	R24,1
    04B9F E0E0      LDI	R30,0
    04BA0 079E      CPC	R25,R30
    04BA1 F409      BNE	0x4BA3
    04BA2 C07F      RJMP	0x4C22
(2225) 					waitMotFluid = 1;
    04BA3 3082      CPI	R24,2
    04BA4 E0E0      LDI	R30,0
    04BA5 079E      CPC	R25,R30
(2226) 					workStep = 9;
    04BA6 F409      BNE	0x4BA8
    04BA7 C081      RJMP	0x4C29
    04BA8 3083      CPI	R24,3
(2227) 					break;
    04BA9 E0E0      LDI	R30,0
(2228) 			    case 9:	
(2229) 				    MotRun(MOT_FLUID, 120);
    04BAA 079E      CPC	R25,R30
    04BAB F409      BNE	0x4BAD
    04BAC C08C      RJMP	0x4C39
    04BAD 3084      CPI	R24,4
    04BAE E0E0      LDI	R30,0
(2230) 					waitMotFluid = 1;	
    04BAF 079E      CPC	R25,R30
    04BB0 F409      BNE	0x4BB2
    04BB1 C091      RJMP	0x4C43
(2231) 					if(sc % 5 == 0)	
    04BB2 3085      CPI	R24,5
    04BB3 E0E0      LDI	R30,0
    04BB4 079E      CPC	R25,R30
    04BB5 F409      BNE	0x4BB7
    04BB6 C098      RJMP	0x4C4F
    04BB7 3086      CPI	R24,6
    04BB8 E0E0      LDI	R30,0
(2232) 						SetDelayTime(MOT_FLUID, 10*6);	// 每抽打5次暂停6秒
    04BB9 079E      CPC	R25,R30
    04BBA F409      BNE	0x4BBC
    04BBB C0A1      RJMP	0x4C5D
    04BBC 3087      CPI	R24,7
    04BBD E0E0      LDI	R30,0
(2233) 					
(2234) 					if(sc==0)
    04BBE 079E      CPC	R25,R30
    04BBF F409      BNE	0x4BC1
    04BC0 C0AC      RJMP	0x4C6D
    04BC1 3088      CPI	R24,0x8
(2235) 					{
(2236) 					   workStep = 6;
    04BC2 E0E0      LDI	R30,0
    04BC3 079E      CPC	R25,R30
    04BC4 F409      BNE	0x4BC6
(2237) 					// sc=15;
(2238) 					}
    04BC5 C0BA      RJMP	0x4C80
(2239) 					else
(2240) 					workStep = 8;		
    04BC6 3089      CPI	R24,0x9
    04BC7 E0E0      LDI	R30,0
    04BC8 079E      CPC	R25,R30
(2241) 					break;
    04BC9 F409      BNE	0x4BCB
(2242) 				case 6:	
(2243) 				    _EffluentMotRun(20, 200);
    04BCA C0BD      RJMP	0x4C88
    04BCB C3F8      RJMP	_SetReadTime0
    04BCC 9020 0530 LDS	R2,_AutoTestCycleNum+2
    04BCE 2022      TST	R2
(2244) 					SetDelayTime(MOT_FLUID, 20);
    04BCF F4E9      BNE	0x4BED
    04BD0 9180 00C1 LDS	R24,0xC1
    04BD2 7E8F      ANDI	R24,0xEF
    04BD3 9380 00C1 STS	0xC1,R24
(2245) 					waitEffluent = 1;
    04BD5 E20E      LDI	R16,0x2E
    04BD6 E016      LDI	R17,6
(2246) 					workStep = 13;
    04BD7 940E A90D CALL	_uart_Printf
    04BD9 9120 1664 LDS	R18,LiquidPhoNum
(2247) 					sc=5;		//清洗外壁5次
    04BDB 9130 1665 LDS	R19,timeOut
(2248) 					break;
    04BDD 9100 1662 LDS	R16,NewTestInfo|liqDetBaseAdc+1
(2249) 				case 13:		// 清洗取样针外壁
(2250) 				    sc--;					
    04BDF 9110 1663 LDS	R17,CardStorePhoNum
    04BE1 940E A940 CALL	_uart0SendInt
(2251) 					SetEValve(EV2, EV_CLOSE);	// 取样针通道关闭
    04BE3 E30B      LDI	R16,0x3B
    04BE4 E016      LDI	R17,6
    04BE5 940E A90D CALL	_uart_Printf
(2252) 					SetEValve(EV1, EV_OPEN);	// 开启清洗头洗液供应
    04BE7 9180 00C1 LDS	R24,0xC1
    04BE9 6180      ORI	R24,0x10
    04BEA 9380 00C1 STS	0xC1,R24
(2253) 					_FluidMotRun(8, 80);		// _FluidMotRun(12, 180);		// 开启清洗液洗混匀池,注入1.0mL清洗液(12, 180)//(12,120)
    04BEC C026      RJMP	0x4C13
    04BED 9180 0530 LDS	R24,_AutoTestCycleNum+2
    04BEF 3081      CPI	R24,1
(2254) 					waitMotFluid = 1;
    04BF0 F421      BNE	0x4BF5
    04BF1 EF8A      LDI	R24,0xFA
    04BF2 9380 0530 STS	_AutoTestCycleNum+2,R24
(2255) 					waitEffluent = 1;
    04BF4 C007      RJMP	0x4BFC
(2256) 					SetEValve(EV3, EV_OPEN);	// 清洗头排液打开
    04BF5 9180 0530 LDS	R24,_AutoTestCycleNum+2
    04BF7 3082      CPI	R24,2
    04BF8 F419      BNE	0x4BFC
(2257) 					workStep = 14;
    04BF9 EF8F      LDI	R24,0xFF
    04BFA 9380 0530 STS	_AutoTestCycleNum+2,R24
(2258) 					break;
    04BFC 9180 00C1 LDS	R24,0xC1
(2259) 				case 14:		// 抽干清洗头
(2260) 					_FluidMotRun(-1, 160);
    04BFE 7E8F      ANDI	R24,0xEF
    04BFF 9380 00C1 STS	0xC1,R24
    04C01 EA25      LDI	R18,0xA5
(2261) 					_EffluentMotRun(24, 240);
    04C02 E134      LDI	R19,0x14
    04C03 E208      LDI	R16,0x28
    04C04 E016      LDI	R17,6
    04C05 940E A90D CALL	_uart_Printf
(2262) 					SetDelayTime(MOT_SAMP_NEEDLE, 5);
    04C07 9180 00C1 LDS	R24,0xC1
    04C09 6180      ORI	R24,0x10
    04C0A 9380 00C1 STS	0xC1,R24
(2263) 					workStep = 15;
    04C0C 2422      CLR	R2
    04C0D 9220 160C STS	EvenPosChangeProcess+2,R2
(2264) 					break;
    04C0F E180      LDI	R24,0x10
(2265) 				case 15:	
(2266) 					// 抽干混匀池
(2267) 					SetEValve(EV3,EV_CLOSE);	// 清洗头排液打开
    04C10 9380 160D STS	EvenPosChangeProcess+3,R24
    04C12 C3B1      RJMP	_SetReadTime0
    04C13 E003      LDI	R16,3
(2268) 					_EffluentMotRun(20, 200);
    04C14 940E 6A13 CALL	_MotStop
    04C16 E00A      LDI	R16,0xA
    04C17 940E 6A13 CALL	_MotStop
(2269) 					SetDelayTime(MOT_FLUID, 20);
    04C19 E12E      LDI	R18,0x1E
    04C1A E030      LDI	R19,0
    04C1B E00B      LDI	R16,0xB
    04C1C 940E 97B7 CALL	_SetDelayTime
(2270) 					waitEffluent = 1;
    04C1E E081      LDI	R24,1
    04C1F 9380 160D STS	EvenPosChangeProcess+3,R24
(2271) 					if (sc!=0)
    04C21 C3A2      RJMP	_SetReadTime0
    04C22 E00B      LDI	R16,0xB
    04C23 940E 6A13 CALL	_MotStop
(2272) 					workStep = 13;
    04C25 E082      LDI	R24,2
    04C26 9380 160D STS	EvenPosChangeProcess+3,R24
    04C28 C39B      RJMP	_SetReadTime0
(2273) 					else
(2274) 					{
(2275) 					workStep = 10;
    04C29 2722      CLR	R18
    04C2A 2700      CLR	R16
    04C2B 940E 6B81 CALL	_SetEValve
(2276) 					sc=15;     //清洗内壁15次
    04C2D EC28      LDI	R18,0xC8
    04C2E E10E      LDI	R16,0x1E
(2277) 					}
(2278) 					break;
    04C2F E010      LDI	R17,0
(2279) 				case 10:	// 清洗和灌注取样针通道
(2280) 				    sc--;
    04C30 940E 6289 CALL	__EffluentMotRun
    04C32 E081      LDI	R24,1
    04C33 9380 1656 STS	CardScanfSW,R24
(2281) 					SetEValve(EV2, EV_OPEN);
    04C35 E083      LDI	R24,3
    04C36 9380 160D STS	EvenPosChangeProcess+3,R24
    04C38 C38B      RJMP	_SetReadTime0
(2282) 					SetEValve(EV1, EV_CLOSE);
    04C39 E003      LDI	R16,3
    04C3A 940E 6AFA CALL	_MotInitCheck
    04C3C E081      LDI	R24,1
(2283) 					SetEValve(EV3, EV_CLOSE);
    04C3D 9380 165A STS	dustbinOldState+3,R24
    04C3F E084      LDI	R24,4
    04C40 9380 160D STS	EvenPosChangeProcess+3,R24
(2284) 					MotInitCheck(MOT_SAMP_PUMP);
    04C42 C381      RJMP	_SetReadTime0
    04C43 2722      CLR	R18
(2285) 					_FluidMotRun(16, 64);		// 注入1.4mL清洗液
    04C44 2733      CLR	R19
    04C45 E002      LDI	R16,2
    04C46 940E 6A5B CALL	_MotRunTo
    04C48 E081      LDI	R24,1
(2286) 					waitMotFluid = 1;
    04C49 9380 165B STS	dustbinOldState+4,R24
    04C4B E085      LDI	R24,5
(2287) 					SetDelayTime(MOT_FLUID, 40);
    04C4C 9380 160D STS	EvenPosChangeProcess+3,R24
    04C4E C375      RJMP	_SetReadTime0
    04C4F 9120 1646 LDS	R18,_NewCardStoreNum+6
(2288) 					workStep = 11;
    04C51 9130 1647 LDS	R19,_NewCardStoreNum+7
    04C53 E002      LDI	R16,2
(2289) 					break;
    04C54 940E 6A5B CALL	_MotRunTo
(2290) 				case 11:
(2291) 					_EffluentMotRun(20, 200);
    04C56 E081      LDI	R24,1
    04C57 9380 165B STS	dustbinOldState+4,R24
    04C59 E086      LDI	R24,6
(2292) 					SetDelayTime(MOT_FLUID, 20);
    04C5A 9380 160D STS	EvenPosChangeProcess+3,R24
    04C5C C367      RJMP	_SetReadTime0
    04C5D EC28      LDI	R18,0xC8
    04C5E E608      LDI	R16,0x68
(2293) 					waitEffluent = 1;
    04C5F E011      LDI	R17,1
    04C60 940E 62FB CALL	__NeedleMotRunTo
(2294) 					if(sc == 0)
    04C62 E021      LDI	R18,1
    04C63 E002      LDI	R16,2
    04C64 940E 6B81 CALL	_SetEValve
(2295) 					workStep = 12;
    04C66 E081      LDI	R24,1
    04C67 9380 165A STS	dustbinOldState+3,R24
    04C69 E087      LDI	R24,7
(2296) 					else
(2297) 					workStep = 10;
    04C6A 9380 160D STS	EvenPosChangeProcess+3,R24
    04C6C C357      RJMP	_SetReadTime0
(2298) 					break;			   
    04C6D E32C      LDI	R18,0x3C
(2299) 				case 12:		
(2300) 					sc = 5;
    04C6E E00A      LDI	R16,0xA
    04C6F E010      LDI	R17,0
    04C70 940E 6264 CALL	__FluidMotRun
(2301) 					mainStep = 0;
    04C72 E520      LDI	R18,0x50
    04C73 E104      LDI	R16,0x14
(2302) 					workStep = 9;
    04C74 E010      LDI	R17,0
    04C75 940E 6289 CALL	__EffluentMotRun
(2303) 					break;
(2304) 				default:
(2305) 					break;
(2306) 				}
(2307) 			break;
    04C77 E081      LDI	R24,1
(2308) 		case 105:	// 自动清洗
(2309) 			switch(workStep)
    04C78 9380 1658 STS	dustbinOldState+1,R24
    04C7A 9380 1656 STS	CardScanfSW,R24
    04C7C E088      LDI	R24,0x8
    04C7D 9380 160D STS	EvenPosChangeProcess+3,R24
    04C7F C344      RJMP	_SetReadTime0
    04C80 2722      CLR	R18
    04C81 2700      CLR	R16
    04C82 940E 6B81 CALL	_SetEValve
    04C84 E089      LDI	R24,0x9
    04C85 9380 160D STS	EvenPosChangeProcess+3,R24
    04C87 C33C      RJMP	_SetReadTime0
    04C88 E022      LDI	R18,2
    04C89 E030      LDI	R19,0
    04C8A E00B      LDI	R16,0xB
    04C8B 940E 97B7 CALL	_SetDelayTime
(2310) 			{
(2311) 				case 0:
(2312) 					_NeedleMotRunTo(0, 180);	// 取样针上升 // 200
    04C8D 940E 65D2 CALL	__PrimingFluid
    04C8F 0158      MOVW	R10,R16
    04C90 92A0 1612 STS	EvenPosChangeProcess+8,R10
(2313) 					waitMotSampNeedle = 1;
    04C92 3001      CPI	R16,1
    04C93 F439      BNE	0x4C9B
    04C94 E083      LDI	R24,3
(2314) 					workStep = 3;
    04C95 9380 160D STS	EvenPosChangeProcess+3,R24
    04C97 E08B      LDI	R24,0xB
(2315) 					break;
    04C98 9380 160C STS	EvenPosChangeProcess+2,R24
(2316) 				case 3:
(2317) 					SetMotRunPam(MOT_SAMP_TRUN,255,10,CURRENT_SAMP_TRUN);
    04C9A C329      RJMP	_SetReadTime0
    04C9B 9180 1612 LDS	R24,EvenPosChangeProcess+8
    04C9D 3F8F      CPI	R24,0xFF
    04C9E F009      BEQ	0x4CA0
    04C9F C324      RJMP	_SetReadTime0
    04CA0 9180 00C1 LDS	R24,0xC1
(2318) 					MotRunTo(MOT_SAMP_TRUN,0);
    04CA2 7E8F      ANDI	R24,0xEF
    04CA3 9380 00C1 STS	0xC1,R24
    04CA5 E626      LDI	R18,0x66
(2319) 					waitMotSampTurn = 1;
    04CA6 E134      LDI	R19,0x14
    04CA7 E80F      LDI	R16,0x8F
    04CA8 E016      LDI	R17,6
(2320) 					workStep = 4;
    04CA9 940E A90D CALL	_uart_Printf
    04CAB 9180 00C1 LDS	R24,0xC1
(2321) 					break;
    04CAD 6180      ORI	R24,0x10
    04CAE 9380 00C1 STS	0xC1,R24
    04CB0 2422      CLR	R2
    04CB1 9220 160C STS	EvenPosChangeProcess+2,R2
    04CB3 E081      LDI	R24,1
(2322) 				case 4:
(2323) 					MotRunTo(MOT_SAMP_TRUN, NeedleOnMixCenterPos);		// 取样臂运行到混匀池壁上方
(2324) 					waitMotSampTurn = 1;
    04CB4 9380 160D STS	EvenPosChangeProcess+3,R24
    04CB6 C30D      RJMP	_SetReadTime0
(2325) 					workStep = 5;
    04CB7 90A0 160D LDS	R10,EvenPosChangeProcess+3
    04CB9 24BB      CLR	R11
(2326) 					break;
    04CBA 20AA      TST	R10
(2327) 				case 5:
(2328) 					_NeedleMotRunTo(_POS_MIX_BUTTOM, 180);	 // 240
    04CBB F419      BNE	0x4CBF
    04CBC 20BB      TST	R11
    04CBD F409      BNE	0x4CBF
    04CBE C02F      RJMP	0x4CEE
    04CBF 01C5      MOVW	R24,R10
(2329) 					waitMotSampNeedle = 1;
    04CC0 3081      CPI	R24,1
    04CC1 E0E0      LDI	R30,0
    04CC2 079E      CPC	R25,R30
(2330) 					sc = 5;
    04CC3 F409      BNE	0x4CC5
    04CC4 C054      RJMP	0x4D19
    04CC5 3082      CPI	R24,2
(2331) 					checkFluid = 1;
    04CC6 E0E0      LDI	R30,0
    04CC7 079E      CPC	R25,R30
    04CC8 F409      BNE	0x4CCA
(2332) 					mainStep = 0;
    04CC9 C056      RJMP	0x4D20
    04CCA 3083      CPI	R24,3
    04CCB E0E0      LDI	R30,0
(2333) 					workStep = 9;
    04CCC 079E      CPC	R25,R30
    04CCD F409      BNE	0x4CCF
    04CCE C061      RJMP	0x4D30
(2334) 					break;
(2335) 				default:
(2336) 					break;
(2337) 				}
(2338) 			break;
(2339) 		default:
(2340) 			break;
(2341) 		}
(2342) 	return 0;
    04CCF 3084      CPI	R24,4
    04CD0 E0E0      LDI	R30,0
    04CD1 079E      CPC	R25,R30
    04CD2 F409      BNE	0x4CD4
    04CD3 C066      RJMP	0x4D3A
    04CD4 3085      CPI	R24,5
_CalSampVolume:
  l                    --> Y,+4
  m                    --> R10
  n                    --> Y,+0
  diluteTime           --> R12
  multipNum            --> R10
    04CD5 E0E0      LDI	R30,0
    04CD6 079E      CPC	R25,R30
    04CD7 F409      BNE	0x4CD9
    04CD8 C06D      RJMP	0x4D46
    04CD9 3086      CPI	R24,6
(2343) }
(2344) 
(2345) signed int CalSampVolume(unsigned char multipNum, unsigned char diluteTime)
(2346) {
(2347) 	unsigned long n, l;
(2348) 	signed int m;
(2349) 	n = 0;
    04CDA E0E0      LDI	R30,0
    04CDB 079E      CPC	R25,R30
    04CDC F409      BNE	0x4CDE
    04CDD C076      RJMP	0x4D54
    04CDE 3087      CPI	R24,7
(2350) 	// 设置不同稀释比例下标准吸样量
(2351) #ifndef Puncture
(2352) 	l = (unsigned long)DiluentCoff[multipNum];	// 读取稀释校准因数
    04CDF E0E0      LDI	R30,0
    04CE0 079E      CPC	R25,R30
    04CE1 F409      BNE	0x4CE3
    04CE2 C081      RJMP	0x4D64
    04CE3 3088      CPI	R24,0x8
    04CE4 E0E0      LDI	R30,0
    04CE5 079E      CPC	R25,R30
    04CE6 F409      BNE	0x4CE8
    04CE7 C08F      RJMP	0x4D77
    04CE8 3089      CPI	R24,0x9
    04CE9 E0E0      LDI	R30,0
    04CEA 079E      CPC	R25,R30
    04CEB F409      BNE	0x4CED
    04CEC C092      RJMP	0x4D7F
    04CED C2D6      RJMP	_SetReadTime0
    04CEE 9180 00C1 LDS	R24,0xC1
(2353) #else
(2354) 	if(WithoutPuncture != 0)
(2355) 		l = (unsigned long)DiluentCoff[multipNum];	// 读取稀释校准因数
(2356) 	else
(2357) 	{
(2358) 		l = (unsigned long)DiluentCoff[8];	// 读取稀释校准因数
(2359) 		uart_Printf("*9944 CurrentDiluentCoff $%4d\r\n", l);
(2360) 	}
(2361) #endif
(2362) 	if(diluteTime == 0)
    04CF0 7E8F      ANDI	R24,0xEF
    04CF1 9380 00C1 STS	0xC1,R24
(2363) 	{
(2364) 		switch(multipNum)		// 第一次稀释
    04CF3 E10F      LDI	R16,0x1F
    04CF4 E016      LDI	R17,6
    04CF5 940E A90D CALL	_uart_Printf
    04CF7 9120 1664 LDS	R18,LiquidPhoNum
    04CF9 9130 1665 LDS	R19,timeOut
    04CFB 9100 1662 LDS	R16,NewTestInfo|liqDetBaseAdc+1
    04CFD 9110 1663 LDS	R17,CardStorePhoNum
    04CFF 940E A940 CALL	_uart0SendInt
    04D01 E30B      LDI	R16,0x3B
    04D02 E016      LDI	R17,6
    04D03 940E A90D CALL	_uart_Printf
    04D05 9180 00C1 LDS	R24,0xC1
    04D07 6180      ORI	R24,0x10
    04D08 9380 00C1 STS	0xC1,R24
(2365) 		{
(2366) 			// 一次稀释
(2367) 			case 1:		//m = _DropVolume;	// 吸样量 == 滴液量
(2368) 						m = _DropVolume+_SAMP_PUMP_INTERVAL + 210 - 45;	return m; break;
    04D0A E003      LDI	R16,3
    04D0B 940E 6A13 CALL	_MotStop
    04D0D E009      LDI	R16,0x9
    04D0E 940E 6A13 CALL	_MotStop
    04D10 E12E      LDI	R18,0x1E
    04D11 E030      LDI	R19,0
    04D12 E00B      LDI	R16,0xB
    04D13 940E 97B7 CALL	_SetDelayTime
(2369) 		//	case 2:		n = l*4244;	break;	// 1:2	100/0.023562 = 4244	
(2370) 			case 2:		n = l*3400; break;  // 1:2  80/0.023562  = 3395
    04D15 E081      LDI	R24,1
    04D16 9380 160D STS	EvenPosChangeProcess+3,R24
    04D18 C2AB      RJMP	_SetReadTime0
    04D19 E00B      LDI	R16,0xB
    04D1A 940E 6A13 CALL	_MotStop
    04D1C E082      LDI	R24,2
    04D1D 9380 160D STS	EvenPosChangeProcess+3,R24
    04D1F C2A4      RJMP	_SetReadTime0
    04D20 2722      CLR	R18
    04D21 2700      CLR	R16
    04D22 940E 6B81 CALL	_SetEValve
    04D24 EC28      LDI	R18,0xC8
    04D25 E10E      LDI	R16,0x1E
    04D26 E010      LDI	R17,0
    04D27 940E 6289 CALL	__EffluentMotRun
(2371) 			case 3:		n = l*4244;	break;	// 1:5	100/0.023562 = 4244
    04D29 E081      LDI	R24,1
    04D2A 9380 1656 STS	CardScanfSW,R24
    04D2C E083      LDI	R24,3
    04D2D 9380 160D STS	EvenPosChangeProcess+3,R24
    04D2F C294      RJMP	_SetReadTime0
    04D30 E003      LDI	R16,3
    04D31 940E 6AFA CALL	_MotInitCheck
    04D33 E081      LDI	R24,1
    04D34 9380 165A STS	dustbinOldState+3,R24
    04D36 E084      LDI	R24,4
    04D37 9380 160D STS	EvenPosChangeProcess+3,R24
    04D39 C28A      RJMP	_SetReadTime0
    04D3A 2722      CLR	R18
    04D3B 2733      CLR	R19
    04D3C E002      LDI	R16,2
    04D3D 940E 6A5B CALL	_MotRunTo
(2372) 			case 4:		n = l*2355;	break;	// 1:10	55.5/0.023562 = 2355
    04D3F E081      LDI	R24,1
    04D40 9380 165B STS	dustbinOldState+4,R24
    04D42 E085      LDI	R24,5
    04D43 9380 160D STS	EvenPosChangeProcess+3,R24
    04D45 C27E      RJMP	_SetReadTime0
    04D46 9120 1646 LDS	R18,_NewCardStoreNum+6
    04D48 9130 1647 LDS	R19,_NewCardStoreNum+7
    04D4A E002      LDI	R16,2
    04D4B 940E 6A5B CALL	_MotRunTo
    04D4D E081      LDI	R24,1
    04D4E 9380 165B STS	dustbinOldState+4,R24
    04D50 E086      LDI	R24,6
    04D51 9380 160D STS	EvenPosChangeProcess+3,R24
(2373) 			case 5:		n = l*1116;	break;	// 1:20	26.3/0.023562 = 1116
    04D53 C270      RJMP	_SetReadTime0
    04D54 EB24      LDI	R18,0xB4
    04D55 E608      LDI	R16,0x68
    04D56 E011      LDI	R17,1
    04D57 940E 62FB CALL	__NeedleMotRunTo
    04D59 E021      LDI	R18,1
    04D5A E002      LDI	R16,2
    04D5B 940E 6B81 CALL	_SetEValve
    04D5D E081      LDI	R24,1
    04D5E 9380 165A STS	dustbinOldState+3,R24
    04D60 E087      LDI	R24,7
    04D61 9380 160D STS	EvenPosChangeProcess+3,R24
    04D63 C260      RJMP	_SetReadTime0
    04D64 E32C      LDI	R18,0x3C
    04D65 E00A      LDI	R16,0xA
    04D66 E010      LDI	R17,0
    04D67 940E 6264 CALL	__FluidMotRun
(2374) 		//	case 6:		n = l*864;	break;	// 1:50	20.4/0.023562 = 864
(2375) 		//	case 6:		n = l*1039;	break;	// 1:50	24.5/0.023562 = 1039  // 4015 设置为114准确
(2376) 		//	case 6: 	n = l*1183; break;  // 1183 = 1039 * 672 / 590,其中672为设置114的值，590为设置100的值
(2377) 		//	case 6: 	n = l*1261; break;  // 29.7ul
(2378) 		//	case 6: 	n = l*1230; break;  // 29ul
(2379) 		//	case 6: 	n = l*1200; break;  // 28.3ul
(2380) 		//	case 6: 	n = l*1220; break;  // 28.7ul
(2381) 		//	case 6:		n = l*1060; break;  // 25ul
(2382) 		//	case 6:		n = l*1082; break;  // 25.5ul
(2383) 		//	case 6:		n = l*1188; break;  // 28ul
(2384) 			case 6:		n = l*923; break;   // 2016-10-25调整  21.75ul
    04D69 E520      LDI	R18,0x50
    04D6A E104      LDI	R16,0x14
    04D6B E010      LDI	R17,0
    04D6C 940E 6289 CALL	__EffluentMotRun
    04D6E E081      LDI	R24,1
    04D6F 9380 1658 STS	dustbinOldState+1,R24
    04D71 9380 1656 STS	CardScanfSW,R24
    04D73 E088      LDI	R24,0x8
    04D74 9380 160D STS	EvenPosChangeProcess+3,R24
    04D76 C24D      RJMP	_SetReadTime0
    04D77 2722      CLR	R18
    04D78 2700      CLR	R16
    04D79 940E 6B81 CALL	_SetEValve
    04D7B E089      LDI	R24,0x9
    04D7C 9380 160D STS	EvenPosChangeProcess+3,R24
(2385) 			case 7:		n = l*429;	break;	// 1:100	10.1/0.023562 = 429
    04D7E C245      RJMP	_SetReadTime0
    04D7F E022      LDI	R18,2
    04D80 E030      LDI	R19,0
    04D81 E00B      LDI	R16,0xB
    04D82 940E 97B7 CALL	_SetDelayTime
    04D84 940E 639F CALL	__PrimingDiluent
    04D86 0158      MOVW	R10,R16
    04D87 92A0 1612 STS	EvenPosChangeProcess+8,R10
    04D89 3001      CPI	R16,1
    04D8A F439      BNE	0x4D92
    04D8B E083      LDI	R24,3
    04D8C 9380 160D STS	EvenPosChangeProcess+3,R24
    04D8E E08B      LDI	R24,0xB
    04D8F 9380 160C STS	EvenPosChangeProcess+2,R24
    04D91 C232      RJMP	_SetReadTime0
(2386) 			case 8:		n = l*212;	break;	// 1:200	5/0.023562 = 212
    04D92 9180 1612 LDS	R24,EvenPosChangeProcess+8
    04D94 3F8F      CPI	R24,0xFF
    04D95 F009      BEQ	0x4D97
    04D96 C22D      RJMP	_SetReadTime0
    04D97 9180 00C1 LDS	R24,0xC1
    04D99 7E8F      ANDI	R24,0xEF
    04D9A 9380 00C1 STS	0xC1,R24
    04D9C E825      LDI	R18,0x85
    04D9D E134      LDI	R19,0x14
    04D9E E80F      LDI	R16,0x8F
    04D9F E016      LDI	R17,6
    04DA0 940E A90D CALL	_uart_Printf
    04DA2 9180 00C1 LDS	R24,0xC1
    04DA4 6180      ORI	R24,0x10
    04DA5 9380 00C1 STS	0xC1,R24
(2387) 			// 高倍率的第一次稀释
(2388) 		//	case 9:		n = l*429;	break;	// 1:100 X 5	= 1:500
(2389) 			case 9:		n = l*300;	break;	// 1:100 X 5	= 1:500	7.07/0.023562 = 300
    04DA7 2422      CLR	R2
    04DA8 9220 160C STS	EvenPosChangeProcess+2,R2
    04DAA E081      LDI	R24,1
    04DAB 9380 160D STS	EvenPosChangeProcess+3,R24
    04DAD C216      RJMP	_SetReadTime0
    04DAE 90A0 160D LDS	R10,EvenPosChangeProcess+3
    04DB0 24BB      CLR	R11
    04DB1 20AA      TST	R10
    04DB2 F411      BNE	0x4DB5
    04DB3 20BB      TST	R11
    04DB4 F051      BEQ	0x4DBF
    04DB5 01C5      MOVW	R24,R10
    04DB6 3081      CPI	R24,1
    04DB7 E0E0      LDI	R30,0
    04DB8 079E      CPC	R25,R30
    04DB9 F119      BEQ	0x4DDD
    04DBA 3082      CPI	R24,2
    04DBB E0E0      LDI	R30,0
(2390) 			case 10:	n = l*429;	break;	// 1:100 X 10	= 1:1000	10.1/0.023562 = 429
    04DBC 079E      CPC	R25,R30
    04DBD F159      BEQ	0x4DE9
    04DBE C205      RJMP	_SetReadTime0
    04DBF 940E 38F8 CALL	_SetStateLedBusy
    04DC1 EB24      LDI	R18,0xB4
    04DC2 2700      CLR	R16
    04DC3 2711      CLR	R17
    04DC4 940E 62FB CALL	__NeedleMotRunTo
    04DC6 E081      LDI	R24,1
    04DC7 9380 165A STS	dustbinOldState+3,R24
    04DC9 9180 00C1 LDS	R24,0xC1
    04DCB 7E8F      ANDI	R24,0xEF
    04DCC 9380 00C1 STS	0xC1,R24
    04DCE E427      LDI	R18,0x47
    04DCF E133      LDI	R19,0x13
    04DD0 E80F      LDI	R16,0x8F
(2391) 			case 11:	n = l*212;	break;	// 1:200 X 10	= 1:2000	5/0.023562 = 212
    04DD1 E016      LDI	R17,6
    04DD2 940E A90D CALL	_uart_Printf
    04DD4 9180 00C1 LDS	R24,0xC1
    04DD6 6180      ORI	R24,0x10
    04DD7 9380 00C1 STS	0xC1,R24
    04DD9 E081      LDI	R24,1
    04DDA 9380 160D STS	EvenPosChangeProcess+3,R24
    04DDC C1E7      RJMP	_SetReadTime0
    04DDD 2722      CLR	R18
    04DDE 2733      CLR	R19
    04DDF E002      LDI	R16,2
    04DE0 940E 6A5B CALL	_MotRunTo
    04DE2 E081      LDI	R24,1
    04DE3 9380 165B STS	dustbinOldState+4,R24
    04DE5 E082      LDI	R24,2
(2392) 			//  2016-05-18
(2393) 			case 12:	n = l*4244;	break;	// 1:3  100/0.023562 = 4244		
    04DE6 9380 160D STS	EvenPosChangeProcess+3,R24
    04DE8 C1DB      RJMP	_SetReadTime0
    04DE9 9180 00C1 LDS	R24,0xC1
    04DEB 7E8F      ANDI	R24,0xEF
    04DEC 9380 00C1 STS	0xC1,R24
    04DEE E525      LDI	R18,0x55
    04DEF E133      LDI	R19,0x13
    04DF0 E80F      LDI	R16,0x8F
    04DF1 E016      LDI	R17,6
    04DF2 940E A90D CALL	_uart_Printf
    04DF4 9180 00C1 LDS	R24,0xC1
    04DF6 6180      ORI	R24,0x10
    04DF7 9380 00C1 STS	0xC1,R24
    04DF9 E082      LDI	R24,2
    04DFA 9380 0533 STS	JumpMode,R24
(2394) 			//case 13:	n = l*4244;	break;	// 1:4	100/0.023562 = 4244
(2395) 			case 13:	n = l*2831; break;	// 1:4  66.7/0.023562 = 2831 
    04DFC 2422      CLR	R2
    04DFD 9220 160C STS	EvenPosChangeProcess+2,R2
    04DFF E081      LDI	R24,1
    04E00 9380 160D STS	EvenPosChangeProcess+3,R24
    04E02 C1C1      RJMP	_SetReadTime0
    04E03 90A0 160D LDS	R10,EvenPosChangeProcess+3
    04E05 24BB      CLR	R11
    04E06 01C5      MOVW	R24,R10
    04E07 3080      CPI	R24,0
    04E08 E0E0      LDI	R30,0
    04E09 079E      CPC	R25,R30
    04E0A F40C      BGE	0x4E0C
    04E0B C1B8      RJMP	_SetReadTime0
    04E0C E08F      LDI	R24,0xF
    04E0D 158A      CP	R24,R10
    04E0E 059B      CPC	R25,R11
    04E0F F05C      BLT	0x4E1B
(2396) 			case 14:    n = l*1634;	break;	// 1:40	38.5/0.023562 = 1634
    04E10 EB86      LDI	R24,0xB6
    04E11 E092      LDI	R25,2
    04E12 01F5      MOVW	R30,R10
    04E13 0FEE      LSL	R30
    04E14 1FFF      ROL	R31
    04E15 0FE8      ADD	R30,R24
    04E16 1FF9      ADC	R31,R25
    04E17 9027      ELPM	R2,Z+
    04E18 9036      ELPM	R3,Z
    04E19 01F1      MOVW	R30,R2
    04E1A 9409      IJMP
    04E1B 01C5      MOVW	R24,R10
    04E1C 3684      CPI	R24,0x64
    04E1D E0E0      LDI	R30,0
    04E1E 079E      CPC	R25,R30
    04E1F F029      BEQ	0x4E25
    04E20 C1A3      RJMP	_SetReadTime0
    04E21 E684      LDI	R24,0x64
    04E22 9380 160D STS	EvenPosChangeProcess+3,R24
    04E24 C19F      RJMP	_SetReadTime0
(2397) 			default:	n = 0;		break;
    04E25 E021      LDI	R18,1
    04E26 E002      LDI	R16,2
    04E27 940E 6B81 CALL	_SetEValve
    04E29 E022      LDI	R18,2
(2398) 			}
(2399) 		}
(2400) 	n = n / _DILUENT_PUMP_BASE_COEFF;
    04E2A E030      LDI	R19,0
    04E2B E00A      LDI	R16,0xA
    04E2C 940E 97B7 CALL	_SetDelayTime
    04E2E E081      LDI	R24,1
    04E2F 9380 160D STS	EvenPosChangeProcess+3,R24
    04E31 C192      RJMP	_SetReadTime0
    04E32 E828      LDI	R18,0x88
    04E33 EF3F      LDI	R19,0xFF
    04E34 E00A      LDI	R16,0xA
    04E35 940E 6A2C CALL	_MotRun
    04E37 E081      LDI	R24,1
    04E38 9380 1658 STS	dustbinOldState+1,R24
    04E3A E082      LDI	R24,2
    04E3B 9380 160D STS	EvenPosChangeProcess+3,R24
(2401) 	m = (signed int)n;
    04E3D C186      RJMP	_SetReadTime0
(2402) 	return m;
    04E3E EB24      LDI	R18,0xB4
    04E3F 2700      CLR	R16
    04E40 2711      CLR	R17
    04E41 940E 62FB CALL	__NeedleMotRunTo
    04E43 E081      LDI	R24,1
(2403) }
(2404) 
(2405) signed int CalDiluteVolume(unsigned char multipNum, unsigned char diluteTime){
(2406) 	// 计算各种稀释比例用的稀释液量，结果为稀释泵的n个单位流量
(2407) 	signed int n;
(2408) 	if(diluteTime == 0){
    04E44 9380 165A STS	dustbinOldState+3,R24
    04E46 E083      LDI	R24,3
(2409) 		switch(multipNum){		// 第一次稀释
    04E47 9380 160D STS	EvenPosChangeProcess+3,R24
    04E49 C17A      RJMP	_SetReadTime0
    04E4A E084      LDI	R24,4
    04E4B 838A      STD	Y+2,R24
    04E4C E08A      LDI	R24,0xA
    04E4D 8388      ST	Y,R24
    04E4E EF2F      LDI	R18,0xFF
    04E4F E002      LDI	R16,2
    04E50 940E 6A9F CALL	_SetMotRunPam
    04E52 2722      CLR	R18
    04E53 2733      CLR	R19
    04E54 E002      LDI	R16,2
    04E55 940E 6A5B CALL	_MotRunTo
    04E57 E081      LDI	R24,1
    04E58 9380 165B STS	dustbinOldState+4,R24
    04E5A E084      LDI	R24,4
    04E5B 9380 160D STS	EvenPosChangeProcess+3,R24
    04E5D C166      RJMP	_SetReadTime0
    04E5E 9120 1646 LDS	R18,_NewCardStoreNum+6
(2410) 			// 一次稀释
(2411) 			case 1:		n = 0;		break;		// 1:1
    04E60 9130 1647 LDS	R19,_NewCardStoreNum+7
    04E62 E002      LDI	R16,2
(2412) 			case 2:		n = 1;		break;		// 1:2		100:(100+100)
    04E63 940E 6A5B CALL	_MotRunTo
    04E65 E081      LDI	R24,1
(2413) 			case 3:		n = 4;		break;		// 1:5		100:(100+400)
    04E66 9380 165B STS	dustbinOldState+4,R24
    04E68 E12E      LDI	R18,0x1E
(2414) 			case 4:		n = 5;		break;		// 1:10		55.5:(55.5+500)	
    04E69 E030      LDI	R19,0
    04E6A E002      LDI	R16,2
    04E6B 940E 97B7 CALL	_SetDelayTime
(2415) 			case 5:		n = 5;		break;		// 1:20		26.3:(26.3+500)	
    04E6D E085      LDI	R24,5
    04E6E 9380 160D STS	EvenPosChangeProcess+3,R24
(2416) 		//	case 6:		n = 10;		break;		// 1:50		20.4:(20.4+1000)
(2417) 		    case 6:		n = 12;		break;		// 1:50		24.5:(24.5+1200)
    04E70 C153      RJMP	_SetReadTime0
    04E71 EC28      LDI	R18,0xC8
(2418) 			case 7:		n = 10;		break;		// 1:100	10.1:(10.1+1000)
    04E72 E804      LDI	R16,0x84
    04E73 E013      LDI	R17,3
    04E74 940E 62FB CALL	__NeedleMotRunTo
(2419) 			case 8:		n = 10;		break;		// 1:200	5:(5+1000)
    04E76 E081      LDI	R24,1
    04E77 9380 165A STS	dustbinOldState+3,R24
(2420) 		//	case 9:		n = 10;		break;		// 1:500	1:100	10.1:(10.1+1000)
(2421) 			case 9:		n = 7;		break;		// 1:500	1:100	7.07:(7.07+700)
    04E79 E087      LDI	R24,7
    04E7A 9380 160D STS	EvenPosChangeProcess+3,R24
(2422) 			case 10:	n = 10;		break;		// 1:1000	1:100	10.1:(10.1+1000)
    04E7C C147      RJMP	_SetReadTime0
    04E7D EB20      LDI	R18,0xB0
(2423) 			case 11:	n = 10;		break;		// 1:2000	1:200	5:(5+1000)
    04E7E E034      LDI	R19,4
    04E7F E00A      LDI	R16,0xA
    04E80 940E 6A2C CALL	_MotRun
(2424) 			// 2016-05-18
(2425) 			case 12:	n = 2;		break;		// 1:3		100:(100+200)
    04E82 E081      LDI	R24,1
    04E83 9380 1610 STS	EvenPosChangeProcess+6,R24
(2426) 			//case 13:	n = 3;		break;		// 1:4		100:(100+300)
(2427) 			case 13:	n = 2;		break;		// 1:4      66.7:(66.7+200)
    04E85 9380 1658 STS	dustbinOldState+1,R24
(2428) 			case 14:	n = 15;		break;		// 1:40		38.5:(38.5+1500)
    04E87 E088      LDI	R24,0x8
    04E88 9380 160D STS	EvenPosChangeProcess+3,R24
(2429) 			default:	 n = 0;		break;
    04E8A E78D      LDI	R24,0x7D
    04E8B 9380 1614 STS	EvenPosChangeProcess+10,R24
(2430) 			}
(2431) 		}
(2432) 	return n;
    04E8D C136      RJMP	_SetReadTime0
    04E8E 9180 1614 LDS	R24,EvenPosChangeProcess+10
    04E90 5081      SUBI	R24,1
(2433) }
(2434) signed int CalDilute2Volume(unsigned char multipNum, unsigned char dilutetype){
(2435) 	signed int n;
(2436) 	if(dilutetype == 0)
    04E91 9380 1614 STS	EvenPosChangeProcess+10,R24
    04E93 E828      LDI	R18,0x88
(2437) 	{	// 原液
(2438) 		switch(multipNum)
    04E94 EF3F      LDI	R19,0xFF
    04E95 E00A      LDI	R16,0xA
    04E96 940E 6A2C CALL	_MotRun
    04E98 E081      LDI	R24,1
    04E99 9380 1658 STS	dustbinOldState+1,R24
    04E9B E089      LDI	R24,0x9
    04E9C 9380 160D STS	EvenPosChangeProcess+3,R24
    04E9E C125      RJMP	_SetReadTime0
    04E9F E728      LDI	R18,0x78
    04EA0 E030      LDI	R19,0
    04EA1 E00A      LDI	R16,0xA
    04EA2 940E 6A2C CALL	_MotRun
    04EA4 E081      LDI	R24,1
    04EA5 9380 1658 STS	dustbinOldState+1,R24
    04EA7 E015      LDI	R17,5
    04EA8 9100 1614 LDS	R16,EvenPosChangeProcess+10
    04EAA 940E ADEA CALL	mod8s
(2439) 		{
(2440) 			case 2:		n = 2;	break;			// 1:2 = 100 + 100 
    04EAC 2300      TST	R16
    04EAD F429      BNE	0x4EB3
(2441) 			case 12:	n = 3;	break;			// 1:3 = 100 + 200
    04EAE E32C      LDI	R18,0x3C
    04EAF E030      LDI	R19,0
    04EB0 E00A      LDI	R16,0xA
(2442) 			case 13:	n = 4;	break;			// 1:4 = 100 + 300
    04EB1 940E 97B7 CALL	_SetDelayTime
    04EB3 9020 1614 LDS	R2,EvenPosChangeProcess+10
(2443) 			case 3:		
(2444) 			case 4:
(2445) 			case 5:
(2446) 			case 6:
(2447) 			case 7:
(2448) 			case 8:
(2449) 			case 14:	n = 5;	break;		// 500ul
    04EB5 2022      TST	R2
    04EB6 F421      BNE	0x4EBB
(2450) 			case 9:		n = 2;	break;		// 1:500  = 1:100 X 5
    04EB7 E086      LDI	R24,6
    04EB8 9380 160D STS	EvenPosChangeProcess+3,R24
(2451) 			case 10:	n = 1;	break;		// 1:1000	= 1:100 X 10	
    04EBA C109      RJMP	_SetReadTime0
    04EBB E088      LDI	R24,0x8
    04EBC 9380 160D STS	EvenPosChangeProcess+3,R24
(2452) 			case 11:	n = 1;	break;		// 1:2000	= 1:200 X 10	
    04EBE C105      RJMP	_SetReadTime0
    04EBF EC28      LDI	R18,0xC8
(2453) 			default:	n = 0;	break;
    04EC0 E104      LDI	R16,0x14
    04EC1 E010      LDI	R17,0
(2454) 		}
(2455) 	}
    04EC2 940E 6289 CALL	__EffluentMotRun
(2456) 	else
(2457) 	{	// 混合液量
(2458) 		switch(multipNum)
    04EC4 E124      LDI	R18,0x14
    04EC5 E030      LDI	R19,0
    04EC6 E00A      LDI	R16,0xA
    04EC7 940E 97B7 CALL	_SetDelayTime
    04EC9 E081      LDI	R24,1
    04ECA 9380 1656 STS	CardScanfSW,R24
    04ECC E08D      LDI	R24,0xD
    04ECD 9380 160D STS	EvenPosChangeProcess+3,R24
    04ECF E085      LDI	R24,5
    04ED0 9380 1614 STS	EvenPosChangeProcess+10,R24
    04ED2 C0F1      RJMP	_SetReadTime0
    04ED3 9180 1614 LDS	R24,EvenPosChangeProcess+10
    04ED5 5081      SUBI	R24,1
    04ED6 9380 1614 STS	EvenPosChangeProcess+10,R24
    04ED8 2722      CLR	R18
    04ED9 E002      LDI	R16,2
(2459) 		{
(2460) 			case 2:		n = 2;	break;
    04EDA 940E 6B81 CALL	_SetEValve
    04EDC E021      LDI	R18,1
(2461) 			case 12:	n = 3;	break;
    04EDD E001      LDI	R16,1
    04EDE 940E 6B81 CALL	_SetEValve
(2462) 			case 13:	n = 4;	break;
    04EE0 E520      LDI	R18,0x50
    04EE1 E008      LDI	R16,0x8
    04EE2 E010      LDI	R17,0
(2463) 			case 3:		
(2464) 			case 4:
(2465) 			case 5:
(2466) 			case 6:
(2467) 			case 7:
(2468) 			case 8:
(2469) 			case 14:	n = 5;	break;
    04EE3 940E 6264 CALL	__FluidMotRun
    04EE5 E081      LDI	R24,1
(2470) 			case 9:		n = 10;		break;		// 1:500	 = 1:100 X 5	
    04EE6 9380 1658 STS	dustbinOldState+1,R24
    04EE8 9380 1656 STS	CardScanfSW,R24
(2471) 			case 10:	n = 10;		break;		// 1:1000	 = 1:100 X 10
    04EEA E021      LDI	R18,1
    04EEB E003      LDI	R16,3
(2472) 			case 11:	n = 10;		break;		// 1:2000	 = 1:200 X 10	
    04EEC 940E 6B81 CALL	_SetEValve
    04EEE E08E      LDI	R24,0xE
(2473) 			default:	 n = 0;		break;
    04EEF 9380 160D STS	EvenPosChangeProcess+3,R24
(2474) 		}
(2475) 	}
(2476) 	return n;
    04EF1 C0D2      RJMP	_SetReadTime0
    04EF2 EA20      LDI	R18,0xA0
    04EF3 EF0F      LDI	R16,0xFF
_CalSampSyringSpeed:
  n                    --> R20
  diluteTime           --> R18
  multipNum            --> R16
    04EF4 EF1F      LDI	R17,0xFF
    04EF5 940E 6264 CALL	__FluidMotRun
(2477) }
(2478) unsigned char CalSampSyringSpeed(unsigned char multipNum, unsigned char diluteTime){
(2479) 	// 计算标本注射速度
(2480) 	unsigned char n;
(2481) 	if(diluteTime == 0){
    04EF7 EF20      LDI	R18,0xF0
    04EF8 E108      LDI	R16,0x18
(2482) 		switch(multipNum){		// 第一次稀释
    04EF9 E010      LDI	R17,0
    04EFA 940E 6289 CALL	__EffluentMotRun
    04EFC E025      LDI	R18,5
    04EFD E030      LDI	R19,0
    04EFE E003      LDI	R16,3
    04EFF 940E 97B7 CALL	_SetDelayTime
    04F01 E08F      LDI	R24,0xF
    04F02 9380 160D STS	EvenPosChangeProcess+3,R24
    04F04 C0BF      RJMP	_SetReadTime0
    04F05 2722      CLR	R18
    04F06 E003      LDI	R16,3
    04F07 940E 6B81 CALL	_SetEValve
    04F09 EC28      LDI	R18,0xC8
    04F0A E104      LDI	R16,0x14
    04F0B E010      LDI	R17,0
    04F0C 940E 6289 CALL	__EffluentMotRun
    04F0E E124      LDI	R18,0x14
    04F0F E030      LDI	R19,0
    04F10 E00A      LDI	R16,0xA
(2483) 			// 一次稀释
(2484) 			case 1:		n = 200;	break;		// 100	1:1
    04F11 940E 97B7 CALL	_SetDelayTime
(2485) 			case 2:		n = 200;	break;		// 100	1:2
    04F13 E081      LDI	R24,1
    04F14 9380 1656 STS	CardScanfSW,R24
(2486) 			case 3:		n = 200;	break;		// 100	1:5
    04F16 9020 1614 LDS	R2,EvenPosChangeProcess+10
(2487) 			case 4:		n = 200;	break;		// 55.5	1:10
    04F18 2022      TST	R2
(2488) 			case 5:		n = 200;	break;		// 26.3	1:20
    04F19 F021      BEQ	0x4F1E
    04F1A E08D      LDI	R24,0xD
(2489) 			//case 6:		n = 140;	break;		// 20.4	1:50
(2490) 			case 6:		n = 200;	break;		// 20.4	1:50
    04F1B 9380 160D STS	EvenPosChangeProcess+3,R24
(2491) 			case 7:		n = 80;		break;		// 10.1	1:100
    04F1D C0A6      RJMP	_SetReadTime0
    04F1E E08A      LDI	R24,0xA
(2492) 			case 8:		n = 60;		break;		// 5		1:200
    04F1F 9380 160D STS	EvenPosChangeProcess+3,R24
(2493) 			case 9:								// 1:500
(2494) 			case 10:	n = 80;		break;		// 1:1000
    04F21 E08F      LDI	R24,0xF
    04F22 9380 1614 STS	EvenPosChangeProcess+10,R24
(2495) 			case 11:	n = 40;		break;		// 1:2000		32
    04F24 C09F      RJMP	_SetReadTime0
(2496) 			// 2016-05-18
(2497) 			case 12:	n = 200;	break;		// 100	1:3
    04F25 9180 1614 LDS	R24,EvenPosChangeProcess+10
(2498) 			//case 13:	n = 200;	break;		// 100	1:4
(2499) 			case 13:	n = 180;	break;		// 66.7 1:4
    04F27 5081      SUBI	R24,1
    04F28 9380 1614 STS	EvenPosChangeProcess+10,R24
(2500) 			//case 14:	n = 140;	break;		// 20.5	1:40
(2501) 			case 14:	n = 200;	break;		// 38.5	1:40
    04F2A E021      LDI	R18,1
(2502) 			default:	 n = 180;	break;
    04F2B E002      LDI	R16,2
(2503) 			}
(2504) 		}
(2505) 	return n;
    04F2C 940E 6B81 CALL	_SetEValve
    04F2E 2722      CLR	R18
_CalDiluentInjectSpeed:
  n                    --> R20
  diluteTime           --> R18
  multipNum            --> R16
    04F2F E001      LDI	R16,1
    04F30 940E 6B81 CALL	_SetEValve
(2506) }
(2507) 
(2508) unsigned char CalDiluentInjectSpeed(unsigned char multipNum, unsigned char diluteTime){
(2509) 	// 计算稀释液注入速度
(2510) 	// 计算标本注射速度
(2511) 	unsigned char n;
(2512) 	if(diluteTime == 0){
    04F32 2722      CLR	R18
    04F33 E003      LDI	R16,3
(2513) 		switch(multipNum){		// 第一次稀释
    04F34 940E 6B81 CALL	_SetEValve
    04F36 E00C      LDI	R16,0xC
    04F37 940E 6AFA CALL	_MotInitCheck
    04F39 E420      LDI	R18,0x40
    04F3A E100      LDI	R16,0x10
    04F3B E010      LDI	R17,0
    04F3C 940E 6264 CALL	__FluidMotRun
    04F3E E081      LDI	R24,1
    04F3F 9380 1658 STS	dustbinOldState+1,R24
    04F41 E228      LDI	R18,0x28
    04F42 E030      LDI	R19,0
    04F43 E00A      LDI	R16,0xA
    04F44 940E 97B7 CALL	_SetDelayTime
    04F46 E08B      LDI	R24,0xB
    04F47 9380 160D STS	EvenPosChangeProcess+3,R24
    04F49 C07A      RJMP	_SetReadTime0
    04F4A EC28      LDI	R18,0xC8
    04F4B E104      LDI	R16,0x14
(2514) 			// 一次稀释
(2515) 			case 1:		n = 0;		break;		// 0		1:1
    04F4C E010      LDI	R17,0
    04F4D 940E 6289 CALL	__EffluentMotRun
(2516) 			//case 2:		n = 4;		break;		// 100	1:2
(2517) 			case 2:		n = 25;		break;		// 100	1:2
    04F4F E124      LDI	R18,0x14
(2518) 			case 3:		n = 16;		break;		// 400	1:5
    04F50 E030      LDI	R19,0
    04F51 E00A      LDI	R16,0xA
(2519) 			case 4:		n = 40;		break;		// 500	1:10
    04F52 940E 97B7 CALL	_SetDelayTime
(2520) 			case 5:		n = 75;		break;		// 500	1:20
    04F54 E081      LDI	R24,1
    04F55 9380 1656 STS	CardScanfSW,R24
(2521) 			case 6:		n = 160;	break;		// 1000	1:50
    04F57 9020 1614 LDS	R2,EvenPosChangeProcess+10
(2522) 			case 7:		n = 160;	break;		// 1000	1:100
    04F59 2022      TST	R2
(2523) 			case 8:		n = 160;	break;		// 1000		1:200
    04F5A F421      BNE	0x4F5F
    04F5B E08C      LDI	R24,0xC
(2524) 			case 9:								// 1:500
(2525) 			case 10:							// 1:1000
(2526) 			case 11:	n = 160-10;	break;		// 1:2000		160-30(cv <1.5)
    04F5C 9380 160D STS	EvenPosChangeProcess+3,R24
(2527) 			// 2016-05-18
(2528) 			//case 12:	n = 8;		break;		// 200	1:3
(2529) 			case 12:	n = 50;		break;		// 200	1:3
    04F5E C065      RJMP	_SetReadTime0
    04F5F E08A      LDI	R24,0xA
(2530) 			//case 13:	n = 12;		break;		// 300  1:4
(2531) 			case 13:	n = 60;		break;		// 300  1:4
    04F60 9380 160D STS	EvenPosChangeProcess+3,R24
(2532) 			//case 14:	n = 150;	break;		// 800	1:40
(2533) 			case 14:	n = 220;	break;		// 1500	1:40
    04F62 C061      RJMP	_SetReadTime0
    04F63 E085      LDI	R24,5
(2534) 			default:	 n = 0;		break;
    04F64 9380 1614 STS	EvenPosChangeProcess+10,R24
(2535) 			}
(2536) 		}
(2537) 	return n;
    04F66 2422      CLR	R2
    04F67 9220 160C STS	EvenPosChangeProcess+2,R2
    04F69 E089      LDI	R24,0x9
    04F6A 9380 160D STS	EvenPosChangeProcess+3,R24
(2538) }
(2539) 
(2540) 
(2541) /******************************************************************************/
(2542) 
(2543) void SetWorkStoreNum(unsigned char num){
(2544) 	// 设置测试卡仓号	1~5,从小仓开始数
(2545) 	if(num > 5)
    04F6C C057      RJMP	_SetReadTime0
    04F6D 90A0 160D LDS	R10,EvenPosChangeProcess+3
(2546) 		num = 5;
    04F6F 24BB      CLR	R11
    04F70 20AA      TST	R10
(2547) 	if(num == 0)
(2548) 		num = 1;
    04F71 F411      BNE	0x4F74
(2549) 	_NewCardStoreNum = num;
    04F72 20BB      TST	R11
    04F73 F071      BEQ	0x4F82
(2550) 	Uart0ReUnable;
    04F74 01C5      MOVW	R24,R10
    04F75 3083      CPI	R24,3
    04F76 E0E0      LDI	R30,0
    04F77 079E      CPC	R25,R30
    04F78 F0A9      BEQ	0x4F8E
(2551) 	uart_Printf("%s $%4d\r\n",strM3137, _NewCardStoreNum);
    04F79 3084      CPI	R24,4
    04F7A E0E0      LDI	R30,0
    04F7B 079E      CPC	R25,R30
    04F7C F129      BEQ	0x4FA2
    04F7D 3085      CPI	R24,5
    04F7E E0E0      LDI	R30,0
    04F7F 079E      CPC	R25,R30
    04F80 F179      BEQ	0x4FB0
    04F81 C042      RJMP	_SetReadTime0
    04F82 EB24      LDI	R18,0xB4
(2552) 	Uart0ReEnable;
    04F83 2700      CLR	R16
    04F84 2711      CLR	R17
    04F85 940E 62FB CALL	__NeedleMotRunTo
    04F87 E081      LDI	R24,1
    04F88 9380 165A STS	dustbinOldState+3,R24
    04F8A E083      LDI	R24,3
(2553) }
(2554) unsigned char GetWorkStoreNum(void){
(2555) 	return _NewCardStoreNum;
_GetWorkStoreNum:
    04F8B 9380 160D STS	EvenPosChangeProcess+3,R24
    04F8D C036      RJMP	_SetReadTime0
_SetDiluentRatio:
  num                  --> R20
    04F8E E084      LDI	R24,4
    04F8F 838A      STD	Y+2,R24
    04F90 E08A      LDI	R24,0xA
(2556) }
(2557) //_CONST unsigned int RatioNumber[] = {0,1,2,5,10,20,50,100,200,500,1000,2000,5000,10000};
(2558) _CONST unsigned int RatioNumber[] = {0,1,2,5,10,20,50,100,200,500,1000,2000,3,4,40};
(2559) void SetDiluentRatio(unsigned char num){
(2560) 	// 设置稀释比例
(2561) 	//if(num>13)
(2562) 	//	num = 13;
(2563) 	if(num == 0)
    04F91 8388      ST	Y,R24
    04F92 EF2F      LDI	R18,0xFF
(2564) 		num = 1;
    04F93 E002      LDI	R16,2
(2565) 	if(num > 14)
    04F94 940E 6A9F CALL	_SetMotRunPam
    04F96 2722      CLR	R18
(2566) 		num = 14;
    04F97 2733      CLR	R19
(2567) 	_NewMultipNum = num;
    04F98 E002      LDI	R16,2
    04F99 940E 6A5B CALL	_MotRunTo
(2568) 	if(1 != _NewMultipNum)	// 如果稀释比例不为1:1
    04F9B E081      LDI	R24,1
(2569) 		_MixtureMode = 0;
    04F9C 9380 165B STS	dustbinOldState+4,R24
    04F9E E084      LDI	R24,4
(2570) 	Uart0ReUnable;
    04F9F 9380 160D STS	EvenPosChangeProcess+3,R24
    04FA1 C022      RJMP	_SetReadTime0
    04FA2 9120 1646 LDS	R18,_NewCardStoreNum+6
(2571) 	uart_Printf("%s $%4d $%4d\r\n",strM3136, _NewMultipNum, RatioNumber[_NewMultipNum]);
    04FA4 9130 1647 LDS	R19,_NewCardStoreNum+7
    04FA6 E002      LDI	R16,2
    04FA7 940E 6A5B CALL	_MotRunTo
    04FA9 E081      LDI	R24,1
    04FAA 9380 165B STS	dustbinOldState+4,R24
    04FAC E085      LDI	R24,5
    04FAD 9380 160D STS	EvenPosChangeProcess+3,R24
    04FAF C014      RJMP	_SetReadTime0
    04FB0 EB24      LDI	R18,0xB4
    04FB1 E804      LDI	R16,0x84
    04FB2 E013      LDI	R17,3
    04FB3 940E 62FB CALL	__NeedleMotRunTo
    04FB5 E081      LDI	R24,1
    04FB6 9380 165A STS	dustbinOldState+3,R24
    04FB8 E085      LDI	R24,5
    04FB9 9380 1614 STS	EvenPosChangeProcess+10,R24
    04FBB E081      LDI	R24,1
(2572) 	Uart0ReEnable;
    04FBC 9380 1610 STS	EvenPosChangeProcess+6,R24
    04FBE 2422      CLR	R2
    04FBF 9220 160C STS	EvenPosChangeProcess+2,R2
    04FC1 E089      LDI	R24,0x9
    04FC2 9380 160D STS	EvenPosChangeProcess+3,R24
_SetReadTime0:
  t                    --> R20
    04FC4 2700      CLR	R16
    04FC5 9624      ADIW	R28,4
    04FC6 940E AE6D CALL	pop_xgsetF0FC
(2573) }
(2574) void SetReadTime0(unsigned int t){
(2575) 	// 设置A检测头测试时间
(2576) 	if(t>900)
    04FC8 9622      ADIW	R28,2
    04FC9 9508      RET
_CalSampVolume:
    04FCA 940E AEB3 CALL	push_xgsetF03C
    04FCC 2EC2      MOV	R12,R18
(2577) 		t = 900;
    04FCD 2EA0      MOV	R10,R16
    04FCE 9728      SBIW	R28,0x8
(2578) 	if(t<20)
    04FCF E080      LDI	R24,0
    04FD0 8388      ST	Y,R24
    04FD1 8389      STD	Y+1,R24
    04FD2 838A      STD	Y+2,R24
(2579) 		t = 20;
    04FD3 838B      STD	Y+3,R24
    04FD4 E885      LDI	R24,0x85
(2580) 	_NewReadTime0 = t;
    04FD5 E197      LDI	R25,0x17
    04FD6 2DEA      MOV	R30,R10
    04FD7 27FF      CLR	R31
    04FD8 0FEE      LSL	R30
(2581) 	Uart0ReUnable;
    04FD9 1FFF      ROL	R31
    04FDA 0FE8      ADD	R30,R24
    04FDB 1FF9      ADC	R31,R25
    04FDC 8020      LD	R2,Z
    04FDD 8031      LDD	R3,Z+1
(2582) 	uart_Printf("%s $%4d\r\n",strM3138, _NewReadTime0);
    04FDE 2444      CLR	R4
    04FDF 2455      CLR	R5
    04FE0 822C      STD	Y+4,R2
    04FE1 823D      STD	Y+5,R3
    04FE2 824E      STD	Y+6,R4
    04FE3 825F      STD	Y+7,R5
    04FE4 20CC      TST	R12
    04FE5 F009      BEQ	0x4FE7
    04FE6 C138      RJMP	0x511F
(2583) 	Uart0ReEnable;
    04FE7 24BB      CLR	R11
    04FE8 01C5      MOVW	R24,R10
    04FE9 3081      CPI	R24,1
    04FEA E0E0      LDI	R30,0
    04FEB 079E      CPC	R25,R30
    04FEC F40C      BGE	0x4FEE
    04FED C12C      RJMP	0x511A
    04FEE E08E      LDI	R24,0xE
    04FEF 158A      CP	R24,R10
_SetReadTime1:
  t                    --> R20
    04FF0 059B      CPC	R25,R11
    04FF1 F40C      BGE	0x4FF3
    04FF2 C127      RJMP	0x511A
    04FF3 ED86      LDI	R24,0xD6
(2584) }
(2585) void SetReadTime1(unsigned int t){
(2586) 	// 设置B检测头测试时间
(2587) 	_NewReadTime1 = 0;
    04FF4 E092      LDI	R25,2
    04FF5 01F5      MOVW	R30,R10
    04FF6 9731      SBIW	R30,1
    04FF7 0FEE      LSL	R30
    04FF8 1FFF      ROL	R31
    04FF9 0FE8      ADD	R30,R24
(2588) 	return;
    04FFA 1FF9      ADC	R31,R25
(2589) 
(2590) 	if(t>900)
(2591) 		t = 900;
    04FFB 9027      ELPM	R2,Z+
    04FFC 9036      ELPM	R3,Z
(2592) 	if(t<20)
    04FFD 01F1      MOVW	R30,R2
    04FFE 9409      IJMP
    04FFF 9180 1654 LDS	R24,_DropVolume|diluteProcessState
(2593) 		t = 20;
    05001 9190 1655 LDS	R25,GetNewPieceProcessState
(2594) 	_NewReadTime1 = t;
    05003 5F82      SUBI	R24,0xF2
    05004 4F9E      SBCI	R25,0xFE
    05005 978D      SBIW	R24,0x2D
    05006 015C      MOVW	R10,R24
(2595) 	Uart0ReUnable;
    05007 018C      MOVW	R16,R24
    05008 C12B      RJMP	0x5134
    05009 802C      LDD	R2,Y+4
    0500A 803D      LDD	R3,Y+5
    0500B 804E      LDD	R4,Y+6
(2596) 	uart_Printf("%s $%4d\r\n", strM3139, _NewReadTime1);
    0500C 805F      LDD	R5,Y+7
    0500D E448      LDI	R20,0x48
    0500E E05D      LDI	R21,0xD
    0500F E060      LDI	R22,0
    05010 E070      LDI	R23,0
    05011 925A      ST	-Y,R5
    05012 924A      ST	-Y,R4
    05013 923A      ST	-Y,R3
    05014 922A      ST	-Y,R2
(2597) 	Uart0ReEnable;
    05015 018A      MOVW	R16,R20
    05016 019B      MOVW	R18,R22
    05017 940E AE24 CALL	empy32s|empy32u
    05019 8308      ST	Y,R16
    0501A 8319      STD	Y+1,R17
    0501B 832A      STD	Y+2,R18
    0501C 833B      STD	Y+3,R19
    0501D C101      RJMP	0x511F
_SetReadMolule:
  n                    --> R10
    0501E 802C      LDD	R2,Y+4
    0501F 803D      LDD	R3,Y+5
    05020 804E      LDD	R4,Y+6
(2598) }
(2599) void SetReadMolule(unsigned char n){
(2600) 	// 设置读数头
(2601) 	if(n == 0)
    05021 805F      LDD	R5,Y+7
    05022 E944      LDI	R20,0x94
(2602) 		_NewTestType = 0;
    05023 E150      LDI	R21,0x10
    05024 E060      LDI	R22,0
    05025 E070      LDI	R23,0
    05026 925A      ST	-Y,R5
(2603) 	else
(2604) 		_NewTestType = 1;
    05027 924A      ST	-Y,R4
    05028 923A      ST	-Y,R3
    05029 922A      ST	-Y,R2
(2605) 	Uart0ReUnable;
    0502A 018A      MOVW	R16,R20
    0502B 019B      MOVW	R18,R22
    0502C 940E AE24 CALL	empy32s|empy32u
    0502E 8308      ST	Y,R16
(2606) 	uart_Printf("%s $%4d\r\n", strM3140, _NewTestType);
    0502F 8319      STD	Y+1,R17
    05030 832A      STD	Y+2,R18
    05031 833B      STD	Y+3,R19
    05032 C0EC      RJMP	0x511F
    05033 802C      LDD	R2,Y+4
    05034 803D      LDD	R3,Y+5
    05035 804E      LDD	R4,Y+6
    05036 805F      LDD	R5,Y+7
    05037 E343      LDI	R20,0x33
    05038 E059      LDI	R21,0x9
    05039 E060      LDI	R22,0
(2607) 	Uart0ReEnable;
    0503A E070      LDI	R23,0
    0503B 925A      ST	-Y,R5
    0503C 924A      ST	-Y,R4
    0503D 923A      ST	-Y,R3
    0503E 922A      ST	-Y,R2
    0503F 018A      MOVW	R16,R20
    05040 019B      MOVW	R18,R22
    05041 940E AE24 CALL	empy32s|empy32u
    05043 8308      ST	Y,R16
    05044 8319      STD	Y+1,R17
(2608) }
(2609) 
(2610) unsigned long _NewTestSetial(void){
(2611) 	// 保存序列号
(2612) 	unsigned char c;
(2613) 	unsigned int i;
(2614) 	unsigned long l;
(2615) 
(2616) 	EEPROM_READ(EEP_ADD_SERIAL, c);		// 读取初始化标识
    05045 832A      STD	Y+2,R18
    05046 833B      STD	Y+3,R19
    05047 C0D7      RJMP	0x511F
    05048 802C      LDD	R2,Y+4
    05049 803D      LDD	R3,Y+5
    0504A 804E      LDD	R4,Y+6
    0504B 805F      LDD	R5,Y+7
    0504C E54C      LDI	R20,0x5C
    0504D E054      LDI	R21,4
    0504E E060      LDI	R22,0
    0504F E070      LDI	R23,0
(2617) 	if(c != 0xc5){		// 初始化
    05050 925A      ST	-Y,R5
    05051 924A      ST	-Y,R4
    05052 923A      ST	-Y,R3
(2618) 		c = 0xc5;
    05053 922A      ST	-Y,R2
    05054 018A      MOVW	R16,R20
(2619) 		EEPROM_WRITE(EEP_ADD_SERIAL, c);
    05055 019B      MOVW	R18,R22
    05056 940E AE24 CALL	empy32s|empy32u
    05058 8308      ST	Y,R16
    05059 8319      STD	Y+1,R17
    0505A 832A      STD	Y+2,R18
    0505B 833B      STD	Y+3,R19
    0505C C0C2      RJMP	0x511F
    0505D 802C      LDD	R2,Y+4
    0505E 803D      LDD	R3,Y+5
    0505F 804E      LDD	R4,Y+6
(2620) 		c = 0;
    05060 805F      LDD	R5,Y+7
    05061 E94B      LDI	R20,0x9B
(2621) 		EEPROM_WRITE(EEP_ADD_SERIAL + 1, c);	// 出示化写入高8位数
    05062 E053      LDI	R21,3
    05063 E060      LDI	R22,0
    05064 E070      LDI	R23,0
    05065 925A      ST	-Y,R5
    05066 924A      ST	-Y,R4
    05067 923A      ST	-Y,R3
    05068 922A      ST	-Y,R2
    05069 018A      MOVW	R16,R20
    0506A 019B      MOVW	R18,R22
    0506B 940E AE24 CALL	empy32s|empy32u
(2622) 		i = 1;
    0506D 8308      ST	Y,R16
    0506E 8319      STD	Y+1,R17
    0506F 832A      STD	Y+2,R18
    05070 833B      STD	Y+3,R19
(2623) 		EEPROM_WRITE(EEP_ADD_SERIAL + 2, i);	// 出示化写入低16位数
    05071 C0AD      RJMP	0x511F
    05072 802C      LDD	R2,Y+4
    05073 803D      LDD	R3,Y+5
    05074 804E      LDD	R4,Y+6
    05075 805F      LDD	R5,Y+7
    05076 EA4D      LDI	R20,0xAD
    05077 E051      LDI	R21,1
    05078 E060      LDI	R22,0
    05079 E070      LDI	R23,0
    0507A 925A      ST	-Y,R5
(2624) 		return 1;
    0507B 924A      ST	-Y,R4
    0507C 923A      ST	-Y,R3
    0507D 922A      ST	-Y,R2
    0507E 018A      MOVW	R16,R20
    0507F 019B      MOVW	R18,R22
(2625) 		}
(2626) 	EEPROM_READ(EEP_ADD_SERIAL + 1, c);		// 读取高8位
    05080 940E AE24 CALL	empy32s|empy32u
    05082 8308      ST	Y,R16
    05083 8319      STD	Y+1,R17
    05084 832A      STD	Y+2,R18
    05085 833B      STD	Y+3,R19
    05086 C098      RJMP	0x511F
    05087 802C      LDD	R2,Y+4
    05088 803D      LDD	R3,Y+5
    05089 804E      LDD	R4,Y+6
    0508A 805F      LDD	R5,Y+7
(2627) 	if(c < 48){
    0508B ED44      LDI	R20,0xD4
    0508C E050      LDI	R21,0
    0508D E060      LDI	R22,0
(2628) 		EEPROM_READ(EEP_ADD_SERIAL+2+c*2, i);
    0508E E070      LDI	R23,0
    0508F 925A      ST	-Y,R5
    05090 924A      ST	-Y,R4
    05091 923A      ST	-Y,R3
    05092 922A      ST	-Y,R2
    05093 018A      MOVW	R16,R20
    05094 019B      MOVW	R18,R22
    05095 940E AE24 CALL	empy32s|empy32u
    05097 8308      ST	Y,R16
    05098 8319      STD	Y+1,R17
    05099 832A      STD	Y+2,R18
    0509A 833B      STD	Y+3,R19
    0509B C083      RJMP	0x511F
    0509C 802C      LDD	R2,Y+4
(2629) 		i++;
    0509D 803D      LDD	R3,Y+5
    0509E 804E      LDD	R4,Y+6
    0509F 805F      LDD	R5,Y+7
    050A0 E24C      LDI	R20,0x2C
    050A1 E051      LDI	R21,1
(2630) 		if(i==0){	// 换新的地16位写入地址
    050A2 E060      LDI	R22,0
    050A3 E070      LDI	R23,0
    050A4 925A      ST	-Y,R5
(2631) 			c ++;
    050A5 924A      ST	-Y,R4
    050A6 923A      ST	-Y,R3
    050A7 922A      ST	-Y,R2
(2632) 			EEPROM_WRITE(EEP_ADD_SERIAL + 1, c);	// 初始化写入高8位数
    050A8 018A      MOVW	R16,R20
    050A9 019B      MOVW	R18,R22
    050AA 940E AE24 CALL	empy32s|empy32u
    050AC 8308      ST	Y,R16
    050AD 8319      STD	Y+1,R17
    050AE 832A      STD	Y+2,R18
    050AF 833B      STD	Y+3,R19
    050B0 C06E      RJMP	0x511F
    050B1 802C      LDD	R2,Y+4
    050B2 803D      LDD	R3,Y+5
(2633) 			}
(2634) 		EEPROM_WRITE(EEP_ADD_SERIAL+2+c*2, i);
    050B3 804E      LDD	R4,Y+6
    050B4 805F      LDD	R5,Y+7
    050B5 EA4D      LDI	R20,0xAD
    050B6 E051      LDI	R21,1
    050B7 E060      LDI	R22,0
    050B8 E070      LDI	R23,0
    050B9 925A      ST	-Y,R5
    050BA 924A      ST	-Y,R4
    050BB 923A      ST	-Y,R3
    050BC 922A      ST	-Y,R2
    050BD 018A      MOVW	R16,R20
    050BE 019B      MOVW	R18,R22
    050BF 940E AE24 CALL	empy32s|empy32u
    050C1 8308      ST	Y,R16
(2635) 		}
(2636) 	l = c * 0x10000 + i;
    050C2 8319      STD	Y+1,R17
    050C3 832A      STD	Y+2,R18
    050C4 833B      STD	Y+3,R19
    050C5 C059      RJMP	0x511F
    050C6 802C      LDD	R2,Y+4
    050C7 803D      LDD	R3,Y+5
    050C8 804E      LDD	R4,Y+6
    050C9 805F      LDD	R5,Y+7
    050CA ED44      LDI	R20,0xD4
    050CB E050      LDI	R21,0
    050CC E060      LDI	R22,0
    050CD E070      LDI	R23,0
    050CE 925A      ST	-Y,R5
    050CF 924A      ST	-Y,R4
    050D0 923A      ST	-Y,R3
    050D1 922A      ST	-Y,R2
    050D2 018A      MOVW	R16,R20
    050D3 019B      MOVW	R18,R22
    050D4 940E AE24 CALL	empy32s|empy32u
    050D6 8308      ST	Y,R16
    050D7 8319      STD	Y+1,R17
    050D8 832A      STD	Y+2,R18
    050D9 833B      STD	Y+3,R19
    050DA C044      RJMP	0x511F
    050DB 802C      LDD	R2,Y+4
    050DC 803D      LDD	R3,Y+5
    050DD 804E      LDD	R4,Y+6
    050DE 805F      LDD	R5,Y+7
    050DF E944      LDI	R20,0x94
(2637) 	return l;
    050E0 E150      LDI	R21,0x10
    050E1 E060      LDI	R22,0
    050E2 E070      LDI	R23,0
    050E3 925A      ST	-Y,R5
    050E4 924A      ST	-Y,R4
    050E5 923A      ST	-Y,R3
    050E6 922A      ST	-Y,R2
_ReadCurTestSetial:
  l                    --> Y,+5
  i                    --> Y,+3
  c                    --> Y,+2
    050E7 018A      MOVW	R16,R20
    050E8 019B      MOVW	R18,R22
    050E9 940E AE24 CALL	empy32s|empy32u
(2638) }
(2639) unsigned long ReadCurTestSetial(void){
(2640) 	unsigned char c;
(2641) 	unsigned int i;
(2642) 	unsigned long l;
(2643) 	l = 1;
    050EB 8308      ST	Y,R16
    050EC 8319      STD	Y+1,R17
    050ED 832A      STD	Y+2,R18
    050EE 833B      STD	Y+3,R19
    050EF C02F      RJMP	0x511F
(2644) 	EEPROM_READ(EEP_ADD_SERIAL, c);		// 读取初始化标识
    050F0 802C      LDD	R2,Y+4
    050F1 803D      LDD	R3,Y+5
    050F2 804E      LDD	R4,Y+6
    050F3 805F      LDD	R5,Y+7
    050F4 E04F      LDI	R20,0xF
    050F5 E05B      LDI	R21,0xB
    050F6 E060      LDI	R22,0
    050F7 E070      LDI	R23,0
    050F8 925A      ST	-Y,R5
    050F9 924A      ST	-Y,R4
    050FA 923A      ST	-Y,R3
(2645) 	if(c != 0xc5){		// 初始化
    050FB 922A      ST	-Y,R2
    050FC 018A      MOVW	R16,R20
    050FD 019B      MOVW	R18,R22
(2646) 		c = 0xc5;
    050FE 940E AE24 CALL	empy32s|empy32u
(2647) 		EEPROM_WRITE(EEP_ADD_SERIAL, c);
    05100 8308      ST	Y,R16
    05101 8319      STD	Y+1,R17
    05102 832A      STD	Y+2,R18
    05103 833B      STD	Y+3,R19
    05104 C01A      RJMP	0x511F
    05105 802C      LDD	R2,Y+4
    05106 803D      LDD	R3,Y+5
    05107 804E      LDD	R4,Y+6
    05108 805F      LDD	R5,Y+7
    05109 E642      LDI	R20,0x62
    0510A E056      LDI	R21,6
(2648) 		c = 0;
    0510B E060      LDI	R22,0
    0510C E070      LDI	R23,0
(2649) 		EEPROM_WRITE(EEP_ADD_SERIAL + 1, c);	// 出示化写入高8位数
    0510D 925A      ST	-Y,R5
    0510E 924A      ST	-Y,R4
    0510F 923A      ST	-Y,R3
    05110 922A      ST	-Y,R2
    05111 018A      MOVW	R16,R20
    05112 019B      MOVW	R18,R22
    05113 940E AE24 CALL	empy32s|empy32u
    05115 8308      ST	Y,R16
    05116 8319      STD	Y+1,R17
    05117 832A      STD	Y+2,R18
(2650) 		i = 1;
    05118 833B      STD	Y+3,R19
    05119 C005      RJMP	0x511F
    0511A E080      LDI	R24,0
    0511B 8388      ST	Y,R24
(2651) 		EEPROM_WRITE(EEP_ADD_SERIAL + 2, i);	// 出示化写入低16位数
    0511C 8389      STD	Y+1,R24
    0511D 838A      STD	Y+2,R24
    0511E 838B      STD	Y+3,R24
    0511F E741      LDI	R20,0x71
    05120 E052      LDI	R21,2
    05121 E060      LDI	R22,0
    05122 E070      LDI	R23,0
    05123 8108      LD	R16,Y
    05124 8119      LDD	R17,Y+1
    05125 812A      LDD	R18,Y+2
(2652) 		return 1;
    05126 813B      LDD	R19,Y+3
    05127 937A      ST	-Y,R23
    05128 936A      ST	-Y,R22
    05129 935A      ST	-Y,R21
    0512A 934A      ST	-Y,R20
(2653) 		}
(2654) 	EEPROM_READ(EEP_ADD_SERIAL + 1, c);		// 读取高8位
    0512B 940E AD80 CALL	div32u
    0512D 8308      ST	Y,R16
    0512E 8319      STD	Y+1,R17
    0512F 832A      STD	Y+2,R18
    05130 833B      STD	Y+3,R19
    05131 80A8      LD	R10,Y
    05132 80B9      LDD	R11,Y+1
    05133 0185      MOVW	R16,R10
    05134 9628      ADIW	R28,0x8
    05135 940C AEBC JMP	pop_xgsetF03C
(2655) 	if(c < 48){
_CalDiluteVolume:
    05137 940E AE8D CALL	push_xgsetF000
(2656) 		EEPROM_READ(EEP_ADD_SERIAL+2+c*2, i);
    05139 2322      TST	R18
    0513A F009      BEQ	0x513C
    0513B C045      RJMP	0x5181
    0513C 2F60      MOV	R22,R16
    0513D 2777      CLR	R23
    0513E 3061      CPI	R22,1
    0513F E0E0      LDI	R30,0
    05140 077E      CPC	R23,R30
    05141 F40C      BGE	0x5143
    05142 C03C      RJMP	0x517F
    05143 E08E      LDI	R24,0xE
    05144 E090      LDI	R25,0
    05145 1786      CP	R24,R22
    05146 0797      CPC	R25,R23
    05147 F40C      BGE	0x5149
(2657) 		l = c * 0x10000 + i;
    05148 C036      RJMP	0x517F
    05149 EF82      LDI	R24,0xF2
    0514A E092      LDI	R25,2
    0514B 01FB      MOVW	R30,R22
    0514C 9731      SBIW	R30,1
    0514D 0FEE      LSL	R30
    0514E 1FFF      ROL	R31
    0514F 0FE8      ADD	R30,R24
    05150 1FF9      ADC	R31,R25
    05151 9027      ELPM	R2,Z+
    05152 9036      ELPM	R3,Z
    05153 01F1      MOVW	R30,R2
    05154 9409      IJMP
    05155 2744      CLR	R20
    05156 2755      CLR	R21
    05157 C029      RJMP	0x5181
    05158 E041      LDI	R20,1
    05159 E050      LDI	R21,0
    0515A C026      RJMP	0x5181
    0515B E044      LDI	R20,4
    0515C E050      LDI	R21,0
    0515D C023      RJMP	0x5181
    0515E E045      LDI	R20,5
    0515F E050      LDI	R21,0
    05160 C020      RJMP	0x5181
    05161 E045      LDI	R20,5
    05162 E050      LDI	R21,0
    05163 C01D      RJMP	0x5181
    05164 E04C      LDI	R20,0xC
    05165 E050      LDI	R21,0
(2658) 		}
(2659) 	return l;
    05166 C01A      RJMP	0x5181
    05167 E04A      LDI	R20,0xA
    05168 E050      LDI	R21,0
    05169 C017      RJMP	0x5181
    0516A E04A      LDI	R20,0xA
    0516B E050      LDI	R21,0
    0516C C014      RJMP	0x5181
__SetCurWorkParamter:
    0516D E047      LDI	R20,7
(2660) }
(2661) void _SetCurWorkParamter(void){
(2662) 	NewTestInfo.cardStoreNum = _NewCardStoreNum;
    0516E E050      LDI	R21,0
    0516F C011      RJMP	0x5181
    05170 E04A      LDI	R20,0xA
    05171 E050      LDI	R21,0
(2663) 	NewTestInfo.sampDiluteMult = _NewMultipNum;
    05172 C00E      RJMP	0x5181
    05173 E04A      LDI	R20,0xA
    05174 E050      LDI	R21,0
    05175 C00B      RJMP	0x5181
(2664) 	NewTestInfo.testTime0 = _NewReadTime0;
    05176 E042      LDI	R20,2
    05177 E050      LDI	R21,0
    05178 C008      RJMP	0x5181
    05179 E042      LDI	R20,2
    0517A E050      LDI	R21,0
    0517B C005      RJMP	0x5181
    0517C E04F      LDI	R20,0xF
    0517D E050      LDI	R21,0
(2665) 	NewTestInfo.testTime1 = _NewReadTime1;
    0517E C002      RJMP	0x5181
    0517F 2744      CLR	R20
    05180 2755      CLR	R21
    05181 018A      MOVW	R16,R20
    05182 940C AE92 JMP	pop_xgsetF000
_CalDilute2Volume:
    05184 940E AE8D CALL	push_xgsetF000
(2666) 	NewTestInfo.readType = _NewTestType;
    05186 2322      TST	R18
    05187 F009      BEQ	0x5189
    05188 C02F      RJMP	0x51B8
    05189 2F40      MOV	R20,R16
(2667) 	NewTestInfo.testSerial = _NewTestSetial();
    0518A 2755      CLR	R21
    0518B 3042      CPI	R20,2
    0518C E0E0      LDI	R30,0
    0518D 075E      CPC	R21,R30
    0518E F134      BLT	0x51B5
    0518F E08E      LDI	R24,0xE
    05190 E090      LDI	R25,0
    05191 1784      CP	R24,R20
    05192 0795      CPC	R25,R21
(2668) //	NewTestInfo.testSerial ++;	// 测试自动编号
(2669) 	// 输出新测试信息
(2670) #ifndef UartSendLong
(2671) 	Uart0ReUnable;
(2672) 	uart_Printf("%s $%8d ",strM3103,NewTestInfo.testSerial);
(2673) #else
(2674) 	Uart0ReUnable;
    05193 F10C      BLT	0x51B5
    05194 E08E      LDI	R24,0xE
    05195 E093      LDI	R25,3
    05196 01FA      MOVW	R30,R20
    05197 9732      SBIW	R30,2
(2675) 	uart_Printf("%s $ ",strM3103);
    05198 0FEE      LSL	R30
    05199 1FFF      ROL	R31
    0519A 0FE8      ADD	R30,R24
    0519B 1FF9      ADC	R31,R25
    0519C 9027      ELPM	R2,Z+
    0519D 9036      ELPM	R3,Z
(2676) 	uart0SendInt(NewTestInfo.testSerial);
    0519E 01F1      MOVW	R30,R2
    0519F 9409      IJMP
    051A0 E042      LDI	R20,2
    051A1 E050      LDI	R21,0
    051A2 C043      RJMP	0x51E6
    051A3 E043      LDI	R20,3
    051A4 E050      LDI	R21,0
    051A5 C040      RJMP	0x51E6
    051A6 E044      LDI	R20,4
    051A7 E050      LDI	R21,0
(2677) #endif
(2678) 	uart_Printf("$%4d $%4d $%4d $%4d $%4d\r\n", 
    051A8 C03D      RJMP	0x51E6
    051A9 E045      LDI	R20,5
    051AA E050      LDI	R21,0
    051AB C03A      RJMP	0x51E6
    051AC E042      LDI	R20,2
    051AD E050      LDI	R21,0
    051AE C037      RJMP	0x51E6
    051AF E041      LDI	R20,1
    051B0 E050      LDI	R21,0
    051B1 C034      RJMP	0x51E6
    051B2 E041      LDI	R20,1
    051B3 E050      LDI	R21,0
    051B4 C031      RJMP	0x51E6
    051B5 2744      CLR	R20
    051B6 2755      CLR	R21
    051B7 C02E      RJMP	0x51E6
    051B8 2F60      MOV	R22,R16
    051B9 2777      CLR	R23
    051BA 3062      CPI	R22,2
    051BB E0E0      LDI	R30,0
    051BC 077E      CPC	R23,R30
    051BD F134      BLT	0x51E4
    051BE E08E      LDI	R24,0xE
    051BF E090      LDI	R25,0
    051C0 1786      CP	R24,R22
    051C1 0797      CPC	R25,R23
    051C2 F10C      BLT	0x51E4
    051C3 E288      LDI	R24,0x28
    051C4 E093      LDI	R25,3
(2679) 			NewTestInfo.sampDiluteMult, 
(2680) 			NewTestInfo.cardStoreNum, 
(2681) 			NewTestInfo.readType, 
(2682) 			NewTestInfo.testTime0, 
(2683) 			NewTestInfo.testTime1);
(2684) 	Uart0ReEnable; 
    051C5 01FB      MOVW	R30,R22
    051C6 9732      SBIW	R30,2
    051C7 0FEE      LSL	R30
    051C8 1FFF      ROL	R31
    051C9 0FE8      ADD	R30,R24
    051CA 1FF9      ADC	R31,R25
    051CB 9027      ELPM	R2,Z+
_SetSleepTime:
  i                    --> Y,+2
  t                    --> R20
    051CC 9036      ELPM	R3,Z
    051CD 01F1      MOVW	R30,R2
    051CE 9409      IJMP
    051CF E042      LDI	R20,2
(2685) }
(2686) void SetSleepTime(unsigned int t){
(2687) 	unsigned int i;
(2688) 	// 设置休眠时间
(2689) 	if(t>4095)
    051D0 E050      LDI	R21,0
    051D1 C014      RJMP	0x51E6
    051D2 E043      LDI	R20,3
    051D3 E050      LDI	R21,0
    051D4 C011      RJMP	0x51E6
(2690) 		t = 4095;
    051D5 E044      LDI	R20,4
    051D6 E050      LDI	R21,0
(2691) 	_SleepTime = t;
    051D7 C00E      RJMP	0x51E6
    051D8 E045      LDI	R20,5
    051D9 E050      LDI	R21,0
    051DA C00B      RJMP	0x51E6
(2692) 	i = _SleepTime  + 0xc000;	// 0xc000 初始化标记
    051DB E04A      LDI	R20,0xA
    051DC E050      LDI	R21,0
    051DD C008      RJMP	0x51E6
    051DE E04A      LDI	R20,0xA
    051DF E050      LDI	R21,0
(2693) 	EEPROM_WRITE(EEP_ADD_SLEEP_TIME,  i);
    051E0 C005      RJMP	0x51E6
    051E1 E04A      LDI	R20,0xA
    051E2 E050      LDI	R21,0
    051E3 C002      RJMP	0x51E6
    051E4 2744      CLR	R20
    051E5 2755      CLR	R21
    051E6 018A      MOVW	R16,R20
    051E7 940C AE92 JMP	pop_xgsetF000
_CalSampSyringSpeed:
    051E9 940E AE8D CALL	push_xgsetF000
(2694) 	Uart0ReUnable;
    051EB 2322      TST	R18
    051EC F009      BEQ	0x51EE
    051ED C033      RJMP	0x5221
    051EE 2F60      MOV	R22,R16
    051EF 2777      CLR	R23
(2695) 	uart_Printf("%s $%4d\r\n", strM3152, _SleepTime);
    051F0 3061      CPI	R22,1
    051F1 E0E0      LDI	R30,0
    051F2 077E      CPC	R23,R30
    051F3 F40C      BGE	0x51F5
    051F4 C02B      RJMP	0x5220
    051F5 E08E      LDI	R24,0xE
    051F6 E090      LDI	R25,0
    051F7 1786      CP	R24,R22
    051F8 0797      CPC	R25,R23
    051F9 F134      BLT	0x5220
    051FA E482      LDI	R24,0x42
    051FB E093      LDI	R25,3
(2696) 	Uart0ReEnable;
    051FC 01FB      MOVW	R30,R22
    051FD 9731      SBIW	R30,1
    051FE 0FEE      LSL	R30
    051FF 1FFF      ROL	R31
    05200 0FE8      ADD	R30,R24
    05201 1FF9      ADC	R31,R25
    05202 9027      ELPM	R2,Z+
    05203 9036      ELPM	R3,Z
    05204 01F1      MOVW	R30,R2
(2697) }
(2698) void TestSleep(void)
(2699) {
(2700) 	// 进入休眠
(2701) 	_SleepTime = 1;
_TestSleep:
    05205 9409      IJMP
    05206 EC48      LDI	R20,0xC8
    05207 C019      RJMP	0x5221
    05208 EC48      LDI	R20,0xC8
    05209 C017      RJMP	0x5221
    0520A EC48      LDI	R20,0xC8
    0520B C015      RJMP	0x5221
(2702) }
(2703) void TestStartup(void){
(2704) 	// 测试启动
(2705) 	_WaitStartKey = 0;
_TestStartup:
    0520C EC48      LDI	R20,0xC8
    0520D C013      RJMP	0x5221
    0520E EC48      LDI	R20,0xC8
    0520F C011      RJMP	0x5221
(2706) }
(2707) void _SetNewCardGet(unsigned char num)
(2708) {
(2709) 	if(GetNewTestCard != 254 && GetNewTestCard != 222)	// 如果卡片已经取出，将不再取卡片
__SetNewCardGet:
  num                  --> R16
    05210 EC48      LDI	R20,0xC8
    05211 C00F      RJMP	0x5221
    05212 E540      LDI	R20,0x50
    05213 C00D      RJMP	0x5221
    05214 E34C      LDI	R20,0x3C
    05215 C00B      RJMP	0x5221
    05216 E540      LDI	R20,0x50
(2710) 	{
(2711) 		GetNewTestCard = num;	// 设置本次取卡片仓号
    05217 C009      RJMP	0x5221
    05218 E248      LDI	R20,0x28
(2712) 	}
    05219 C007      RJMP	0x5221
_SetDropVolumeFactor:
  i                    --> Y,+2
  n                    --> Y,+3
    0521A EC48      LDI	R20,0xC8
    0521B C005      RJMP	0x5221
    0521C EB44      LDI	R20,0xB4
(2713) }
(2714) 
(2715) // 滴样量调节因子
(2716) signed char SetDropVolumeFactor(signed char n)
(2717) {
(2718) 	signed char i;
(2719) 	if(n <= 120 && n >= -120)
    0521D C003      RJMP	0x5221
    0521E EC48      LDI	R20,0xC8
    0521F C001      RJMP	0x5221
    05220 EB44      LDI	R20,0xB4
    05221 2F04      MOV	R16,R20
    05222 940C AE92 JMP	pop_xgsetF000
(2720) 	{	// 参数范围判断
(2721) 		EEPROM_WRITE(EEP_DROP_VOLUME_FACTOR, n);
_CalDiluentInjectSpeed:
    05224 940E AE8D CALL	push_xgsetF000
    05226 2322      TST	R18
    05227 F009      BEQ	0x5229
    05228 C031      RJMP	0x525A
    05229 2F60      MOV	R22,R16
    0522A 2777      CLR	R23
    0522B 3061      CPI	R22,1
    0522C E0E0      LDI	R30,0
    0522D 077E      CPC	R23,R30
    0522E F40C      BGE	0x5230
(2722) 	}
(2723) 	EEPROM_READ(EEP_DROP_VOLUME_FACTOR, i);		// 重新读取写入的设置值
    0522F C029      RJMP	0x5259
    05230 E08E      LDI	R24,0xE
    05231 E090      LDI	R25,0
    05232 1786      CP	R24,R22
    05233 0797      CPC	R25,R23
    05234 F124      BLT	0x5259
    05235 E58E      LDI	R24,0x5E
    05236 E093      LDI	R25,3
    05237 01FB      MOVW	R30,R22
    05238 9731      SBIW	R30,1
    05239 0FEE      LSL	R30
(2724) 	if(i > 120 || i < -120)
    0523A 1FFF      ROL	R31
    0523B 0FE8      ADD	R30,R24
    0523C 1FF9      ADC	R31,R25
    0523D 9027      ELPM	R2,Z+
    0523E 9036      ELPM	R3,Z
    0523F 01F1      MOVW	R30,R2
    05240 9409      IJMP
(2725) 	{		// 保存的值有异常
(2726) 		i = 0;
    05241 2744      CLR	R20
    05242 C017      RJMP	0x525A
(2727) 		EEPROM_WRITE(EEP_DROP_VOLUME_FACTOR, i);
    05243 E149      LDI	R20,0x19
    05244 C015      RJMP	0x525A
    05245 E140      LDI	R20,0x10
    05246 C013      RJMP	0x525A
    05247 E248      LDI	R20,0x28
    05248 C011      RJMP	0x525A
    05249 E44B      LDI	R20,0x4B
    0524A C00F      RJMP	0x525A
    0524B EA40      LDI	R20,0xA0
    0524C C00D      RJMP	0x525A
    0524D EA40      LDI	R20,0xA0
(2728) 	}
(2729) 	return i;
    0524E C00B      RJMP	0x525A
    0524F EA40      LDI	R20,0xA0
    05250 C009      RJMP	0x525A
_GetDropVolumeFactor:
  sc                   --> Y,+2
    05251 EC48      LDI	R20,0xC8
(2730) }
(2731) 
(2732) signed int GetDropVolumeFactor(void)
(2733) {
(2734) 	signed char sc;
(2735) 	EEPROM_READ(EEP_DROP_VOLUME_FACTOR, sc);		// 重新读取写入的设置值
    05252 C007      RJMP	0x525A
    05253 E342      LDI	R20,0x32
    05254 C005      RJMP	0x525A
    05255 E34C      LDI	R20,0x3C
    05256 C003      RJMP	0x525A
    05257 ED4C      LDI	R20,0xDC
    05258 C001      RJMP	0x525A
    05259 2744      CLR	R20
    0525A 2F04      MOV	R16,R20
    0525B 940C AE92 JMP	pop_xgsetF000
(2736) 	if(sc > 120 || sc < -120)
_SetWorkStoreNum:
    0525D 934A      ST	-Y,R20
    0525E 2F40      MOV	R20,R16
    0525F 9722      SBIW	R28,2
    05260 E085      LDI	R24,5
    05261 1784      CP	R24,R20
    05262 F408      BCC	0x5264
    05263 E045      LDI	R20,5
(2737) 	{		// 保存的值有异常
(2738) 		sc = 0;
    05264 2344      TST	R20
    05265 F409      BNE	0x5267
(2739) 		EEPROM_WRITE(EEP_ADD_DROP_HEIGHT_ADJ, sc);
    05266 E041      LDI	R20,1
    05267 9340 1640 STS	_NewCardStoreNum,R20
    05269 9180 00C1 LDS	R24,0xC1
    0526B 7E8F      ANDI	R24,0xEF
    0526C 9380 00C1 STS	0xC1,R24
    0526E 2E24      MOV	R2,R20
    0526F 2433      CLR	R3
    05270 8239      STD	Y+1,R3
(2740) 	}
(2741) 	return sc;
    05271 8228      ST	Y,R2
    05272 ED2B      LDI	R18,0xDB
    05273 E03F      LDI	R19,0xF
    05274 E904      LDI	R16,0x94
    05275 E016      LDI	R17,6
    05276 940E A90D CALL	_uart_Printf
    05278 9180 00C1 LDS	R24,0xC1
    0527A 6180      ORI	R24,0x10
(2742) }
(2743) 
(2744) void SetDropVolume(unsigned int vol)
(2745) {
(2746) 	if(vol > 110)
    0527B 9380 00C1 STS	0xC1,R24
    0527D 9622      ADIW	R28,2
    0527E 9149      LD	R20,Y+
    0527F 9508      RET
(2747) 		vol = 110;
_GetWorkStoreNum:
    05280 9100 1640 LDS	R16,_NewCardStoreNum
(2748) 	Uart0ReUnable;
    05282 9508      RET
_SetDiluentRatio:
    05283 934A      ST	-Y,R20
    05284 2F40      MOV	R20,R16
    05285 9724      SBIW	R28,4
    05286 2344      TST	R20
(2749) 	uart_Printf("%s $%4d\r\n", strM3141, vol);
    05287 F409      BNE	0x5289
    05288 E041      LDI	R20,1
    05289 E08E      LDI	R24,0xE
    0528A 1784      CP	R24,R20
    0528B F408      BCC	0x528D
    0528C E04E      LDI	R20,0xE
    0528D 9340 163F STS	_NewMultipNum,R20
(2750) 	Uart0ReEnable;
    0528F 3041      CPI	R20,1
    05290 F019      BEQ	0x5294
    05291 2422      CLR	R2
    05292 9220 164D STS	_MixtureMode,R2
(2751) 	_DropVolume = (vol * 425) / 10;	// 每uL42.5步，0.023562uL/步
    05294 9180 00C1 LDS	R24,0xC1
    05296 7E8F      ANDI	R24,0xEF
    05297 9380 00C1 STS	0xC1,R24
    05299 9040 163F LDS	R4,_NewMultipNum
    0529B E080      LDI	R24,0
    0529C E095      LDI	R25,5
    0529D 2DE4      MOV	R30,R4
    0529E 27FF      CLR	R31
    0529F 0FEE      LSL	R30
    052A0 1FFF      ROL	R31
(2752) 	// 2016-06-17 增加 if(_DropVolume != 0)
(2753) 	if(_DropVolume != 0)
    052A1 0FE8      ADD	R30,R24
    052A2 1FF9      ADC	R31,R25
    052A3 9027      ELPM	R2,Z+
    052A4 9036      ELPM	R3,Z
(2754) 		_DropVolume += 149; 	// 3.5uL
    052A5 823B      STD	Y+3,R3
    052A6 822A      STD	Y+2,R2
    052A7 2C24      MOV	R2,R4
    052A8 2433      CLR	R3
    052A9 8239      STD	Y+1,R3
    052AA 8228      ST	Y,R2
    052AB EC22      LDI	R18,0xC2
    052AC E03F      LDI	R19,0xF
    052AD E404      LDI	R16,0x44
    052AE E016      LDI	R17,6
    052AF 940E A90D CALL	_uart_Printf
    052B1 9180 00C1 LDS	R24,0xC1
    052B3 6180      ORI	R24,0x10
(2755) }
(2756) 
(2757) 
(2758) //********************************************************
(2759) //add 2016.7.6
(2760) void SetSamplingVolume(unsigned int vol)
(2761) {
(2762) 	if(vol > 110)
    052B4 9380 00C1 STS	0xC1,R24
    052B6 9624      ADIW	R28,4
    052B7 9149      LD	R20,Y+
    052B8 9508      RET
(2763) 		vol = 110;
_SetReadTime0:
    052B9 934A      ST	-Y,R20
    052BA 935A      ST	-Y,R21
(2764) 	Uart0ReUnable;
    052BB 01A8      MOVW	R20,R16
    052BC 9722      SBIW	R28,2
    052BD E884      LDI	R24,0x84
    052BE E093      LDI	R25,3
    052BF 1784      CP	R24,R20
(2765) 	uart_Printf("%s $%4d\r\n", strM3121, vol);
    052C0 0795      CPC	R25,R21
    052C1 F410      BCC	0x52C4
    052C2 E844      LDI	R20,0x84
    052C3 E053      LDI	R21,3
    052C4 3144      CPI	R20,0x14
    052C5 E0E0      LDI	R30,0
    052C6 075E      CPC	R21,R30
    052C7 F410      BCC	0x52CA
(2766) 	Uart0ReEnable;
    052C8 E144      LDI	R20,0x14
    052C9 E050      LDI	R21,0
    052CA 9350 163E STS	EvenPosChangeProcess+52,R21
    052CC 9340 163D STS	EvenPosChangeProcess+51,R20
(2767) 	_SamplingVolume = (vol * 425) / 10;	// 每uL42.5步，0.023562uL/步
    052CE 9180 00C1 LDS	R24,0xC1
    052D0 7E8F      ANDI	R24,0xEF
    052D1 9380 00C1 STS	0xC1,R24
    052D3 011A      MOVW	R2,R20
    052D4 8239      STD	Y+1,R3
    052D5 8228      ST	Y,R2
    052D6 EF25      LDI	R18,0xF5
    052D7 E03F      LDI	R19,0xF
    052D8 E904      LDI	R16,0x94
    052D9 E016      LDI	R17,6
    052DA 940E A90D CALL	_uart_Printf
    052DC 9180 00C1 LDS	R24,0xC1
_SetDropMode:
  mode                 --> R20
    052DE 6180      ORI	R24,0x10
    052DF 9380 00C1 STS	0xC1,R24
    052E1 9622      ADIW	R28,2
(2768) }
(2769) //********************************************************
(2770) 
(2771) //********************************************************
(2772) //add 2016.4.20
(2773) void SetDropMode(unsigned int mode)
(2774) {
(2775) 	if(mode > 1)
    052E2 9159      LD	R21,Y+
    052E3 9149      LD	R20,Y+
    052E4 9508      RET
_SetReadTime1:
    052E5 934A      ST	-Y,R20
    052E6 935A      ST	-Y,R21
(2776) 		mode = 1;
    052E7 01A8      MOVW	R20,R16
    052E8 9722      SBIW	R28,2
(2777) 	Uart0ReUnable;
    052E9 2422      CLR	R2
    052EA 2433      CLR	R3
    052EB 9230 163C STS	EvenPosChangeProcess+50,R3
    052ED 9220 163B STS	EvenPosChangeProcess+49,R2
(2778) 	uart_Printf("%s $%4d\r\n", strM3142, mode);
    052EF C01F      RJMP	0x530F
    052F0 E844      LDI	R20,0x84
    052F1 E053      LDI	R21,3
    052F2 3144      CPI	R20,0x14
    052F3 E0E0      LDI	R30,0
    052F4 075E      CPC	R21,R30
    052F5 F410      BCC	0x52F8
(2779) 	Uart0ReEnable;
    052F6 E144      LDI	R20,0x14
    052F7 E050      LDI	R21,0
    052F8 9350 163C STS	EvenPosChangeProcess+50,R21
    052FA 9340 163B STS	EvenPosChangeProcess+49,R20
(2780) 	_DropMode = mode;
    052FC 9180 00C1 LDS	R24,0xC1
    052FE 7E8F      ANDI	R24,0xEF
(2781) 	//2016-06-15  是否需要同时设置滴样量
(2782) 	if(_DropMode)
    052FF 9380 00C1 STS	0xC1,R24
    05301 011A      MOVW	R2,R20
(2783) 	{
(2784) 		;
(2785) 	}
    05302 8239      STD	Y+1,R3
    05303 8228      ST	Y,R2
    05304 E02C      LDI	R18,0xC
    05305 E130      LDI	R19,0x10
_SetMixtureMode:
  mode                 --> R20
    05306 E904      LDI	R16,0x94
    05307 E016      LDI	R17,6
    05308 940E A90D CALL	_uart_Printf
(2786) }
(2787) 
(2788) // 设置_DropMode 模式下,设置1:1是否需要抽打混匀
(2789) void SetMixtureMode(unsigned int mode)
(2790) {
(2791) 	if(0 == _DropMode)		return;			// 非_DropMode模式下,无效
    0530A 9180 00C1 LDS	R24,0xC1
    0530C 6180      ORI	R24,0x10
    0530D 9380 00C1 STS	0xC1,R24
    0530F 9622      ADIW	R28,2
    05310 9159      LD	R21,Y+
    05311 9149      LD	R20,Y+
    05312 9508      RET
(2792) 	if(mode > 1)
_SetReadMolule:
    05313 92AA      ST	-Y,R10
    05314 2EA0      MOV	R10,R16
    05315 9722      SBIW	R28,2
    05316 20AA      TST	R10
    05317 F421      BNE	0x531C
(2793) 		mode = 1;
    05318 2422      CLR	R2
    05319 9220 163A STS	EvenPosChangeProcess+48,R2
(2794) 	Uart0ReUnable;
    0531B C003      RJMP	0x531F
    0531C E081      LDI	R24,1
    0531D 9380 163A STS	EvenPosChangeProcess+48,R24
(2795) 	uart_Printf("%s $%4d\r\n", strM3164, mode);
    0531F 9180 00C1 LDS	R24,0xC1
    05321 7E8F      ANDI	R24,0xEF
    05322 9380 00C1 STS	0xC1,R24
    05324 9020 163A LDS	R2,EvenPosChangeProcess+48
    05326 2433      CLR	R3
(2796) 	Uart0ReEnable;
    05327 8239      STD	Y+1,R3
    05328 8228      ST	Y,R2
    05329 E223      LDI	R18,0x23
    0532A E130      LDI	R19,0x10
    0532B E904      LDI	R16,0x94
(2797) 	_MixtureMode = mode;
    0532C E016      LDI	R17,6
    0532D 940E A90D CALL	_uart_Printf
    0532F 9180 00C1 LDS	R24,0xC1
    05331 6180      ORI	R24,0x10
_SetReMixNum:
  MixNum               --> R20
    05332 9380 00C1 STS	0xC1,R24
    05334 9622      ADIW	R28,2
    05335 90A9      LD	R10,Y+
(2798) }
(2799) 
(2800) void SetReMixNum(unsigned int MixNum)
(2801) {
(2802)   	if(_DropMode == 0) 
    05336 9508      RET
__NewTestSetial:
    05337 940E AE8D CALL	push_xgsetF000
    05339 9729      SBIW	R28,0x9
    0533A E081      LDI	R24,1
    0533B E090      LDI	R25,0
    0533C 8399      STD	Y+1,R25
    0533D 8388      ST	Y,R24
(2803)   	{
(2804) 		Uart0ReUnable;
    0533E 019E      MOVW	R18,R28
    0533F 5F2E      SUBI	R18,0xFE
    05340 4F3F      SBCI	R19,0xFF
    05341 E906      LDI	R16,0x96
    05342 E010      LDI	R17,0
(2805) 		uart_Printf("%s $%4d\r\n", strM3142, _DropMode);
    05343 940E AF2A CALL	_EEPROMReadBytes_extIO
    05345 818A      LDD	R24,Y+2
    05346 3C85      CPI	R24,0xC5
    05347 F169      BEQ	0x5375
    05348 EC85      LDI	R24,0xC5
    05349 838A      STD	Y+2,R24
    0534A E081      LDI	R24,1
(2806)     	uart_Printf("%s\r\n",strM3144);
    0534B E090      LDI	R25,0
    0534C 8399      STD	Y+1,R25
    0534D 8388      ST	Y,R24
    0534E 019E      MOVW	R18,R28
    0534F 5F2E      SUBI	R18,0xFE
    05350 4F3F      SBCI	R19,0xFF
(2807) 		Uart0ReEnable;
    05351 E906      LDI	R16,0x96
    05352 E010      LDI	R17,0
    05353 940E AF45 CALL	_EEPROMWriteBytes_extIO
    05355 2422      CLR	R2
(2808)     	return;
    05356 822A      STD	Y+2,R2
(2809)   	}
(2810)   	if(MixNum < 5)
    05357 E081      LDI	R24,1
    05358 E090      LDI	R25,0
    05359 8399      STD	Y+1,R25
    0535A 8388      ST	Y,R24
(2811)     	MixNum = 5;
    0535B 019E      MOVW	R18,R28
    0535C 5F2E      SUBI	R18,0xFE
    0535D 4F3F      SBCI	R19,0xFF
(2812)   	else if(MixNum > 20)
    0535E E907      LDI	R16,0x97
    0535F E010      LDI	R17,0
    05360 940E AF45 CALL	_EEPROMWriteBytes_extIO
    05362 E081      LDI	R24,1
(2813)     	MixNum = 20;
    05363 E090      LDI	R25,0
    05364 839C      STD	Y+4,R25
(2814)   	_ReMixNum = MixNum;
    05365 838B      STD	Y+3,R24
    05366 E082      LDI	R24,2
    05367 8399      STD	Y+1,R25
    05368 8388      ST	Y,R24
(2815) 	Uart0ReUnable;
    05369 019E      MOVW	R18,R28
    0536A 5F2D      SUBI	R18,0xFD
    0536B 4F3F      SBCI	R19,0xFF
    0536C E908      LDI	R16,0x98
    0536D E010      LDI	R17,0
(2816)   	uart_Printf("%s $%4d\r\n", strM3143, _ReMixNum);
    0536E 940E AF45 CALL	_EEPROMWriteBytes_extIO
    05370 E001      LDI	R16,1
    05371 E010      LDI	R17,0
    05372 E020      LDI	R18,0
    05373 E030      LDI	R19,0
    05374 C064      RJMP	0x53D9
    05375 E081      LDI	R24,1
    05376 E090      LDI	R25,0
(2817) 	Uart0ReEnable;
    05377 8399      STD	Y+1,R25
    05378 8388      ST	Y,R24
    05379 019E      MOVW	R18,R28
    0537A 5F2E      SUBI	R18,0xFE
    0537B 4F3F      SBCI	R19,0xFF
    0537C E907      LDI	R16,0x97
    0537D E010      LDI	R17,0
    0537E 940E AF2A CALL	_EEPROMReadBytes_extIO
(2818) }
(2819) //********************************************************
(2820) 
(2821) // 定标数据
(2822) 
(2823) /*
(2824) unsigned int  CalculateCalStandCoeff(unsigned int n)
(2825) {
(2826) 	unsigned long l1,l2;
(2827) 	unsigned int i;
(2828) 	if(n == 0)
(2829) 		return _DiluentCalChart.calStand;	// 返回当前设置值
(2830) 
(2831) 	if(n>_DILUENT_MIX_BASE_COEFF_UP)
(2832) 		n = _DILUENT_MIX_BASE_COEFF_UP;
(2833) 	if(n<_DILUENT_MIX_BASE_COEFF_DOWN)
(2834) 		n = _DILUENT_MIX_BASE_COEFF_DOWN;
(2835) 	_DiluentCalChart.calStand = n;
(2836) 	//Save_DiluentCalChart();
(2837) 	return _DiluentCalChart.calStand;		// 返回设置后的校准因子
(2838) }
(2839) */
(2840) 
(2841) // 将吸样量调整为不同稀释倍数下
(2842) // m 为稀释倍数   n 为调节因子
(2843) unsigned int  CalculateCalStandCoeff(unsigned int m,unsigned int n)
(2844) {
(2845) //#ifndef Puncture
(2846) 	if(m > 13)	m = 13;
_CalculateCalStandCoeff:
  n                    --> R18
  m                    --> R16
    05380 818A      LDD	R24,Y+2
    05381 3380      CPI	R24,0x30
    05382 F5A0      BCC	0x53B7
    05383 E082      LDI	R24,2
    05384 E090      LDI	R25,0
    05385 8399      STD	Y+1,R25
    05386 8388      ST	Y,R24
(2847) 	if(m == 0)	m = 9;
    05387 019E      MOVW	R18,R28
    05388 5F2D      SUBI	R18,0xFD
    05389 4F3F      SBCI	R19,0xFF
    0538A 810A      LDD	R16,Y+2
    0538B 2711      CLR	R17
(2848) 	if(n == 0)
    0538C 0F00      LSL	R16
    0538D 1F11      ROL	R17
    0538E 5608      SUBI	R16,0x68
(2849) 		return _DiluentCalChart.calStand[m];	// 返回当前设置值
    0538F 4F1F      SBCI	R17,0xFF
    05390 940E AF2A CALL	_EEPROMReadBytes_extIO
    05392 818B      LDD	R24,Y+3
    05393 819C      LDD	R25,Y+4
    05394 9601      ADIW	R24,1
    05395 839C      STD	Y+4,R25
    05396 838B      STD	Y+3,R24
    05397 3080      CPI	R24,0
    05398 0789      CPC	R24,R25
(2850) 	if(n > _DILUENT_MIX_BASE_COEFF_UP)
    05399 F471      BNE	0x53A8
    0539A 818A      LDD	R24,Y+2
    0539B 5F8F      SUBI	R24,0xFF
    0539C 838A      STD	Y+2,R24
    0539D E081      LDI	R24,1
(2851) 		n = _DILUENT_MIX_BASE_COEFF_UP;
    0539E E090      LDI	R25,0
    0539F 8399      STD	Y+1,R25
(2852) 	if(n < _DILUENT_MIX_BASE_COEFF_DOWN)
    053A0 8388      ST	Y,R24
    053A1 019E      MOVW	R18,R28
    053A2 5F2E      SUBI	R18,0xFE
    053A3 4F3F      SBCI	R19,0xFF
(2853) 		n = _DILUENT_MIX_BASE_COEFF_DOWN;
    053A4 E907      LDI	R16,0x97
    053A5 E010      LDI	R17,0
(2854) 	_DiluentCalChart.calStand[m] = n;
    053A6 940E AF45 CALL	_EEPROMWriteBytes_extIO
    053A8 E082      LDI	R24,2
    053A9 E090      LDI	R25,0
    053AA 8399      STD	Y+1,R25
    053AB 8388      ST	Y,R24
    053AC 019E      MOVW	R18,R28
    053AD 5F2D      SUBI	R18,0xFD
    053AE 4F3F      SBCI	R19,0xFF
(2855) 	return _DiluentCalChart.calStand[m];	// 返回当前设置值
    053AF 810A      LDD	R16,Y+2
    053B0 2711      CLR	R17
    053B1 0F00      LSL	R16
    053B2 1F11      ROL	R17
    053B3 5608      SUBI	R16,0x68
    053B4 4F1F      SBCI	R17,0xFF
    053B5 940E AF45 CALL	_EEPROMWriteBytes_extIO
_DiluteStartCheck:
  n                    --> Y,+4
  siTmp1               --> Y,+4
  siTmp                --> Y,+4
  m                    --> R12
  i                    --> R10
  ucTmp                --> R20
  pInfoEvent           --> R12
    053B7 802A      LDD	R2,Y+2
    053B8 2433      CLR	R3
    053B9 2444      CLR	R4
    053BA 2455      CLR	R5
(2856) /*
(2857) #else
(2858) {
(2859) 	if(WithoutPuncture != 0)		// 无需穿刺
(2860) 	{
(2861) 		if(m > 13)	m = 13;
(2862) 		if(m == 0)	m = 9;
(2863) 		if(n == 0)
(2864) 			return _DiluentCalChart.calStand[m];	// 返回当前设置值
(2865) 		if(n > _DILUENT_MIX_BASE_COEFF_UP)
(2866) 		n = _DILUENT_MIX_BASE_COEFF_UP;
(2867) 		if(n < _DILUENT_MIX_BASE_COEFF_DOWN)
(2868) 		n = _DILUENT_MIX_BASE_COEFF_DOWN;
(2869) 		_DiluentCalChart.calStand[m] = n;
(2870) 		return _DiluentCalChart.calStand[m];	// 返回当前设置值
(2871) 	}
(2872) 	else
(2873) 	{
(2874) 		if(n == 0)
(2875) 			return _DiluentCalChart.calStand[8];	// 返回当前设置值
(2876) 		if(n > _DILUENT_MIX_BASE_COEFF_UP)
(2877) 		n = _DILUENT_MIX_BASE_COEFF_UP;
(2878) 		if(n < _DILUENT_MIX_BASE_COEFF_DOWN)
(2879) 		n = _DILUENT_MIX_BASE_COEFF_DOWN;
(2880) 		_DiluentCalChart.calStand[8] = n;
(2881) 		return _DiluentCalChart.calStand[8];	// 返回当前设置值
(2882) 	}
(2883) }
(2884) #endif
(2885) */
(2886) }
(2887) 
(2888) // 此部分函数暂未使用
(2889) /*
(2890) unsigned int CalMixingHeight(unsigned char multipNum, unsigned char diluteTime)
(2891) {
(2892) 	// 计算混匀液高度
(2893) 	unsigned int n;
(2894) 	if(diluteTime == 0)
(2895) 	{
(2896) 		switch(multipNum)		// 第一次稀释
(2897) 		{
(2898) 			// 一次稀释
(2899) 			case 1:		n = 1740;			break;		// 0 1:1
(2900) 			case 2:		n = 1740-56;		break;		// 240uL-130uL=110uL 1:2
(2901) 			case 3:		n = 1740-163;		break;		// 450uL-130uL=320uL 1:5
(2902) 			case 4:		n = 1740-239;		break;		// 600uL-130uL=470uL 1:10
(2903) 			case 5:		n = 1740-239;		break;		// 600uL-130uL=470uL 19 1:20
(2904) 			case 6:		n = 1740-448;		break;		// 1010uL-130uL=880uL 33 1:50
(2905) 			case 7:		n = 1740-443;		break;		// 1000uL-130uL=870uL 33 1:100
(2906) 			case 8:		n = 1740-442;		break;		// 995uL-130uL=865uL 33 1:200
(2907) 			// 二次稀释的第一次稀释
(2908) 			case 9:										// 1:500
(2909) 			case 10:									// 1:1000
(2910) 			case 11:									// 1:2000
(2911) 			case 12:									// 1:5000	
(2912) 			case 13:	n = 1740-443;		break;		// 33 1:10000
(2913) 			default:	n = 1740;			break;
(2914) 			}
(2915) 		}
(2916) 	else
(2917) 	{			// 二次稀释
(2918) 		switch(multipNum)
(2919) 		{
(2920) 			// 二次稀释中的第二次稀释
(2921) 			case 9:		n = 1740-201;		break;		// 525uL-130uL=395uL 14 1:500
(2922) 			case 10:	n = 1740-443;		break;		// 1000uL-130uL=870uL 30 1:1000
(2923) 			case 11:	n = 1740-433;		break;		// 979uL-130uL=849uL 31 1:2000
(2924) 			case 12:	n = 1740-417;		break;		// 949uL-130uL=819uL 31 1:5000
(2925) 			case 13:	n = 1740-443;		break;		// 1000uL-130uL=870uL 33 1:10000
(2926) 			default:	n = 1740;			break;
(2927) 		}
(2928) 	}
(2929) 	return n;
(2930) }
(2931) */
(2932) 
(2933) /********************************  液路自检处理程序  ***************************************/
(2934) 
(2935) unsigned char DiluteStartCheck(INFO_EVENT * pInfoEvent)
(2936) {
(2937) //	static unsigned int liqDetBaseAdc;
(2938) //	static unsigned char waitMotSampTurn,waitMotSampNeedle, waitMotSampPump,waitMotFluid,waitMotDiluent,waitEffluent;
(2939) 	static unsigned char mainStep,workStep, subStep;		
(2940) 	static unsigned char pos;
(2941) 	static unsigned char detRetry ;		// 液体探测重试次数
(2942) 	static unsigned char CalCnt;		// 重复校准计数
(2943) 	static unsigned int CalValue1, CalValue2;
(2944) 	static unsigned char cNum;
(2945) 
(2946) 		
(2947) 	static unsigned int mixLiqLevel;
(2948) 	static unsigned int mixCalStartPos;
(2949) 	unsigned char ucTmp;
(2950) 	signed int siTmp, siTmp1;
(2951) 	unsigned int i, n, m;
(2952) 
(2953) 	if(pInfoEvent == 0)
    053BB E040      LDI	R20,0
    053BC E050      LDI	R21,0
    053BD E061      LDI	R22,1
    053BE E070      LDI	R23,0
    053BF 925A      ST	-Y,R5
    053C0 924A      ST	-Y,R4
(2954) 	{
(2955) 		if(WaitDelayTime(MOT_SAMP_PUMP))		return 0;
    053C1 923A      ST	-Y,R3
    053C2 922A      ST	-Y,R2
    053C3 018A      MOVW	R16,R20
    053C4 019B      MOVW	R18,R22
    053C5 940E AE24 CALL	empy32s|empy32u
    053C7 0118      MOVW	R2,R16
    053C8 0129      MOVW	R4,R18
(2956) 		if(WaitDelayTime(MOT_SAMP_TRUN))		return 0;
    053C9 806B      LDD	R6,Y+3
    053CA 807C      LDD	R7,Y+4
    053CB 2488      CLR	R8
    053CC 2499      CLR	R9
    053CD 0C26      ADD	R2,R6
    053CE 1C37      ADC	R3,R7
    053CF 1C48      ADC	R4,R8
    053D0 1C59      ADC	R5,R9
(2957) 		if(WaitDelayTime(MOT_SAMP_NEEDLE))		return 0;
    053D1 822D      STD	Y+5,R2
    053D2 823E      STD	Y+6,R3
    053D3 824F      STD	Y+7,R4
    053D4 8658      STD	Y+8,R5
    053D5 810D      LDD	R16,Y+5
    053D6 811E      LDD	R17,Y+6
    053D7 812F      LDD	R18,Y+7
    053D8 8538      LDD	R19,Y+8
    053D9 9629      ADIW	R28,0x9
(2958) 		if(WaitDelayTime(MOT_EFFLUENT))			return 0;
    053DA 940C AE92 JMP	pop_xgsetF000
_ReadCurTestSetial:
    053DC 940E AE8D CALL	push_xgsetF000
    053DE 9729      SBIW	R28,0x9
    053DF E081      LDI	R24,1
    053E0 838D      STD	Y+5,R24
    053E1 E080      LDI	R24,0
    053E2 838E      STD	Y+6,R24
(2959) 		if(WaitDelayTime(MOT_DILUENT))			return 0;
    053E3 838F      STD	Y+7,R24
    053E4 8788      STD	Y+8,R24
    053E5 E081      LDI	R24,1
    053E6 E090      LDI	R25,0
    053E7 8399      STD	Y+1,R25
    053E8 8388      ST	Y,R24
    053E9 019E      MOVW	R18,R28
    053EA 5F2E      SUBI	R18,0xFE
    053EB 4F3F      SBCI	R19,0xFF
(2960) 		
(2961) 		if(waitMotSampTurn)		{	if(GetMotState(MOT_SAMP_TRUN)!=STA_SLAVE_FREE)		return 0;	waitMotSampTurn = 0;	}
    053EC E906      LDI	R16,0x96
    053ED E010      LDI	R17,0
    053EE 940E AF2A CALL	_EEPROMReadBytes_extIO
    053F0 818A      LDD	R24,Y+2
    053F1 3C85      CPI	R24,0xC5
    053F2 F169      BEQ	0x5420
    053F3 EC85      LDI	R24,0xC5
    053F4 838A      STD	Y+2,R24
    053F5 E081      LDI	R24,1
    053F6 E090      LDI	R25,0
    053F7 8399      STD	Y+1,R25
    053F8 8388      ST	Y,R24
    053F9 019E      MOVW	R18,R28
    053FA 5F2E      SUBI	R18,0xFE
    053FB 4F3F      SBCI	R19,0xFF
(2962) 		if(waitMotSampNeedle)	{	if(GetMotState(MOT_SAMP_NEEDLE)!=STA_SLAVE_FREE)	return 0;	waitMotSampNeedle = 0;	}
    053FC E906      LDI	R16,0x96
    053FD E010      LDI	R17,0
    053FE 940E AF45 CALL	_EEPROMWriteBytes_extIO
    05400 2422      CLR	R2
    05401 822A      STD	Y+2,R2
    05402 E081      LDI	R24,1
    05403 E090      LDI	R25,0
    05404 8399      STD	Y+1,R25
    05405 8388      ST	Y,R24
    05406 019E      MOVW	R18,R28
    05407 5F2E      SUBI	R18,0xFE
    05408 4F3F      SBCI	R19,0xFF
    05409 E907      LDI	R16,0x97
    0540A E010      LDI	R17,0
    0540B 940E AF45 CALL	_EEPROMWriteBytes_extIO
(2963) 		if(waitMotSampPump)		{	if(GetMotState(MOT_SAMP_PUMP)!=STA_SLAVE_FREE)		return 0;	waitMotSampPump = 0;	}
    0540D E081      LDI	R24,1
    0540E E090      LDI	R25,0
    0540F 839C      STD	Y+4,R25
    05410 838B      STD	Y+3,R24
    05411 E082      LDI	R24,2
    05412 8399      STD	Y+1,R25
    05413 8388      ST	Y,R24
    05414 019E      MOVW	R18,R28
    05415 5F2D      SUBI	R18,0xFD
    05416 4F3F      SBCI	R19,0xFF
    05417 E908      LDI	R16,0x98
    05418 E010      LDI	R17,0
    05419 940E AF45 CALL	_EEPROMWriteBytes_extIO
    0541B E001      LDI	R16,1
(2964) 		if(waitMotFluid)		{	if(GetMotState(MOT_FLUID)!=STA_SLAVE_FREE)			return 0;	waitMotFluid = 0;	}
    0541C E010      LDI	R17,0
    0541D E020      LDI	R18,0
    0541E E030      LDI	R19,0
    0541F C03F      RJMP	0x545F
    05420 E081      LDI	R24,1
    05421 E090      LDI	R25,0
    05422 8399      STD	Y+1,R25
    05423 8388      ST	Y,R24
    05424 019E      MOVW	R18,R28
    05425 5F2E      SUBI	R18,0xFE
    05426 4F3F      SBCI	R19,0xFF
    05427 E907      LDI	R16,0x97
    05428 E010      LDI	R17,0
    05429 940E AF2A CALL	_EEPROMReadBytes_extIO
    0542B 818A      LDD	R24,Y+2
(2965) 		if(waitMotDiluent)		{	if(GetMotState(MOT_DILUENT)!=STA_SLAVE_FREE)		return 0;	waitMotDiluent = 0;	}
    0542C 3380      CPI	R24,0x30
    0542D F568      BCC	0x545B
    0542E E082      LDI	R24,2
    0542F E090      LDI	R25,0
    05430 8399      STD	Y+1,R25
    05431 8388      ST	Y,R24
    05432 019E      MOVW	R18,R28
    05433 5F2D      SUBI	R18,0xFD
    05434 4F3F      SBCI	R19,0xFF
    05435 810A      LDD	R16,Y+2
    05436 2711      CLR	R17
    05437 0F00      LSL	R16
    05438 1F11      ROL	R17
    05439 5608      SUBI	R16,0x68
    0543A 4F1F      SBCI	R17,0xFF
    0543B 940E AF2A CALL	_EEPROMReadBytes_extIO
(2966) 		if(waitEffluent)		{	if(GetMotState(MOT_EFFLUENT)!=STA_SLAVE_FREE)		return 0;	waitEffluent = 0;	}
    0543D 802A      LDD	R2,Y+2
    0543E 2433      CLR	R3
    0543F 2444      CLR	R4
    05440 2455      CLR	R5
    05441 E040      LDI	R20,0
    05442 E050      LDI	R21,0
    05443 E061      LDI	R22,1
    05444 E070      LDI	R23,0
    05445 925A      ST	-Y,R5
    05446 924A      ST	-Y,R4
    05447 923A      ST	-Y,R3
    05448 922A      ST	-Y,R2
    05449 018A      MOVW	R16,R20
    0544A 019B      MOVW	R18,R22
    0544B 940E AE24 CALL	empy32s|empy32u
(2967) 	}
    0544D 0118      MOVW	R2,R16
    0544E 0129      MOVW	R4,R18
    0544F 806B      LDD	R6,Y+3
(2968) 	else
(2969) 		return 0;
(2970) 
(2971) 	switch(mainStep)
    05450 807C      LDD	R7,Y+4
    05451 2488      CLR	R8
    05452 2499      CLR	R9
    05453 0C26      ADD	R2,R6
    05454 1C37      ADC	R3,R7
    05455 1C48      ADC	R4,R8
    05456 1C59      ADC	R5,R9
    05457 822D      STD	Y+5,R2
    05458 823E      STD	Y+6,R3
    05459 824F      STD	Y+7,R4
    0545A 8658      STD	Y+8,R5
    0545B 810D      LDD	R16,Y+5
    0545C 811E      LDD	R17,Y+6
    0545D 812F      LDD	R18,Y+7
    0545E 8538      LDD	R19,Y+8
    0545F 9629      ADIW	R28,0x9
    05460 940C AE92 JMP	pop_xgsetF000
__SetCurWorkParamter:
    05462 9728      SBIW	R28,0x8
    05463 9020 1640 LDS	R2,_NewCardStoreNum
    05465 9220 1667 STS	i,R2
    05467 9020 163F LDS	R2,_NewMultipNum
    05469 9220 1668 STS	j,R2
    0546B 9020 163D LDS	R2,EvenPosChangeProcess+51
    0546D 9030 163E LDS	R3,EvenPosChangeProcess+52
    0546F 9230 166B STS	checkHB,R3
    05471 9220 166A STS	checkLB,R2
    05473 9020 163B LDS	R2,EvenPosChangeProcess+49
    05475 9030 163C LDS	R3,EvenPosChangeProcess+50
    05477 9230 166D STS	timeOut+1,R3
    05479 9220 166C STS	timeOut,R2
    0547B 9020 163A LDS	R2,EvenPosChangeProcess+48
    0547D 9220 1669 STS	checkSum,R2
    0547F DEB7      RCALL	__NewTestSetial
    05480 9310 1663 STS	CardStorePhoNum,R17
    05482 9300 1662 STS	NewTestInfo|liqDetBaseAdc+1,R16
(2972) 	{
(2973) 		case 0:		// 取样臂位置初始化
(2974) 			switch(workStep)
    05484 9330 1665 STS	timeOut,R19
    05486 9320 1664 STS	LiquidPhoNum,R18
    05488 9180 00C1 LDS	R24,0xC1
    0548A 7E8F      ANDI	R24,0xEF
    0548B 9380 00C1 STS	0xC1,R24
    0548D E022      LDI	R18,2
    0548E E03D      LDI	R19,0xD
    0548F E30E      LDI	R16,0x3E
    05490 E016      LDI	R17,6
    05491 940E A90D CALL	_uart_Printf
    05493 9120 1664 LDS	R18,LiquidPhoNum
    05495 9130 1665 LDS	R19,timeOut
    05497 9100 1662 LDS	R16,NewTestInfo|liqDetBaseAdc+1
    05499 9110 1663 LDS	R17,CardStorePhoNum
    0549B 940E A940 CALL	_uart0SendInt
    0549D 9020 166C LDS	R2,timeOut
    0549F 9030 166D LDS	R3,timeOut+1
    054A1 823F      STD	Y+7,R3
    054A2 822E      STD	Y+6,R2
    054A3 9020 166A LDS	R2,checkLB
    054A5 9030 166B LDS	R3,checkHB
    054A7 823D      STD	Y+5,R3
    054A8 822C      STD	Y+4,R2
    054A9 9020 1669 LDS	R2,checkSum
    054AB 2433      CLR	R3
    054AC 823B      STD	Y+3,R3
    054AD 822A      STD	Y+2,R2
    054AE 9020 1667 LDS	R2,i
    054B0 2433      CLR	R3
    054B1 8239      STD	Y+1,R3
    054B2 8228      ST	Y,R2
    054B3 9120 1668 LDS	R18,j
    054B5 2733      CLR	R19
    054B6 E004      LDI	R16,4
    054B7 E016      LDI	R17,6
    054B8 940E A90D CALL	_uart_Printf
    054BA 9180 00C1 LDS	R24,0xC1
    054BC 6180      ORI	R24,0x10
    054BD 9380 00C1 STS	0xC1,R24
    054BF 9628      ADIW	R28,0x8
    054C0 9508      RET
_TestSleep:
    054C1 E081      LDI	R24,1
    054C2 E090      LDI	R25,0
    054C3 9390 164C STS	_SleepTime+1,R25
    054C5 9380 164B STS	_SleepTime,R24
    054C7 9508      RET
_TestStartup:
    054C8 2422      CLR	R2
    054C9 9220 1641 STS	_NewCardStoreNum+1,R2
    054CB 9508      RET
__SetNewCardGet:
    054CC 9020 165F LDS	R2,GetNewTestCard
    054CE 2D82      MOV	R24,R2
    054CF 3F8E      CPI	R24,0xFE
    054D0 F021      BEQ	0x54D5
    054D1 3D8E      CPI	R24,0xDE
    054D2 F011      BEQ	0x54D5
    054D3 9300 165F STS	GetNewTestCard,R16
    054D5 9508      RET
_SetDropVolumeFactor:
    054D6 931A      ST	-Y,R17
    054D7 930A      ST	-Y,R16
(2975) 			{
(2976) 				case 0:		// 	取样针回到起始位
(2977) 					ReadLiquidMonitorResult(0);
    054D8 9722      SBIW	R28,2
    054D9 EF84      LDI	R24,0xF4
    054DA E091      LDI	R25,1
(2978) 					ReadLiquidMonitorResult(1);
    054DB 802A      LDD	R2,Y+2
    054DC 803B      LDD	R3,Y+3
    054DD 1582      CP	R24,R2
(2979) 					ReadLiquidMonitorResult(2);
    054DE 0593      CPC	R25,R3
    054DF F08C      BLT	0x54F1
    054E0 01C1      MOVW	R24,R2
(2980) 					ReadLiquidMonitorResult(3);
    054E1 308C      CPI	R24,0xC
    054E2 EFEE      LDI	R30,0xFE
    054E3 079E      CPC	R25,R30
(2981) 					SetMotRunPam(MOT_SAMP_NEEDLE, 240, 20, CURRENT_SAMP_NEEDLE);
    054E4 F064      BLT	0x54F1
    054E5 E082      LDI	R24,2
    054E6 E090      LDI	R25,0
    054E7 8399      STD	Y+1,R25
    054E8 8388      ST	Y,R24
    054E9 019E      MOVW	R18,R28
    054EA 5F2E      SUBI	R18,0xFE
    054EB 4F3F      SBCI	R19,0xFF
(2982) 					SetMotRunPam(MOT_SAMP_TRUN,200,10,CURRENT_SAMP_TRUN);
    054EC EE00      LDI	R16,0xE0
    054ED E010      LDI	R17,0
    054EE 940E AF45 CALL	_EEPROMWriteBytes_extIO
    054F0 C021      RJMP	0x5512
    054F1 E082      LDI	R24,2
    054F2 E090      LDI	R25,0
    054F3 8399      STD	Y+1,R25
(2983) 					MotInitCheck(MOT_SAMP_NEEDLE);
    054F4 8388      ST	Y,R24
    054F5 E522      LDI	R18,0x52
    054F6 E136      LDI	R19,0x16
(2984) 					_EffluentMotRun(20, 120);
    054F7 EE00      LDI	R16,0xE0
    054F8 E010      LDI	R17,0
    054F9 940E AF2A CALL	_EEPROMReadBytes_extIO
    054FB 9180 00C1 LDS	R24,0xC1
(2985) 					waitMotSampNeedle = 1;
    054FD 7E8F      ANDI	R24,0xEF
    054FE 9380 00C1 STS	0xC1,R24
(2986) 					workStep = 1;
    05500 9020 1652 LDS	R2,cmdState
(2987) 					Uart0ReUnable;
    05502 9030 1653 LDS	R3,taskSate
    05504 8239      STD	Y+1,R3
    05505 8228      ST	Y,R2
(2988) 					uart_Printf("%s\r\n",strM2100);
    05506 EE2C      LDI	R18,0xEC
    05507 E133      LDI	R19,0x13
    05508 E904      LDI	R16,0x94
    05509 E016      LDI	R17,6
    0550A 940E A90D CALL	_uart_Printf
(2989) 					Uart0ReEnable;
    0550C 9180 00C1 LDS	R24,0xC1
    0550E 6180      ORI	R24,0x10
    0550F 9380 00C1 STS	0xC1,R24
(2990) 					break;
    05511 C03E      RJMP	0x5550
    05512 E082      LDI	R24,2
(2991) 				case 1:		// 旋转臂回到起始点
(2992) 					MotInitCheck(MOT_SAMP_TRUN);
    05513 E090      LDI	R25,0
    05514 8399      STD	Y+1,R25
    05515 8388      ST	Y,R24
(2993) 					waitMotSampTurn = 1;
    05516 E522      LDI	R18,0x52
    05517 E136      LDI	R19,0x16
    05518 EE00      LDI	R16,0xE0
(2994) 					// 读取取样臂位置
(2995) 					NeedleOnMixCenterPos = GetNeedleOnMixCenterPos();
    05519 E010      LDI	R17,0
    0551A 940E AF2A CALL	_EEPROMReadBytes_extIO
    0551C 9020 1652 LDS	R2,cmdState
    0551E 9030 1653 LDS	R3,taskSate
(2996) 					NeedleOnMixSidePos = GetNeedleOnMixSidePos();
    05520 EF84      LDI	R24,0xF4
    05521 E091      LDI	R25,1
    05522 1582      CP	R24,R2
    05523 0593      CPC	R25,R3
    05524 F02C      BLT	0x552A
    05525 01C1      MOVW	R24,R2
    05526 308C      CPI	R24,0xC
(2997) 					workStep = 2;
    05527 EFEE      LDI	R30,0xFE
    05528 079E      CPC	R25,R30
    05529 F484      BGE	0x553A
(2998) 					break;
    0552A 2422      CLR	R2
    0552B 2433      CLR	R3
(2999) 				case 2:		// 取样臂运行到混匀池正上方
(3000) 					MotRunTo(MOT_SAMP_TRUN, NeedleOnMixCenterPos);	
    0552C 9230 1653 STS	taskSate,R3
    0552E 9220 1652 STS	cmdState,R2
    05530 E082      LDI	R24,2
    05531 E090      LDI	R25,0
    05532 8399      STD	Y+1,R25
(3001) 					waitMotSampTurn = 1;
    05533 8388      ST	Y,R24
    05534 E522      LDI	R18,0x52
    05535 E136      LDI	R19,0x16
(3002) 					waitEffluent = 1;
    05536 EE00      LDI	R16,0xE0
    05537 E010      LDI	R17,0
(3003) 					detRetry = 0;
    05538 940E AF45 CALL	_EEPROMWriteBytes_extIO
    0553A 9180 00C1 LDS	R24,0xC1
(3004) 					workStep = 3;
    0553C 7E8F      ANDI	R24,0xEF
    0553D 9380 00C1 STS	0xC1,R24
(3005) 					break;
    0553F 9020 1652 LDS	R2,cmdState
(3006) 				case 3:		// 预排清洗头
(3007) 					detRetry ++;
    05541 9030 1653 LDS	R3,taskSate
    05543 8239      STD	Y+1,R3
    05544 8228      ST	Y,R2
(3008) 					SetEValve(EV3, EV_OPEN);
    05545 EE2C      LDI	R18,0xEC
    05546 E133      LDI	R19,0x13
    05547 E904      LDI	R16,0x94
    05548 E016      LDI	R17,6
(3009) 					_EffluentMotRun(20, 120);
    05549 940E A90D CALL	_uart_Printf
    0554B 9180 00C1 LDS	R24,0xC1
    0554D 6180      ORI	R24,0x10
(3010) 					_NeedleMotRunTo(_POS_MIX_TOP, 200);
    0554E 9380 00C1 STS	0xC1,R24
    05550 9624      ADIW	R28,4
    05551 9508      RET
_GetDropVolumeFactor:
    05552 9724      SBIW	R28,4
(3011) 					waitMotSampNeedle = 1;
    05553 E082      LDI	R24,2
    05554 E090      LDI	R25,0
    05555 8399      STD	Y+1,R25
(3012) 					waitEffluent = 1;
    05556 8388      ST	Y,R24
    05557 019E      MOVW	R18,R28
(3013) 					if( getLiqDetADC(NeedleChannel) < 500)	// 检查液体探测
    05558 5F2E      SUBI	R18,0xFE
    05559 4F3F      SBCI	R19,0xFF
    0555A EE00      LDI	R16,0xE0
    0555B E010      LDI	R17,0
    0555C 940E AF2A CALL	_EEPROMReadBytes_extIO
    0555E EF84      LDI	R24,0xF4
    0555F E091      LDI	R25,1
(3014) 						workStep = 110;
    05560 802A      LDD	R2,Y+2
    05561 803B      LDD	R3,Y+3
    05562 1582      CP	R24,R2
    05563 0593      CPC	R25,R3
    05564 F02C      BLT	0x556A
(3015) 					else
(3016) 						workStep = 4;
    05565 01C1      MOVW	R24,R2
    05566 308C      CPI	R24,0xC
    05567 EFEE      LDI	R30,0xFE
(3017) 					break;
    05568 079E      CPC	R25,R30
    05569 F47C      BGE	0x5579
(3018) 				case 110:	// 取样针空吸,将液路与针隔离
(3019) 					SetEValve(EV2, EV_OPEN);
    0556A 2422      CLR	R2
    0556B 2433      CLR	R3
    0556C 823B      STD	Y+3,R3
    0556D 822A      STD	Y+2,R2
(3020) 					_FluidMotRun(-1, 20);
    0556E E082      LDI	R24,2
    0556F E090      LDI	R25,0
    05570 8399      STD	Y+1,R25
    05571 8388      ST	Y,R24
    05572 019E      MOVW	R18,R28
(3021) 					waitMotFluid = 1;
    05573 5F2E      SUBI	R18,0xFE
    05574 4F3F      SBCI	R19,0xFF
    05575 EE00      LDI	R16,0xE0
(3022) 					workStep = 111;
    05576 E010      LDI	R17,0
    05577 940E AF45 CALL	_EEPROMWriteBytes_extIO
(3023) 					break;
    05579 810A      LDD	R16,Y+2
    0557A 811B      LDD	R17,Y+3
(3024) 				case 111:	// 关闭吸空
(3025) 					SetDelayTime(MOT_FLUID, 20);
    0557B 9624      ADIW	R28,4
    0557C 9508      RET
_SetDropVolume:
    0557D 934A      ST	-Y,R20
    0557E 935A      ST	-Y,R21
    0557F 01A8      MOVW	R20,R16
(3026) 					SetEValve(EV2, EV_CLOSE);
    05580 9722      SBIW	R28,2
    05581 E68E      LDI	R24,0x6E
    05582 E090      LDI	R25,0
    05583 1784      CP	R24,R20
(3027) 					workStep = 112;
    05584 0795      CPC	R25,R21
    05585 F410      BCC	0x5588
    05586 E64E      LDI	R20,0x6E
(3028) 					break;
    05587 E050      LDI	R21,0
    05588 9180 00C1 LDS	R24,0xC1
(3029) 				case 112:	// 再次检查液体探测
(3030) 					if( getLiqDetADC(NeedleChannel) < 500)	// 检查液体探测
    0558A 7E8F      ANDI	R24,0xEF
    0558B 9380 00C1 STS	0xC1,R24
    0558D 8359      STD	Y+1,R21
    0558E 8348      ST	Y,R20
    0558F E32B      LDI	R18,0x3B
    05590 E130      LDI	R19,0x10
(3031) 						workStep = 113;
    05591 E904      LDI	R16,0x94
    05592 E016      LDI	R17,6
    05593 940E A90D CALL	_uart_Printf
    05595 9180 00C1 LDS	R24,0xC1
(3032) 					else
(3033) 						workStep = 4;
    05597 6180      ORI	R24,0x10
    05598 9380 00C1 STS	0xC1,R24
(3034) 					break;
    0559A EA09      LDI	R16,0xA9
(3035) 				case 113:	// 清洗头液路吸空, 将液路与针隔离
(3036) 					SetEValve(EV1, EV_OPEN);
    0559B E011      LDI	R17,1
    0559C 019A      MOVW	R18,R20
    0559D 940E AE14 CALL	empy16s
(3037) 					_FluidMotRun(-1, 20);
    0559F E02A      LDI	R18,0xA
    055A0 E030      LDI	R19,0
    055A1 940E AD66 CALL	div16u
    055A3 9310 1655 STS	GetNewPieceProcessState,R17
(3038) 					waitMotFluid = 1;
    055A5 9300 1654 STS	_DropVolume|diluteProcessState,R16
(3039) 					workStep = 114;
    055A7 0118      MOVW	R2,R16
    055A8 3000      CPI	R16,0
    055A9 0701      CPC	R16,R17
(3040) 					break;
    055AA F039      BEQ	0x55B2
    055AB 01C1      MOVW	R24,R2
(3041) 				case 114:
(3042) 					SetDelayTime(MOT_FLUID, 20);
    055AC 568B      SUBI	R24,0x6B
    055AD 4F9F      SBCI	R25,0xFF
    055AE 9390 1655 STS	GetNewPieceProcessState,R25
    055B0 9380 1654 STS	_DropVolume|diluteProcessState,R24
(3043) 					SetEValve(EV1, EV_CLOSE);
    055B2 9622      ADIW	R28,2
    055B3 9159      LD	R21,Y+
    055B4 9149      LD	R20,Y+
(3044) 				//	if(detRetry < 4)
(3045) 				//		workStep = 3;
(3046) 				//	else
(3047) 						workStep = 4;
    055B5 9508      RET
_SetSamplingVolume:
    055B6 934A      ST	-Y,R20
    055B7 935A      ST	-Y,R21
(3048) 					break;
    055B8 01A8      MOVW	R20,R16
    055B9 9722      SBIW	R28,2
(3049) 				case 4:		// 液体探测初始化
(3050) 				/*	if(CheckLiqDetBase())
(3051) 					{
(3052) 						mainStep = 8;	
(3053) 						workStep = 0;
(3054) 						Uart0ReUnable;	
(3055) 						uart_Printf("!2501\r\n");		// 开始液路自检，在进行液面探测功能检验时发生错误
(3056) 						Uart0ReEnable;
(3057) 						break;// 退出处理
(3058) 					}
(3059) 				*/
(3060) 					liqDetBaseAdc = getLiqDetADC(NeedleChannel);
    055BA E68E      LDI	R24,0x6E
    055BB E090      LDI	R25,0
    055BC 1784      CP	R24,R20
    055BD 0795      CPC	R25,R21
    055BE F410      BCC	0x55C1
    055BF E64E      LDI	R20,0x6E
    055C0 E050      LDI	R21,0
    055C1 9180 00C1 LDS	R24,0xC1
(3061) 					//uart_Printf("//LiqDetBaseAdc1 $%4d\r\n",liqDetBaseAdc);	
(3062) 					workStep = 5;
    055C3 7E8F      ANDI	R24,0xEF
    055C4 9380 00C1 STS	0xC1,R24
(3063) 					break;
    055C6 8359      STD	Y+1,R21
(3064) 				case 5:		// 取样针运行到混匀池中,探测池中是否有液体, 分两段进行
(3065) 					SetEValve(EV_ALL, EV_CLOSE);
    055C7 8348      ST	Y,R20
    055C8 E526      LDI	R18,0x56
    055C9 E03E      LDI	R19,0xE
    055CA E904      LDI	R16,0x94
(3066) 					SetMotRunPam(MOT_SAMP_NEEDLE, 100, 10, CURRENT_SAMP_NEEDLE);
    055CB E016      LDI	R17,6
    055CC 940E A90D CALL	_uart_Printf
    055CE 9180 00C1 LDS	R24,0xC1
    055D0 6180      ORI	R24,0x10
    055D1 9380 00C1 STS	0xC1,R24
(3067) 					MotRunTo(MOT_SAMP_NEEDLE, (_POS_MIX_TOP+_POS_MIX_BUTTOM)/2);
    055D3 EA09      LDI	R16,0xA9
    055D4 E011      LDI	R17,1
    055D5 019A      MOVW	R18,R20
    055D6 940E AE14 CALL	empy16s
(3068) 					detRetry = 0;
    055D8 E02A      LDI	R18,0xA
    055D9 E030      LDI	R19,0
    055DA 940E AD66 CALL	div16u
(3069) 					workStep = 6;
    055DC 9310 1651 STS	_SamplingVolume+1,R17
(3070) 					break;
    055DE 9300 1650 STS	_SamplingVolume,R16
(3071) 				case 6:		// 液面探测，如果有探测到液体，则报警排液异常
(3072) 					i = getLiqDetADC(NeedleChannel);
    055E0 9622      ADIW	R28,2
    055E1 9159      LD	R21,Y+
    055E2 9149      LD	R20,Y+
    055E3 9508      RET
_SetDropMode:
    055E4 934A      ST	-Y,R20
(3073) 					if(i < liqDetBaseAdc)
    055E5 935A      ST	-Y,R21
    055E6 01A8      MOVW	R20,R16
    055E7 9722      SBIW	R28,2
    055E8 E081      LDI	R24,1
    055E9 E090      LDI	R25,0
    055EA 1784      CP	R24,R20
    055EB 0795      CPC	R25,R21
(3074) 					{
(3075) 						i = liqDetBaseAdc - i;
    055EC F410      BCC	0x55EF
    055ED E041      LDI	R20,1
    055EE E050      LDI	R21,0
(3076) 						if(i > 200)
    055EF 9180 00C1 LDS	R24,0xC1
    055F1 7E8F      ANDI	R24,0xEF
    055F2 9380 00C1 STS	0xC1,R24
(3077) 						{
(3078) 							if(detRetry < 15)	// 重测计数
    055F4 8359      STD	Y+1,R21
    055F5 8348      ST	Y,R20
    055F6 E523      LDI	R18,0x53
    055F7 E130      LDI	R19,0x10
(3079) 							{
(3080) 								detRetry ++;	
    055F8 E904      LDI	R16,0x94
    055F9 E016      LDI	R17,6
    055FA 940E A90D CALL	_uart_Printf
(3081) 								break;	
    055FC 9180 00C1 LDS	R24,0xC1
(3082) 							}
(3083) 							// 混匀池有残留液，排液异常
(3084) 							MotStop(MOT_SAMP_NEEDLE);
    055FE 6180      ORI	R24,0x10
    055FF 9380 00C1 STS	0xC1,R24
(3085) 							SetBeepWarning();
    05601 9350 164F STS	_DropMode+1,R21
(3086) 							mainStep = 8;
    05603 9340 164E STS	_DropMode,R20
(3087) 							workStep = 0;
    05605 3040      CPI	R20,0
    05606 0745      CPC	R20,R21
    05607 F001      BEQ	0x5608
(3088) 							SetDelayTime(MOT_SAMP_NEEDLE, 20);
    05608 9622      ADIW	R28,2
    05609 9159      LD	R21,Y+
    0560A 9149      LD	R20,Y+
    0560B 9508      RET
_SetMixtureMode:
    0560C 934A      ST	-Y,R20
(3089) 							Uart0ReUnable;
    0560D 935A      ST	-Y,R21
    0560E 01A8      MOVW	R20,R16
    0560F 9722      SBIW	R28,2
    05610 9020 164E LDS	R2,_DropMode
(3090) 							uart_Printf("!2502\r\n");	// 开始液路自检， 在检查混匀池时， 发现混匀池中有残留水， 请检查废液泵以及排液通道
    05612 9030 164F LDS	R3,_DropMode+1
    05614 2022      TST	R2
    05615 F419      BNE	0x5619
(3091) 							Uart0ReEnable;
    05616 2033      TST	R3
    05617 F409      BNE	0x5619
    05618 C01B      RJMP	0x5634
    05619 E081      LDI	R24,1
    0561A E090      LDI	R25,0
(3092) 							break;
    0561B 1784      CP	R24,R20
    0561C 0795      CPC	R25,R21
(3093) 						}
(3094) 						else
(3095) 							detRetry = 0;
    0561D F410      BCC	0x5620
    0561E E041      LDI	R20,1
    0561F E050      LDI	R21,0
(3096) 					}
(3097) 					if(GetMotState(MOT_SAMP_NEEDLE) == STA_SLAVE_FREE)
    05620 9180 00C1 LDS	R24,0xC1
    05622 7E8F      ANDI	R24,0xEF
    05623 9380 00C1 STS	0xC1,R24
    05625 8359      STD	Y+1,R21
    05626 8348      ST	Y,R20
    05627 E326      LDI	R18,0x36
(3098) 					{
(3099) 						// 取样针下降停止，未探测到残留液体,正常
(3100) 						workStep = 7;
    05628 E132      LDI	R19,0x12
    05629 E904      LDI	R16,0x94
    0562A E016      LDI	R17,6
(3101) 					}
(3102) 					break;
    0562B 940E A90D CALL	_uart_Printf
(3103) 				case 7:		// 液体探测初始化
(3104) 				/*	if(CheckLiqDetBase())
(3105) 					{
(3106) 						mainStep = 8;	
(3107) 						workStep = 0;	
(3108) 						break;// 退出处理
(3109) 					}
(3110) 				*/
(3111) 					liqDetBaseAdc = getLiqDetADC(NeedleChannel);
    0562D 9180 00C1 LDS	R24,0xC1
    0562F 6180      ORI	R24,0x10
    05630 9380 00C1 STS	0xC1,R24
    05632 9340 164D STS	_MixtureMode,R20
    05634 9622      ADIW	R28,2
(3112) 					//uart_Printf("//LiqDetBaseAdc2 $%4d\r\n",liqDetBaseAdc);	
(3113) 					SetDelayTime(MOT_SAMP_NEEDLE, 20);
    05635 9159      LD	R21,Y+
    05636 9149      LD	R20,Y+
    05637 9508      RET
_SetReMixNum:
    05638 934A      ST	-Y,R20
    05639 935A      ST	-Y,R21
(3114) 					workStep = 8;
    0563A 01A8      MOVW	R20,R16
    0563B 9722      SBIW	R28,2
    0563C 9020 164E LDS	R2,_DropMode
(3115) 					break;
    0563E 9030 164F LDS	R3,_DropMode+1
(3116) 				case 8:		// 取样针运行到混匀池中,探测池中是否有液体, 第二`段
(3117) 					SetEValve(EV_ALL, EV_CLOSE);
    05640 2022      TST	R2
    05641 F4D9      BNE	0x565D
    05642 2033      TST	R3
(3118) 					SetMotRunPam(MOT_SAMP_NEEDLE, 60, 20, CURRENT_SAMP_NEEDLE);
    05643 F4C9      BNE	0x565D
    05644 9180 00C1 LDS	R24,0xC1
    05646 7E8F      ANDI	R24,0xEF
    05647 9380 00C1 STS	0xC1,R24
    05649 8239      STD	Y+1,R3
    0564A 8228      ST	Y,R2
(3119) 					MotRunTo(MOT_SAMP_NEEDLE, _POS_MIX_BUTTOM);
    0564B E523      LDI	R18,0x53
    0564C E130      LDI	R19,0x10
    0564D E904      LDI	R16,0x94
    0564E E016      LDI	R17,6
    0564F 940E A90D CALL	_uart_Printf
(3120) 					detRetry = 0;
    05651 E72F      LDI	R18,0x7F
    05652 E130      LDI	R19,0x10
(3121) 					workStep = 9;
    05653 E80F      LDI	R16,0x8F
    05654 E016      LDI	R17,6
    05655 940E A90D CALL	_uart_Printf
(3122) 					break;
    05657 9180 00C1 LDS	R24,0xC1
(3123) 				case 9:		// 液面探测，如果有探测到液体，则报警排液异常
(3124) 					i = getLiqDetADC(NeedleChannel);
    05659 6180      ORI	R24,0x10
    0565A 9380 00C1 STS	0xC1,R24
    0565C C025      RJMP	0x5682
(3125) 					if(i < liqDetBaseAdc)
    0565D 3045      CPI	R20,5
    0565E E0E0      LDI	R30,0
    0565F 075E      CPC	R21,R30
    05660 F418      BCC	0x5664
    05661 E045      LDI	R20,5
    05662 E050      LDI	R21,0
    05663 C007      RJMP	0x566B
(3126) 					{
(3127) 						i = liqDetBaseAdc - i;
    05664 E184      LDI	R24,0x14
    05665 E090      LDI	R25,0
    05666 1784      CP	R24,R20
(3128) 						if(i > 150)
    05667 0795      CPC	R25,R21
    05668 F410      BCC	0x566B
    05669 E144      LDI	R20,0x14
    0566A E050      LDI	R21,0
    0566B 9350 052D STS	_ReMixNum+1,R21
(3129) 						{
(3130) 							if(detRetry < 15)	// 重测计数
    0566D 9340 052C STS	_ReMixNum,R20
    0566F 9180 00C1 LDS	R24,0xC1
(3131) 							{
(3132) 								detRetry ++;	
    05671 7E8F      ANDI	R24,0xEF
    05672 9380 00C1 STS	0xC1,R24
(3133) 								break;	
    05674 011A      MOVW	R2,R20
(3134) 							}
(3135) 							// 混匀池有残留液，排液异常
(3136) 							MotStop(MOT_SAMP_NEEDLE);
    05675 8239      STD	Y+1,R3
    05676 8228      ST	Y,R2
    05677 E629      LDI	R18,0x69
(3137) 							SetBeepWarning();
    05678 E130      LDI	R19,0x10
    05679 E904      LDI	R16,0x94
(3138) 							mainStep = 8;
    0567A E016      LDI	R17,6
    0567B 940E A90D CALL	_uart_Printf
(3139) 							workStep = 0;
    0567D 9180 00C1 LDS	R24,0xC1
    0567F 6180      ORI	R24,0x10
(3140) 							SetDelayTime(MOT_SAMP_NEEDLE, 5);
    05680 9380 00C1 STS	0xC1,R24
    05682 9622      ADIW	R28,2
    05683 9159      LD	R21,Y+
    05684 9149      LD	R20,Y+
(3141) 							Uart0ReUnable;
    05685 9508      RET
_CalculateCalStandCoeff:
    05686 E08D      LDI	R24,0xD
    05687 E090      LDI	R25,0
    05688 1780      CP	R24,R16
    05689 0791      CPC	R25,R17
(3142) 							uart_Printf("!2502\r\n");	// 开始液路自检， 在检查混匀池时， 发现混匀池中有残留水， 请检查废液泵以及排液通道
    0568A F410      BCC	0x568D
    0568B E00D      LDI	R16,0xD
    0568C E010      LDI	R17,0
    0568D 3000      CPI	R16,0
(3143) 							Uart0ReEnable;
    0568E 0701      CPC	R16,R17
    0568F F411      BNE	0x5692
    05690 E009      LDI	R16,0x9
    05691 E010      LDI	R17,0
    05692 3020      CPI	R18,0
(3144) 							break;
    05693 0723      CPC	R18,R19
    05694 F451      BNE	0x569F
(3145) 							}
(3146) 						else
(3147) 							detRetry = 0;
    05695 EA8E      LDI	R24,0xAE
    05696 E197      LDI	R25,0x17
    05697 01F8      MOVW	R30,R16
(3148) 					}
(3149) 					if(GetMotState(MOT_SAMP_NEEDLE) == STA_SLAVE_FREE)
    05698 0FEE      LSL	R30
    05699 1FFF      ROL	R31
    0569A 0FE8      ADD	R30,R24
    0569B 1FF9      ADC	R31,R25
    0569C 8100      LD	R16,Z
    0569D 8111      LDD	R17,Z+1
    0569E C01D      RJMP	0x56BC
    0569F EF8A      LDI	R24,0xFA
(3150) 					{
(3151) 						// 取样针下降停止，未探测到残留液体,正常
(3152) 						workStep = 0;
    056A0 E090      LDI	R25,0
    056A1 1782      CP	R24,R18
    056A2 0793      CPC	R25,R19
(3153) 						mainStep = 1;
    056A3 F410      BCC	0x56A6
    056A4 EF2A      LDI	R18,0xFA
    056A5 E030      LDI	R19,0
(3154) 					}
(3155) 					break;
(3156) 				}
(3157) 			break;
    056A6 302A      CPI	R18,0xA
    056A7 E0E0      LDI	R30,0
(3158) 		case 1:		// 灌注清洗液
(3159) 			SetDelayTime(MOT_EFFLUENT, 2);
    056A8 073E      CPC	R19,R30
    056A9 F410      BCC	0x56AC
    056AA E02A      LDI	R18,0xA
    056AB E030      LDI	R19,0
    056AC EA8E      LDI	R24,0xAE
(3160) 			ucTmp = _PrimingFluid();
    056AD E197      LDI	R25,0x17
    056AE 01F8      MOVW	R30,R16
    056AF 0FEE      LSL	R30
    056B0 1FFF      ROL	R31
(3161) 			if(ucTmp == 1)
    056B1 0FE8      ADD	R30,R24
    056B2 1FF9      ADC	R31,R25
(3162) 			{
(3163) 				workStep = 0;
    056B3 8331      STD	Z+1,R19
    056B4 8320      ST	Z,R18
    056B5 01F8      MOVW	R30,R16
(3164) 				mainStep = 100;
    056B6 0FEE      LSL	R30
    056B7 1FFF      ROL	R31
    056B8 0FE8      ADD	R30,R24
(3165) 			}
    056B9 1FF9      ADC	R31,R25
    056BA 8100      LD	R16,Z
(3166) 			else if(ucTmp == 0xff)
    056BB 8111      LDD	R17,Z+1
    056BC 9508      RET
_DiluteStartCheck:
    056BD 940E AEB3 CALL	push_xgsetF03C
(3167) 			{
(3168) 				Uart0ReUnable;
    056BF 0168      MOVW	R12,R16
    056C0 9723      SBIW	R28,3
    056C1 20CC      TST	R12
    056C2 F009      BEQ	0x56C4
    056C3 C08F      RJMP	0x5753
(3169) 				uart_Printf("%s\r\n",strE3902);	
    056C4 20DD      TST	R13
    056C5 F009      BEQ	0x56C7
    056C6 C08C      RJMP	0x5753
    056C7 E00C      LDI	R16,0xC
    056C8 940E 97C6 CALL	_WaitDelayTime
(3170) 				Uart0ReEnable;
    056CA 2300      TST	R16
    056CB F019      BEQ	0x56CF
    056CC 2700      CLR	R16
    056CD 940C 61EA JMP	0x61EA
(3171) 				mainStep = 8;
    056CF E002      LDI	R16,2
    056D0 940E 97C6 CALL	_WaitDelayTime
(3172) 				workStep = 0;
    056D2 2300      TST	R16
    056D3 F019      BEQ	0x56D7
    056D4 2700      CLR	R16
(3173) 			}
(3174) 			break;
    056D5 940C 61EA JMP	0x61EA
(3175) 		case 100:	// 清洗清洗头和取样针通道
(3176) 			switch(workStep)
    056D7 E003      LDI	R16,3
    056D8 940E 97C6 CALL	_WaitDelayTime
    056DA 2EC0      MOV	R12,R16
    056DB 2300      TST	R16
    056DC F019      BEQ	0x56E0
    056DD 2700      CLR	R16
    056DE 940C 61EA JMP	0x61EA
    056E0 E00B      LDI	R16,0xB
    056E1 940E 97C6 CALL	_WaitDelayTime
    056E3 2EC0      MOV	R12,R16
    056E4 2300      TST	R16
    056E5 F019      BEQ	0x56E9
    056E6 2700      CLR	R16
    056E7 940C 61EA JMP	0x61EA
    056E9 E009      LDI	R16,0x9
    056EA 940E 97C6 CALL	_WaitDelayTime
    056EC 2EC0      MOV	R12,R16
    056ED 2300      TST	R16
    056EE F019      BEQ	0x56F2
    056EF 2700      CLR	R16
    056F0 940C 61EA JMP	0x61EA
    056F2 9020 165B LDS	R2,dustbinOldState+4
    056F4 2022      TST	R2
    056F5 F061      BEQ	0x5702
    056F6 E002      LDI	R16,2
    056F7 940E 6A0C CALL	_GetMotState
    056F9 2F40      MOV	R20,R16
    056FA 3001      CPI	R16,1
    056FB F019      BEQ	0x56FF
    056FC 2700      CLR	R16
    056FD 940C 61EA JMP	0x61EA
    056FF 2422      CLR	R2
    05700 9220 165B STS	dustbinOldState+4,R2
    05702 9020 165A LDS	R2,dustbinOldState+3
    05704 2022      TST	R2
    05705 F061      BEQ	0x5712
    05706 E003      LDI	R16,3
    05707 940E 6A0C CALL	_GetMotState
    05709 2F40      MOV	R20,R16
    0570A 3001      CPI	R16,1
    0570B F019      BEQ	0x570F
(3177) 			{
(3178) 				case 0:	// 建立负压
(3179) 					SetEValve(EV3, EV_OPEN);
    0570C 2700      CLR	R16
    0570D 940C 61EA JMP	0x61EA
    0570F 2422      CLR	R2
(3180) 					_EffluentMotRun(100, 200);
    05710 9220 165A STS	dustbinOldState+3,R2
    05712 9020 1659 LDS	R2,dustbinOldState+2
    05714 2022      TST	R2
(3181) 					SetDelayTime(MOT_EFFLUENT, 5);
    05715 F061      BEQ	0x5722
    05716 E00C      LDI	R16,0xC
    05717 940E 6A0C CALL	_GetMotState
    05719 2F40      MOV	R20,R16
(3182) 					workStep = 1;
    0571A 3001      CPI	R16,1
    0571B F019      BEQ	0x571F
    0571C 2700      CLR	R16
(3183) 				case 1:	// 清洗
(3184) 					SetEValve(EV1, EV_OPEN);
    0571D 940C 61EA JMP	0x61EA
    0571F 2422      CLR	R2
    05720 9220 1659 STS	dustbinOldState+2,R2
(3185) 					_FluidMotRun(30, 30);
    05722 9020 1658 LDS	R2,dustbinOldState+1
    05724 2022      TST	R2
    05725 F061      BEQ	0x5732
(3186) 					MotInitCheck(MOT_SAMP_NEEDLE);
    05726 E00A      LDI	R16,0xA
    05727 940E 6A0C CALL	_GetMotState
(3187) 					SetDelayTime(MOT_EFFLUENT, 20);
    05729 2F40      MOV	R20,R16
    0572A 3001      CPI	R16,1
    0572B F019      BEQ	0x572F
    0572C 2700      CLR	R16
    0572D 940C 61EA JMP	0x61EA
(3188) 					waitMotSampNeedle = 1;
    0572F 2422      CLR	R2
    05730 9220 1658 STS	dustbinOldState+1,R2
(3189) 					workStep = 2;
    05732 9020 1657 LDS	R2,dustbinOldState
(3190) 					break;
    05734 2022      TST	R2
(3191) 				case 2:	// 先关闭清洗液
(3192) 					MotStop(MOT_FLUID);
    05735 F061      BEQ	0x5742
    05736 E009      LDI	R16,0x9
    05737 940E 6A0C CALL	_GetMotState
(3193) 					_FluidMotRun(-1, 80);
    05739 2F40      MOV	R20,R16
    0573A 3001      CPI	R16,1
    0573B F019      BEQ	0x573F
    0573C 2700      CLR	R16
(3194) 					SetDelayTime(MOT_EFFLUENT, 5);
    0573D 940C 61EA JMP	0x61EA
    0573F 2422      CLR	R2
    05740 9220 1657 STS	dustbinOldState,R2
(3195) 					workStep = 3;
    05742 9020 1656 LDS	R2,CardScanfSW
    05744 2022      TST	R2
(3196) 					break;
    05745 F081      BEQ	0x5756
(3197) 				case 3:	// 关闭负压
(3198) 					SetEValve(EV_ALL, EV_CLOSE);
    05746 E00B      LDI	R16,0xB
    05747 940E 6A0C CALL	_GetMotState
    05749 2F40      MOV	R20,R16
(3199) 					MotStop(MOT_EFFLUENT);
    0574A 3001      CPI	R16,1
    0574B F019      BEQ	0x574F
    0574C 2700      CLR	R16
(3200) 					_NeedleMotRunTo(_POS_MIX_TOP, 240);
    0574D 940C 61EA JMP	0x61EA
    0574F 2422      CLR	R2
    05750 9220 1656 STS	CardScanfSW,R2
(3201) 					waitMotSampNeedle = 1;
    05752 C003      RJMP	0x5756
    05753 2700      CLR	R16
    05754 940C 61EA JMP	0x61EA
(3202) 					workStep = 4;
    05756 9140 161D LDS	R20,EvenPosChangeProcess+19
(3203) 					break;
    05758 2755      CLR	R21
(3204) 				case 4:	// 清洗和灌注取样针通道
(3205) 					SetEValve(EV2, EV_OPEN);
    05759 3040      CPI	R20,0
    0575A 0745      CPC	R20,R21
    0575B F169      BEQ	0x5789
    0575C 3041      CPI	R20,1
(3206) 					SetMotRunPam(MOT_SAMP_PUMP,64,60,CURRENT_SAMP_PUMP);
    0575D E0E0      LDI	R30,0
    0575E 075E      CPC	R21,R30
    0575F F409      BNE	0x5761
    05760 C24D      RJMP	0x59AE
    05761 3042      CPI	R20,2
    05762 E0E0      LDI	R30,0
    05763 075E      CPC	R21,R30
    05764 F409      BNE	0x5766
(3207) 					MotInitCheck(MOT_SAMP_PUMP);
    05765 C35F      RJMP	0x5AC5
    05766 3043      CPI	R20,3
    05767 E0E0      LDI	R30,0
(3208) 					_FluidMotRun(10, 64);
    05768 075E      CPC	R21,R30
    05769 F409      BNE	0x576B
    0576A C386      RJMP	0x5AF1
    0576B 3044      CPI	R20,4
(3209) 					waitMotFluid = 1;
    0576C E0E0      LDI	R30,0
    0576D 075E      CPC	R21,R30
    0576E F409      BNE	0x5770
(3210) 					workStep = 5;
    0576F C61B      RJMP	0x5D8B
    05770 3047      CPI	R20,7
    05771 E0E0      LDI	R30,0
(3211) 					break;
    05772 075E      CPC	R21,R30
(3212) 				case 5:	// 清洗完毕，抽清洗头残留水
(3213) 					SetEValve(EV_ALL, EV_CLOSE);
    05773 F411      BNE	0x5776
    05774 940C 614A JMP	0x614A
    05776 3048      CPI	R20,0x8
(3214) 					SetEValve(EV3, EV_OPEN);
    05777 E0E0      LDI	R30,0
    05778 075E      CPC	R21,R30
    05779 F411      BNE	0x577C
    0577A 940C 6167 JMP	0x6167
(3215) 					_NeedleMotRunTo(0, 240);
    0577C 3040      CPI	R20,0
    0577D E0E0      LDI	R30,0
    0577E 075E      CPC	R21,R30
    0577F F414      BGE	0x5782
(3216) 					_EffluentMotRun(20, 200);
    05780 940C 61E4 JMP	0x61E4
    05782 3644      CPI	R20,0x64
    05783 E0E0      LDI	R30,0
    05784 075E      CPC	R21,R30
(3217) 					waitMotSampNeedle = 1;
    05785 F409      BNE	0x5787
    05786 C256      RJMP	0x59DD
    05787 940C 61E4 JMP	0x61E4
(3218) 					waitEffluent = 1;
    05789 9140 161E LDS	R20,EvenPosChangeProcess+20
(3219) 					workStep = 6;
    0578B 2755      CLR	R21
    0578C 3040      CPI	R20,0
(3220) 					break;
    0578D 0745      CPC	R20,R21
(3221) 				case 6:	// 排干混匀池水
(3222) 					SetEValve(EV_ALL, EV_CLOSE);
    0578E F409      BNE	0x5790
    0578F C04E      RJMP	0x57DE
    05790 3041      CPI	R20,1
    05791 E0E0      LDI	R30,0
(3223) 					_EffluentMotRun(20, 220);
    05792 075E      CPC	R21,R30
    05793 F409      BNE	0x5795
    05794 C084      RJMP	0x5819
    05795 3042      CPI	R20,2
(3224) 					waitEffluent = 1;
    05796 E0E0      LDI	R30,0
    05797 075E      CPC	R21,R30
    05798 F409      BNE	0x579A
(3225) 					workStep = 7;
    05799 C098      RJMP	0x5832
    0579A 3043      CPI	R20,3
    0579B E0E0      LDI	R30,0
(3226) 					break;
    0579C 075E      CPC	R21,R30
(3227) 				case 7:	// 吸样针回抽液体，形成隔离段
(3228) 					SetEValve(EV2, EV_OPEN);
    0579D F409      BNE	0x579F
    0579E C0A7      RJMP	0x5846
    0579F 3044      CPI	R20,4
    057A0 E0E0      LDI	R30,0
(3229) 					SetDelayTime(MOT_DILUENT, 2);
    057A1 075E      CPC	R21,R30
    057A2 F409      BNE	0x57A4
    057A3 C11C      RJMP	0x58C0
    057A4 3045      CPI	R20,5
    057A5 E0E0      LDI	R30,0
(3230) 					workStep = 8;
    057A6 075E      CPC	R21,R30
    057A7 F409      BNE	0x57A9
    057A8 C124      RJMP	0x58CD
(3231) 					break;
    057A9 3046      CPI	R20,6
(3232) 				case 8:
(3233) 					_FluidMotRun(-2, 64);
    057AA E0E0      LDI	R30,0
    057AB 075E      CPC	R21,R30
    057AC F409      BNE	0x57AE
    057AD C138      RJMP	0x58E6
(3234) 					waitMotFluid = 1;
    057AE 3047      CPI	R20,7
    057AF E0E0      LDI	R30,0
    057B0 075E      CPC	R21,R30
(3235) 					workStep = 9;
    057B1 F409      BNE	0x57B3
    057B2 C180      RJMP	0x5933
    057B3 3048      CPI	R20,0x8
(3236) 					break;
    057B4 E0E0      LDI	R30,0
(3237) 				case 9:
(3238) 					SetEValve(EV2, EV_CLOSE);
    057B5 075E      CPC	R21,R30
    057B6 F409      BNE	0x57B8
    057B7 C18D      RJMP	0x5945
    057B8 3049      CPI	R20,0x9
(3239) 					workStep = 0;
    057B9 E0E0      LDI	R30,0
    057BA 075E      CPC	R21,R30
    057BB F409      BNE	0x57BD
(3240) 					mainStep = 2;
    057BC C1A1      RJMP	0x595E
    057BD 3040      CPI	R20,0
    057BE E0E0      LDI	R30,0
(3241) 					break;
(3242) 				}
(3243) 			break;
    057BF 075E      CPC	R21,R30
(3244) 		case 2:		// 灌注稀释液
(3245) 			SetDelayTime(MOT_EFFLUENT, 2);
    057C0 F414      BGE	0x57C3
    057C1 940C 61E9 JMP	0x61E9
    057C3 364E      CPI	R20,0x6E
    057C4 E0E0      LDI	R30,0
(3246) 			ucTmp = _PrimingDiluent();
    057C5 075E      CPC	R21,R30
    057C6 F409      BNE	0x57C8
    057C7 C0A8      RJMP	0x5870
    057C8 364F      CPI	R20,0x6F
(3247) 			if(ucTmp == 1)
    057C9 E0E0      LDI	R30,0
    057CA 075E      CPC	R21,R30
(3248) 			{
(3249) 				workStep = 0;
    057CB F409      BNE	0x57CD
    057CC C0B4      RJMP	0x5881
    057CD 3740      CPI	R20,0x70
(3250) 				mainStep = 3;
    057CE E0E0      LDI	R30,0
    057CF 075E      CPC	R21,R30
    057D0 F409      BNE	0x57D2
(3251) 			}
    057D1 C0BD      RJMP	0x588F
(3252) 			else if(ucTmp == 0xff)
    057D2 3741      CPI	R20,0x71
    057D3 E0E0      LDI	R30,0
    057D4 075E      CPC	R21,R30
(3253) 			{
(3254) 				Uart0ReUnable;
    057D5 F409      BNE	0x57D7
    057D6 C0CA      RJMP	0x58A1
    057D7 3742      CPI	R20,0x72
    057D8 E0E0      LDI	R30,0
    057D9 075E      CPC	R21,R30
(3255) 				uart_Printf("%s\r\n", strE3904);
    057DA F409      BNE	0x57DC
    057DB C0D6      RJMP	0x58B2
    057DC 940C 61E9 JMP	0x61E9
    057DE 2700      CLR	R16
    057DF 940E 6BE3 CALL	_ReadLiquidMonitorResult
(3256) 				Uart0ReEnable;
    057E1 E001      LDI	R16,1
    057E2 940E 6BE3 CALL	_ReadLiquidMonitorResult
    057E4 E002      LDI	R16,2
(3257) 				mainStep = 8;
    057E5 940E 6BE3 CALL	_ReadLiquidMonitorResult
    057E7 E003      LDI	R16,3
(3258) 				workStep = 0;
    057E8 940E 6BE3 CALL	_ReadLiquidMonitorResult
    057EA E083      LDI	R24,3
(3259) 			}
(3260) 			break;
    057EB 838A      STD	Y+2,R24
(3261) 		// 清洗液泵和废液泵流量定标
(3262) 		case 3:	
(3263) 			switch(workStep)
    057EC E184      LDI	R24,0x14
    057ED 8388      ST	Y,R24
    057EE EF20      LDI	R18,0xF0
    057EF E003      LDI	R16,3
    057F0 940E 6A9F CALL	_SetMotRunPam
    057F2 E084      LDI	R24,4
    057F3 838A      STD	Y+2,R24
    057F4 E08A      LDI	R24,0xA
    057F5 8388      ST	Y,R24
    057F6 EC28      LDI	R18,0xC8
    057F7 E002      LDI	R16,2
    057F8 940E 6A9F CALL	_SetMotRunPam
    057FA E003      LDI	R16,3
    057FB 940E 6AFA CALL	_MotInitCheck
    057FD E728      LDI	R18,0x78
    057FE E104      LDI	R16,0x14
    057FF E010      LDI	R17,0
    05800 940E 6289 CALL	__EffluentMotRun
    05802 E081      LDI	R24,1
    05803 9380 165A STS	dustbinOldState+3,R24
    05805 9380 161E STS	EvenPosChangeProcess+20,R24
    05807 9180 00C1 LDS	R24,0xC1
    05809 7E8F      ANDI	R24,0xEF
    0580A 9380 00C1 STS	0xC1,R24
    0580C E22A      LDI	R18,0x2A
    0580D E039      LDI	R19,0x9
    0580E E80F      LDI	R16,0x8F
    0580F E016      LDI	R17,6
    05810 940E A90D CALL	_uart_Printf
    05812 9180 00C1 LDS	R24,0xC1
    05814 6180      ORI	R24,0x10
    05815 9380 00C1 STS	0xC1,R24
    05817 940C 61E9 JMP	0x61E9
    05819 E002      LDI	R16,2
    0581A 940E 6AFA CALL	_MotInitCheck
(3264) 			{
(3265) 				case 0:
(3266) 					SetMotRunPam(MOT_SAMP_NEEDLE, 240, 20, CURRENT_SAMP_NEEDLE);
    0581C E081      LDI	R24,1
    0581D 9380 165B STS	dustbinOldState+4,R24
    0581F 940E 82CB CALL	_GetNeedleOnMixCenterPos
    05821 0168      MOVW	R12,R16
    05822 92D0 1647 STS	_NewCardStoreNum+7,R13
(3267) 					MotInitCheck(MOT_SAMP_NEEDLE);
    05824 92C0 1646 STS	_NewCardStoreNum+6,R12
    05826 940E 82F8 CALL	_GetNeedleOnMixSidePos
(3268) 					waitMotSampNeedle = 1;
    05828 0168      MOVW	R12,R16
    05829 92D0 1649 STS	_NewCardStoreNum+9,R13
(3269) 					workStep = 100;
    0582B 92C0 1648 STS	_NewCardStoreNum+8,R12
(3270) 					break;
    0582D E082      LDI	R24,2
(3271) 				case 100:
(3272) 					SetMotRunPam(MOT_SAMP_TRUN,200,5,CURRENT_SAMP_TRUN);
    0582E 9380 161E STS	EvenPosChangeProcess+20,R24
    05830 940C 61E9 JMP	0x61E9
    05832 9120 1646 LDS	R18,_NewCardStoreNum+6
    05834 9130 1647 LDS	R19,_NewCardStoreNum+7
(3273) 					MotRunTo(MOT_SAMP_TRUN, 0);
    05836 E002      LDI	R16,2
    05837 940E 6A5B CALL	_MotRunTo
    05839 E081      LDI	R24,1
    0583A 9380 165B STS	dustbinOldState+4,R24
(3274) 					waitMotSampTurn = 1;
    0583C 9380 1656 STS	CardScanfSW,R24
(3275) 					workStep = 101;
    0583E 2422      CLR	R2
    0583F 9220 1621 STS	EvenPosChangeProcess+23,R2
(3276) 					break;
    05841 E083      LDI	R24,3
(3277) 				case 101:
(3278) 					MotRunTo(MOT_SAMP_TRUN, NeedleOnMixCenterPos);
    05842 9380 161E STS	EvenPosChangeProcess+20,R24
    05844 940C 61E9 JMP	0x61E9
    05846 9180 1621 LDS	R24,EvenPosChangeProcess+23
    05848 5F8F      SUBI	R24,0xFF
(3279) 					waitMotSampTurn = 1;
    05849 9380 1621 STS	EvenPosChangeProcess+23,R24
    0584B E021      LDI	R18,1
(3280) 					workStep = 102;
    0584C E003      LDI	R16,3
    0584D 940E 6B81 CALL	_SetEValve
(3281) 					break;
    0584F E728      LDI	R18,0x78
(3282) 				case 102:		// 取样针运行到定标液起始高位
(3283) 					_NeedleMotRunTo(_POS_MIX_CAL_START, 240);
    05850 E104      LDI	R16,0x14
    05851 E010      LDI	R17,0
    05852 940E 6289 CALL	__EffluentMotRun
(3284) 					waitMotSampNeedle = 1;
    05854 EC28      LDI	R18,0xC8
    05855 E608      LDI	R16,0x68
    05856 E011      LDI	R17,1
(3285) 					workStep = 103;
    05857 940E 62FB CALL	__NeedleMotRunTo
    05859 E081      LDI	R24,1
(3286) 					break;
    0585A 9380 165A STS	dustbinOldState+3,R24
(3287) 				case 103:
(3288) 					if(CheckLiqDetBase())
    0585C 9380 1656 STS	CardScanfSW,R24
    0585E 2700      CLR	R16
    0585F 940E 9A52 CALL	_getLiqDetADC
(3289) 					{
(3290) 						SetEValve(EV1, EV_OPEN);
    05861 01A8      MOVW	R20,R16
    05862 3F04      CPI	R16,0xF4
    05863 E0E1      LDI	R30,1
(3291) 						_FluidMotRun(-1, 30);
    05864 071E      CPC	R17,R30
    05865 F428      BCC	0x586B
    05866 E68E      LDI	R24,0x6E
    05867 9380 161E STS	EvenPosChangeProcess+20,R24
(3292) 						waitMotFluid = 1;
    05869 940C 61E9 JMP	0x61E9
(3293) 						workStep = 104;
    0586B E084      LDI	R24,4
    0586C 9380 161E STS	EvenPosChangeProcess+20,R24
(3294) 					}
    0586E 940C 61E9 JMP	0x61E9
(3295) 					else
(3296) 						workStep = 1;
    05870 E021      LDI	R18,1
    05871 E002      LDI	R16,2
(3297) 					break;
    05872 940E 6B81 CALL	_SetEValve
(3298) 				case 104:
(3299) 					SetEValve(EV1, EV_CLOSE);
    05874 E124      LDI	R18,0x14
    05875 EF0F      LDI	R16,0xFF
    05876 EF1F      LDI	R17,0xFF
(3300) 					if(CheckLiqDetBase())
    05877 940E 6264 CALL	__FluidMotRun
    05879 E081      LDI	R24,1
    0587A 9380 1658 STS	dustbinOldState+1,R24
(3301) 					{
(3302) 						SetEValve(EV2, EV_OPEN);
    0587C E68F      LDI	R24,0x6F
    0587D 9380 161E STS	EvenPosChangeProcess+20,R24
    0587F 940C 61E9 JMP	0x61E9
(3303) 						_FluidMotRun(-1, 30);
    05881 E124      LDI	R18,0x14
    05882 E030      LDI	R19,0
    05883 E00A      LDI	R16,0xA
(3304) 						waitMotFluid = 1;
    05884 940E 97B7 CALL	_SetDelayTime
    05886 2722      CLR	R18
(3305) 					}
(3306) 					workStep = 1;
    05887 E002      LDI	R16,2
    05888 940E 6B81 CALL	_SetEValve
(3307) 					break;
    0588A E780      LDI	R24,0x70
(3308) 				case 1:		// 初始化液面探测
(3309) 					SetEValve(EV_ALL, EV_CLOSE);
    0588B 9380 161E STS	EvenPosChangeProcess+20,R24
    0588D 940C 61E9 JMP	0x61E9
(3310) 				/*	if(CheckLiqDetBase())
(3311) 					{
(3312) 						mainStep = 8;	
(3313) 						workStep = 0;	
(3314) 						Uart0ReUnable;
(3315) 						uart_Printf("!2510\r\n");	// 开始准备清洗液泵流量检查时，液面探测功能自检出现错误
(3316) 						Uart0ReEnable;
(3317) 						break;// 退出处理
(3318) 					}
(3319) 				*/
(3320) 					liqDetBaseAdc = getLiqDetADC(NeedleChannel);
    0588F 2700      CLR	R16
    05890 940E 9A52 CALL	_getLiqDetADC
    05892 01A8      MOVW	R20,R16
    05893 3F04      CPI	R16,0xF4
    05894 E0E1      LDI	R30,1
    05895 071E      CPC	R17,R30
    05896 F428      BCC	0x589C
(3321) 					//uart_Printf("//LiqDetBaseAdc3 $%4d\r\n",liqDetBaseAdc);	
(3322) 					_SampPumpMotRun(100, 64);		// 注射泵吸入，防止针头挂水滴
    05897 E781      LDI	R24,0x71
    05898 9380 161E STS	EvenPosChangeProcess+20,R24
    0589A 940C 61E9 JMP	0x61E9
(3323) 					workStep = 2;
    0589C E084      LDI	R24,4
    0589D 9380 161E STS	EvenPosChangeProcess+20,R24
(3324) 					break;
    0589F 940C 61E9 JMP	0x61E9
    058A1 E021      LDI	R18,1
    058A2 E001      LDI	R16,1
(3325) 				case 2:		// 注入最大800mL清洗液到定标液预定高度	
(3326) 					_FluidMotRun(9, 32);
(3327) 					detRetry = 0;
    058A3 940E 6B81 CALL	_SetEValve
    058A5 E124      LDI	R18,0x14
(3328) 					workStep = 3;
    058A6 EF0F      LDI	R16,0xFF
    058A7 EF1F      LDI	R17,0xFF
    058A8 940E 6264 CALL	__FluidMotRun
(3329) 					break;
    058AA E081      LDI	R24,1
    058AB 9380 1658 STS	dustbinOldState+1,R24
    058AD E782      LDI	R24,0x72
    058AE 9380 161E STS	EvenPosChangeProcess+20,R24
(3330) 				case 3:		// 等待探测到液面
(3331) 					if(GetLiquidMonitorState(1) == INFO_LIQ_EMPTY)
(3332) 					{
(3333) 						// 清洗液供应异常
(3334) 						SetBeepWarning();
    058B0 940C 61E9 JMP	0x61E9
(3335) 						// 退出处理
(3336) 						mainStep = 8;
    058B2 E124      LDI	R18,0x14
    058B3 E030      LDI	R19,0
    058B4 E00A      LDI	R16,0xA
(3337) 						workStep = 0;
    058B5 940E 97B7 CALL	_SetDelayTime
    058B7 2722      CLR	R18
(3338) 						MotStop(MOT_FLUID);
    058B8 E001      LDI	R16,1
    058B9 940E 6B81 CALL	_SetEValve
(3339) 						MotInitCheck(MOT_SAMP_PUMP);
    058BB E084      LDI	R24,4
    058BC 9380 161E STS	EvenPosChangeProcess+20,R24
(3340) 						SetDelayTime(MOT_SAMP_NEEDLE, 5);
    058BE 940C 61E9 JMP	0x61E9
    058C0 2700      CLR	R16
    058C1 940E 9A52 CALL	_getLiqDetADC
(3341) 						Uart0ReUnable;
    058C3 0168      MOVW	R12,R16
    058C4 92D0 165E STS	dustbinOldState+7,R13
    058C6 92C0 165D STS	dustbinOldState+6,R12
(3342) 						uart_Printf("!2511\r\n");	// 清洗液泵流量检查时，出现清洗液供应中断，请更换清洗液后重试
    058C8 E085      LDI	R24,5
    058C9 9380 161E STS	EvenPosChangeProcess+20,R24
    058CB 940C 61E9 JMP	0x61E9
(3343) 						Uart0ReEnable;
    058CD 2722      CLR	R18
    058CE 2700      CLR	R16
    058CF 940E 6B81 CALL	_SetEValve
(3344) 						break;
    058D1 E083      LDI	R24,3
(3345) 					}
(3346) 					if(GetMotState(MOT_FLUID) == STA_SLAVE_FREE)
    058D2 838A      STD	Y+2,R24
    058D3 E08A      LDI	R24,0xA
    058D4 8388      ST	Y,R24
    058D5 E624      LDI	R18,0x64
    058D6 E003      LDI	R16,3
    058D7 940E 6A9F CALL	_SetMotRunPam
(3347) 					{
(3348) 						// 检查清洗液泵是否在运行，如果停止表示未注入液体或注入液体偏少
(3349) 						SetBeepWarning();
    058D9 E726      LDI	R18,0x76
(3350) 						// 退出处理
(3351) 						mainStep = 8;
    058DA E032      LDI	R19,2
    058DB E003      LDI	R16,3
    058DC 940E 6A5B CALL	_MotRunTo
(3352) 						workStep = 0;
    058DE 2422      CLR	R2
    058DF 9220 1621 STS	EvenPosChangeProcess+23,R2
(3353) 						MotInitCheck(MOT_SAMP_PUMP);
    058E1 E086      LDI	R24,6
    058E2 9380 161E STS	EvenPosChangeProcess+20,R24
(3354) 						SetDelayTime(MOT_SAMP_NEEDLE, 5);
    058E4 940C 61E9 JMP	0x61E9
    058E6 2700      CLR	R16
    058E7 940E 9A52 CALL	_getLiqDetADC
(3355) 						Uart0ReUnable;
    058E9 0168      MOVW	R12,R16
    058EA 0156      MOVW	R10,R12
    058EB 9020 165D LDS	R2,dustbinOldState+6
(3356) 						uart_Printf("!2512\r\n");	// 清洗液泵流量检查时，未检测到清洗液注入，请检查清洗液泵后重新运行液路自检程序
    058ED 9030 165E LDS	R3,dustbinOldState+7
    058EF 1502      CP	R16,R2
    058F0 0513      CPC	R17,R3
(3357) 						Uart0ReEnable;
    058F1 F5A0      BCC	0x5926
    058F2 1A20      SUB	R2,R16
    058F3 0A31      SBC	R3,R17
    058F4 0151      MOVW	R10,R2
    058F5 EC88      LDI	R24,0xC8
(3358) 						break;
    058F6 E090      LDI	R25,0
(3359) 						}
(3360) 					i = getLiqDetADC(NeedleChannel);
    058F7 1582      CP	R24,R2
    058F8 0593      CPC	R25,R3
    058F9 F548      BCC	0x5923
    058FA 9180 1621 LDS	R24,EvenPosChangeProcess+23
(3361) 					if(i < liqDetBaseAdc)
    058FC 308F      CPI	R24,0xF
    058FD F428      BCC	0x5903
    058FE 5F8F      SUBI	R24,0xFF
    058FF 9380 1621 STS	EvenPosChangeProcess+23,R24
    05901 940C 61E9 JMP	0x61E9
    05903 E003      LDI	R16,3
(3362) 					{
(3363) 						i = liqDetBaseAdc - i;
    05904 940E 6A13 CALL	_MotStop
    05906 940E 372D CALL	_SetBeepWarning
(3364) 						if(i > 30)
    05908 E088      LDI	R24,0x8
    05909 9380 161D STS	EvenPosChangeProcess+19,R24
    0590B 2422      CLR	R2
(3365) 						{
(3366) 							if(detRetry < 5)	// 重测计数
    0590C 9220 161E STS	EvenPosChangeProcess+20,R2
    0590E E124      LDI	R18,0x14
    0590F E030      LDI	R19,0
(3367) 							{
(3368) 								detRetry ++;	
    05910 E003      LDI	R16,3
    05911 940E 97B7 CALL	_SetDelayTime
(3369) 								break;	
    05913 9180 00C1 LDS	R24,0xC1
(3370) 							}
(3371) 							MotStop(MOT_FLUID);
    05915 7E8F      ANDI	R24,0xEF
    05916 9380 00C1 STS	0xC1,R24
(3372) 							MotInitCheck(MOT_SAMP_PUMP);
    05918 EF0C      LDI	R16,0xFC
    05919 E015      LDI	R17,5
(3373) 							workStep = 4;
    0591A 940E A90D CALL	_uart_Printf
    0591C 9180 00C1 LDS	R24,0xC1
(3374) 							SetBeepAck();
    0591E 6180      ORI	R24,0x10
(3375) 						}
    0591F 9380 00C1 STS	0xC1,R24
(3376) 						else
(3377) 							detRetry = 0;
    05921 940C 61E9 JMP	0x61E9
(3378) 					}
(3379) 					break;
    05923 2422      CLR	R2
(3380) 				case 4:		// 取样针运行到高位
(3381) 					_NeedleMotRunTo(_POS_MIX_TOP, 240);
    05924 9220 1621 STS	EvenPosChangeProcess+23,R2
    05926 E003      LDI	R16,3
    05927 940E 6A0C CALL	_GetMotState
(3382) 					waitMotSampNeedle = 1;
    05929 2F40      MOV	R20,R16
    0592A 3001      CPI	R16,1
(3383) 					workStep = 5;
    0592B F011      BEQ	0x592E
    0592C 940C 61E9 JMP	0x61E9
(3384) 					break;
    0592E E087      LDI	R24,7
(3385) 				case 5:		// 注入1.2mL定标液
(3386) 					_FluidMotRun(12, 64);
    0592F 9380 161E STS	EvenPosChangeProcess+20,R24
    05931 940C 61E9 JMP	0x61E9
(3387) 					workStep = 6;
    05933 2700      CLR	R16
    05934 940E 9A52 CALL	_getLiqDetADC
(3388) 					break;
    05936 0168      MOVW	R12,R16
(3389) 				case 6:		// 监测清洗液供应
(3390) 					if(GetLiquidMonitorState(1) == INFO_LIQ_EMPTY)
    05937 92D0 165E STS	dustbinOldState+7,R13
    05939 92C0 165D STS	dustbinOldState+6,R12
    0593B E124      LDI	R18,0x14
    0593C E030      LDI	R19,0
(3391) 					{
(3392) 						// 清洗液供应异常
(3393) 						SetBeepWarning();
    0593D E003      LDI	R16,3
    0593E 940E 97B7 CALL	_SetDelayTime
(3394) 						// 退出处理
(3395) 						mainStep = 8;
    05940 E088      LDI	R24,0x8
    05941 9380 161E STS	EvenPosChangeProcess+20,R24
(3396) 						workStep = 0;
    05943 940C 61E9 JMP	0x61E9
(3397) 						MotStop(MOT_FLUID);
    05945 2722      CLR	R18
    05946 2700      CLR	R16
    05947 940E 6B81 CALL	_SetEValve
(3398) 						MotInitCheck(MOT_SAMP_PUMP);
    05949 E083      LDI	R24,3
    0594A 838A      STD	Y+2,R24
(3399) 						SetDelayTime(MOT_SAMP_NEEDLE, 5);
    0594B E184      LDI	R24,0x14
    0594C 8388      ST	Y,R24
    0594D E32C      LDI	R18,0x3C
    0594E E003      LDI	R16,3
    0594F 940E 6A9F CALL	_SetMotRunPam
(3400) 						Uart0ReUnable;
    05951 E824      LDI	R18,0x84
    05952 E033      LDI	R19,3
    05953 E003      LDI	R16,3
    05954 940E 6A5B CALL	_MotRunTo
(3401) 						uart_Printf("!2511\r\n");	// 清洗液泵流量检查时，出现清洗液供应中断，请更换清洗液后重试
    05956 2422      CLR	R2
    05957 9220 1621 STS	EvenPosChangeProcess+23,R2
(3402) 						Uart0ReEnable;
    05959 E089      LDI	R24,0x9
    0595A 9380 161E STS	EvenPosChangeProcess+20,R24
    0595C 940C 61E9 JMP	0x61E9
(3403) 						break;
    0595E 2700      CLR	R16
(3404) 						}
(3405) 					if(GetMotState(MOT_FLUID) == STA_SLAVE_FREE)
    0595F 940E 9A52 CALL	_getLiqDetADC
    05961 0168      MOVW	R12,R16
    05962 0156      MOVW	R10,R12
    05963 9020 165D LDS	R2,dustbinOldState+6
    05965 9030 165E LDS	R3,dustbinOldState+7
(3406) 					{
(3407) 						workStep = 7;	// 注液完毕
    05967 1502      CP	R16,R2
    05968 0513      CPC	R17,R3
(3408) 					}
(3409) 					break;
    05969 F5A0      BCC	0x599E
(3410) 				case 7:			// 初始化液面探测
(3411) 				/*	if(CheckLiqDetBase())
(3412) 					{
(3413) 						mainStep = 8;	
(3414) 						workStep = 0;	
(3415) 						Uart0ReUnable;
(3416) 						uart_Printf("!2513\r\n");	// 清洗液泵流量检查时，液面探测功能自检出现错误
(3417) 						Uart0ReEnable;
(3418) 						break;// 退出处理
(3419) 					}
(3420) 				*/
(3421) 					liqDetBaseAdc = getLiqDetADC(NeedleChannel);
    0596A 1A20      SUB	R2,R16
    0596B 0A31      SBC	R3,R17
    0596C 0151      MOVW	R10,R2
    0596D E986      LDI	R24,0x96
    0596E E090      LDI	R25,0
    0596F 1582      CP	R24,R2
    05970 0593      CPC	R25,R3
    05971 F548      BCC	0x599B
(3422) 					//uart_Printf("//LiqDetBaseAdc4 $%4d\r\n",liqDetBaseAdc);	
(3423) 					_SampPumpMotRun(100, 64);
    05972 9180 1621 LDS	R24,EvenPosChangeProcess+23
    05974 308F      CPI	R24,0xF
    05975 F428      BCC	0x597B
(3424) 					_NeedleMotRunTo(_POS_MIX_CAL_START-200, 16);
    05976 5F8F      SUBI	R24,0xFF
    05977 9380 1621 STS	EvenPosChangeProcess+23,R24
    05979 940C 61E9 JMP	0x61E9
(3425) 					detRetry = 0;
    0597B E003      LDI	R16,3
    0597C 940E 6A13 CALL	_MotStop
(3426) 					workStep = 8;
    0597E 940E 372D CALL	_SetBeepWarning
(3427) 					break;
    05980 E088      LDI	R24,0x8
(3428) 				case 8:		// 取样针下降探测液面
(3429) 					if(GetMotState(MOT_SAMP_NEEDLE) == STA_SLAVE_FREE)
    05981 9380 161D STS	EvenPosChangeProcess+19,R24
    05983 2422      CLR	R2
    05984 9220 161E STS	EvenPosChangeProcess+20,R2
    05986 E025      LDI	R18,5
(3430) 					{
(3431) 						// 检查 取样针是否在运行，如果停止表示液面高度太低
(3432) 						SetBeepWarning();
    05987 E030      LDI	R19,0
    05988 E003      LDI	R16,3
(3433) 						// 退出处理
(3434) 						mainStep = 8;
    05989 940E 97B7 CALL	_SetDelayTime
    0598B 9180 00C1 LDS	R24,0xC1
(3435) 						workStep = 0;
    0598D 7E8F      ANDI	R24,0xEF
    0598E 9380 00C1 STS	0xC1,R24
(3436) 						MotInitCheck(MOT_SAMP_PUMP);
    05990 EF0C      LDI	R16,0xFC
    05991 E015      LDI	R17,5
(3437) 					//	uart_Printf("!2514\r\n");	// 清洗液泵流量检查时在检测流量时，未检测到液体注入，请检查稀释液泵后重新运行液路自检程序
(3438) 						Uart0ReUnable;
    05992 940E A90D CALL	_uart_Printf
    05994 9180 00C1 LDS	R24,0xC1
    05996 6180      ORI	R24,0x10
(3439) 						uart_Printf("!2514 $%4d $%4d\r\n",liqDetBaseAdc,i);  // 2016-08-24 更改
    05997 9380 00C1 STS	0xC1,R24
    05999 940C 61E9 JMP	0x61E9
    0599B 2422      CLR	R2
    0599C 9220 1621 STS	EvenPosChangeProcess+23,R2
    0599E E003      LDI	R16,3
    0599F 940E 6A0C CALL	_GetMotState
(3440) 						Uart0ReEnable;
    059A1 2F40      MOV	R20,R16
    059A2 3001      CPI	R16,1
    059A3 F011      BEQ	0x59A6
    059A4 940C 61E9 JMP	0x61E9
(3441) 						break;
    059A6 2422      CLR	R2
(3442) 					}
(3443) 					i = getLiqDetADC(NeedleChannel);
    059A7 9220 161E STS	EvenPosChangeProcess+20,R2
    059A9 E081      LDI	R24,1
    059AA 9380 161D STS	EvenPosChangeProcess+19,R24
(3444) 					if(i < liqDetBaseAdc)
    059AC 940C 61E9 JMP	0x61E9
    059AE E022      LDI	R18,2
    059AF E030      LDI	R19,0
    059B0 E00B      LDI	R16,0xB
    059B1 940E 97B7 CALL	_SetDelayTime
    059B3 940E 65D2 CALL	__PrimingFluid
(3445) 					{
(3446) 						i = liqDetBaseAdc - i;
    059B5 0168      MOVW	R12,R16
    059B6 2D4C      MOV	R20,R12
(3447) 						if(i > 90)
    059B7 3001      CPI	R16,1
    059B8 F441      BNE	0x59C1
    059B9 2422      CLR	R2
    059BA 9220 161E STS	EvenPosChangeProcess+20,R2
(3448) 						{
(3449) 							if(detRetry < 10)	// 重测计数
    059BC E684      LDI	R24,0x64
    059BD 9380 161D STS	EvenPosChangeProcess+19,R24
    059BF 940C 61E9 JMP	0x61E9
(3450) 							{
(3451) 								detRetry ++;	
    059C1 3F4F      CPI	R20,0xFF
    059C2 F011      BEQ	0x59C5
(3452) 								break;	
    059C3 940C 61E9 JMP	0x61E9
(3453) 							}
(3454) 							MotStop(MOT_SAMP_NEEDLE);
    059C5 9180 00C1 LDS	R24,0xC1
(3455) 							MotInitCheck(MOT_SAMP_PUMP);
    059C7 7E8F      ANDI	R24,0xEF
    059C8 9380 00C1 STS	0xC1,R24
(3456) 							SetMotRunPam(MOT_SAMP_NEEDLE, 240, 20, CURRENT_SAMP_NEEDLE);
    059CA E626      LDI	R18,0x66
    059CB E134      LDI	R19,0x14
    059CC E80F      LDI	R16,0x8F
    059CD E016      LDI	R17,6
    059CE 940E A90D CALL	_uart_Printf
    059D0 9180 00C1 LDS	R24,0xC1
(3457) 							workStep = 9;
    059D2 6180      ORI	R24,0x10
    059D3 9380 00C1 STS	0xC1,R24
(3458) 							SetDelayTime(MOT_SAMP_NEEDLE, 5);
    059D5 E088      LDI	R24,0x8
    059D6 9380 161D STS	EvenPosChangeProcess+19,R24
    059D8 2422      CLR	R2
    059D9 9220 161E STS	EvenPosChangeProcess+20,R2
(3459) 							SetBeepAck();
    059DB 940C 61E9 JMP	0x61E9
(3460) 						}
    059DD 9160 161E LDS	R22,EvenPosChangeProcess+20
    059DF 2777      CLR	R23
(3461) 						else
(3462) 							detRetry = 0;
(3463) 					}
(3464) 					break;
    059E0 3060      CPI	R22,0
(3465) 				case 9:		// 计算定标结果
(3466) 					MotInitCheck(MOT_SAMP_PUMP);
    059E1 0767      CPC	R22,R23
    059E2 F409      BNE	0x59E4
    059E3 C02E      RJMP	0x5A12
(3467) 					waitMotSampPump = 1;
    059E4 3061      CPI	R22,1
    059E5 E0E0      LDI	R30,0
    059E6 077E      CPC	R23,R30
(3468) 					i = (unsigned int)GetMotPositionOfStep(MOT_SAMP_NEEDLE);
    059E7 F409      BNE	0x59E9
    059E8 C03A      RJMP	0x5A23
    059E9 3062      CPI	R22,2
    059EA E0E0      LDI	R30,0
    059EB 077E      CPC	R23,R30
(3469) 					mixLiqLevel = i;
    059EC F409      BNE	0x59EE
    059ED C04D      RJMP	0x5A3B
    059EE 3063      CPI	R22,3
    059EF E0E0      LDI	R30,0
(3470) 					i = _POS_MIX_CAL_START - mixLiqLevel;
    059F0 077E      CPC	R23,R30
    059F1 F409      BNE	0x59F3
    059F2 C059      RJMP	0x5A4C
    059F3 3064      CPI	R22,4
    059F4 E0E0      LDI	R30,0
(3471) 					Uart0ReUnable;
    059F5 077E      CPC	R23,R30
    059F6 F409      BNE	0x59F8
    059F7 C067      RJMP	0x5A5F
    059F8 3065      CPI	R22,5
    059F9 E0E0      LDI	R30,0
(3472) 					uart_Printf("%s $%d\r\n",strM2111, i);
    059FA 077E      CPC	R23,R30
    059FB F409      BNE	0x59FD
    059FC C07C      RJMP	0x5A79
    059FD 3066      CPI	R22,6
    059FE E0E0      LDI	R30,0
    059FF 077E      CPC	R23,R30
    05A00 F409      BNE	0x5A02
    05A01 C091      RJMP	0x5A93
(3473) 					Uart0ReEnable;
    05A02 3067      CPI	R22,7
    05A03 E0E0      LDI	R30,0
    05A04 077E      CPC	R23,R30
    05A05 F409      BNE	0x5A07
    05A06 C09B      RJMP	0x5AA2
(3474) 					SetDelayTime(MOT_SAMP_NEEDLE, 10);
    05A07 3068      CPI	R22,0x8
    05A08 E0E0      LDI	R30,0
    05A09 077E      CPC	R23,R30
    05A0A F409      BNE	0x5A0C
    05A0B C0A3      RJMP	0x5AAF
(3475) 					workStep = 10;
    05A0C 3069      CPI	R22,0x9
    05A0D E0E0      LDI	R30,0
    05A0E 077E      CPC	R23,R30
(3476) 					break;
    05A0F F409      BNE	0x5A11
(3477) 				// 开始废液定标
(3478) 				case 10:
(3479) 					_EffluentMotRun(10, 140);		// 1000/125 = 8
    05A10 C0A9      RJMP	0x5ABA
    05A11 C7D7      RJMP	0x61E9
    05A12 E021      LDI	R18,1
    05A13 E003      LDI	R16,3
(3480) 					waitEffluent = 1;
    05A14 940E 6B81 CALL	_SetEValve
    05A16 EC28      LDI	R18,0xC8
(3481) 					workStep = 11;
    05A17 E604      LDI	R16,0x64
    05A18 E010      LDI	R17,0
    05A19 940E 6289 CALL	__EffluentMotRun
(3482) 					break;
    05A1B E025      LDI	R18,5
    05A1C E030      LDI	R19,0
    05A1D E00B      LDI	R16,0xB
    05A1E 940E 97B7 CALL	_SetDelayTime
    05A20 E081      LDI	R24,1
    05A21 9380 161E STS	EvenPosChangeProcess+20,R24
(3483) 				case 11:			// 初始化液面探测
(3484) 				/*	if(CheckLiqDetBase())
(3485) 					{
(3486) 						mainStep = 8;	workStep = 0;	
(3487) 						Uart0ReUnable;
(3488) 						uart_Printf("!2520\r\n");	// 开始废液泵流量检查时，液面探测功能自检出现错误
(3489) 						Uart0ReEnable;
(3490) 						break;// 退出处理
(3491) 					}
(3492) 				*/
(3493) 					liqDetBaseAdc = getLiqDetADC(NeedleChannel);
(3494) 					//uart_Printf("//LiqDetBaseAdc5 $%4d\r\n",liqDetBaseAdc);	
(3495) 					_SampPumpMotRun(100, 64);		// 注射泵吸入，防止针头挂水滴
    05A23 E021      LDI	R18,1
    05A24 E001      LDI	R16,1
    05A25 940E 6B81 CALL	_SetEValve
(3496) 					_NeedleMotRunTo(_POS_MIX_CAL_START, 16);
    05A27 E12E      LDI	R18,0x1E
    05A28 E10E      LDI	R16,0x1E
    05A29 E010      LDI	R17,0
    05A2A 940E 6264 CALL	__FluidMotRun
(3497) 					detRetry = 0;
    05A2C E003      LDI	R16,3
    05A2D 940E 6AFA CALL	_MotInitCheck
(3498) 					workStep = 12;
    05A2F E124      LDI	R18,0x14
    05A30 E030      LDI	R19,0
(3499) 					break;
    05A31 E00B      LDI	R16,0xB
(3500) 				case 12:	// 液面探测
(3501) 					// 检查 取样针是否在运行，如果停止表示液面高度太低
(3502) 					if(GetMotState(MOT_SAMP_NEEDLE) == STA_SLAVE_FREE)
    05A32 940E 97B7 CALL	_SetDelayTime
    05A34 E081      LDI	R24,1
    05A35 9380 165A STS	dustbinOldState+3,R24
    05A37 E082      LDI	R24,2
(3503) 					{
(3504) 						SetBeepWarning();
    05A38 9380 161E STS	EvenPosChangeProcess+20,R24
(3505) 						// 退出处理
(3506) 					//	mainStep = 8;	
(3507) 					//	workStep = 0;
(3508) 					//	MotInitCheck(MOT_SAMP_PUMP);
(3509) 					//	uart_Printf("!2521\r\n");	// 在废液泵流量检测时，取样针未探测到液体，请检查液面探测功能后重新运行液路自检程序
(3510) 						workStep = 13;
    05A3A C7AE      RJMP	0x61E9
    05A3B E00A      LDI	R16,0xA
    05A3C 940E 6A13 CALL	_MotStop
(3511) 						break;
    05A3E E520      LDI	R18,0x50
    05A3F EF0F      LDI	R16,0xFF
    05A40 EF1F      LDI	R17,0xFF
    05A41 940E 6264 CALL	__FluidMotRun
(3512) 					}
(3513) 					i = getLiqDetADC(NeedleChannel);
(3514) 					if(i < liqDetBaseAdc)
    05A43 E025      LDI	R18,5
    05A44 E030      LDI	R19,0
    05A45 E00B      LDI	R16,0xB
    05A46 940E 97B7 CALL	_SetDelayTime
    05A48 E083      LDI	R24,3
    05A49 9380 161E STS	EvenPosChangeProcess+20,R24
(3515) 					{
(3516) 						i = liqDetBaseAdc - i;
    05A4B C79D      RJMP	0x61E9
    05A4C 2722      CLR	R18
    05A4D 2700      CLR	R16
(3517) 						if(i > 50)
    05A4E 940E 6B81 CALL	_SetEValve
    05A50 E00B      LDI	R16,0xB
    05A51 940E 6A13 CALL	_MotStop
(3518) 						{
(3519) 							if(detRetry < 10)	// 重测计数
    05A53 EF20      LDI	R18,0xF0
    05A54 E608      LDI	R16,0x68
    05A55 E011      LDI	R17,1
    05A56 940E 62FB CALL	__NeedleMotRunTo
(3520) 							{
(3521) 								detRetry ++;	
    05A58 E081      LDI	R24,1
    05A59 9380 165A STS	dustbinOldState+3,R24
(3522) 								break;	
    05A5B E084      LDI	R24,4
    05A5C 9380 161E STS	EvenPosChangeProcess+20,R24
(3523) 							}
(3524) 							MotStop(MOT_SAMP_NEEDLE);
(3525) 							SetDelayTime(MOT_SAMP_NEEDLE, 5);
    05A5E C78A      RJMP	0x61E9
    05A5F E021      LDI	R18,1
    05A60 E002      LDI	R16,2
    05A61 940E 6B81 CALL	_SetEValve
(3526) 							SetBeepAck();
    05A63 E086      LDI	R24,6
    05A64 838A      STD	Y+2,R24
(3527) 							workStep = 13;
    05A65 E38C      LDI	R24,0x3C
    05A66 8388      ST	Y,R24
    05A67 E420      LDI	R18,0x40
(3528) 						}
    05A68 E00C      LDI	R16,0xC
(3529) 						else
(3530) 							detRetry = 0;
    05A69 940E 6A9F CALL	_SetMotRunPam
    05A6B E00C      LDI	R16,0xC
(3531) 					}
(3532) 					break;
    05A6C 940E 6AFA CALL	_MotInitCheck
(3533) 				case 13:	// 计算废液泵流量
(3534) 					MotInitCheck(MOT_SAMP_PUMP);	// 注射泵复位
    05A6E E420      LDI	R18,0x40
    05A6F E00A      LDI	R16,0xA
(3535) 					i = (unsigned int)GetMotPositionOfStep(MOT_SAMP_NEEDLE);
    05A70 E010      LDI	R17,0
    05A71 D7F2      RCALL	__FluidMotRun
    05A72 E081      LDI	R24,1
    05A73 9380 1658 STS	dustbinOldState+1,R24
(3536) 					i = i-mixLiqLevel;
    05A75 E085      LDI	R24,5
    05A76 9380 161E STS	EvenPosChangeProcess+20,R24
    05A78 C770      RJMP	0x61E9
    05A79 2722      CLR	R18
    05A7A 2700      CLR	R16
(3537) 					Uart0ReUnable;
    05A7B 940E 6B81 CALL	_SetEValve
    05A7D E021      LDI	R18,1
    05A7E E003      LDI	R16,3
    05A7F 940E 6B81 CALL	_SetEValve
(3538) 					uart_Printf("%s $%d\r\n",strM2112, i);
    05A81 EF20      LDI	R18,0xF0
    05A82 2700      CLR	R16
    05A83 2711      CLR	R17
    05A84 940E 62FB CALL	__NeedleMotRunTo
    05A86 EC28      LDI	R18,0xC8
    05A87 E104      LDI	R16,0x14
(3539) 					Uart0ReEnable;
    05A88 E010      LDI	R17,0
    05A89 D7FF      RCALL	__EffluentMotRun
    05A8A E081      LDI	R24,1
    05A8B 9380 165A STS	dustbinOldState+3,R24
(3540) 					SetDelayTime(MOT_SAMP_NEEDLE, 10);
    05A8D 9380 1656 STS	CardScanfSW,R24
    05A8F E086      LDI	R24,6
    05A90 9380 161E STS	EvenPosChangeProcess+20,R24
(3541) 					workStep = 14;
    05A92 C756      RJMP	0x61E9
    05A93 2722      CLR	R18
    05A94 2700      CLR	R16
(3542) 					break;
    05A95 940E 6B81 CALL	_SetEValve
(3543) 				case 14:
(3544) 					SetEValve(EV_ALL,EV_CLOSE);
    05A97 ED2C      LDI	R18,0xDC
    05A98 E104      LDI	R16,0x14
    05A99 E010      LDI	R17,0
(3545) 					_NeedleMotRunTo(0, 240);
    05A9A D7EE      RCALL	__EffluentMotRun
    05A9B E081      LDI	R24,1
    05A9C 9380 1656 STS	CardScanfSW,R24
(3546) 					workStep = 15;
    05A9E E087      LDI	R24,7
    05A9F 9380 161E STS	EvenPosChangeProcess+20,R24
(3547) 					break;
    05AA1 C747      RJMP	0x61E9
(3548) 				case 15:
(3549) 					_EffluentMotRun(20, 200);
    05AA2 E021      LDI	R18,1
    05AA3 E002      LDI	R16,2
    05AA4 940E 6B81 CALL	_SetEValve
(3550) 					workStep = 0;
    05AA6 E022      LDI	R18,2
    05AA7 E030      LDI	R19,0
    05AA8 E009      LDI	R16,0x9
(3551) 					mainStep = 4;
    05AA9 940E 97B7 CALL	_SetDelayTime
    05AAB E088      LDI	R24,0x8
(3552) 					subStep = 0;
    05AAC 9380 161E STS	EvenPosChangeProcess+20,R24
(3553) 					waitEffluent = 1;
    05AAE C73A      RJMP	0x61E9
    05AAF E420      LDI	R18,0x40
    05AB0 EF0E      LDI	R16,0xFE
(3554) 					waitMotSampNeedle = 1;
    05AB1 EF1F      LDI	R17,0xFF
    05AB2 D7B1      RCALL	__FluidMotRun
(3555) 					CalCnt = 5;
    05AB3 E081      LDI	R24,1
    05AB4 9380 1658 STS	dustbinOldState+1,R24
(3556) 					CalValue1 = 0;
    05AB6 E089      LDI	R24,0x9
    05AB7 9380 161E STS	EvenPosChangeProcess+20,R24
    05AB9 C72F      RJMP	0x61E9
    05ABA 2722      CLR	R18
(3557) 					CalValue2 = 0;
    05ABB E002      LDI	R16,2
    05ABC 940E 6B81 CALL	_SetEValve
    05ABE 2422      CLR	R2
(3558) 					InitFlowMeter(); // 初始化流量定标判断
    05ABF 9220 161E STS	EvenPosChangeProcess+20,R2
(3559) 					break;
(3560) 				}
(3561) 			break;
    05AC1 E082      LDI	R24,2
(3562) 		case 4:		//  稀释液蠕动泵流量定标
(3563) 			switch(workStep)
    05AC2 9380 161D STS	EvenPosChangeProcess+19,R24
    05AC4 C724      RJMP	0x61E9
    05AC5 E022      LDI	R18,2
    05AC6 E030      LDI	R19,0
    05AC7 E00B      LDI	R16,0xB
    05AC8 940E 97B7 CALL	_SetDelayTime
    05ACA 940E 639F CALL	__PrimingDiluent
    05ACC 0168      MOVW	R12,R16
    05ACD 2D4C      MOV	R20,R12
    05ACE 3001      CPI	R16,1
    05ACF F439      BNE	0x5AD7
    05AD0 2422      CLR	R2
    05AD1 9220 161E STS	EvenPosChangeProcess+20,R2
    05AD3 E083      LDI	R24,3
    05AD4 9380 161D STS	EvenPosChangeProcess+19,R24
    05AD6 C712      RJMP	0x61E9
    05AD7 3F4F      CPI	R20,0xFF
    05AD8 F009      BEQ	0x5ADA
    05AD9 C70F      RJMP	0x61E9
    05ADA 9180 00C1 LDS	R24,0xC1
(3564) 			{
(3565) 				case 0:		// 准备
(3566) 					switch(subStep)
    05ADC 7E8F      ANDI	R24,0xEF
    05ADD 9380 00C1 STS	0xC1,R24
    05ADF E825      LDI	R18,0x85
    05AE0 E134      LDI	R19,0x14
    05AE1 E80F      LDI	R16,0x8F
    05AE2 E016      LDI	R17,6
    05AE3 940E A90D CALL	_uart_Printf
    05AE5 9180 00C1 LDS	R24,0xC1
    05AE7 6180      ORI	R24,0x10
    05AE8 9380 00C1 STS	0xC1,R24
    05AEA E088      LDI	R24,0x8
    05AEB 9380 161D STS	EvenPosChangeProcess+19,R24
    05AED 2422      CLR	R2
    05AEE 9220 161E STS	EvenPosChangeProcess+20,R2
    05AF0 C6F8      RJMP	0x61E9
    05AF1 9140 161E LDS	R20,EvenPosChangeProcess+20
    05AF3 2755      CLR	R21
    05AF4 3040      CPI	R20,0
    05AF5 E0E0      LDI	R30,0
    05AF6 075E      CPC	R21,R30
    05AF7 F40C      BGE	0x5AF9
    05AF8 C6F0      RJMP	0x61E9
    05AF9 E08F      LDI	R24,0xF
    05AFA E090      LDI	R25,0
    05AFB 1784      CP	R24,R20
    05AFC 0795      CPC	R25,R21
    05AFD F05C      BLT	0x5B09
    05AFE E78A      LDI	R24,0x7A
    05AFF E093      LDI	R25,3
    05B00 01FA      MOVW	R30,R20
    05B01 0FEE      LSL	R30
    05B02 1FFF      ROL	R31
    05B03 0FE8      ADD	R30,R24
(3567) 					{
(3568) 						case 0:
(3569) 							SetMotRunPam(MOT_SAMP_NEEDLE, 220, 20, CURRENT_SAMP_NEEDLE);
    05B04 1FF9      ADC	R31,R25
    05B05 9027      ELPM	R2,Z+
    05B06 9036      ELPM	R3,Z
    05B07 01F1      MOVW	R30,R2
    05B08 9409      IJMP
    05B09 3644      CPI	R20,0x64
    05B0A E0E0      LDI	R30,0
    05B0B 075E      CPC	R21,R30
(3570) 							MotInitCheck(MOT_SAMP_NEEDLE);
    05B0C F0D9      BEQ	0x5B28
    05B0D 3645      CPI	R20,0x65
    05B0E E0E0      LDI	R30,0
(3571) 							waitMotSampNeedle = 1;
    05B0F 075E      CPC	R21,R30
    05B10 F159      BEQ	0x5B3C
    05B11 3646      CPI	R20,0x66
(3572) 							subStep = 1;
    05B12 E0E0      LDI	R30,0
    05B13 075E      CPC	R21,R30
(3573) 							break;
    05B14 F1A9      BEQ	0x5B4A
(3574) 						case 1:
(3575) 							SetMotRunPam(MOT_SAMP_TRUN,200,10,CURRENT_SAMP_TRUN);
    05B15 C6D3      RJMP	0x61E9
    05B16 E083      LDI	R24,3
    05B17 838A      STD	Y+2,R24
    05B18 E184      LDI	R24,0x14
    05B19 8388      ST	Y,R24
    05B1A EF20      LDI	R18,0xF0
    05B1B E003      LDI	R16,3
    05B1C 940E 6A9F CALL	_SetMotRunPam
(3576) 							MotRunTo(MOT_SAMP_TRUN, 0);
    05B1E E003      LDI	R16,3
    05B1F 940E 6AFA CALL	_MotInitCheck
    05B21 E081      LDI	R24,1
(3577) 							waitMotSampTurn = 1;
    05B22 9380 165A STS	dustbinOldState+3,R24
    05B24 E684      LDI	R24,0x64
(3578) 							subStep = 2;
    05B25 9380 161E STS	EvenPosChangeProcess+20,R24
    05B27 C6C1      RJMP	0x61E9
(3579) 							break;
    05B28 E084      LDI	R24,4
(3580) 						case 2:
(3581) 							MotRunTo(MOT_SAMP_TRUN, NeedleOnMixCenterPos);
    05B29 838A      STD	Y+2,R24
    05B2A E085      LDI	R24,5
    05B2B 8388      ST	Y,R24
    05B2C EC28      LDI	R18,0xC8
    05B2D E002      LDI	R16,2
    05B2E 940E 6A9F CALL	_SetMotRunPam
(3582) 							waitMotSampTurn = 1;
    05B30 2722      CLR	R18
    05B31 2733      CLR	R19
    05B32 E002      LDI	R16,2
(3583) 							subStep = 3;
    05B33 940E 6A5B CALL	_MotRunTo
    05B35 E081      LDI	R24,1
(3584) 							break;
    05B36 9380 165B STS	dustbinOldState+4,R24
(3585) 						case 3:		// 取样针运行到低位,同时取样针吸干清洗头
(3586) 							_FluidMotRun(-1, 70);
    05B38 E685      LDI	R24,0x65
    05B39 9380 161E STS	EvenPosChangeProcess+20,R24
(3587) 							SetEValve(EV3,EV_OPEN);
    05B3B C6AD      RJMP	0x61E9
    05B3C 9120 1646 LDS	R18,_NewCardStoreNum+6
    05B3E 9130 1647 LDS	R19,_NewCardStoreNum+7
(3588) 							_EffluentMotRun(100, 200);
    05B40 E002      LDI	R16,2
    05B41 940E 6A5B CALL	_MotRunTo
(3589) 							_NeedleMotRunTo(_POS_MIX_CAL_START-100, 220);
    05B43 E081      LDI	R24,1
    05B44 9380 165B STS	dustbinOldState+4,R24
    05B46 E686      LDI	R24,0x66
(3590) 							waitMotSampNeedle = 1;
    05B47 9380 161E STS	EvenPosChangeProcess+20,R24
    05B49 C69F      RJMP	0x61E9
(3591) 							subStep = 4;
    05B4A EF20      LDI	R18,0xF0
    05B4B E50C      LDI	R16,0x5C
    05B4C E013      LDI	R17,3
(3592) 							break;
    05B4D D7AD      RCALL	__NeedleMotRunTo
(3593) 						case 4:
(3594) 							MotStop(MOT_EFFLUENT);
    05B4E E081      LDI	R24,1
    05B4F 9380 165A STS	dustbinOldState+3,R24
(3595) 							SetEValve(0, 0);
    05B51 9380 161E STS	EvenPosChangeProcess+20,R24
    05B53 C695      RJMP	0x61E9
    05B54 2722      CLR	R18
(3596) 							subStep = 5;
    05B55 2700      CLR	R16
    05B56 940E 6B81 CALL	_SetEValve
(3597) 							SetDelayTime(MOT_EFFLUENT, 5);
    05B58 2700      CLR	R16
    05B59 940E 9A52 CALL	_getLiqDetADC
    05B5B 0168      MOVW	R12,R16
    05B5C 92D0 165E STS	dustbinOldState+7,R13
(3598) 							break;
    05B5E 92C0 165D STS	dustbinOldState+6,R12
    05B60 E420      LDI	R18,0x40
(3599) 						case 5:
(3600) 						/*	if(CheckLiqDetBase())
(3601) 							{
(3602) 								mainStep = 8;	
(3603) 								workStep = 0;	// 退出处理
(3604) 								Uart0ReUnable;
(3605) 								uart_Printf("!2530\r\n");	// 开始准备稀释液流量定标时，液面探测功能自检出现错误
(3606) 								Uart0ReEnable;
(3607) 							}
(3608) 							else
(3609) 						*/
(3610) 								subStep = 6;
(3611) 							break;
    05B61 E604      LDI	R16,0x64
(3612) 						case 6:		// 注入第一段液体
(3613) 							_SampPumpMotRun(100, 64);
    05B62 E010      LDI	R17,0
    05B63 D7B7      RCALL	__SampPumpMotRun
    05B64 E082      LDI	R24,2
    05B65 9380 161E STS	EvenPosChangeProcess+20,R24
(3614) 							liqDetBaseAdc = getLiqDetADC(NeedleChannel);
    05B67 C681      RJMP	0x61E9
    05B68 E220      LDI	R18,0x20
    05B69 E009      LDI	R16,0x9
    05B6A E010      LDI	R17,0
    05B6B D6F8      RCALL	__FluidMotRun
    05B6C 2422      CLR	R2
    05B6D 9220 1621 STS	EvenPosChangeProcess+23,R2
(3615) 							//uart_Printf("//LiqDetBaseAdc6 $%4d\r\n",liqDetBaseAdc);	
(3616) #if 	(DILUTE_TUBE == 14)
(3617) 							_DiluentMotRun(12+5, 16);
(3618) #elif	(DILUTE_TUBE == 16)
(3619) 							_DiluentMotRun(4, 64);	
    05B6F E083      LDI	R24,3
    05B70 9380 161E STS	EvenPosChangeProcess+20,R24
(3620) #endif
(3621) 							waitMotDiluent = 1;
    05B72 C676      RJMP	0x61E9
    05B73 E001      LDI	R16,1
    05B74 940E 2DBB CALL	_GetLiquidMonitorState
(3622) 						//	workStep = 2;
(3623) 							subStep = 7;
    05B76 2F40      MOV	R20,R16
    05B77 300E      CPI	R16,0xE
(3624) 							break;
    05B78 F511      BNE	0x5B9B
(3625) 						case 7:		// 稀释液回抽
(3626) #if 	(DILUTE_TUBE == 14)
(3627) 							_DiluentMotRun(-5, 64);	
(3628) #elif	(DILUTE_TUBE == 16)
(3629) 							_DiluentMotRun(-1, 64);	
    05B79 940E 372D CALL	_SetBeepWarning
    05B7B E088      LDI	R24,0x8
    05B7C 9380 161D STS	EvenPosChangeProcess+19,R24
(3630) #endif
(3631) 							waitMotDiluent = 1;
    05B7E 2422      CLR	R2
    05B7F 9220 161E STS	EvenPosChangeProcess+20,R2
(3632) 							workStep = 2;
    05B81 E00A      LDI	R16,0xA
    05B82 940E 6A13 CALL	_MotStop
(3633) 							subStep = 0;
    05B84 E00C      LDI	R16,0xC
    05B85 940E 6AFA CALL	_MotInitCheck
(3634) 							break;
(3635) 						}
(3636) 					break;
    05B87 E025      LDI	R18,5
    05B88 E030      LDI	R19,0
    05B89 E003      LDI	R16,3
    05B8A 940E 97B7 CALL	_SetDelayTime
    05B8C 9180 00C1 LDS	R24,0xC1
    05B8E 7E8F      ANDI	R24,0xEF
    05B8F 9380 00C1 STS	0xC1,R24
    05B91 EF04      LDI	R16,0xF4
    05B92 E015      LDI	R17,5
    05B93 940E A90D CALL	_uart_Printf
    05B95 9180 00C1 LDS	R24,0xC1
    05B97 6180      ORI	R24,0x10
    05B98 9380 00C1 STS	0xC1,R24
    05B9A C64E      RJMP	0x61E9
    05B9B E00A      LDI	R16,0xA
    05B9C 940E 6A0C CALL	_GetMotState
(3637) 				case 2:		// 探测液面高度
(3638) 					switch(subStep)
(3639) 					{
(3640) 						case 0:		// 检查液面探测
(3641) 							i = getLiqDetADC(NeedleChannel);
    05B9E 2F40      MOV	R20,R16
    05B9F 3001      CPI	R16,1
    05BA0 F4F9      BNE	0x5BC0
    05BA1 940E 372D CALL	_SetBeepWarning
(3642) 							if(i < liqDetBaseAdc)
    05BA3 E088      LDI	R24,0x8
    05BA4 9380 161D STS	EvenPosChangeProcess+19,R24
    05BA6 2422      CLR	R2
    05BA7 9220 161E STS	EvenPosChangeProcess+20,R2
(3643) 							{
(3644) 								i = liqDetBaseAdc - i;
    05BA9 E00C      LDI	R16,0xC
    05BAA 940E 6AFA CALL	_MotInitCheck
(3645) 								if(i > 30)		// 液面高度异常
    05BAC E025      LDI	R18,5
    05BAD E030      LDI	R19,0
    05BAE E003      LDI	R16,3
    05BAF 940E 97B7 CALL	_SetDelayTime
(3646) 								{
(3647) 									mainStep = 8;	
    05BB1 9180 00C1 LDS	R24,0xC1
    05BB3 7E8F      ANDI	R24,0xEF
(3648) 									workStep = 0;	// 退出处理
    05BB4 9380 00C1 STS	0xC1,R24
    05BB6 EE0C      LDI	R16,0xEC
(3649) 									Uart0ReUnable;
    05BB7 E015      LDI	R17,5
    05BB8 940E A90D CALL	_uart_Printf
    05BBA 9180 00C1 LDS	R24,0xC1
(3650) 									uart_Printf("!2531\r\n");	// 在稀释液流量定标起始液面高度测量时，检测出液面高度超高，请检重新调整取样针高度后重新运行液路自检程序
    05BBC 6180      ORI	R24,0x10
    05BBD 9380 00C1 STS	0xC1,R24
    05BBF C629      RJMP	0x61E9
(3651) 									Uart0ReEnable;
    05BC0 2700      CLR	R16
    05BC1 940E 9A52 CALL	_getLiqDetADC
    05BC3 0168      MOVW	R12,R16
    05BC4 0156      MOVW	R10,R12
(3652) 									break;
    05BC5 9020 165D LDS	R2,dustbinOldState+6
(3653) 								}
(3654) 							}
(3655) 							subStep = 1;
    05BC7 9030 165E LDS	R3,dustbinOldState+7
(3656) 							break;
    05BC9 1502      CP	R16,R2
(3657) 						case 1:
(3658) 							liqDetBaseAdc = getLiqDetADC(NeedleChannel);
    05BCA 0513      CPC	R17,R3
    05BCB F008      BCS	0x5BCD
    05BCC C61C      RJMP	0x61E9
    05BCD 1A20      SUB	R2,R16
    05BCE 0A31      SBC	R3,R17
    05BCF 0151      MOVW	R10,R2
    05BD0 E18E      LDI	R24,0x1E
    05BD1 E090      LDI	R25,0
(3659) 							//uart_Printf("//LiqDetBaseAdc7 $%4d\r\n",liqDetBaseAdc);	
(3660) 							_NeedleMotRunTo(_POS_MIX_CAL_START+100, 8);
    05BD2 1582      CP	R24,R2
    05BD3 0593      CPC	R25,R3
    05BD4 F4A0      BCC	0x5BE9
    05BD5 9180 1621 LDS	R24,EvenPosChangeProcess+23
(3661) 							mixCalStartPos = 0;
    05BD7 3085      CPI	R24,5
    05BD8 F420      BCC	0x5BDD
    05BD9 5F8F      SUBI	R24,0xFF
    05BDA 9380 1621 STS	EvenPosChangeProcess+23,R24
(3662) 							detRetry = 0;
    05BDC C60C      RJMP	0x61E9
    05BDD E00A      LDI	R16,0xA
(3663) 							subStep = 2;
    05BDE 940E 6A13 CALL	_MotStop
    05BE0 E00C      LDI	R16,0xC
(3664) 							break;
    05BE1 940E 6AFA CALL	_MotInitCheck
(3665) 						case 2:	// 等待取样针接触到液面
(3666) 							// 检查取样针是否在运行，如果停止表示在指定行程内未探测到液面
(3667) 							if(GetMotState(MOT_SAMP_NEEDLE) == STA_SLAVE_FREE)
    05BE3 E084      LDI	R24,4
    05BE4 9380 161E STS	EvenPosChangeProcess+20,R24
    05BE6 940E 3739 CALL	_SetBeepAck
(3668) 							{
(3669) 								SetBeepWarning();
    05BE8 C600      RJMP	0x61E9
    05BE9 2422      CLR	R2
(3670) 								// 退出处理
(3671) 								mainStep = 8;
    05BEA 9220 1621 STS	EvenPosChangeProcess+23,R2
    05BEC C5FC      RJMP	0x61E9
(3672) 								workStep = 0;
    05BED EF20      LDI	R18,0xF0
    05BEE E608      LDI	R16,0x68
    05BEF E011      LDI	R17,1
(3673) 								MotInitCheck(MOT_SAMP_PUMP);
    05BF0 D70A      RCALL	__NeedleMotRunTo
    05BF1 E081      LDI	R24,1
    05BF2 9380 165A STS	dustbinOldState+3,R24
(3674) 								Uart0ReUnable;
    05BF4 E085      LDI	R24,5
    05BF5 9380 161E STS	EvenPosChangeProcess+20,R24
    05BF7 C5F1      RJMP	0x61E9
(3675) 								uart_Printf("!2532\r\n");	// 在稀释液流量定标起始液面高度测量时，未探测到液面，请检查稀释液泵后重新运行液路自检程序
    05BF8 E420      LDI	R18,0x40
    05BF9 E00C      LDI	R16,0xC
    05BFA E010      LDI	R17,0
    05BFB D668      RCALL	__FluidMotRun
(3676) 								Uart0ReEnable;
    05BFC E086      LDI	R24,6
    05BFD 9380 161E STS	EvenPosChangeProcess+20,R24
    05BFF C5E9      RJMP	0x61E9
    05C00 E001      LDI	R16,1
(3677) 								break;
    05C01 940E 2DBB CALL	_GetLiquidMonitorState
(3678) 							}
(3679) 							i = getLiqDetADC(NeedleChannel);
    05C03 2F40      MOV	R20,R16
    05C04 300E      CPI	R16,0xE
    05C05 F511      BNE	0x5C28
    05C06 940E 372D CALL	_SetBeepWarning
(3680) 							if(i < liqDetBaseAdc)
    05C08 E088      LDI	R24,0x8
    05C09 9380 161D STS	EvenPosChangeProcess+19,R24
    05C0B 2422      CLR	R2
    05C0C 9220 161E STS	EvenPosChangeProcess+20,R2
    05C0E E00A      LDI	R16,0xA
(3681) 							{
(3682) 								i = liqDetBaseAdc - i;
    05C0F 940E 6A13 CALL	_MotStop
    05C11 E00C      LDI	R16,0xC
(3683) 								if(i > 30)
    05C12 940E 6AFA CALL	_MotInitCheck
    05C14 E025      LDI	R18,5
    05C15 E030      LDI	R19,0
    05C16 E003      LDI	R16,3
(3684) 								{
(3685) 									if(detRetry < 5)	// 重测计数
    05C17 940E 97B7 CALL	_SetDelayTime
    05C19 9180 00C1 LDS	R24,0xC1
(3686) 									{
(3687) 										detRetry ++;	
    05C1B 7E8F      ANDI	R24,0xEF
    05C1C 9380 00C1 STS	0xC1,R24
(3688) 										break;	
    05C1E EF04      LDI	R16,0xF4
(3689) 									}
(3690) 									MotStop(MOT_SAMP_NEEDLE);
    05C1F E015      LDI	R17,5
    05C20 940E A90D CALL	_uart_Printf
(3691) 									subStep = 3;
    05C22 9180 00C1 LDS	R24,0xC1
    05C24 6180      ORI	R24,0x10
(3692) 									SetDelayTime(MOT_SAMP_NEEDLE, 10);
    05C25 9380 00C1 STS	0xC1,R24
    05C27 C5C1      RJMP	0x61E9
    05C28 E00A      LDI	R16,0xA
    05C29 940E 6A0C CALL	_GetMotState
(3693) 									SetBeepAck();
    05C2B 2F40      MOV	R20,R16
(3694) 								}
    05C2C 3001      CPI	R16,1
(3695) 								else
(3696) 									detRetry = 0;
    05C2D F009      BEQ	0x5C2F
    05C2E C5BA      RJMP	0x61E9
    05C2F E087      LDI	R24,7
(3697) 							}
(3698) 							break;
    05C30 9380 161E STS	EvenPosChangeProcess+20,R24
(3699) 						case 3:		// 记录起始液面高度
(3700) 							mixCalStartPos = (unsigned int)GetMotPositionOfStep(MOT_SAMP_NEEDLE);
    05C32 C5B6      RJMP	0x61E9
    05C33 2700      CLR	R16
    05C34 940E 9A52 CALL	_getLiqDetADC
    05C36 0168      MOVW	R12,R16
    05C37 92D0 165E STS	dustbinOldState+7,R13
(3701) 							_NeedleMotRunTo(_POS_MIX_TOP, 200);
    05C39 92C0 165D STS	dustbinOldState+6,R12
    05C3B E420      LDI	R18,0x40
    05C3C E604      LDI	R16,0x64
(3702) 							MotInitCheck(MOT_SAMP_PUMP);
    05C3D E010      LDI	R17,0
    05C3E D6DC      RCALL	__SampPumpMotRun
    05C3F E120      LDI	R18,0x10
(3703) 							SetDelayTime(MOT_DILUENT, 10);
    05C40 E904      LDI	R16,0x94
    05C41 E012      LDI	R17,2
    05C42 D6B8      RCALL	__NeedleMotRunTo
    05C43 2422      CLR	R2
    05C44 9220 1621 STS	EvenPosChangeProcess+23,R2
(3704) 							subStep = 0;
    05C46 E088      LDI	R24,0x8
    05C47 9380 161E STS	EvenPosChangeProcess+20,R24
(3705) 							workStep = 3;
    05C49 C59F      RJMP	0x61E9
    05C4A E003      LDI	R16,3
(3706) 							waitMotSampNeedle = 1;
    05C4B 940E 6A0C CALL	_GetMotState
    05C4D 2F40      MOV	R20,R16
(3707) 							waitMotSampPump = 1;
    05C4E 3001      CPI	R16,1
    05C4F F501      BNE	0x5C70
(3708) 							break;
(3709) 						}
(3710) 					break;
    05C50 940E 372D CALL	_SetBeepWarning
(3711) 				case 3:		// 注入定标液
(3712) 					switch(subStep)
    05C52 E088      LDI	R24,0x8
    05C53 9380 161D STS	EvenPosChangeProcess+19,R24
    05C55 2422      CLR	R2
    05C56 9220 161E STS	EvenPosChangeProcess+20,R2
    05C58 E00C      LDI	R16,0xC
    05C59 940E 6AFA CALL	_MotInitCheck
    05C5B 9180 00C1 LDS	R24,0xC1
    05C5D 7E8F      ANDI	R24,0xEF
    05C5E 9380 00C1 STS	0xC1,R24
    05C60 82B9      STD	Y+1,R11
    05C61 82A8      ST	Y,R10
    05C62 9120 165D LDS	R18,dustbinOldState+6
    05C64 9130 165E LDS	R19,dustbinOldState+7
    05C66 ED0A      LDI	R16,0xDA
    05C67 E015      LDI	R17,5
    05C68 940E A90D CALL	_uart_Printf
    05C6A 9180 00C1 LDS	R24,0xC1
    05C6C 6180      ORI	R24,0x10
    05C6D 9380 00C1 STS	0xC1,R24
    05C6F C579      RJMP	0x61E9
    05C70 2700      CLR	R16
    05C71 940E 9A52 CALL	_getLiqDetADC
    05C73 0168      MOVW	R12,R16
    05C74 0156      MOVW	R10,R12
(3713) 					{
(3714) 						case 0:
(3715) 					//		_DiluentMotRun(50, 80);		// 注入50个单位溶液
(3716) #if 	(DILUTE_TUBE == 14)
(3717) 							_DiluentMotRun(40+5, 64);		// 注入40个单位溶液
(3718) #elif	(DILUTE_TUBE == 16)
(3719) 							_DiluentMotRun(12+2, 64);		// 注入12+2个单位溶液
    05C75 9020 165D LDS	R2,dustbinOldState+6
    05C77 9030 165E LDS	R3,dustbinOldState+7
(3720) #endif
(3721) 							subStep = 1;
    05C79 1502      CP	R16,R2
    05C7A 0513      CPC	R17,R3
    05C7B F008      BCS	0x5C7D
(3722) 							break;
    05C7C C56C      RJMP	0x61E9
(3723) 						case 1:
(3724) 							if(GetLiquidMonitorState(0) == INFO_LIQ_EMPTY)
    05C7D 1A20      SUB	R2,R16
    05C7E 0A31      SBC	R3,R17
    05C7F 0151      MOVW	R10,R2
    05C80 E58A      LDI	R24,0x5A
    05C81 E090      LDI	R25,0
    05C82 1582      CP	R24,R2
(3725) 							{
(3726) 								// 稀释液供应异常
(3727) 								SetBeepWarning();
    05C83 0593      CPC	R25,R3
    05C84 F508      BCC	0x5CA6
(3728) 								// 退出处理
(3729) 								mainStep = 8;
    05C85 9180 1621 LDS	R24,EvenPosChangeProcess+23
    05C87 308A      CPI	R24,0xA
(3730) 								workStep = 0;
    05C88 F420      BCC	0x5C8D
    05C89 5F8F      SUBI	R24,0xFF
    05C8A 9380 1621 STS	EvenPosChangeProcess+23,R24
(3731) 								MotStop(MOT_DILUENT);
    05C8C C55C      RJMP	0x61E9
    05C8D E003      LDI	R16,3
(3732) 								SetDelayTime(MOT_SAMP_NEEDLE, 5);
    05C8E 940E 6A13 CALL	_MotStop
    05C90 E00C      LDI	R16,0xC
    05C91 940E 6AFA CALL	_MotInitCheck
(3733) 								Uart0ReUnable;
    05C93 E083      LDI	R24,3
    05C94 838A      STD	Y+2,R24
    05C95 E184      LDI	R24,0x14
    05C96 8388      ST	Y,R24
    05C97 EF20      LDI	R18,0xF0
(3734) 								uart_Printf("!2533\r\n");	// 在稀释液流量定标时，稀释液供应中断，请检查和更换稀释液后重新运行液路自检程序
    05C98 E003      LDI	R16,3
    05C99 940E 6A9F CALL	_SetMotRunPam
    05C9B E089      LDI	R24,0x9
(3735) 								Uart0ReEnable;
    05C9C 9380 161E STS	EvenPosChangeProcess+20,R24
    05C9E E025      LDI	R18,5
    05C9F E030      LDI	R19,0
    05CA0 E003      LDI	R16,3
(3736) 								break;
    05CA1 940E 97B7 CALL	_SetDelayTime
(3737) 							}
(3738) 							if(GetMotState(MOT_DILUENT) == STA_SLAVE_FREE)
    05CA3 940E 3739 CALL	_SetBeepAck
    05CA5 C543      RJMP	0x61E9
    05CA6 2422      CLR	R2
    05CA7 9220 1621 STS	EvenPosChangeProcess+23,R2
(3739) 							{
(3740) 								subStep = 2;
    05CA9 C53F      RJMP	0x61E9
    05CAA E00C      LDI	R16,0xC
    05CAB 940E 6AFA CALL	_MotInitCheck
(3741) 							}
(3742) 							break;
    05CAD E081      LDI	R24,1
    05CAE 9380 1659 STS	dustbinOldState+2,R24
    05CB0 E003      LDI	R16,3
(3743) 						case 2:	
(3744) #if 	(DILUTE_TUBE == 14)
(3745) 							_DiluentMotRun(-5, 64);
(3746) #elif	(DILUTE_TUBE == 16)
(3747) 							_DiluentMotRun(-2, 64);
(3748) #endif
(3749) 							waitMotDiluent = 1;
    05CB1 940E 2DAD CALL	_GetMotPositionOfStep
    05CB3 0168      MOVW	R12,R16
(3750) 							subStep = 3;
    05CB4 0156      MOVW	R10,R12
    05CB5 92B0 1629 STS	EvenPosChangeProcess+31,R11
(3751) 							break;
    05CB7 92A0 1628 STS	EvenPosChangeProcess+30,R10
(3752) 						case 3:		// 取样针下降探测液面高度
(3753) 						/*
(3754) 							if(CheckLiqDetBase())
(3755) 							{
(3756) 								mainStep = 8;	workStep = 0;
(3757) 								Uart0ReUnable;
(3758) 								uart_Printf("!2534\r\n");	// 在稀释液流量定标液面高度测量时，液面探测功能自检出现错误
(3759) 								Uart0ReEnable;
(3760) 								break;// 退出处理
(3761) 							}
(3762) 							*/
(3763) 							liqDetBaseAdc = getLiqDetADC(NeedleChannel);
    05CB9 E58C      LDI	R24,0x5C
    05CBA E093      LDI	R25,3
    05CBB 015C      MOVW	R10,R24
    05CBC 1AA0      SUB	R10,R16
    05CBD 0AB1      SBC	R11,R17
    05CBE 9180 00C1 LDS	R24,0xC1
(3764) 							//uart_Printf("//LiqDetBaseAdc8 $%4d\r\n",liqDetBaseAdc);	
(3765) 							_SampPumpMotRun(100, 64);
    05CC0 7E8F      ANDI	R24,0xEF
    05CC1 9380 00C1 STS	0xC1,R24
    05CC3 82B9      STD	Y+1,R11
(3766) 							_NeedleMotRunTo(_POS_MIX_CAL_START-225, 8);
    05CC4 82A8      ST	Y,R10
    05CC5 E325      LDI	R18,0x35
    05CC6 E03A      LDI	R19,0xA
    05CC7 ED01      LDI	R16,0xD1
(3767) 							detRetry = 0;
    05CC8 E015      LDI	R17,5
    05CC9 940E A90D CALL	_uart_Printf
(3768) 							subStep = 4;
    05CCB 9180 00C1 LDS	R24,0xC1
    05CCD 6180      ORI	R24,0x10
(3769) 							break;
    05CCE 9380 00C1 STS	0xC1,R24
(3770) 						case 4:	// 等待取样针接触到液面
(3771) 							// 检查稀释液泵是否在运行，如果停止表示未注入液体或液面探测失败
(3772) 							if(GetMotState(MOT_SAMP_NEEDLE)==STA_SLAVE_FREE)
    05CD0 E02A      LDI	R18,0xA
    05CD1 E030      LDI	R19,0
    05CD2 E003      LDI	R16,3
    05CD3 940E 97B7 CALL	_SetDelayTime
(3773) 							{
(3774) 								MotStop(MOT_SAMP_NEEDLE);
    05CD5 E08A      LDI	R24,0xA
    05CD6 9380 161E STS	EvenPosChangeProcess+20,R24
(3775) 								SetBeepWarning();
    05CD8 C510      RJMP	0x61E9
    05CD9 E82C      LDI	R18,0x8C
(3776) 								// 退出处理
(3777) 								mainStep = 8;
    05CDA E00A      LDI	R16,0xA
    05CDB E010      LDI	R17,0
    05CDC D5AC      RCALL	__EffluentMotRun
(3778) 								workStep = 0;
    05CDD E081      LDI	R24,1
    05CDE 9380 1656 STS	CardScanfSW,R24
(3779) 								MotInitCheck(MOT_SAMP_PUMP);
    05CE0 E08B      LDI	R24,0xB
    05CE1 9380 161E STS	EvenPosChangeProcess+20,R24
(3780) 								Uart0ReUnable;
    05CE3 C505      RJMP	0x61E9
    05CE4 2700      CLR	R16
    05CE5 940E 9A52 CALL	_getLiqDetADC
    05CE7 0168      MOVW	R12,R16
(3781) 								uart_Printf("!2535\r\n");	// 在稀释液流量定标液面高度测量时，未探测到液面，请检查稀释液泵后重新运行液路自检程序
    05CE8 92D0 165E STS	dustbinOldState+7,R13
    05CEA 92C0 165D STS	dustbinOldState+6,R12
(3782) 								Uart0ReEnable;
    05CEC E420      LDI	R18,0x40
    05CED E604      LDI	R16,0x64
    05CEE E010      LDI	R17,0
    05CEF D62B      RCALL	__SampPumpMotRun
    05CF0 E120      LDI	R18,0x10
(3783) 								break;
    05CF1 E50C      LDI	R16,0x5C
(3784) 							}
(3785) 							i = getLiqDetADC(NeedleChannel);
    05CF2 E013      LDI	R17,3
    05CF3 D607      RCALL	__NeedleMotRunTo
    05CF4 2422      CLR	R2
    05CF5 9220 1621 STS	EvenPosChangeProcess+23,R2
(3786) 							if(i < liqDetBaseAdc)
    05CF7 E08C      LDI	R24,0xC
    05CF8 9380 161E STS	EvenPosChangeProcess+20,R24
    05CFA C4EE      RJMP	0x61E9
    05CFB E003      LDI	R16,3
    05CFC 940E 6A0C CALL	_GetMotState
    05CFE 2F40      MOV	R20,R16
(3787) 							{
(3788) 								i = liqDetBaseAdc - i;
    05CFF 3001      CPI	R16,1
    05D00 F431      BNE	0x5D07
    05D01 940E 372D CALL	_SetBeepWarning
(3789) 								if(i>90)
    05D03 E08D      LDI	R24,0xD
    05D04 9380 161E STS	EvenPosChangeProcess+20,R24
    05D06 C4E2      RJMP	0x61E9
(3790) 								{
(3791) 									if(detRetry < 5)	// 重测计数
    05D07 2700      CLR	R16
    05D08 940E 9A52 CALL	_getLiqDetADC
    05D0A 0168      MOVW	R12,R16
(3792) 									{
(3793) 										detRetry ++;	
    05D0B 0156      MOVW	R10,R12
    05D0C 9020 165D LDS	R2,dustbinOldState+6
(3794) 										break;	
    05D0E 9030 165E LDS	R3,dustbinOldState+7
(3795) 									}
(3796) 									MotStop(MOT_SAMP_NEEDLE);
    05D10 1502      CP	R16,R2
    05D11 0513      CPC	R17,R3
(3797) 									subStep = 5;
    05D12 F008      BCS	0x5D14
    05D13 C4D5      RJMP	0x61E9
    05D14 1A20      SUB	R2,R16
(3798) 									SetDelayTime(MOT_SAMP_NEEDLE, 10);
    05D15 0A31      SBC	R3,R17
    05D16 0151      MOVW	R10,R2
    05D17 E382      LDI	R24,0x32
    05D18 E090      LDI	R25,0
    05D19 1582      CP	R24,R2
(3799) 									SetBeepAck();
    05D1A 0593      CPC	R25,R3
    05D1B F4B0      BCC	0x5D32
(3800) 								}
    05D1C 9180 1621 LDS	R24,EvenPosChangeProcess+23
(3801) 								else
(3802) 									detRetry = 0;
    05D1E 308A      CPI	R24,0xA
    05D1F F420      BCC	0x5D24
(3803) 							}
(3804) 							break;
    05D20 5F8F      SUBI	R24,0xFF
(3805) 						case 5:
(3806) 						//	MotInitCheck(MOT_SAMP_PUMP);
(3807) 							MotRunTo(MOT_SAMP_PUMP, 0);
    05D21 9380 1621 STS	EvenPosChangeProcess+23,R24
    05D23 C4C5      RJMP	0x61E9
    05D24 E003      LDI	R16,3
    05D25 940E 6A13 CALL	_MotStop
(3808) 							i = (unsigned int)GetMotPositionOfStep(MOT_SAMP_NEEDLE);		// 记录泵起始值
    05D27 E025      LDI	R18,5
    05D28 E030      LDI	R19,0
(3809) 							i = mixCalStartPos - i;	// 1680
    05D29 E003      LDI	R16,3
    05D2A 940E 97B7 CALL	_SetDelayTime
    05D2C 940E 3739 CALL	_SetBeepAck
    05D2E E08D      LDI	R24,0xD
    05D2F 9380 161E STS	EvenPosChangeProcess+20,R24
(3810) #ifndef Puncture
(3811) 							i = i*2;
    05D31 C4B7      RJMP	0x61E9
(3812) #endif
(3813) 							Uart0ReUnable;
    05D32 2422      CLR	R2
    05D33 9220 1621 STS	EvenPosChangeProcess+23,R2
    05D35 C4B3      RJMP	0x61E9
    05D36 E00C      LDI	R16,0xC
(3814) 							uart_Printf("// DiluteFlow:%d\r\n", i);
    05D37 940E 6AFA CALL	_MotInitCheck
    05D39 E003      LDI	R16,3
    05D3A 940E 2DAD CALL	_GetMotPositionOfStep
(3815) 							Uart0ReEnable;
    05D3C 0168      MOVW	R12,R16
    05D3D 0156      MOVW	R10,R12
    05D3E 9020 1628 LDS	R2,EvenPosChangeProcess+30
    05D40 9030 1629 LDS	R3,EvenPosChangeProcess+31
(3816) 							m = JudgeFlowMeter(i);
    05D42 18A2      SUB	R10,R2
    05D43 08B3      SBC	R11,R3
    05D44 9180 00C1 LDS	R24,0xC1
(3817) 							if(m)
    05D46 7E8F      ANDI	R24,0xEF
    05D47 9380 00C1 STS	0xC1,R24
(3818) 							{
(3819) 								Uart0ReUnable;
    05D49 82B9      STD	Y+1,R11
    05D4A 82A8      ST	Y,R10
    05D4B E520      LDI	R18,0x50
    05D4C E03A      LDI	R19,0xA
    05D4D ED01      LDI	R16,0xD1
(3820) 								uart_Printf("// FlowJudge:%d\r\n", m);
    05D4E E015      LDI	R17,5
    05D4F 940E A90D CALL	_uart_Printf
    05D51 9180 00C1 LDS	R24,0xC1
(3821) 								Uart0ReEnable;
    05D53 6180      ORI	R24,0x10
    05D54 9380 00C1 STS	0xC1,R24
    05D56 E02A      LDI	R18,0xA
    05D57 E030      LDI	R19,0
(3822) 								i = InsetrDiluentFlowCalValue(m);
    05D58 E003      LDI	R16,3
    05D59 940E 97B7 CALL	_SetDelayTime
    05D5B E08E      LDI	R24,0xE
    05D5C 9380 161E STS	EvenPosChangeProcess+20,R24
(3823) 								if(i)
    05D5E C48A      RJMP	0x61E9
    05D5F 2722      CLR	R18
(3824) 								{
(3825) 									Uart0ReUnable;
    05D60 2700      CLR	R16
    05D61 940E 6B81 CALL	_SetEValve
    05D63 EF20      LDI	R18,0xF0
    05D64 2700      CLR	R16
(3826) 									uart_Printf("%s $%4d\r\n",strM2110, i);
    05D65 2711      CLR	R17
    05D66 D594      RCALL	__NeedleMotRunTo
    05D67 E08F      LDI	R24,0xF
    05D68 9380 161E STS	EvenPosChangeProcess+20,R24
    05D6A C47E      RJMP	0x61E9
    05D6B EC28      LDI	R18,0xC8
    05D6C E104      LDI	R16,0x14
(3827) 									Uart0ReEnable;
    05D6D E010      LDI	R17,0
    05D6E D51A      RCALL	__EffluentMotRun
    05D6F 2422      CLR	R2
    05D70 9220 161E STS	EvenPosChangeProcess+20,R2
(3828) 									CalCnt = 0;		
    05D72 E084      LDI	R24,4
    05D73 9380 161D STS	EvenPosChangeProcess+19,R24
(3829) 								}
    05D75 9220 161F STS	EvenPosChangeProcess+21,R2
(3830) 								else
(3831) 								{	
(3832) 									Uart0ReUnable;
    05D77 E081      LDI	R24,1
    05D78 9380 1656 STS	CardScanfSW,R24
    05D7A 9380 165A STS	dustbinOldState+3,R24
(3833) 									uart_Printf("// CalibRetry:\r\n");
    05D7C E085      LDI	R24,5
    05D7D 9380 1622 STS	EvenPosChangeProcess+24,R24
(3834) 									Uart0ReEnable;
    05D7F 2433      CLR	R3
    05D80 9230 1624 STS	EvenPosChangeProcess+26,R3
    05D82 9220 1623 STS	EvenPosChangeProcess+25,R2
(3835) 								//	CalCnt --;
(3836) 								}
(3837) 							}
(3838) 							else
(3839) 							{
(3840) 							//	CalCnt = 2;
(3841) 							}
(3842) 							subStep = 0;
    05D84 9230 1626 STS	EvenPosChangeProcess+28,R3
    05D86 9220 1625 STS	EvenPosChangeProcess+27,R2
(3843) 							workStep = 4;
    05D88 940E 6E1B CALL	_InitFlowMeter
(3844) 							waitMotSampPump = 1;
    05D8A C45E      RJMP	0x61E9
    05D8B 9140 161E LDS	R20,EvenPosChangeProcess+20
(3845) 							break;
    05D8D 2755      CLR	R21
(3846) 						case 6:
(3847) 							subStep = 0;
    05D8E 3040      CPI	R20,0
    05D8F E0E0      LDI	R30,0
    05D90 075E      CPC	R21,R30
(3848) 							workStep = 4;
    05D91 F40C      BGE	0x5D93
    05D92 C456      RJMP	0x61E9
    05D93 E180      LDI	R24,0x10
(3849) 							break;
(3850) 						default:
(3851) 							break;
(3852) 						}
(3853) 					break;
    05D94 E090      LDI	R25,0
(3854) 				case 4:
(3855) 					_NeedleMotRunTo(0, 240);
    05D95 1784      CP	R24,R20
    05D96 0795      CPC	R25,R21
    05D97 F40C      BGE	0x5D99
    05D98 C450      RJMP	0x61E9
(3856) 					_EffluentMotRun(30, 120);
    05D99 E98A      LDI	R24,0x9A
    05D9A E093      LDI	R25,3
    05D9B 01FA      MOVW	R30,R20
    05D9C 0FEE      LSL	R30
(3857) 					waitMotSampNeedle = 1;
    05D9D 1FFF      ROL	R31
    05D9E 0FE8      ADD	R30,R24
    05D9F 1FF9      ADC	R31,R25
(3858) 					waitEffluent = 1;
    05DA0 9027      ELPM	R2,Z+
    05DA1 9036      ELPM	R3,Z
(3859) 					if(CalCnt != 0)
    05DA2 01F1      MOVW	R30,R2
    05DA3 9409      IJMP
    05DA4 9140 161F LDS	R20,EvenPosChangeProcess+21
(3860) 					{
(3861) 						CalCnt --;
    05DA6 2755      CLR	R21
    05DA7 3040      CPI	R20,0
    05DA8 0745      CPC	R20,R21
    05DA9 F119      BEQ	0x5DCD
(3862) 						workStep = 0;
    05DAA 3041      CPI	R20,1
    05DAB E0E0      LDI	R30,0
    05DAC 075E      CPC	R21,R30
(3863) 						mainStep = 4;
    05DAD F181      BEQ	0x5DDE
    05DAE 3042      CPI	R20,2
    05DAF E0E0      LDI	R30,0
(3864) 						subStep = 0;
    05DB0 075E      CPC	R21,R30
    05DB1 F409      BNE	0x5DB3
(3865) 					}
    05DB2 C03F      RJMP	0x5DF2
(3866) 					else
(3867) 						workStep = 5;
    05DB3 3043      CPI	R20,3
    05DB4 E0E0      LDI	R30,0
    05DB5 075E      CPC	R21,R30
(3868) 					break;
    05DB6 F409      BNE	0x5DB8
(3869) 				case 5:
(3870) 					MotRunTo(MOT_SAMP_TRUN, 0);
    05DB7 C048      RJMP	0x5E00
    05DB8 3044      CPI	R20,4
    05DB9 E0E0      LDI	R30,0
    05DBA 075E      CPC	R21,R30
    05DBB F409      BNE	0x5DBD
(3871) 					waitMotSampTurn= 1;
    05DBC C05A      RJMP	0x5E17
    05DBD 3045      CPI	R20,5
    05DBE E0E0      LDI	R30,0
(3872) 					workStep = 6;
    05DBF 075E      CPC	R21,R30
    05DC0 F409      BNE	0x5DC2
    05DC1 C065      RJMP	0x5E27
(3873) 					break;
    05DC2 3046      CPI	R20,6
(3874) 				case 6:
(3875) 					if(WorkProcessStep == 3)
    05DC3 E0E0      LDI	R30,0
    05DC4 075E      CPC	R21,R30
    05DC5 F409      BNE	0x5DC7
    05DC6 C064      RJMP	0x5E2B
(3876) 					{
(3877) 
(3878) 						MotRunTo(MOT_SAMP_TRUN, NeedleOnMixCenterPos);
    05DC7 3047      CPI	R20,7
    05DC8 E0E0      LDI	R30,0
    05DC9 075E      CPC	R21,R30
    05DCA F409      BNE	0x5DCC
    05DCB C076      RJMP	0x5E42
    05DCC C41C      RJMP	0x61E9
    05DCD E083      LDI	R24,3
(3879) 						waitMotSampTurn= 1;
    05DCE 838A      STD	Y+2,R24
    05DCF E184      LDI	R24,0x14
    05DD0 8388      ST	Y,R24
(3880) 						cNum = 3;
    05DD1 ED2C      LDI	R18,0xDC
    05DD2 E003      LDI	R16,3
    05DD3 940E 6A9F CALL	_SetMotRunPam
(3881) 						workStep = 9;
    05DD5 E003      LDI	R16,3
    05DD6 940E 6AFA CALL	_MotInitCheck
(3882) /*
(3883) 						MotRunTo(MOT_SAMP_TRUN, _POS_SAMPTURN_SAMP);
(3884) 						waitMotSampTurn= 1;
(3885) #ifndef Puncture
(3886) 						workStep = 7;
(3887) #else
(3888) 						workStep = 8;
(3889) #endif
(3890) */
(3891) 					}
    05DD8 E081      LDI	R24,1
    05DD9 9380 165A STS	dustbinOldState+3,R24
(3892) 					else
(3893) 					{
(3894) 						workStep = 0;
(3895) 						mainStep = 7;
    05DDB 9380 161F STS	EvenPosChangeProcess+21,R24
    05DDD C40B      RJMP	0x61E9
(3896) 						subStep = 0;
    05DDE E084      LDI	R24,4
    05DDF 838A      STD	Y+2,R24
(3897) 					}
(3898) 					break;
    05DE0 E08A      LDI	R24,0xA
(3899) 				case 7:
(3900) 					_NeedleMotRunTo(_POS_SAMP_DOWN, 180);
    05DE1 8388      ST	Y,R24
    05DE2 EC28      LDI	R18,0xC8
    05DE3 E002      LDI	R16,2
    05DE4 940E 6A9F CALL	_SetMotRunPam
(3901) 					waitMotSampNeedle = 1;
    05DE6 2722      CLR	R18
    05DE7 2733      CLR	R19
(3902) 					workStep = 8;
    05DE8 E002      LDI	R16,2
    05DE9 940E 6A5B CALL	_MotRunTo
(3903) 					break;
    05DEB E081      LDI	R24,1
(3904) 				case 8:
(3905) 					workStep = 0;
    05DEC 9380 165B STS	dustbinOldState+4,R24
    05DEE E082      LDI	R24,2
(3906) 					mainStep = 7;
    05DEF 9380 161F STS	EvenPosChangeProcess+21,R24
    05DF1 C3F7      RJMP	0x61E9
(3907) 					subStep = 0;
    05DF2 9120 1646 LDS	R18,_NewCardStoreNum+6
(3908) 					break;
    05DF4 9130 1647 LDS	R19,_NewCardStoreNum+7
(3909) 				case 9:	
(3910) 					MotRunTo(MOT_SAMP_NEEDLE, _POS_MIX_TOP);
    05DF6 E002      LDI	R16,2
    05DF7 940E 6A5B CALL	_MotRunTo
    05DF9 E081      LDI	R24,1
(3911) 					waitMotSampNeedle = 1;
    05DFA 9380 165B STS	dustbinOldState+4,R24
    05DFC E083      LDI	R24,3
(3912) 					workStep = 10;
    05DFD 9380 161F STS	EvenPosChangeProcess+21,R24
    05DFF C3E9      RJMP	0x61E9
(3913) 					break;
    05E00 E426      LDI	R18,0x46
(3914) 				case 10:// 清洗和灌注取样针通道
(3915) 					cNum--;
    05E01 EF0F      LDI	R16,0xFF
    05E02 EF1F      LDI	R17,0xFF
    05E03 D460      RCALL	__FluidMotRun
    05E04 E021      LDI	R18,1
    05E05 E003      LDI	R16,3
(3916) 					SetEValve(EV2, EV_OPEN);
    05E06 940E 6B81 CALL	_SetEValve
    05E08 EC28      LDI	R18,0xC8
    05E09 E604      LDI	R16,0x64
(3917) 					MotInitCheck(MOT_SAMP_PUMP);
    05E0A E010      LDI	R17,0
    05E0B D47D      RCALL	__EffluentMotRun
    05E0C ED2C      LDI	R18,0xDC
(3918) 					_FluidMotRun(12, 100);		// 注入1mL清洗液
    05E0D E904      LDI	R16,0x94
    05E0E E012      LDI	R17,2
    05E0F D4EB      RCALL	__NeedleMotRunTo
    05E10 E081      LDI	R24,1
(3919) 					waitMotFluid = 1;
    05E11 9380 165A STS	dustbinOldState+3,R24
    05E13 E084      LDI	R24,4
(3920) 					SetDelayTime(MOT_FLUID, 40);
    05E14 9380 161F STS	EvenPosChangeProcess+21,R24
    05E16 C3D2      RJMP	0x61E9
    05E17 E00B      LDI	R16,0xB
    05E18 940E 6A13 CALL	_MotStop
(3921) 					workStep = 11;
    05E1A 2722      CLR	R18
    05E1B 2700      CLR	R16
(3922) 					break;
    05E1C 940E 6B81 CALL	_SetEValve
(3923) 				case 11:
(3924) 					_EffluentMotRun(20, 200);
    05E1E E085      LDI	R24,5
    05E1F 9380 161F STS	EvenPosChangeProcess+21,R24
(3925) 					SetDelayTime(MOT_FLUID, 20);
    05E21 E025      LDI	R18,5
    05E22 E030      LDI	R19,0
    05E23 E00B      LDI	R16,0xB
    05E24 940E 97B7 CALL	_SetDelayTime
(3926) 					waitEffluent = 1;
    05E26 C3C2      RJMP	0x61E9
    05E27 E086      LDI	R24,6
    05E28 9380 161F STS	EvenPosChangeProcess+21,R24
(3927) 					workStep = 12;
    05E2A C3BE      RJMP	0x61E9
    05E2B E420      LDI	R18,0x40
(3928) 					break;
    05E2C E604      LDI	R16,0x64
(3929) 				case 12:
(3930) 					if(cNum != 0)
    05E2D E010      LDI	R17,0
    05E2E D4EC      RCALL	__SampPumpMotRun
    05E2F 2700      CLR	R16
    05E30 940E 9A52 CALL	_getLiqDetADC
(3931) 						workStep = 10;
    05E32 0168      MOVW	R12,R16
    05E33 92D0 165E STS	dustbinOldState+7,R13
(3932) 					else
(3933) 						workStep = 13;
    05E35 92C0 165D STS	dustbinOldState+6,R12
    05E37 E420      LDI	R18,0x40
(3934) 					break;
    05E38 E004      LDI	R16,4
(3935) 				case 13:	// 清洗完毕，抽清洗头残留水
(3936) 					SetEValve(EV_ALL, EV_CLOSE);
    05E39 E010      LDI	R17,0
    05E3A D467      RCALL	__DiluentMotRun
    05E3B E081      LDI	R24,1
    05E3C 9380 1657 STS	dustbinOldState,R24
(3937) 					SetEValve(EV3, EV_OPEN);
    05E3E E087      LDI	R24,7
    05E3F 9380 161F STS	EvenPosChangeProcess+21,R24
(3938) 					_NeedleMotRunTo(0, 180);//240
    05E41 C3A7      RJMP	0x61E9
    05E42 E420      LDI	R18,0x40
    05E43 EF0F      LDI	R16,0xFF
    05E44 EF1F      LDI	R17,0xFF
(3939) 					_EffluentMotRun(30, 200);
    05E45 D45C      RCALL	__DiluentMotRun
    05E46 E081      LDI	R24,1
    05E47 9380 1657 STS	dustbinOldState,R24
(3940) 					waitMotSampNeedle = 1;
    05E49 E082      LDI	R24,2
    05E4A 9380 161E STS	EvenPosChangeProcess+20,R24
(3941) 					waitEffluent = 1;
    05E4C 2422      CLR	R2
    05E4D 9220 161F STS	EvenPosChangeProcess+21,R2
(3942) 					workStep = 14;
    05E4F C399      RJMP	0x61E9
    05E50 9140 161F LDS	R20,EvenPosChangeProcess+21
(3943) 					break;
    05E52 2755      CLR	R21
    05E53 3040      CPI	R20,0
    05E54 0745      CPC	R20,R21
    05E55 F081      BEQ	0x5E66
(3944) 				case 14:	// 排干混匀池水
(3945) 					SetEValve(EV_ALL, EV_CLOSE);
(3946) 					_EffluentMotRun(20, 220);
    05E56 3041      CPI	R20,1
    05E57 E0E0      LDI	R30,0
    05E58 075E      CPC	R21,R30
    05E59 F409      BNE	0x5E5B
(3947) 					waitEffluent = 1;
    05E5A C038      RJMP	0x5E93
    05E5B 3042      CPI	R20,2
    05E5C E0E0      LDI	R30,0
(3948) 					workStep = 15;
    05E5D 075E      CPC	R21,R30
    05E5E F409      BNE	0x5E60
    05E5F C04B      RJMP	0x5EAB
(3949) 					break;
    05E60 3043      CPI	R20,3
(3950) 				case 15:
(3951) 					MotRunTo(MOT_SAMP_TRUN, 0);
    05E61 E0E0      LDI	R30,0
    05E62 075E      CPC	R21,R30
    05E63 F409      BNE	0x5E65
    05E64 C095      RJMP	0x5EFA
    05E65 C383      RJMP	0x61E9
(3952) 					waitMotSampTurn= 1;
    05E66 2700      CLR	R16
    05E67 940E 9A52 CALL	_getLiqDetADC
(3953) 					workStep = 16;
    05E69 0168      MOVW	R12,R16
    05E6A 0156      MOVW	R10,R12
    05E6B 9020 165D LDS	R2,dustbinOldState+6
(3954) 					break;
    05E6D 9030 165E LDS	R3,dustbinOldState+7
    05E6F 1502      CP	R16,R2
    05E70 0513      CPC	R17,R3
    05E71 F4E8      BCC	0x5E8F
(3955) 				case 16:
(3956) 					MotRunTo(MOT_SAMP_TRUN, _POS_SAMPTURN_SAMP);
(3957) 					waitMotSampTurn= 1;
    05E72 1A20      SUB	R2,R16
    05E73 0A31      SBC	R3,R17
    05E74 0151      MOVW	R10,R2
(3958) 					MotRun(MOT_SAMP_PUMP, _SAMP_PUMP_INTERVAL + _SAMP_PUMP_AIR_ISOLATE);
    05E75 E18E      LDI	R24,0x1E
    05E76 E090      LDI	R25,0
    05E77 1582      CP	R24,R2
    05E78 0593      CPC	R25,R3
    05E79 F4A8      BCC	0x5E8F
(3959) 					waitMotSampPump = 1;
    05E7A E088      LDI	R24,0x8
    05E7B 9380 161D STS	EvenPosChangeProcess+19,R24
(3960) #ifndef Puncture
(3961) 					workStep = 7;
    05E7D 2422      CLR	R2
    05E7E 9220 161E STS	EvenPosChangeProcess+20,R2
(3962) #else
(3963) 					workStep = 8;
(3964) #endif
(3965) 					break;
(3966) 			}
(3967) 			break;
    05E80 9180 00C1 LDS	R24,0xC1
(3968) 		case 7:		// 液路自检完成
(3969) 			SetBeepAck();
    05E82 7E8F      ANDI	R24,0xEF
(3970) 			SetEValve(EV_ALL, EV_CLOSE);
    05E83 9380 00C1 STS	0xC1,R24
    05E85 EC09      LDI	R16,0xC9
    05E86 E015      LDI	R17,5
(3971) 			workStep = 0;
    05E87 940E A90D CALL	_uart_Printf
    05E89 9180 00C1 LDS	R24,0xC1
(3972) 			mainStep = 0;
    05E8B 6180      ORI	R24,0x10
(3973) 			Uart0ReUnable;
    05E8C 9380 00C1 STS	0xC1,R24
    05E8E C35A      RJMP	0x61E9
    05E8F E081      LDI	R24,1
    05E90 9380 161F STS	EvenPosChangeProcess+21,R24
(3974) 			uart_Printf("%s\r\n",strM2120);
    05E92 C356      RJMP	0x61E9
    05E93 2700      CLR	R16
    05E94 940E 9A52 CALL	_getLiqDetADC
    05E96 0168      MOVW	R12,R16
(3975) 			Uart0ReEnable;
    05E97 92D0 165E STS	dustbinOldState+7,R13
    05E99 92C0 165D STS	dustbinOldState+6,R12
    05E9B E028      LDI	R18,0x8
(3976) 			return 1;
    05E9C E80E      LDI	R16,0x8E
    05E9D E013      LDI	R17,3
(3977) 			break;
(3978) 		case 8:		// 液路自检失败，失败跳转到这里
(3979) 			switch(workStep)
    05E9E D45C      RCALL	__NeedleMotRunTo
    05E9F 2422      CLR	R2
    05EA0 2433      CLR	R3
    05EA1 9230 162B STS	EvenPosChangeProcess+33,R3
    05EA3 9220 162A STS	EvenPosChangeProcess+32,R2
    05EA5 9220 1621 STS	EvenPosChangeProcess+23,R2
    05EA7 E082      LDI	R24,2
    05EA8 9380 161F STS	EvenPosChangeProcess+21,R24
    05EAA C33E      RJMP	0x61E9
    05EAB E003      LDI	R16,3
    05EAC 940E 6A0C CALL	_GetMotState
(3980) 			{
(3981) 				case 0:
(3982) 					SetMotRunPam(MOT_SAMP_NEEDLE, 220, 20, CURRENT_SAMP_NEEDLE);	// 恢复取样针正常运行参数
    05EAE 2F40      MOV	R20,R16
    05EAF 3001      CPI	R16,1
    05EB0 F4D1      BNE	0x5ECB
    05EB1 940E 372D CALL	_SetBeepWarning
    05EB3 E088      LDI	R24,0x8
    05EB4 9380 161D STS	EvenPosChangeProcess+19,R24
(3983) 					MotInitCheck(MOT_SAMP_NEEDLE);
    05EB6 2422      CLR	R2
    05EB7 9220 161E STS	EvenPosChangeProcess+20,R2
(3984) 					SetEValve(EV_ALL, EV_CLOSE);
    05EB9 E00C      LDI	R16,0xC
    05EBA 940E 6AFA CALL	_MotInitCheck
(3985) 					_EffluentMotRun(30, 200);
    05EBC 9180 00C1 LDS	R24,0xC1
    05EBE 7E8F      ANDI	R24,0xEF
    05EBF 9380 00C1 STS	0xC1,R24
(3986) 					waitMotSampNeedle = 1;
    05EC1 EC01      LDI	R16,0xC1
    05EC2 E015      LDI	R17,5
(3987) 					workStep = 1;
    05EC3 940E A90D CALL	_uart_Printf
(3988) 					break;
    05EC5 9180 00C1 LDS	R24,0xC1
(3989) 				case 1:
(3990) 					MotInitCheck(MOT_SAMP_TRUN);
    05EC7 6180      ORI	R24,0x10
    05EC8 9380 00C1 STS	0xC1,R24
(3991) 					waitMotSampTurn= 1;
    05ECA C31E      RJMP	0x61E9
    05ECB 2700      CLR	R16
(3992) 					waitEffluent = 1;
    05ECC 940E 9A52 CALL	_getLiqDetADC
(3993) 					workStep = 2;
    05ECE 0168      MOVW	R12,R16
    05ECF 0156      MOVW	R10,R12
    05ED0 9020 165D LDS	R2,dustbinOldState+6
(3994) 					break;
    05ED2 9030 165E LDS	R3,dustbinOldState+7
    05ED4 1502      CP	R16,R2
(3995) 				case 2:
(3996) 					workStep = 0;
(3997) 					mainStep = 0;
    05ED5 0513      CPC	R17,R3
    05ED6 F008      BCS	0x5ED8
(3998) 					subStep = 0;
    05ED7 C311      RJMP	0x61E9
    05ED8 1A20      SUB	R2,R16
(3999) 					Uart0ReUnable;
    05ED9 0A31      SBC	R3,R17
    05EDA 0151      MOVW	R10,R2
    05EDB E18E      LDI	R24,0x1E
    05EDC E090      LDI	R25,0
    05EDD 1582      CP	R24,R2
(4000) 					uart_Printf("!2550\r\n");	// 液路自检失败退出
    05EDE 0593      CPC	R25,R3
    05EDF F4B0      BCC	0x5EF6
    05EE0 9180 1621 LDS	R24,EvenPosChangeProcess+23
(4001) 					Uart0ReEnable;
    05EE2 3085      CPI	R24,5
    05EE3 F420      BCC	0x5EE8
    05EE4 5F8F      SUBI	R24,0xFF
    05EE5 9380 1621 STS	EvenPosChangeProcess+23,R24
(4002) 					return 1;
    05EE7 C301      RJMP	0x61E9
    05EE8 E003      LDI	R16,3
(4003) 					break;
(4004) 			}
(4005) 			break;
(4006) 		default:
(4007) 			mainStep = 0;
    05EE9 940E 6A13 CALL	_MotStop
    05EEB E083      LDI	R24,3
(4008) 			workStep = 0;
    05EEC 9380 161F STS	EvenPosChangeProcess+21,R24
(4009) 			break;
(4010) 		}
(4011) 	return 0;
    05EEE E02A      LDI	R18,0xA
    05EEF E030      LDI	R19,0
    05EF0 E003      LDI	R16,3
    05EF1 940E 97B7 CALL	_SetDelayTime
    05EF3 940E 3739 CALL	_SetBeepAck
(4012) }
(4013) 
(4014) 
(4015) /*******************************************************************************************/
(4016) 
(4017) 
(4018) void DiluteProcDatInit(void)
(4019) {
(4020) 	unsigned int i;
(4021) 	unsigned char *pChar;
(4022) 
(4023) 	pChar = (unsigned char *)&(NewTestInfo);
    05EF5 C2F3      RJMP	0x61E9
    05EF6 2422      CLR	R2
(4024) 	for(i=0; i<sizeof(SAMP_INFO); i++)
    05EF7 9220 1621 STS	EvenPosChangeProcess+23,R2
    05EF9 C2EF      RJMP	0x61E9
    05EFA E003      LDI	R16,3
    05EFB 940E 2DAD CALL	_GetMotPositionOfStep
(4025) 	{
(4026) 		*pChar++ = 0;
    05EFD 0168      MOVW	R12,R16
    05EFE 92D0 162B STS	EvenPosChangeProcess+33,R13
    05F00 92C0 162A STS	EvenPosChangeProcess+32,R12
    05F02 EC28      LDI	R18,0xC8
    05F03 E608      LDI	R16,0x68
    05F04 E011      LDI	R17,1
    05F05 D3F5      RCALL	__NeedleMotRunTo
    05F06 E00C      LDI	R16,0xC
    05F07 940E 6AFA CALL	_MotInitCheck
    05F09 E02A      LDI	R18,0xA
    05F0A E030      LDI	R19,0
(4027) 	}
(4028) 	CurInsertRingNum = 0xff;
    05F0B E009      LDI	R16,0x9
    05F0C 940E 97B7 CALL	_SetDelayTime
(4029) 	GetNewTestCard = 0;
    05F0E 2422      CLR	R2
    05F0F 9220 161F STS	EvenPosChangeProcess+21,R2
(4030) 	SecondCount = 0;
    05F11 E083      LDI	R24,3
    05F12 9380 161E STS	EvenPosChangeProcess+20,R24
    05F14 E081      LDI	R24,1
    05F15 9380 165A STS	dustbinOldState+3,R24
    05F17 9380 1659 STS	dustbinOldState+2,R24
    05F19 C2CF      RJMP	0x61E9
(4031) 	// 初始化测试参数
(4032) 	_NewCardStoreNum = 1;
    05F1A 9140 161F LDS	R20,EvenPosChangeProcess+21
    05F1C 2755      CLR	R21
(4033) 	_NewMultipNum = 9;
    05F1D 3040      CPI	R20,0
    05F1E 0745      CPC	R20,R21
    05F1F F0F1      BEQ	0x5F3E
(4034) 	_NewReadTime0 = 60;
    05F20 3041      CPI	R20,1
    05F21 E0E0      LDI	R30,0
    05F22 075E      CPC	R21,R30
    05F23 F111      BEQ	0x5F46
    05F24 3042      CPI	R20,2
    05F25 E0E0      LDI	R30,0
(4035) 	_NewReadTime1 = 0;
    05F26 075E      CPC	R21,R30
    05F27 F409      BNE	0x5F29
    05F28 C04D      RJMP	0x5F76
    05F29 3043      CPI	R20,3
    05F2A E0E0      LDI	R30,0
(4036) 	_NewTestType = 0;
    05F2B 075E      CPC	R21,R30
    05F2C F409      BNE	0x5F2E
(4037) //	_DropVolume = 0; 
(4038) 	_DropVolume = 0;//60*42; 
    05F2D C053      RJMP	0x5F81
    05F2E 3044      CPI	R20,4
    05F2F E0E0      LDI	R30,0
    05F30 075E      CPC	R21,R30
(4039) 	Read_DiluentCalChart();
    05F31 F409      BNE	0x5F33
    05F32 C065      RJMP	0x5F98
(4040) 	EEPROM_READ(EEP_ADD_SLEEP_TIME,  i);
    05F33 3045      CPI	R20,5
    05F34 E0E0      LDI	R30,0
    05F35 075E      CPC	R21,R30
    05F36 F409      BNE	0x5F38
    05F37 C0B2      RJMP	0x5FEA
    05F38 3046      CPI	R20,6
    05F39 E0E0      LDI	R30,0
    05F3A 075E      CPC	R21,R30
    05F3B F409      BNE	0x5F3D
    05F3C C11A      RJMP	0x6057
    05F3D C2AB      RJMP	0x61E9
(4041) 	if((i & 0xc000) != 0xc000)		// 0xc000 初始化标记
    05F3E E420      LDI	R18,0x40
    05F3F E00E      LDI	R16,0xE
    05F40 E010      LDI	R17,0
    05F41 D360      RCALL	__DiluentMotRun
    05F42 E081      LDI	R24,1
    05F43 9380 161F STS	EvenPosChangeProcess+21,R24
    05F45 C2A3      RJMP	0x61E9
(4042) 	{
(4043) 		i = 1800;
    05F46 2700      CLR	R16
    05F47 940E 2DBB CALL	_GetLiquidMonitorState
    05F49 2F40      MOV	R20,R16
(4044) 	}
(4045) 	_SleepTime = i;
    05F4A 300E      CPI	R16,0xE
    05F4B F4F9      BNE	0x5F6B
    05F4C 940E 372D CALL	_SetBeepWarning
    05F4E E088      LDI	R24,0x8
    05F4F 9380 161D STS	EvenPosChangeProcess+19,R24
(4046) 	EEPROM_WRITE(EEP_ADD_SLEEP_TIME,  i + 0xc000);
    05F51 2422      CLR	R2
    05F52 9220 161E STS	EvenPosChangeProcess+20,R2
    05F54 E009      LDI	R16,0x9
    05F55 940E 6A13 CALL	_MotStop
    05F57 E025      LDI	R18,5
    05F58 E030      LDI	R19,0
    05F59 E003      LDI	R16,3
    05F5A 940E 97B7 CALL	_SetDelayTime
(4047) 	NewTestInfo.testSerial = ReadCurTestSetial();
    05F5C 9180 00C1 LDS	R24,0xC1
    05F5E 7E8F      ANDI	R24,0xEF
    05F5F 9380 00C1 STS	0xC1,R24
    05F61 EB09      LDI	R16,0xB9
    05F62 E015      LDI	R17,5
    05F63 940E A90D CALL	_uart_Printf
    05F65 9180 00C1 LDS	R24,0xC1
    05F67 6180      ORI	R24,0x10
    05F68 9380 00C1 STS	0xC1,R24
    05F6A C27E      RJMP	0x61E9
    05F6B E009      LDI	R16,0x9
    05F6C 940E 6A0C CALL	_GetMotState
(4048) }
(4049) 
(4050) void _FluidMotRun(signed int n,unsigned char vel)
(4051) {
(4052) 	if(vel>128)
    05F6E 2F40      MOV	R20,R16
    05F6F 3001      CPI	R16,1
    05F70 F009      BEQ	0x5F72
(4053) 		SetMotRunPam(MOT_FLUID, vel, 10, CURRENT_FLUID);
    05F71 C277      RJMP	0x61E9
    05F72 E082      LDI	R24,2
    05F73 9380 161F STS	EvenPosChangeProcess+21,R24
    05F75 C273      RJMP	0x61E9
    05F76 E420      LDI	R18,0x40
    05F77 EF0E      LDI	R16,0xFE
    05F78 EF1F      LDI	R17,0xFF
    05F79 D328      RCALL	__DiluentMotRun
(4054) 	else
(4055) 		SetMotRunPam(MOT_FLUID, vel, 10, CURRENT_FLUID);
    05F7A E081      LDI	R24,1
    05F7B 9380 1657 STS	dustbinOldState,R24
    05F7D E083      LDI	R24,3
    05F7E 9380 161F STS	EvenPosChangeProcess+21,R24
    05F80 C268      RJMP	0x61E9
    05F81 2700      CLR	R16
(4056) 	MotRun(MOT_FLUID, n*100);			// 开启清洗液泵
    05F82 940E 9A52 CALL	_getLiqDetADC
    05F84 0168      MOVW	R12,R16
    05F85 92D0 165E STS	dustbinOldState+7,R13
    05F87 92C0 165D STS	dustbinOldState+6,R12
    05F89 E420      LDI	R18,0x40
    05F8A E604      LDI	R16,0x64
    05F8B E010      LDI	R17,0
    05F8C D38E      RCALL	__SampPumpMotRun
    05F8D E028      LDI	R18,0x8
__EffluentMotRun:
  vel                  --> R12
  n                    --> R10
    05F8E E70B      LDI	R16,0x7B
    05F8F E012      LDI	R17,2
    05F90 D36A      RCALL	__NeedleMotRunTo
    05F91 2422      CLR	R2
    05F92 9220 1621 STS	EvenPosChangeProcess+23,R2
(4057) }
(4058) 
(4059) void _EffluentMotRun(signed int n,unsigned char vel)
(4060) {
(4061) 	SetMotRunPam(MOT_EFFLUENT, vel, 10, CURRENT_EFFLUENT);
    05F94 E084      LDI	R24,4
    05F95 9380 161F STS	EvenPosChangeProcess+21,R24
    05F97 C251      RJMP	0x61E9
    05F98 E003      LDI	R16,3
    05F99 940E 6A0C CALL	_GetMotState
(4062) 	MotRun(MOT_EFFLUENT, n*100);			// 开启废液泵
    05F9B 2F40      MOV	R20,R16
    05F9C 3001      CPI	R16,1
    05F9D F4E9      BNE	0x5FBB
    05F9E E003      LDI	R16,3
    05F9F 940E 6A13 CALL	_MotStop
    05FA1 940E 372D CALL	_SetBeepWarning
    05FA3 E088      LDI	R24,0x8
    05FA4 9380 161D STS	EvenPosChangeProcess+19,R24
    05FA6 2422      CLR	R2
__DiluentMotRun:
  vel                  --> R12
  n                    --> R10
    05FA7 9220 161E STS	EvenPosChangeProcess+20,R2
    05FA9 E00C      LDI	R16,0xC
    05FAA 940E 6AFA CALL	_MotInitCheck
(4063) }
(4064) 
(4065) void _DiluentMotRun(signed int n,unsigned char vel)
(4066) {
(4067) 	if(vel>128)
    05FAC 9180 00C1 LDS	R24,0xC1
    05FAE 7E8F      ANDI	R24,0xEF
(4068) 		SetMotRunPam(MOT_DILUENT, vel, 10, CURRENT_DILUENT);
    05FAF 9380 00C1 STS	0xC1,R24
    05FB1 EB01      LDI	R16,0xB1
    05FB2 E015      LDI	R17,5
    05FB3 940E A90D CALL	_uart_Printf
    05FB5 9180 00C1 LDS	R24,0xC1
    05FB7 6180      ORI	R24,0x10
(4069) 	else
(4070) 		SetMotRunPam(MOT_DILUENT, vel, 10, CURRENT_DILUENT);
    05FB8 9380 00C1 STS	0xC1,R24
    05FBA C22E      RJMP	0x61E9
    05FBB 2700      CLR	R16
    05FBC 940E 9A52 CALL	_getLiqDetADC
    05FBE 0168      MOVW	R12,R16
    05FBF 0156      MOVW	R10,R12
(4071) 	MotRun(MOT_DILUENT, n*100);			// 开启稀释液泵
    05FC0 9020 165D LDS	R2,dustbinOldState+6
    05FC2 9030 165E LDS	R3,dustbinOldState+7
    05FC4 1502      CP	R16,R2
    05FC5 0513      CPC	R17,R3
    05FC6 F008      BCS	0x5FC8
    05FC7 C221      RJMP	0x61E9
    05FC8 1A20      SUB	R2,R16
    05FC9 0A31      SBC	R3,R17
    05FCA 0151      MOVW	R10,R2
    05FCB E58A      LDI	R24,0x5A
__NewDiluentMotRun:
  vel                  --> R12
  n                    --> R10
    05FCC E090      LDI	R25,0
    05FCD 1582      CP	R24,R2
    05FCE 0593      CPC	R25,R3
    05FCF F4B0      BCC	0x5FE6
    05FD0 9180 1621 LDS	R24,EvenPosChangeProcess+23
(4072) }
(4073) 
(4074) void _NewDiluentMotRun(signed int n,unsigned char vel)
(4075) {
(4076) 	SetMotRunPam(MOT_DILUENT, vel, 10, CURRENT_DILUENT);
    05FD2 3085      CPI	R24,5
    05FD3 F420      BCC	0x5FD8
    05FD4 5F8F      SUBI	R24,0xFF
    05FD5 9380 1621 STS	EvenPosChangeProcess+23,R24
    05FD7 C211      RJMP	0x61E9
    05FD8 E003      LDI	R16,3
(4077) 	MotRun(MOT_DILUENT, n);			
    05FD9 940E 6A13 CALL	_MotStop
    05FDB E085      LDI	R24,5
    05FDC 9380 161F STS	EvenPosChangeProcess+21,R24
    05FDE E02A      LDI	R18,0xA
    05FDF E030      LDI	R19,0
__NeedleMotRun:
  vel                  --> R12
  n                    --> R10
    05FE0 E003      LDI	R16,3
    05FE1 940E 97B7 CALL	_SetDelayTime
    05FE3 940E 3739 CALL	_SetBeepAck
(4078) }
(4079) 
(4080) void _NeedleMotRun(signed int n,unsigned char vel)
(4081) {
(4082) 	if(vel>128)
    05FE5 C203      RJMP	0x61E9
    05FE6 2422      CLR	R2
    05FE7 9220 1621 STS	EvenPosChangeProcess+23,R2
(4083) 		SetMotRunPam(MOT_SAMP_NEEDLE, vel, 5, CURRENT_SAMP_NEEDLE);
    05FE9 C1FF      RJMP	0x61E9
    05FEA 2722      CLR	R18
    05FEB 2733      CLR	R19
    05FEC E00C      LDI	R16,0xC
    05FED 940E 6A5B CALL	_MotRunTo
    05FEF E003      LDI	R16,3
    05FF0 940E 2DAD CALL	_GetMotPositionOfStep
(4084) 	else
(4085) 		SetMotRunPam(MOT_SAMP_NEEDLE, vel, 5, CURRENT_SAMP_NEEDLE);
    05FF2 9020 162A LDS	R2,EvenPosChangeProcess+32
    05FF4 9030 162B LDS	R3,EvenPosChangeProcess+33
    05FF6 1A20      SUB	R2,R16
    05FF7 0A31      SBC	R3,R17
    05FF8 0151      MOVW	R10,R2
(4086) 	MotRun(MOT_SAMP_NEEDLE, n);	
    05FF9 0CAA      LSL	R10
    05FFA 1CBB      ROL	R11
    05FFB 9180 00C1 LDS	R24,0xC1
    05FFD 7E8F      ANDI	R24,0xEF
    05FFE 9380 00C1 STS	0xC1,R24
__NeedleMotRunTo:
  vel                  --> R12
  n                    --> R10
    06000 0195      MOVW	R18,R10
    06001 E90E      LDI	R16,0x9E
    06002 E015      LDI	R17,5
    06003 940E A90D CALL	_uart_Printf
(4087) }
(4088) 
(4089) void _NeedleMotRunTo(signed int n,unsigned char vel)
(4090) {
(4091) 	if(vel>128)
    06005 9180 00C1 LDS	R24,0xC1
    06007 6180      ORI	R24,0x10
(4092) 		SetMotRunPam(MOT_SAMP_NEEDLE, vel, 5, CURRENT_SAMP_NEEDLE);
    06008 9380 00C1 STS	0xC1,R24
    0600A 0185      MOVW	R16,R10
    0600B 940E 6E26 CALL	_JudgeFlowMeter
    0600D 0168      MOVW	R12,R16
    0600E 3000      CPI	R16,0
    0600F 0701      CPC	R16,R17
    06010 F409      BNE	0x6012
(4093) 	else
(4094) 		SetMotRunPam(MOT_SAMP_NEEDLE, vel, 5, CURRENT_SAMP_NEEDLE);
    06011 C03B      RJMP	0x604D
    06012 9180 00C1 LDS	R24,0xC1
    06014 7E8F      ANDI	R24,0xEF
    06015 9380 00C1 STS	0xC1,R24
    06017 0196      MOVW	R18,R12
    06018 E80C      LDI	R16,0x8C
(4095) 	MotRunTo(MOT_SAMP_NEEDLE, n);	
    06019 E015      LDI	R17,5
    0601A 940E A90D CALL	_uart_Printf
    0601C 9180 00C1 LDS	R24,0xC1
    0601E 6180      ORI	R24,0x10
    0601F 9380 00C1 STS	0xC1,R24
    06021 0186      MOVW	R16,R12
    06022 940E 6EB0 CALL	_InsetrDiluentFlowCalValue
    06024 0168      MOVW	R12,R16
(4096) }
(4097) 
(4098) void _SampPumpMotRun(signed int n,unsigned char vel)
(4099) {
(4100) 	if(vel>128)
    06025 0156      MOVW	R10,R12
    06026 3000      CPI	R16,0
    06027 0701      CPC	R16,R17
(4101) 		SetMotRunPam(MOT_SAMP_PUMP, vel, 5, CURRENT_SAMP_PUMP);
    06028 F0B1      BEQ	0x603F
    06029 9180 00C1 LDS	R24,0xC1
    0602B 7E8F      ANDI	R24,0xEF
    0602C 9380 00C1 STS	0xC1,R24
    0602E 82B9      STD	Y+1,R11
    0602F 82A8      ST	Y,R10
    06030 E129      LDI	R18,0x19
(4102) 	else
(4103) 		SetMotRunPam(MOT_SAMP_PUMP, vel, 5, CURRENT_SAMP_PUMP);
    06031 E03A      LDI	R19,0xA
    06032 E904      LDI	R16,0x94
    06033 E016      LDI	R17,6
    06034 940E A90D CALL	_uart_Printf
    06036 9180 00C1 LDS	R24,0xC1
    06038 6180      ORI	R24,0x10
(4104) 	MotRun(MOT_SAMP_PUMP, n);	
    06039 9380 00C1 STS	0xC1,R24
    0603B 2422      CLR	R2
    0603C 9220 1622 STS	EvenPosChangeProcess+24,R2
    0603E C00E      RJMP	0x604D
    0603F 9180 00C1 LDS	R24,0xC1
    06041 7E8F      ANDI	R24,0xEF
    06042 9380 00C1 STS	0xC1,R24
    06044 E70B      LDI	R16,0x7B
(4105) }
(4106) void _SampPumpMotRunTo(signed int n,unsigned char vel)
(4107) {
(4108) 	if(vel>128)
    06045 E015      LDI	R17,5
    06046 940E A90D CALL	_uart_Printf
(4109) 		SetMotRunPam(MOT_SAMP_PUMP, vel, 5, CURRENT_SAMP_PUMP);
    06048 9180 00C1 LDS	R24,0xC1
    0604A 6180      ORI	R24,0x10
    0604B 9380 00C1 STS	0xC1,R24
    0604D 2422      CLR	R2
    0604E 9220 161F STS	EvenPosChangeProcess+21,R2
    06050 E084      LDI	R24,4
(4110) 	else
(4111) 		SetMotRunPam(MOT_SAMP_PUMP, vel, 5, CURRENT_SAMP_PUMP);
    06051 9380 161E STS	EvenPosChangeProcess+20,R24
    06053 E081      LDI	R24,1
    06054 9380 1659 STS	dustbinOldState+2,R24
    06056 C192      RJMP	0x61E9
    06057 2422      CLR	R2
    06058 9220 161F STS	EvenPosChangeProcess+21,R2
(4112) 	MotRunTo(MOT_SAMP_PUMP, n);	
    0605A E084      LDI	R24,4
    0605B 9380 161E STS	EvenPosChangeProcess+20,R24
    0605D C18B      RJMP	0x61E9
    0605E EF20      LDI	R18,0xF0
    0605F 2700      CLR	R16
(4113) }
(4114) 
(4115) void SetAutoTestCycle(unsigned int num)
(4116) {
(4117) 	_AutoTestCycleNum = num;
_SetAutoTestCycle:
  num                  --> R16
    06060 2711      CLR	R17
    06061 D299      RCALL	__NeedleMotRunTo
    06062 E728      LDI	R18,0x78
    06063 E10E      LDI	R16,0x1E
    06064 E010      LDI	R17,0
(4118) }
(4119) 
(4120) unsigned char SetDiluentQuit(void)
(4121) {
(4122) 	_DiluentQuitFlag = 1;
_SetDiluentQuit:
    06065 D223      RCALL	__EffluentMotRun
    06066 E081      LDI	R24,1
    06067 9380 165A STS	dustbinOldState+3,R24
(4123) 	return 0;
    06069 9380 1656 STS	CardScanfSW,R24
(4124) }
(4125) 
(4126) unsigned char _CheckFluidSupply(void)
(4127) {
(4128) 	if(GetLiquidMonitorState(1) == INFO_LIQ_EMPTY)
    0606B 9020 1622 LDS	R2,EvenPosChangeProcess+24
    0606D 2022      TST	R2
    0606E F069      BEQ	0x607C
(4129) 	{
(4130) 		// 清洗液空
(4131) 		SetBeepWarning();
    0606F 2D82      MOV	R24,R2
    06070 5081      SUBI	R24,1
(4132) 		if(0 == CleanMode)
    06071 9380 1622 STS	EvenPosChangeProcess+24,R24
    06073 2422      CLR	R2
    06074 9220 161E STS	EvenPosChangeProcess+20,R2
(4133) 		{
(4134) 			Uart0ReUnable;
    06076 E084      LDI	R24,4
    06077 9380 161D STS	EvenPosChangeProcess+19,R24
    06079 9220 161F STS	EvenPosChangeProcess+21,R2
(4135) 			uart_Printf("%s\r\n",strE2953);
    0607B C16D      RJMP	0x61E9
    0607C E085      LDI	R24,5
    0607D 9380 161E STS	EvenPosChangeProcess+20,R24
    0607F C169      RJMP	0x61E9
(4136) 			Uart0ReEnable;
    06080 2722      CLR	R18
    06081 2733      CLR	R19
    06082 E002      LDI	R16,2
    06083 940E 6A5B CALL	_MotRunTo
(4137) 		}
(4138) 		return 1;
    06085 E081      LDI	R24,1
    06086 9380 165B STS	dustbinOldState+4,R24
(4139) 	}
(4140) 	/*	
(4141) 	else if(GetLiquidMonitorState(1) == INFO_LIQ_BUBBLE)
(4142) 	{
(4143) 		// 清洗液气泡
(4144) 		SetBeepWarning();
(4145) 		uart0SendString(strE2956);	uart_Printf("\r\n");
(4146) 		return 2;
(4147) 	}
(4148) 	*/
(4149) 	return 0;
    06088 E086      LDI	R24,6
(4150) }
(4151) unsigned char _CheckDiluentSupply(void)
(4152) {
(4153) 	if(GetLiquidMonitorState(0) == INFO_LIQ_EMPTY)
__CheckDiluentSupply:
    06089 9380 161E STS	EvenPosChangeProcess+20,R24
    0608B C15D      RJMP	0x61E9
    0608C 9180 17D7 LDS	R24,WorkProcessStep
(4154) 	{
(4155) 		// 稀释液空
(4156) 		SetBeepWarning();
    0608E 3083      CPI	R24,3
    0608F F489      BNE	0x60A1
(4157) 		Uart0ReUnable;
    06090 9120 1646 LDS	R18,_NewCardStoreNum+6
    06092 9130 1647 LDS	R19,_NewCardStoreNum+7
    06094 E002      LDI	R16,2
(4158) 		uart_Printf("%s\r\n",strE2952);
    06095 940E 6A5B CALL	_MotRunTo
    06097 E081      LDI	R24,1
    06098 9380 165B STS	dustbinOldState+4,R24
    0609A E083      LDI	R24,3
(4159) 		Uart0ReEnable;
    0609B 9380 1627 STS	EvenPosChangeProcess+29,R24
    0609D E089      LDI	R24,0x9
    0609E 9380 161E STS	EvenPosChangeProcess+20,R24
(4160) 		return 1;
    060A0 C148      RJMP	0x61E9
    060A1 2422      CLR	R2
(4161) 	}
(4162) 	/*
(4163) 	else if(GetLiquidMonitorState(0) == INFO_LIQ_BUBBLE)
(4164) 	{
(4165) 		// 稀释液气泡
(4166) 		SetBeepWarning();
(4167) 		uart0SendString(strE2955);	uart_Printf("\r\n");
(4168) 		return 2;
(4169) 	}
(4170) 	*/
(4171) 	return 0;
    060A2 9220 161E STS	EvenPosChangeProcess+20,R2
__PrimingDiluent:
    060A4 E087      LDI	R24,7
    060A5 9380 161D STS	EvenPosChangeProcess+19,R24
(4172) }
(4173) 
(4174) unsigned char _PrimingDiluent(void)
(4175) {
(4176) 	static unsigned char mainStep = 0;
(4177) 	static unsigned int i;
(4178) 	static unsigned char ucTmp;
(4179) 	static unsigned char detRetry;
(4180) 
(4181) 	switch(mainStep)
    060A7 9220 161F STS	EvenPosChangeProcess+21,R2
    060A9 C13F      RJMP	0x61E9
    060AA EB24      LDI	R18,0xB4
    060AB EA08      LDI	R16,0xA8
    060AC E017      LDI	R17,7
    060AD D24D      RCALL	__NeedleMotRunTo
    060AE E081      LDI	R24,1
    060AF 9380 165A STS	dustbinOldState+3,R24
    060B1 E088      LDI	R24,0x8
    060B2 9380 161E STS	EvenPosChangeProcess+20,R24
    060B4 C134      RJMP	0x61E9
    060B5 2422      CLR	R2
    060B6 9220 161E STS	EvenPosChangeProcess+20,R2
    060B8 E087      LDI	R24,7
    060B9 9380 161D STS	EvenPosChangeProcess+19,R24
    060BB 9220 161F STS	EvenPosChangeProcess+21,R2
    060BD C12B      RJMP	0x61E9
    060BE E628      LDI	R18,0x68
    060BF E031      LDI	R19,1
    060C0 E003      LDI	R16,3
    060C1 940E 6A5B CALL	_MotRunTo
    060C3 E081      LDI	R24,1
    060C4 9380 165A STS	dustbinOldState+3,R24
    060C6 E08A      LDI	R24,0xA
    060C7 9380 161E STS	EvenPosChangeProcess+20,R24
    060C9 C11F      RJMP	0x61E9
    060CA 9180 1627 LDS	R24,EvenPosChangeProcess+29
    060CC 5081      SUBI	R24,1
    060CD 9380 1627 STS	EvenPosChangeProcess+29,R24
    060CF E021      LDI	R18,1
    060D0 E002      LDI	R16,2
    060D1 940E 6B81 CALL	_SetEValve
    060D3 E00C      LDI	R16,0xC
    060D4 940E 6AFA CALL	_MotInitCheck
    060D6 E624      LDI	R18,0x64
    060D7 E00C      LDI	R16,0xC
    060D8 E010      LDI	R17,0
    060D9 D18A      RCALL	__FluidMotRun
    060DA E081      LDI	R24,1
    060DB 9380 1658 STS	dustbinOldState+1,R24
    060DD E228      LDI	R18,0x28
    060DE E030      LDI	R19,0
    060DF E00A      LDI	R16,0xA
    060E0 940E 97B7 CALL	_SetDelayTime
(4182) 	{
(4183) 		case 0:		// 取样针高度回零
(4184) 			ReadLiquidMonitorResult(0);
    060E2 E08B      LDI	R24,0xB
    060E3 9380 161E STS	EvenPosChangeProcess+20,R24
(4185) 			ReadLiquidMonitorResult(1);
    060E5 C103      RJMP	0x61E9
    060E6 EC28      LDI	R18,0xC8
(4186) 			ReadLiquidMonitorResult(2);
    060E7 E104      LDI	R16,0x14
    060E8 E010      LDI	R17,0
    060E9 D19F      RCALL	__EffluentMotRun
(4187) 			ReadLiquidMonitorResult(3);
    060EA E124      LDI	R18,0x14
    060EB E030      LDI	R19,0
    060EC E00A      LDI	R16,0xA
(4188) 			SetMotRunPam(MOT_SAMP_NEEDLE, 220, 20, 4);
    060ED 940E 97B7 CALL	_SetDelayTime
    060EF E081      LDI	R24,1
    060F0 9380 1656 STS	CardScanfSW,R24
    060F2 E08C      LDI	R24,0xC
    060F3 9380 161E STS	EvenPosChangeProcess+20,R24
(4189) 			MotInitCheck(MOT_SAMP_NEEDLE);
    060F5 C0F3      RJMP	0x61E9
    060F6 9020 1627 LDS	R2,EvenPosChangeProcess+29
(4190) 			waitMotSampNeedle = 1;
    060F8 2022      TST	R2
    060F9 F021      BEQ	0x60FE
    060FA E08A      LDI	R24,0xA
(4191) 			// 读取取样臂位置
(4192) 			NeedleOnMixCenterPos = GetNeedleOnMixCenterPos();
    060FB 9380 161E STS	EvenPosChangeProcess+20,R24
    060FD C0EB      RJMP	0x61E9
    060FE E08D      LDI	R24,0xD
    060FF 9380 161E STS	EvenPosChangeProcess+20,R24
(4193) 			SetEValve(EV_ALL, EV_CLOSE);
    06101 C0E7      RJMP	0x61E9
    06102 2722      CLR	R18
    06103 2700      CLR	R16
    06104 940E 6B81 CALL	_SetEValve
(4194) 			mainStep = 1;
    06106 E021      LDI	R18,1
    06107 E003      LDI	R16,3
(4195) 		//	mainStep = 9;	// 关闭液面探测
(4196) 			runNum = 5;
    06108 940E 6B81 CALL	_SetEValve
    0610A EB24      LDI	R18,0xB4
(4197) 			break;
    0610B 2700      CLR	R16
(4198) 		case 1:
(4199) 			SetMotRunPam(MOT_SAMP_TRUN,240,10,CURRENT_SAMP_TRUN);
    0610C 2711      CLR	R17
    0610D D1ED      RCALL	__NeedleMotRunTo
    0610E EC28      LDI	R18,0xC8
    0610F E10E      LDI	R16,0x1E
    06110 E010      LDI	R17,0
    06111 D177      RCALL	__EffluentMotRun
    06112 E081      LDI	R24,1
    06113 9380 165A STS	dustbinOldState+3,R24
(4200) 			MotRunTo(MOT_SAMP_TRUN, NeedleOnMixCenterPos);
    06115 9380 1656 STS	CardScanfSW,R24
    06117 E08E      LDI	R24,0xE
    06118 9380 161E STS	EvenPosChangeProcess+20,R24
    0611A C0CE      RJMP	0x61E9
(4201) 			waitMotSampTurn = 1;
    0611B 2722      CLR	R18
    0611C 2700      CLR	R16
    0611D 940E 6B81 CALL	_SetEValve
(4202) 			mainStep = 4;
    0611F ED2C      LDI	R18,0xDC
    06120 E104      LDI	R16,0x14
(4203) 			break;
    06121 E010      LDI	R17,0
(4204) 		case 4:		// 
(4205) 			SetMotRunPam(MOT_SAMP_NEEDLE, 100, 20, CURRENT_SAMP_NEEDLE);
    06122 D166      RCALL	__EffluentMotRun
    06123 E081      LDI	R24,1
    06124 9380 1656 STS	CardScanfSW,R24
    06126 E08F      LDI	R24,0xF
    06127 9380 161E STS	EvenPosChangeProcess+20,R24
    06129 C0BF      RJMP	0x61E9
(4206) 			MotInitCheck(MOT_SAMP_NEEDLE);
    0612A 2722      CLR	R18
    0612B 2733      CLR	R19
    0612C E002      LDI	R16,2
(4207) 			SetEValve(EV3, EV_OPEN);
    0612D 940E 6A5B CALL	_MotRunTo
    0612F E081      LDI	R24,1
    06130 9380 165B STS	dustbinOldState+4,R24
(4208) 			_EffluentMotRun(40, 160);	// 清洗头吸空
    06132 E180      LDI	R24,0x10
    06133 9380 161E STS	EvenPosChangeProcess+20,R24
(4209) 			waitMotSampNeedle = 1;
    06135 C0B3      RJMP	0x61E9
    06136 ED24      LDI	R18,0xD4
    06137 E033      LDI	R19,3
(4210) 			waitEffluent = 1;
    06138 E002      LDI	R16,2
    06139 940E 6A5B CALL	_MotRunTo
(4211) 			mainStep = 5;
    0613B E081      LDI	R24,1
    0613C 9380 165B STS	dustbinOldState+4,R24
(4212) 			break;
    0613E E628      LDI	R18,0x68
    0613F E031      LDI	R19,1
    06140 E00C      LDI	R16,0xC
    06141 940E 6A2C CALL	_MotRun
(4213) 		case 5:	// 	取样针运行到混匀池上方
(4214) 			SetEValve(EV3, EV_CLOSE);
(4215) 			MotRunTo(MOT_SAMP_NEEDLE, _POS_MIX_TOP + 100);	// 200
    06143 E081      LDI	R24,1
    06144 9380 1659 STS	dustbinOldState+2,R24
    06146 E087      LDI	R24,7
(4216) 			waitMotSampNeedle = 1;
    06147 9380 161E STS	EvenPosChangeProcess+20,R24
    06149 C09F      RJMP	0x61E9
(4217) 			detRetry = 0;
    0614A 940E 3739 CALL	_SetBeepAck
    0614C 2722      CLR	R18
(4218) 			mainStep = 6;
    0614D 2700      CLR	R16
    0614E 940E 6B81 CALL	_SetEValve
(4219) 			break;
    06150 2422      CLR	R2
(4220) 		case 6:	// 取样针管道吸入空气,将液路与取样针隔离
(4221) 			SetEValve(EV1, EV_CLOSE);
    06151 9220 161E STS	EvenPosChangeProcess+20,R2
    06153 9220 161D STS	EvenPosChangeProcess+19,R2
(4222) 			SetEValve(EV2, EV_OPEN);
    06155 9180 00C1 LDS	R24,0xC1
    06157 7E8F      ANDI	R24,0xEF
    06158 9380 00C1 STS	0xC1,R24
(4223) 			_FluidMotRun(-1, 20);
    0615A E026      LDI	R18,6
    0615B E03B      LDI	R19,0xB
    0615C E80F      LDI	R16,0x8F
(4224) 			waitMotFluid = 1;
    0615D E016      LDI	R17,6
    0615E 940E A90D CALL	_uart_Printf
(4225) 			detRetry ++;
    06160 9180 00C1 LDS	R24,0xC1
    06162 6180      ORI	R24,0x10
    06163 9380 00C1 STS	0xC1,R24
(4226) 			mainStep = 7;
    06165 E001      LDI	R16,1
    06166 C083      RJMP	0x61EA
    06167 9140 161E LDS	R20,EvenPosChangeProcess+20
(4227) 			break;
    06169 2755      CLR	R21
    0616A 3040      CPI	R20,0
    0616B 0745      CPC	R20,R21
    0616C F0A1      BEQ	0x6181
    0616D 3041      CPI	R20,1
(4228) 		case 7:
(4229) 			SetDelayTime(MOT_FLUID, 30);
(4230) 			SetEValve(EV2, EV_CLOSE);
    0616E E0E0      LDI	R30,0
    0616F 075E      CPC	R21,R30
    06170 F149      BEQ	0x619A
    06171 3042      CPI	R20,2
(4231) 			mainStep = 8;
    06172 E0E0      LDI	R30,0
    06173 075E      CPC	R21,R30
    06174 F409      BNE	0x6176
(4232) 			break;
    06175 C038      RJMP	0x61AE
(4233) 		case 8:		// 初始化液面探测
(4234) 			liqDetBaseAdc = getLiqDetADC(NeedleChannel);
    06176 3043      CPI	R20,3
    06177 E0E0      LDI	R30,0
    06178 075E      CPC	R21,R30
    06179 F409      BNE	0x617B
    0617A C04A      RJMP	0x61C5
    0617B 3044      CPI	R20,4
    0617C E0E0      LDI	R30,0
(4235) 			if(liqDetBaseAdc > 1015)
    0617D 075E      CPC	R21,R30
    0617E F409      BNE	0x6180
    0617F C059      RJMP	0x61D9
    06180 C068      RJMP	0x61E9
    06181 E083      LDI	R24,3
(4236) 			{
(4237) 				SetBeepWarning();
    06182 838A      STD	Y+2,R24
    06183 E184      LDI	R24,0x14
(4238) 				Uart0ReUnable;
    06184 8388      ST	Y,R24
    06185 ED2C      LDI	R18,0xDC
    06186 E003      LDI	R16,3
    06187 940E 6A9F CALL	_SetMotRunPam
(4239) 				uart_Printf("!2901 $%d\r\n", liqDetBaseAdc);		// 液体探测电极未连接, 请检查液体探测电极连接是否完好
    06189 E003      LDI	R16,3
    0618A 940E 6AFA CALL	_MotInitCheck
    0618C 2722      CLR	R18
    0618D 2700      CLR	R16
    0618E 940E 6B81 CALL	_SetEValve
    06190 EC28      LDI	R18,0xC8
(4240) 				Uart0ReEnable;
    06191 E10E      LDI	R16,0x1E
    06192 E010      LDI	R17,0
    06193 D0F5      RCALL	__EffluentMotRun
    06194 E081      LDI	R24,1
    06195 9380 165A STS	dustbinOldState+3,R24
(4241) 				mainStep = 0;
    06197 9380 161E STS	EvenPosChangeProcess+20,R24
(4242) 				return 0xff;
    06199 C04F      RJMP	0x61E9
    0619A E002      LDI	R16,2
(4243) 			}
(4244) 			//else if(liqDetBaseAdc < 400)
(4245) 			else if(liqDetBaseAdc < 200)
    0619B 940E 6AFA CALL	_MotInitCheck
    0619D E081      LDI	R24,1
    0619E 9380 165B STS	dustbinOldState+4,R24
    061A0 9380 1656 STS	CardScanfSW,R24
    061A2 9180 17D7 LDS	R24,WorkProcessStep
(4246) 			{
(4247) 				if(detRetry < 3)
    061A4 3083      CPI	R24,3
    061A5 F421      BNE	0x61AA
    061A6 E083      LDI	R24,3
(4248) 				{
(4249) 					SetEValve(EV1, EV_OPEN);
    061A7 9380 161E STS	EvenPosChangeProcess+20,R24
    061A9 C03F      RJMP	0x61E9
    061AA E082      LDI	R24,2
(4250) 					_FluidMotRun(-1, 20);
    061AB 9380 161E STS	EvenPosChangeProcess+20,R24
    061AD C03B      RJMP	0x61E9
    061AE 2422      CLR	R2
(4251) 					waitMotFluid = 1;
    061AF 9220 161E STS	EvenPosChangeProcess+20,R2
    061B1 9220 161D STS	EvenPosChangeProcess+19,R2
(4252) 					mainStep = 6;
    061B3 9220 161F STS	EvenPosChangeProcess+21,R2
(4253) 					break;
    061B5 9180 00C1 LDS	R24,0xC1
(4254) 				}
(4255) 				else
(4256) 				{
(4257) 					SetBeepWarning();
    061B7 7E8F      ANDI	R24,0xEF
(4258) 					MotInitCheck(MOT_SAMP_NEEDLE);
    061B8 9380 00C1 STS	0xC1,R24
    061BA E703      LDI	R16,0x73
(4259) 					Uart0ReUnable;
    061BB E015      LDI	R17,5
    061BC 940E A90D CALL	_uart_Printf
    061BE 9180 00C1 LDS	R24,0xC1
(4260) 					uart_Printf("!2911\r\n");		// 在进行稀释液灌注时，液面探测自检出现异常	
    061C0 6180      ORI	R24,0x10
    061C1 9380 00C1 STS	0xC1,R24
    061C3 E001      LDI	R16,1
(4261) 					Uart0ReEnable;
    061C4 C025      RJMP	0x61EA
    061C5 ED24      LDI	R18,0xD4
    061C6 E033      LDI	R19,3
    061C7 E002      LDI	R16,2
    061C8 940E 6A5B CALL	_MotRunTo
(4262) 					mainStep = 0;
    061CA E081      LDI	R24,1
    061CB 9380 165B STS	dustbinOldState+4,R24
(4263) 					return 0xff;	
    061CD E628      LDI	R18,0x68
(4264) 				}
(4265) 			}
(4266) 			else
(4267) 			{
(4268) 				liqDetBaseAdc = getLiqDetADC(NeedleChannel);
    061CE E031      LDI	R19,1
    061CF E00C      LDI	R16,0xC
    061D0 940E 6A2C CALL	_MotRun
    061D2 E081      LDI	R24,1
    061D3 9380 1659 STS	dustbinOldState+2,R24
    061D5 E084      LDI	R24,4
(4269) 				mainStep = 9;
    061D6 9380 161E STS	EvenPosChangeProcess+20,R24
    061D8 C010      RJMP	0x61E9
(4270) 			}
(4271) 			break;
    061D9 EB24      LDI	R18,0xB4
(4272) 		case 9:		// 启动稀释液泵和废液泵
(4273) 			SetEValve(EV_ALL, EV_CLOSE);
    061DA EA08      LDI	R16,0xA8
    061DB E017      LDI	R17,7
    061DC D11E      RCALL	__NeedleMotRunTo
    061DD E081      LDI	R24,1
(4274) #if		(DILUTE_TUBE == 14)
(4275) 			_DiluentMotRun(300, 160);		// 最大灌注9mL液体，超出表示灌注失败，提示用户检查供液
(4276) 			_EffluentMotRun(160, 80);
(4277) #elif	(DILUTE_TUBE == 16)
(4278) 			_DiluentMotRun(100, 120);		// 最大灌注9mL液体，超出表示灌注失败，提示用户检查供液
    061DE 9380 165A STS	dustbinOldState+3,R24
    061E0 E082      LDI	R24,2
    061E1 9380 161E STS	EvenPosChangeProcess+20,R24
(4279) 			_EffluentMotRun(160, 140);
    061E3 C005      RJMP	0x61E9
    061E4 2422      CLR	R2
    061E5 9220 161D STS	EvenPosChangeProcess+19,R2
(4280) #endif
(4281) 			SetDelayTime(15, 50);		// 设置灌注延时量，跳过内部存在的量，防止外部管道液体未进入时就判断灌注结果
    061E7 9220 161E STS	EvenPosChangeProcess+20,R2
    061E9 2700      CLR	R16
    061EA 9623      ADIW	R28,3
(4282) 			detRetry = 0;
    061EB 940C AEBC JMP	pop_xgsetF03C
_DiluteProcDatInit:
    061ED 934A      ST	-Y,R20
(4283) 			mainStep = 10;
    061EE 935A      ST	-Y,R21
    061EF 9724      SBIW	R28,4
    061F0 E641      LDI	R20,0x61
(4284) 			break;
    061F1 E156      LDI	R21,0x16
(4285) 		case 10:		// 等待液路事件
(4286) 			SetDelayTime(MOT_EFFLUENT, 3);
    061F2 2422      CLR	R2
    061F3 2433      CLR	R3
    061F4 823B      STD	Y+3,R3
    061F5 822A      STD	Y+2,R2
    061F6 C009      RJMP	0x6200
(4287) 			ReadLiquidMonitorResult(0);
    061F7 2422      CLR	R2
    061F8 01FA      MOVW	R30,R20
    061F9 9221      ST	Z+,R2
(4288) 			i = getLiqDetADC(NeedleChannel);
    061FA 01AF      MOVW	R20,R30
    061FB 818A      LDD	R24,Y+2
    061FC 819B      LDD	R25,Y+3
    061FD 9601      ADIW	R24,1
    061FE 839B      STD	Y+3,R25
    061FF 838A      STD	Y+2,R24
    06200 818A      LDD	R24,Y+2
    06201 819B      LDD	R25,Y+3
(4289) 			if(i<liqDetBaseAdc)
    06202 308D      CPI	R24,0xD
    06203 E0E0      LDI	R30,0
    06204 079E      CPC	R25,R30
    06205 F388      BCS	0x61F7
    06206 EF8F      LDI	R24,0xFF
    06207 9380 1660 STS	CurInsertRingNum,R24
    06209 2422      CLR	R2
(4290) 			{
(4291) 				i = liqDetBaseAdc - i;
    0620A 9220 165F STS	GetNewTestCard,R2
    0620C E080      LDI	R24,0
    0620D 9380 0527 STS	SecondCount,R24
    0620F 9380 0528 STS	SecondCount+1,R24
(4292) 				//if(i>300)	
(4293) 				if(i > 150)
    06211 9380 0529 STS	SecondCount+2,R24
    06213 9380 052A STS	SecondCount+3,R24
    06215 E081      LDI	R24,1
(4294) 				{
(4295) 					if(detRetry < 10)	// 重测计数
    06216 9380 1640 STS	_NewCardStoreNum,R24
    06218 E089      LDI	R24,0x9
    06219 9380 163F STS	_NewMultipNum,R24
(4296) 					{
(4297) 						detRetry ++;	
    0621B E38C      LDI	R24,0x3C
    0621C E090      LDI	R25,0
(4298) 						break;	
    0621D 9390 163E STS	EvenPosChangeProcess+52,R25
(4299) 						}
(4300) 					// 探测到排液异常
(4301) 					MotStop(MOT_DILUENT);
    0621F 9380 163D STS	EvenPosChangeProcess+51,R24
(4302) 					MotStop(MOT_EFFLUENT);
    06221 2433      CLR	R3
    06222 9230 163C STS	EvenPosChangeProcess+50,R3
(4303) 					MotInitCheck(MOT_SAMP_NEEDLE);
    06224 9220 163B STS	EvenPosChangeProcess+49,R2
    06226 9220 163A STS	EvenPosChangeProcess+48,R2
(4304) 					SetBeepWarning();
    06228 9230 1655 STS	GetNewPieceProcessState,R3
(4305) 					SetDelayTime(MOT_SAMP_NEEDLE, 5);
    0622A 9220 1654 STS	_DropVolume|diluteProcessState,R2
    0622C 940E 6F72 CALL	_Read_DiluentCalChart
(4306) 					uart_Printf("!2912\r\n");	// 稀释液灌注过程中检测到混匀池中液体水位超高，请检查废液泵排液状态
    0622E E082      LDI	R24,2
    0622F E090      LDI	R25,0
    06230 8399      STD	Y+1,R25
    06231 8388      ST	Y,R24
(4307) 					// 退出处理
(4308) 					mainStep = 21;
    06232 019E      MOVW	R18,R28
    06233 5F2E      SUBI	R18,0xFE
    06234 4F3F      SBCI	R19,0xFF
(4309) 					}
    06235 E500      LDI	R16,0x50
(4310) 				else
(4311) 					detRetry = 0;
    06236 E010      LDI	R17,0
    06237 940E AF2A CALL	_EEPROMReadBytes_extIO
(4312) 				}
(4313) 				
(4314) 			if(GetMotState(MOT_DILUENT)!=STA_SLAVE_FREE && GetMotState(MOT_EFFLUENT) != STA_SLAVE_FREE)
    06239 818A      LDD	R24,Y+2
    0623A 819B      LDD	R25,Y+3
    0623B 7080      ANDI	R24,0
    0623C 7C90      ANDI	R25,0xC0
    0623D 3080      CPI	R24,0
    0623E ECE0      LDI	R30,0xC0
    0623F 079E      CPC	R25,R30
    06240 F021      BEQ	0x6245
    06241 E088      LDI	R24,0x8
    06242 E097      LDI	R25,7
    06243 839B      STD	Y+3,R25
    06244 838A      STD	Y+2,R24
    06245 802A      LDD	R2,Y+2
(4315) 			{
(4316) 				if(WaitDelayTime(15)!=0)
    06246 803B      LDD	R3,Y+3
    06247 9230 164C STS	_SleepTime+1,R3
    06249 9220 164B STS	_SleepTime,R2
    0624B E082      LDI	R24,2
(4317) 				{
(4318) 					ucTmp = GetLiquidMonitorState(0);	// 读取0号液路
    0624C E090      LDI	R25,0
    0624D 8399      STD	Y+1,R25
    0624E 8388      ST	Y,R24
    0624F 019E      MOVW	R18,R28
    06250 5F2E      SUBI	R18,0xFE
    06251 473F      SBCI	R19,0x7F
(4319) 					if(ucTmp==INFO_LIQ_EMPTY || ucTmp==INFO_LIQ_BUBBLE)
    06252 E500      LDI	R16,0x50
    06253 E010      LDI	R17,0
    06254 940E AF45 CALL	_EEPROMWriteBytes_extIO
    06256 940E 53DC CALL	_ReadCurTestSetial
(4320) 					{
(4321) 						SetDelayTime(15, 50);	// 液路有空气，重新开始计时
    06258 9310 1663 STS	CardStorePhoNum,R17
    0625A 9300 1662 STS	NewTestInfo|liqDetBaseAdc+1,R16
    0625C 9330 1665 STS	timeOut,R19
(4322) 					}
(4323) 				}
    0625E 9320 1664 STS	LiquidPhoNum,R18
    06260 9624      ADIW	R28,4
(4324) 				else
(4325) 				{
(4326) 					// 灌注完成
(4327) 					MotStop(MOT_DILUENT);
(4328) 					MotStop(MOT_EFFLUENT);
    06261 9159      LD	R21,Y+
    06262 9149      LD	R20,Y+
    06263 9508      RET
(4329) 					MotInitCheck(MOT_SAMP_NEEDLE);
__FluidMotRun:
    06264 940E AE7E CALL	push_xgset003C
    06266 2EC2      MOV	R12,R18
(4330) 					SetBeepAck();
    06267 0158      MOVW	R10,R16
    06268 9723      SBIW	R28,3
(4331) 					Uart0ReUnable;
    06269 E880      LDI	R24,0x80
    0626A 158C      CP	R24,R12
    0626B F448      BCC	0x6275
    0626C E084      LDI	R24,4
    0626D 838A      STD	Y+2,R24
(4332) 					uart_Printf("%s\r\n",strM2102);
    0626E E08A      LDI	R24,0xA
    0626F 8388      ST	Y,R24
    06270 2D2C      MOV	R18,R12
    06271 E00A      LDI	R16,0xA
    06272 940E 6A9F CALL	_SetMotRunPam
(4333) 					Uart0ReEnable;
    06274 C008      RJMP	0x627D
    06275 E084      LDI	R24,4
    06276 838A      STD	Y+2,R24
    06277 E08A      LDI	R24,0xA
    06278 8388      ST	Y,R24
(4334) 					mainStep = 20;
    06279 2D2C      MOV	R18,R12
    0627A E00A      LDI	R16,0xA
    0627B 940E 6A9F CALL	_SetMotRunPam
(4335) 				}
(4336) 			}
    0627D E604      LDI	R16,0x64
    0627E E010      LDI	R17,0
    0627F 0195      MOVW	R18,R10
    06280 940E AE14 CALL	empy16s
(4337) 			else
(4338) 			{
(4339) 				if(runNum!=0)		// 因为稀释液泵流量小，需要最多灌注3遍
(4340) 				{
(4341) 					MotStop(MOT_DILUENT);
    06282 0198      MOVW	R18,R16
    06283 E00A      LDI	R16,0xA
(4342) 					MotStop(MOT_EFFLUENT);
    06284 940E 6A2C CALL	_MotRun
    06286 9623      ADIW	R28,3
(4343) 				//	_EffluentMotRun(5, 220);
(4344) 					SetDelayTime(MOT_DILUENT, 20);
    06287 940C AE58 JMP	pop_xgset003C
__EffluentMotRun:
    06289 940E AE7E CALL	push_xgset003C
    0628B 2EC2      MOV	R12,R18
(4345) 					mainStep = 9;
    0628C 0158      MOVW	R10,R16
    0628D 9723      SBIW	R28,3
    0628E E084      LDI	R24,4
(4346) 					runNum --;
    0628F 838A      STD	Y+2,R24
    06290 E08A      LDI	R24,0xA
    06291 8388      ST	Y,R24
    06292 2D2C      MOV	R18,R12
    06293 E00B      LDI	R16,0xB
(4347) 					break;
    06294 940E 6A9F CALL	_SetMotRunPam
(4348) 				}
(4349) 				// 供液已经停止，灌注失败
(4350) 				MotStop(MOT_DILUENT);
    06296 E604      LDI	R16,0x64
    06297 E010      LDI	R17,0
(4351) 				MotStop(MOT_EFFLUENT);
    06298 0195      MOVW	R18,R10
    06299 940E AE14 CALL	empy16s
(4352) 				MotInitCheck(MOT_SAMP_NEEDLE);
    0629B 0198      MOVW	R18,R16
    0629C E00B      LDI	R16,0xB
    0629D 940E 6A2C CALL	_MotRun
(4353) 				SetBeepWarning();
    0629F 9623      ADIW	R28,3
(4354) 				Uart0ReUnable;
    062A0 940C AE58 JMP	pop_xgset003C
__DiluentMotRun:
    062A2 940E AE7E CALL	push_xgset003C
    062A4 2EC2      MOV	R12,R18
(4355) 				uart_Printf("%s\r\n",strE3904);// 稀释液灌注失败， 请检查稀释液供给，如果供给正常则请重新调试稀释液传感器后重试灌注
    062A5 0158      MOVW	R10,R16
    062A6 9723      SBIW	R28,3
    062A7 E880      LDI	R24,0x80
    062A8 158C      CP	R24,R12
    062A9 F448      BCC	0x62B3
    062AA E084      LDI	R24,4
(4356) 				Uart0ReEnable;
    062AB 838A      STD	Y+2,R24
    062AC E08A      LDI	R24,0xA
    062AD 8388      ST	Y,R24
    062AE 2D2C      MOV	R18,R12
    062AF E009      LDI	R16,0x9
(4357) 				mainStep = 21;
    062B0 940E 6A9F CALL	_SetMotRunPam
    062B2 C008      RJMP	0x62BB
(4358) 			}
(4359) 			break;
    062B3 E084      LDI	R24,4
(4360) 		case 20:		// 完成退出
(4361) 			//SetEValve(EV_ALL, EV_CLOSE);
(4362) 			_EffluentMotRun(20, 220);
    062B4 838A      STD	Y+2,R24
    062B5 E08A      LDI	R24,0xA
    062B6 8388      ST	Y,R24
    062B7 2D2C      MOV	R18,R12
(4363) 			waitEffluent = 1;
    062B8 E009      LDI	R16,0x9
    062B9 940E 6A9F CALL	_SetMotRunPam
(4364) 			waitMotSampNeedle = 1;
    062BB E604      LDI	R16,0x64
    062BC E010      LDI	R17,0
(4365) 			mainStep = 0;
    062BD 0195      MOVW	R18,R10
    062BE 940E AE14 CALL	empy16s
(4366) 			return 1;
    062C0 0198      MOVW	R18,R16
    062C1 E009      LDI	R16,0x9
(4367) 			break;
(4368) 		case 21:		// 失败退出
(4369) 			_EffluentMotRun(20, 220);
    062C2 940E 6A2C CALL	_MotRun
    062C4 9623      ADIW	R28,3
    062C5 940C AE58 JMP	pop_xgset003C
(4370) 			waitEffluent = 1;
__NewDiluentMotRun:
    062C7 940E AE7E CALL	push_xgset003C
(4371) 			waitMotSampNeedle = 1;
    062C9 2EC2      MOV	R12,R18
    062CA 0158      MOVW	R10,R16
(4372) 			mainStep = 0;
    062CB 9723      SBIW	R28,3
    062CC E084      LDI	R24,4
    062CD 838A      STD	Y+2,R24
(4373) 			return 0xff;
    062CE E08A      LDI	R24,0xA
    062CF 8388      ST	Y,R24
(4374) 			break;
(4375) 		default:
(4376) 			mainStep = 0;
    062D0 2D2C      MOV	R18,R12
    062D1 E009      LDI	R16,0x9
    062D2 940E 6A9F CALL	_SetMotRunPam
(4377) 			break;
(4378) 		}
(4379) 	return 0;
    062D4 0195      MOVW	R18,R10
    062D5 E009      LDI	R16,0x9
    062D6 940E 6A2C CALL	_MotRun
    062D8 9623      ADIW	R28,3
    062D9 940C AE58 JMP	pop_xgset003C
(4380) }
(4381) 
(4382) unsigned char _PrimingFluid(void)
(4383) {
(4384) 	static unsigned char mainStep = 0;
(4385) 	static unsigned int i;
(4386) 	static unsigned char ucTmp;
(4387) 	static unsigned char detRetry;
(4388) //	static unsigned char waitMotSampTurn,waitMotSampNeedle,waitMotFluid,waitEffluent;
(4389) 
(4390) //	if(WaitDelayTime(MOT_FLUID))			return 0;
(4391) 		
(4392) 	if(waitMotSampTurn)		{	if(GetMotState(MOT_SAMP_TRUN)!=STA_SLAVE_FREE)		return 0;	waitMotSampTurn = 0;	}
__NeedleMotRun:
    062DB 940E AE7E CALL	push_xgset003C
    062DD 2EC2      MOV	R12,R18
    062DE 0158      MOVW	R10,R16
    062DF 9723      SBIW	R28,3
    062E0 E880      LDI	R24,0x80
    062E1 158C      CP	R24,R12
    062E2 F448      BCC	0x62EC
    062E3 E083      LDI	R24,3
    062E4 838A      STD	Y+2,R24
    062E5 E085      LDI	R24,5
    062E6 8388      ST	Y,R24
    062E7 2D2C      MOV	R18,R12
(4393) 	if(waitMotSampNeedle)	{	if(GetMotState(MOT_SAMP_NEEDLE)!=STA_SLAVE_FREE)	return 0;	waitMotSampNeedle = 0;	}
    062E8 E003      LDI	R16,3
    062E9 940E 6A9F CALL	_SetMotRunPam
    062EB C008      RJMP	0x62F4
    062EC E083      LDI	R24,3
    062ED 838A      STD	Y+2,R24
    062EE E085      LDI	R24,5
    062EF 8388      ST	Y,R24
    062F0 2D2C      MOV	R18,R12
    062F1 E003      LDI	R16,3
    062F2 940E 6A9F CALL	_SetMotRunPam
    062F4 0195      MOVW	R18,R10
    062F5 E003      LDI	R16,3
(4394) 	if(waitMotFluid)		{	if(GetMotState(MOT_FLUID)!=STA_SLAVE_FREE)			return 0;	waitMotFluid = 0;	}
    062F6 940E 6A2C CALL	_MotRun
    062F8 9623      ADIW	R28,3
    062F9 940C AE58 JMP	pop_xgset003C
__NeedleMotRunTo:
    062FB 940E AE7E CALL	push_xgset003C
    062FD 2EC2      MOV	R12,R18
    062FE 0158      MOVW	R10,R16
    062FF 9723      SBIW	R28,3
    06300 E880      LDI	R24,0x80
    06301 158C      CP	R24,R12
    06302 F448      BCC	0x630C
    06303 E083      LDI	R24,3
    06304 838A      STD	Y+2,R24
(4395) 	if(waitEffluent)		{	if(GetMotState(MOT_EFFLUENT)!=STA_SLAVE_FREE)		return 0;	waitEffluent = 0;	}
    06305 E085      LDI	R24,5
    06306 8388      ST	Y,R24
    06307 2D2C      MOV	R18,R12
    06308 E003      LDI	R16,3
    06309 940E 6A9F CALL	_SetMotRunPam
    0630B C008      RJMP	0x6314
    0630C E083      LDI	R24,3
    0630D 838A      STD	Y+2,R24
    0630E E085      LDI	R24,5
    0630F 8388      ST	Y,R24
    06310 2D2C      MOV	R18,R12
    06311 E003      LDI	R16,3
    06312 940E 6A9F CALL	_SetMotRunPam
(4396) 		
(4397) 	switch(mainStep)
    06314 0195      MOVW	R18,R10
    06315 E003      LDI	R16,3
    06316 940E 6A5B CALL	_MotRunTo
    06318 9623      ADIW	R28,3
    06319 940C AE58 JMP	pop_xgset003C
__SampPumpMotRun:
    0631B 940E AE7E CALL	push_xgset003C
    0631D 2EC2      MOV	R12,R18
    0631E 0158      MOVW	R10,R16
    0631F 9723      SBIW	R28,3
    06320 E880      LDI	R24,0x80
    06321 158C      CP	R24,R12
    06322 F448      BCC	0x632C
    06323 E086      LDI	R24,6
    06324 838A      STD	Y+2,R24
    06325 E085      LDI	R24,5
    06326 8388      ST	Y,R24
    06327 2D2C      MOV	R18,R12
    06328 E00C      LDI	R16,0xC
    06329 940E 6A9F CALL	_SetMotRunPam
    0632B C008      RJMP	0x6334
    0632C E086      LDI	R24,6
    0632D 838A      STD	Y+2,R24
    0632E E085      LDI	R24,5
    0632F 8388      ST	Y,R24
    06330 2D2C      MOV	R18,R12
    06331 E00C      LDI	R16,0xC
    06332 940E 6A9F CALL	_SetMotRunPam
    06334 0195      MOVW	R18,R10
    06335 E00C      LDI	R16,0xC
    06336 940E 6A2C CALL	_MotRun
    06338 9623      ADIW	R28,3
    06339 940C AE58 JMP	pop_xgset003C
__SampPumpMotRunTo:
    0633B 940E AE7E CALL	push_xgset003C
    0633D 2EC2      MOV	R12,R18
    0633E 0158      MOVW	R10,R16
    0633F 9723      SBIW	R28,3
    06340 E880      LDI	R24,0x80
    06341 158C      CP	R24,R12
    06342 F448      BCC	0x634C
    06343 E086      LDI	R24,6
    06344 838A      STD	Y+2,R24
    06345 E085      LDI	R24,5
    06346 8388      ST	Y,R24
    06347 2D2C      MOV	R18,R12
    06348 E00C      LDI	R16,0xC
(4398) 	{
(4399) 		case 0:		// 取样针高度回零
(4400) 			SetMotRunPam(MOT_SAMP_NEEDLE, 240, 20, CURRENT_SAMP_NEEDLE);
    06349 940E 6A9F CALL	_SetMotRunPam
    0634B C008      RJMP	0x6354
    0634C E086      LDI	R24,6
    0634D 838A      STD	Y+2,R24
    0634E E085      LDI	R24,5
    0634F 8388      ST	Y,R24
    06350 2D2C      MOV	R18,R12
(4401) 			MotInitCheck(MOT_SAMP_NEEDLE);
    06351 E00C      LDI	R16,0xC
    06352 940E 6A9F CALL	_SetMotRunPam
(4402) 			// 读取取样臂位置
(4403) 			NeedleOnMixCenterPos = GetNeedleOnMixCenterPos();
    06354 0195      MOVW	R18,R10
    06355 E00C      LDI	R16,0xC
    06356 940E 6A5B CALL	_MotRunTo
    06358 9623      ADIW	R28,3
    06359 940C AE58 JMP	pop_xgset003C
(4404) 			waitMotSampNeedle = 1;
_SetAutoTestCycle:
    0635B 9310 052F STS	_AutoTestCycleNum+1,R17
    0635D 9300 052E STS	_AutoTestCycleNum,R16
(4405) 			SetEValve(EV_ALL, EV_CLOSE);
    0635F 9508      RET
_SetDiluentQuit:
    06360 E081      LDI	R24,1
    06361 9380 052B STS	SecondCount+4,R24
(4406) 			mainStep = 1;
    06363 2700      CLR	R16
    06364 9508      RET
(4407) 		//	mainStep = 8;	// 关闭液面探测
(4408) 			runNum = 5;
__CheckFluidSupply:
    06365 E001      LDI	R16,1
    06366 940E 2DBB CALL	_GetLiquidMonitorState
(4409) 			break;
    06368 300E      CPI	R16,0xE
(4410) 		case 1:		// 取样针旋转
(4411) 			SetMotRunPam(MOT_SAMP_TRUN,240,10,CURRENT_SAMP_TRUN);
    06369 F4C1      BNE	0x6382
    0636A 940E 372D CALL	_SetBeepWarning
    0636C 9020 0530 LDS	R2,_AutoTestCycleNum+2
    0636E 2022      TST	R2
    0636F F481      BNE	0x6380
    06370 9180 00C1 LDS	R24,0xC1
(4412) 			MotRunTo(MOT_SAMP_TRUN, NeedleOnMixCenterPos);
    06372 7E8F      ANDI	R24,0xEF
    06373 9380 00C1 STS	0xC1,R24
    06375 E52D      LDI	R18,0x5D
    06376 E03C      LDI	R19,0xC
    06377 E80F      LDI	R16,0x8F
(4413) 			waitMotSampTurn = 1;
    06378 E016      LDI	R17,6
    06379 940E A90D CALL	_uart_Printf
(4414) 			mainStep = 4;
    0637B 9180 00C1 LDS	R24,0xC1
    0637D 6180      ORI	R24,0x10
(4415) 			break;
    0637E 9380 00C1 STS	0xC1,R24
(4416) 		case 4:		// 取样针运行到稀释液口上方位置
(4417) 			ReadLiquidMonitorResult(1);
    06380 E001      LDI	R16,1
    06381 C001      RJMP	0x6383
(4418) 			ReadLiquidMonitorResult(2);
    06382 2700      CLR	R16
    06383 9508      RET
__CheckDiluentSupply:
    06384 2700      CLR	R16
(4419) 			_NeedleMotRunTo(_POS_MIX_TOP + 100, 240);
    06385 940E 2DBB CALL	_GetLiquidMonitorState
    06387 300E      CPI	R16,0xE
    06388 F4A1      BNE	0x639D
(4420) 			waitMotSampNeedle = 1;
    06389 940E 372D CALL	_SetBeepWarning
    0638B 9180 00C1 LDS	R24,0xC1
(4421) 			mainStep = 5;
    0638D 7E8F      ANDI	R24,0xEF
    0638E 9380 00C1 STS	0xC1,R24
(4422) 			detRetry = 0;
    06390 E424      LDI	R18,0x44
    06391 E03C      LDI	R19,0xC
(4423) 			break;
    06392 E80F      LDI	R16,0x8F
(4424) 		case 5:	// 取样针空吸,将液路与针隔离
(4425) 			SetEValve(EV_ALL, EV_CLOSE);
    06393 E016      LDI	R17,6
    06394 940E A90D CALL	_uart_Printf
    06396 9180 00C1 LDS	R24,0xC1
(4426) 			SetEValve(EV2, EV_OPEN);
    06398 6180      ORI	R24,0x10
    06399 9380 00C1 STS	0xC1,R24
(4427) 			_FluidMotRun(-1, 20);
    0639B E001      LDI	R16,1
    0639C C001      RJMP	0x639E
    0639D 2700      CLR	R16
    0639E 9508      RET
(4428) 			waitMotFluid = 1;
__PrimingDiluent:
    0639F 940E AE83 CALL	push_xgset300C
    063A1 9723      SBIW	R28,3
(4429) 			detRetry ++;
    063A2 9140 053A LDS	R20,stopTestFlag+6
    063A4 2755      CLR	R21
    063A5 3040      CPI	R20,0
    063A6 0745      CPC	R20,R21
(4430) 			mainStep = 6;
    063A7 F409      BNE	0x63A9
    063A8 C033      RJMP	0x63DC
    063A9 3041      CPI	R20,1
(4431) 			break;
    063AA E0E0      LDI	R30,0
(4432) 		case 6:
(4433) 			SetDelayTime(MOT_FLUID, 30);
    063AB 075E      CPC	R21,R30
    063AC F409      BNE	0x63AE
    063AD C059      RJMP	0x6407
    063AE 3044      CPI	R20,4
    063AF E0E0      LDI	R30,0
(4434) 			SetEValve(EV2, EV_CLOSE);
    063B0 075E      CPC	R21,R30
    063B1 F409      BNE	0x63B3
    063B2 C06A      RJMP	0x641D
    063B3 3045      CPI	R20,5
(4435) 			mainStep = 7;
    063B4 E0E0      LDI	R30,0
    063B5 075E      CPC	R21,R30
    063B6 F409      BNE	0x63B8
(4436) 			break;
    063B7 C081      RJMP	0x6439
(4437) 		case 7:		// 初始化液面探测
(4438) 			liqDetBaseAdc = getLiqDetADC(NeedleChannel);
    063B8 3046      CPI	R20,6
    063B9 E0E0      LDI	R30,0
    063BA 075E      CPC	R21,R30
    063BB F409      BNE	0x63BD
    063BC C08F      RJMP	0x644C
    063BD 3047      CPI	R20,7
    063BE E0E0      LDI	R30,0
    063BF 075E      CPC	R21,R30
(4439) 			if(liqDetBaseAdc > 1015)
    063C0 F409      BNE	0x63C2
    063C1 C0A2      RJMP	0x6464
    063C2 3048      CPI	R20,0x8
    063C3 E0E0      LDI	R30,0
    063C4 075E      CPC	R21,R30
(4440) 			{
(4441) 				SetBeepWarning();
    063C5 F409      BNE	0x63C7
    063C6 C0AA      RJMP	0x6471
(4442) 				MotInitCheck(MOT_SAMP_NEEDLE);
    063C7 3049      CPI	R20,0x9
    063C8 E0E0      LDI	R30,0
    063C9 075E      CPC	R21,R30
(4443) 				Uart0ReUnable;
    063CA F409      BNE	0x63CC
    063CB C109      RJMP	0x64D5
    063CC 304A      CPI	R20,0xA
    063CD E0E0      LDI	R30,0
    063CE 075E      CPC	R21,R30
(4444) 				uart_Printf("!2901 $%d\r\n", liqDetBaseAdc);		// 液体探测电极未连接, 请检查液体探测电极连接是否完好
    063CF F409      BNE	0x63D1
    063D0 C11C      RJMP	0x64ED
    063D1 3144      CPI	R20,0x14
    063D2 E0E0      LDI	R30,0
    063D3 075E      CPC	R21,R30
    063D4 F409      BNE	0x63D6
    063D5 C1D9      RJMP	0x65AF
    063D6 3145      CPI	R20,0x15
(4445) 				Uart0ReEnable;
    063D7 E0E0      LDI	R30,0
    063D8 075E      CPC	R21,R30
    063D9 F409      BNE	0x63DB
    063DA C1E2      RJMP	0x65BD
    063DB C1EF      RJMP	0x65CB
(4446) 				mainStep = 0;
    063DC 2700      CLR	R16
    063DD 940E 6BE3 CALL	_ReadLiquidMonitorResult
(4447) 				return 0xff;
    063DF E001      LDI	R16,1
    063E0 940E 6BE3 CALL	_ReadLiquidMonitorResult
(4448) 			}
(4449) 			//else if(liqDetBaseAdc < 400)
(4450) 			else if(liqDetBaseAdc < 200)
    063E2 E002      LDI	R16,2
    063E3 940E 6BE3 CALL	_ReadLiquidMonitorResult
    063E5 E003      LDI	R16,3
    063E6 940E 6BE3 CALL	_ReadLiquidMonitorResult
    063E8 E084      LDI	R24,4
(4451) 			{
(4452) 				if(detRetry < 4)
    063E9 838A      STD	Y+2,R24
    063EA E184      LDI	R24,0x14
    063EB 8388      ST	Y,R24
    063EC ED2C      LDI	R18,0xDC
(4453) 				{
(4454) 					SetEValve(EV1, EV_OPEN);
    063ED E003      LDI	R16,3
    063EE 940E 6A9F CALL	_SetMotRunPam
    063F0 E003      LDI	R16,3
(4455) 					_FluidMotRun(-2, 20);
    063F1 940E 6AFA CALL	_MotInitCheck
    063F3 E081      LDI	R24,1
    063F4 9380 165A STS	dustbinOldState+3,R24
(4456) 					SetEValve(EV3, EV_OPEN);
    063F6 940E 82CB CALL	_GetNeedleOnMixCenterPos
    063F8 9310 1647 STS	_NewCardStoreNum+7,R17
(4457) 					_EffluentMotRun(40, 160);	// 清洗头吸空
    063FA 9300 1646 STS	_NewCardStoreNum+6,R16
    063FC 2722      CLR	R18
(4458) 					waitMotFluid = 1;
    063FD 2700      CLR	R16
    063FE 940E 6B81 CALL	_SetEValve
(4459) 					waitEffluent = 1;
    06400 E081      LDI	R24,1
    06401 9380 053A STS	stopTestFlag+6,R24
(4460) 					mainStep = 5;
    06403 E085      LDI	R24,5
    06404 9380 165C STS	dustbinOldState+5,R24
(4461) 					break;
    06406 C1C7      RJMP	0x65CE
    06407 E084      LDI	R24,4
(4462) 				}
(4463) 				else
(4464) 				{
(4465) 					SetBeepWarning();
(4466) 					MotInitCheck(MOT_SAMP_NEEDLE);
    06408 838A      STD	Y+2,R24
    06409 E08A      LDI	R24,0xA
    0640A 8388      ST	Y,R24
(4467) 					Uart0ReUnable;
    0640B EF20      LDI	R18,0xF0
    0640C E002      LDI	R16,2
    0640D 940E 6A9F CALL	_SetMotRunPam
    0640F 9120 1646 LDS	R18,_NewCardStoreNum+6
(4468) 					uart_Printf("!2906\r\n");		// 在进行稀释液灌注时，液面探测自检出现异常	
    06411 9130 1647 LDS	R19,_NewCardStoreNum+7
    06413 E002      LDI	R16,2
(4469) 					Uart0ReEnable;
    06414 940E 6A5B CALL	_MotRunTo
    06416 E081      LDI	R24,1
    06417 9380 165B STS	dustbinOldState+4,R24
(4470) 					mainStep = 0;
    06419 E084      LDI	R24,4
    0641A 9380 053A STS	stopTestFlag+6,R24
(4471) 					return 0xff;	
    0641C C1B1      RJMP	0x65CE
    0641D E083      LDI	R24,3
(4472) 				}
(4473) 			}
(4474) 			else
(4475) 			{
(4476) 				liqDetBaseAdc = getLiqDetADC(NeedleChannel);
    0641E 838A      STD	Y+2,R24
    0641F E184      LDI	R24,0x14
    06420 8388      ST	Y,R24
    06421 E624      LDI	R18,0x64
    06422 E003      LDI	R16,3
    06423 940E 6A9F CALL	_SetMotRunPam
    06425 E003      LDI	R16,3
(4477) 				SetEValve(EV_ALL, EV_CLOSE);
    06426 940E 6AFA CALL	_MotInitCheck
    06428 E021      LDI	R18,1
    06429 E003      LDI	R16,3
(4478) 				detRetry = 0;
    0642A 940E 6B81 CALL	_SetEValve
    0642C EA20      LDI	R18,0xA0
(4479) 				mainStep = 8;
    0642D E208      LDI	R16,0x28
    0642E E010      LDI	R17,0
    0642F DE59      RCALL	__EffluentMotRun
(4480) 			}
(4481) 			/*
(4482) 			if(CheckLiqDetBase())
(4483) 			{
(4484) 				MotInitCheck(MOT_SAMP_NEEDLE);
(4485) 				mainStep = 0;
(4486) 				Uart0ReUnable;
(4487) 				uart_Printf("!2906\r\n");		// 在进行稀释液灌注时，液面探测自检出现异常
(4488) 				Uart0ReEnable;
(4489) 				return 0xff;	
(4490) 			}
(4491) 			*/
(4492) 			break;
    06430 E081      LDI	R24,1
(4493) 		case 8:		// 启动清洗液泵和废液泵
(4494) 			_FluidMotRun(100, 60);		// 最大灌注30mL液体，超出表示灌注失败，提示用户检查供液
    06431 9380 165A STS	dustbinOldState+3,R24
    06433 9380 1656 STS	CardScanfSW,R24
(4495) 			_EffluentMotRun(105, 60);
    06435 E085      LDI	R24,5
    06436 9380 053A STS	stopTestFlag+6,R24
    06438 C195      RJMP	0x65CE
(4496) 			SetDelayTime(15, 60);		// 设置灌注延时量，跳过内部存在的量，防止外部管道液体未进入时就判断灌注结果
    06439 2722      CLR	R18
    0643A E003      LDI	R16,3
    0643B 940E 6B81 CALL	_SetEValve
    0643D EC2C      LDI	R18,0xCC
(4497) 			ReadLiquidMonitorResult(1);
    0643E E031      LDI	R19,1
    0643F E003      LDI	R16,3
    06440 940E 6A5B CALL	_MotRunTo
(4498) 			mainStep = 9;
    06442 E081      LDI	R24,1
    06443 9380 165A STS	dustbinOldState+3,R24
(4499) 			break;
    06445 2422      CLR	R2
    06446 9220 162F STS	EvenPosChangeProcess+37,R2
    06448 E086      LDI	R24,6
    06449 9380 053A STS	stopTestFlag+6,R24
(4500) 		case 9:		// 等待液路事件
(4501) 			SetDelayTime(MOT_EFFLUENT, 3);
(4502) 			ReadLiquidMonitorResult(1);
    0644B C182      RJMP	0x65CE
    0644C 2722      CLR	R18
(4503) 			if(GetMotState(MOT_EFFLUENT) != STA_SLAVE_FREE && GetMotState(MOT_FLUID) != STA_SLAVE_FREE) 
    0644D E001      LDI	R16,1
    0644E 940E 6B81 CALL	_SetEValve
    06450 E021      LDI	R18,1
    06451 E002      LDI	R16,2
    06452 940E 6B81 CALL	_SetEValve
    06454 E124      LDI	R18,0x14
    06455 EF0F      LDI	R16,0xFF
    06456 EF1F      LDI	R17,0xFF
    06457 DE0C      RCALL	__FluidMotRun
    06458 E081      LDI	R24,1
    06459 9380 1658 STS	dustbinOldState+1,R24
(4504) 			{
(4505) 				if(WaitDelayTime(15)!=0)
    0645B 9180 162F LDS	R24,EvenPosChangeProcess+37
    0645D 5F8F      SUBI	R24,0xFF
    0645E 9380 162F STS	EvenPosChangeProcess+37,R24
(4506) 				{
(4507) 					ucTmp = GetLiquidMonitorState(1);
    06460 E087      LDI	R24,7
    06461 9380 053A STS	stopTestFlag+6,R24
    06463 C16A      RJMP	0x65CE
    06464 E12E      LDI	R18,0x1E
    06465 E030      LDI	R19,0
(4508) 					if(ucTmp==INFO_LIQ_EMPTY || ucTmp==INFO_LIQ_BUBBLE)
    06466 E00A      LDI	R16,0xA
    06467 940E 97B7 CALL	_SetDelayTime
    06469 2722      CLR	R18
    0646A E002      LDI	R16,2
    0646B 940E 6B81 CALL	_SetEValve
(4509) 					{
(4510) 						SetDelayTime(15, 60);	// 液路有空气，重新开始计时
    0646D E088      LDI	R24,0x8
    0646E 9380 053A STS	stopTestFlag+6,R24
    06470 C15D      RJMP	0x65CE
(4511) 					}
(4512) 				}
    06471 2700      CLR	R16
(4513) 				else
(4514) 				{
(4515) 					// 灌注完成
(4516) 					MotStop(MOT_FLUID);
    06472 940E 9A52 CALL	_getLiqDetADC
    06474 9310 165E STS	dustbinOldState+7,R17
(4517) 					MotStop(MOT_EFFLUENT);
    06476 9300 165D STS	dustbinOldState+6,R16
(4518) 					MotInitCheck(MOT_SAMP_NEEDLE);
    06478 EF87      LDI	R24,0xF7
    06479 E093      LDI	R25,3
    0647A 1780      CP	R24,R16
(4519) 					SetBeepAck();
    0647B 0791      CPC	R25,R17
    0647C F4C8      BCC	0x6496
(4520) 					Uart0ReUnable;
    0647D 940E 372D CALL	_SetBeepWarning
    0647F 9180 00C1 LDS	R24,0xC1
    06481 7E8F      ANDI	R24,0xEF
(4521) 					uart_Printf("%s\r\n",strM2101);
    06482 9380 00C1 STS	0xC1,R24
    06484 9120 165D LDS	R18,dustbinOldState+6
    06486 9130 165E LDS	R19,dustbinOldState+7
(4522) 					Uart0ReEnable;
    06488 E607      LDI	R16,0x67
    06489 E015      LDI	R17,5
    0648A 940E A90D CALL	_uart_Printf
    0648C 9180 00C1 LDS	R24,0xC1
(4523) 					mainStep = 10;
    0648E 6180      ORI	R24,0x10
    0648F 9380 00C1 STS	0xC1,R24
(4524) 				}
(4525) 			}
    06491 2422      CLR	R2
    06492 9220 053A STS	stopTestFlag+6,R2
    06494 EF0F      LDI	R16,0xFF
(4526) 			else
(4527) 			{
(4528) 				if(runNum!=0)		// 因为稀释液泵流量小，需要最多灌注3遍
(4529) 				{
(4530) 					MotStop(MOT_FLUID);
    06495 C139      RJMP	0x65CF
    06496 9180 165D LDS	R24,dustbinOldState+6
(4531) 					MotStop(MOT_EFFLUENT);
    06498 9190 165E LDS	R25,dustbinOldState+7
    0649A 3C88      CPI	R24,0xC8
(4532) 					SetDelayTime(MOT_DILUENT, 20);
    0649B E0E0      LDI	R30,0
    0649C 079E      CPC	R25,R30
    0649D F558      BCC	0x64C9
    0649E 9180 162F LDS	R24,EvenPosChangeProcess+37
(4533) 					mainStep = 8;
    064A0 3083      CPI	R24,3
    064A1 F478      BCC	0x64B1
    064A2 E021      LDI	R18,1
(4534) 					runNum --;
    064A3 E001      LDI	R16,1
    064A4 940E 6B81 CALL	_SetEValve
    064A6 E124      LDI	R18,0x14
    064A7 EF0F      LDI	R16,0xFF
(4535) 					break;
    064A8 EF1F      LDI	R17,0xFF
(4536) 				}
(4537) 				// 供液已经停止，灌注失败
(4538) 				MotStop(MOT_FLUID);
    064A9 DDBA      RCALL	__FluidMotRun
    064AA E081      LDI	R24,1
    064AB 9380 1658 STS	dustbinOldState+1,R24
(4539) 				MotStop(MOT_EFFLUENT);
    064AD E086      LDI	R24,6
    064AE 9380 053A STS	stopTestFlag+6,R24
(4540) 				MotInitCheck(MOT_SAMP_NEEDLE);
    064B0 C11D      RJMP	0x65CE
    064B1 940E 372D CALL	_SetBeepWarning
(4541) 				SetBeepWarning();
    064B3 E003      LDI	R16,3
(4542) 				Uart0ReUnable;
    064B4 940E 6AFA CALL	_MotInitCheck
    064B6 9180 00C1 LDS	R24,0xC1
    064B8 7E8F      ANDI	R24,0xEF
(4543) 				uart_Printf("%s\r\n",strE3902);	// 清洗液灌注失败， 请检查清洗液供给，如果供给正常则请重新调试清洗液传感器后重试灌注
    064B9 9380 00C1 STS	0xC1,R24
    064BB E50F      LDI	R16,0x5F
    064BC E015      LDI	R17,5
    064BD 940E A90D CALL	_uart_Printf
(4544) 				Uart0ReEnable;
    064BF 9180 00C1 LDS	R24,0xC1
    064C1 6180      ORI	R24,0x10
    064C2 9380 00C1 STS	0xC1,R24
(4545) 				mainStep = 11;
    064C4 2422      CLR	R2
    064C5 9220 053A STS	stopTestFlag+6,R2
(4546) 			}
(4547) 			i = getLiqDetADC(NeedleChannel);
    064C7 EF0F      LDI	R16,0xFF
    064C8 C106      RJMP	0x65CF
    064C9 2700      CLR	R16
    064CA 940E 9A52 CALL	_getLiqDetADC
    064CC 0158      MOVW	R10,R16
    064CD 92B0 165E STS	dustbinOldState+7,R11
(4548) 			if(i < liqDetBaseAdc)
    064CF 92A0 165D STS	dustbinOldState+6,R10
    064D1 E089      LDI	R24,0x9
    064D2 9380 053A STS	stopTestFlag+6,R24
    064D4 C0F9      RJMP	0x65CE
    064D5 2722      CLR	R18
    064D6 2700      CLR	R16
    064D7 940E 6B81 CALL	_SetEValve
(4549) 			{
(4550) 				i = liqDetBaseAdc - i;
    064D9 E728      LDI	R18,0x78
    064DA E604      LDI	R16,0x64
    064DB E010      LDI	R17,0
    064DC DDC5      RCALL	__DiluentMotRun
    064DD E82C      LDI	R18,0x8C
    064DE EA00      LDI	R16,0xA0
(4551) 				//if(i > 300)
(4552) 				if(i > 150)
    064DF E010      LDI	R17,0
    064E0 DDA8      RCALL	__EffluentMotRun
    064E1 E322      LDI	R18,0x32
    064E2 E030      LDI	R19,0
    064E3 E00F      LDI	R16,0xF
(4553) 				{
(4554) 					if(detRetry < 10)	// 重测计数
    064E4 940E 97B7 CALL	_SetDelayTime
    064E6 2422      CLR	R2
    064E7 9220 162F STS	EvenPosChangeProcess+37,R2
(4555) 					{
(4556) 						detRetry ++;	
    064E9 E08A      LDI	R24,0xA
    064EA 9380 053A STS	stopTestFlag+6,R24
(4557) 						break;	
    064EC C0E1      RJMP	0x65CE
    064ED E023      LDI	R18,3
    064EE E030      LDI	R19,0
(4558) 					}
(4559) 					// 探测到排液异常
(4560) 					MotStop(MOT_FLUID);
(4561) 					MotStop(MOT_EFFLUENT);
    064EF E00B      LDI	R16,0xB
    064F0 940E 97B7 CALL	_SetDelayTime
(4562) 					MotInitCheck(MOT_SAMP_NEEDLE);
    064F2 2700      CLR	R16
    064F3 940E 6BE3 CALL	_ReadLiquidMonitorResult
(4563) 					SetBeepWarning();
    064F5 2700      CLR	R16
    064F6 940E 9A52 CALL	_getLiqDetADC
(4564) 					SetDelayTime(MOT_SAMP_NEEDLE, 5);
    064F8 0158      MOVW	R10,R16
    064F9 92B0 162D STS	EvenPosChangeProcess+35,R11
    064FB 92A0 162C STS	EvenPosChangeProcess+34,R10
(4565) 					uart_Printf("!2906\r\n");	// 清洗液灌注过程中检测到混匀池中液体水位超高，请检查废液泵排液状态
    064FD 9020 165D LDS	R2,dustbinOldState+6
    064FF 9030 165E LDS	R3,dustbinOldState+7
(4566) 					// 退出处理
(4567) 					mainStep = 11;
    06501 0125      MOVW	R4,R10
    06502 1502      CP	R16,R2
(4568) 				}
    06503 0513      CPC	R17,R3
(4569) 				else
(4570) 					detRetry = 0;
    06504 F578      BCC	0x6534
    06505 0121      MOVW	R4,R2
    06506 1A40      SUB	R4,R16
(4571) 			}
(4572) 			break;
    06507 0A51      SBC	R5,R17
(4573) 		case 10:		// 完成退出
(4574) 			//SetEValve(EV_ALL, EV_CLOSE);
(4575) 			_EffluentMotRun(20, 220);
    06508 9250 162D STS	EvenPosChangeProcess+35,R5
    0650A 9240 162C STS	EvenPosChangeProcess+34,R4
(4576) 			waitEffluent = 1;
    0650C E986      LDI	R24,0x96
    0650D E090      LDI	R25,0
    0650E 1584      CP	R24,R4
(4577) 			waitMotSampNeedle = 1;
    0650F 0595      CPC	R25,R5
    06510 F500      BCC	0x6531
(4578) 			mainStep = 0;
    06511 9180 162F LDS	R24,EvenPosChangeProcess+37
    06513 308A      CPI	R24,0xA
(4579) 			return 1;
    06514 F420      BCC	0x6519
    06515 5F8F      SUBI	R24,0xFF
(4580) 			break;
(4581) 		case 11:		// 失败退出
(4582) 			_EffluentMotRun(20, 220);
    06516 9380 162F STS	EvenPosChangeProcess+37,R24
    06518 C0B5      RJMP	0x65CE
    06519 E009      LDI	R16,0x9
(4583) 			waitEffluent = 1;
    0651A 940E 6A13 CALL	_MotStop
    0651C E00B      LDI	R16,0xB
(4584) 			waitMotSampNeedle = 1;
    0651D 940E 6A13 CALL	_MotStop
(4585) 			mainStep = 0;
    0651F E003      LDI	R16,3
    06520 940E 6AFA CALL	_MotInitCheck
(4586) 			return 0xff;
    06522 940E 372D CALL	_SetBeepWarning
(4587) 			break;
(4588) 		default:
(4589) 			mainStep = 0;
    06524 E025      LDI	R18,5
    06525 E030      LDI	R19,0
    06526 E003      LDI	R16,3
(4590) 			break;
(4591) 		}
(4592) 	return 0;
    06527 940E 97B7 CALL	_SetDelayTime
    06529 E507      LDI	R16,0x57
    0652A E015      LDI	R17,5
__ManualPrimingDiluent:
  ucTmp                --> R20
    0652B 940E A90D CALL	_uart_Printf
(4593) }
(4594) 
(4595) unsigned char _ManualPrimingDiluent(void)
(4596) {
(4597) 	static unsigned char mainStep = 0;
(4598) 	unsigned char ucTmp;
(4599) 	
(4600) 	if(WaitDelayTime(MOT_EFFLUENT))		return 0;
    0652D E185      LDI	R24,0x15
    0652E 9380 053A STS	stopTestFlag+6,R24
    06530 C003      RJMP	0x6534
    06531 2422      CLR	R2
    06532 9220 162F STS	EvenPosChangeProcess+37,R2
(4601) 	if(WaitDelayTime(MOT_DILUENT))		return 0;
    06534 E009      LDI	R16,0x9
    06535 940E 6A0C CALL	_GetMotState
    06537 2F40      MOV	R20,R16
    06538 3001      CPI	R16,1
    06539 F409      BNE	0x653B
    0653A C03D      RJMP	0x6578
(4602) 	if(waitEffluent){if(GetMotState(MOT_EFFLUENT)!=STA_SLAVE_FREE)		return 0;	waitEffluent = 0;}
    0653B E00B      LDI	R16,0xB
    0653C 940E 6A0C CALL	_GetMotState
    0653E 2F40      MOV	R20,R16
    0653F 3001      CPI	R16,1
    06540 F1B9      BEQ	0x6578
    06541 E00F      LDI	R16,0xF
    06542 940E 97C6 CALL	_WaitDelayTime
    06544 2EA0      MOV	R10,R16
    06545 2300      TST	R16
    06546 F091      BEQ	0x6559
    06547 2700      CLR	R16
    06548 940E 2DBB CALL	_GetLiquidMonitorState
(4603) 	
(4604) 	switch(mainStep)
    0654A 2EA0      MOV	R10,R16
    0654B 92A0 162E STS	EvenPosChangeProcess+36,R10
    0654D 2D4A      MOV	R20,R10
    0654E 300E      CPI	R16,0xE
    0654F F019      BEQ	0x6553
    06550 3100      CPI	R16,0x10
    06551 F009      BEQ	0x6553
    06552 C07B      RJMP	0x65CE
    06553 E322      LDI	R18,0x32
    06554 E030      LDI	R19,0
    06555 E00F      LDI	R16,0xF
    06556 940E 97B7 CALL	_SetDelayTime
    06558 C075      RJMP	0x65CE
    06559 E009      LDI	R16,0x9
    0655A 940E 6A13 CALL	_MotStop
    0655C E00B      LDI	R16,0xB
    0655D 940E 6A13 CALL	_MotStop
    0655F E003      LDI	R16,3
    06560 940E 6AFA CALL	_MotInitCheck
    06562 940E 3739 CALL	_SetBeepAck
(4605) 	{
(4606) 		case 0:
(4607) 			runNum = 5;
    06564 9180 00C1 LDS	R24,0xC1
(4608) 			mainStep = 1;
    06566 7E8F      ANDI	R24,0xEF
    06567 9380 00C1 STS	0xC1,R24
(4609) 			break;
    06569 E529      LDI	R18,0x59
(4610) 		case 1:		// 启动稀释液泵和废液泵
(4611) 			SetEValve(EV_ALL, EV_CLOSE);
    0656A E039      LDI	R19,0x9
    0656B E80F      LDI	R16,0x8F
    0656C E016      LDI	R17,6
    0656D 940E A90D CALL	_uart_Printf
(4612) 		//	_DiluentMotRun(600, 120);		// 最大灌注50mL液体，超出表示灌注失败，提示用户检查供液
(4613) 		//	_EffluentMotRun(1000, 140);
(4614) 			_DiluentMotRun(120, 120);		// 最大灌注50mL液体，超出表示灌注失败，提示用户检查供液
    0656F 9180 00C1 LDS	R24,0xC1
    06571 6180      ORI	R24,0x10
(4615) 			_EffluentMotRun(200, 140);
    06572 9380 00C1 STS	0xC1,R24
    06574 E184      LDI	R24,0x14
    06575 9380 053A STS	stopTestFlag+6,R24
(4616) 			SetDelayTime(15, 30);		// 设置连续供水3秒判断灌注成功
    06577 C056      RJMP	0x65CE
    06578 9020 165C LDS	R2,dustbinOldState+5
    0657A 2022      TST	R2
(4617) 			mainStep = 2;
    0657B F0A1      BEQ	0x6590
    0657C E009      LDI	R16,0x9
    0657D 940E 6A13 CALL	_MotStop
(4618) 			break;
    0657F E00B      LDI	R16,0xB
    06580 940E 6A13 CALL	_MotStop
    06582 E124      LDI	R18,0x14
    06583 E030      LDI	R19,0
(4619) 		case 2:		// 等待液路事件
(4620) 			SetDelayTime(MOT_EFFLUENT, 3);
(4621) 			ReadLiquidMonitorResult(0);
    06584 E009      LDI	R16,0x9
    06585 940E 97B7 CALL	_SetDelayTime
(4622) 
(4623) 			if(GetMotState(MOT_DILUENT)!=STA_SLAVE_FREE && GetMotState(MOT_EFFLUENT) != STA_SLAVE_FREE)
    06587 E089      LDI	R24,0x9
    06588 9380 053A STS	stopTestFlag+6,R24
    0658A 9180 165C LDS	R24,dustbinOldState+5
    0658C 5081      SUBI	R24,1
    0658D 9380 165C STS	dustbinOldState+5,R24
    0658F C03E      RJMP	0x65CE
    06590 E009      LDI	R16,0x9
    06591 940E 6A13 CALL	_MotStop
(4624) 			{
(4625) 				if(WaitDelayTime(15) != 0)
    06593 E00B      LDI	R16,0xB
    06594 940E 6A13 CALL	_MotStop
    06596 E003      LDI	R16,3
    06597 940E 6AFA CALL	_MotInitCheck
(4626) 				{
(4627) 					ucTmp = GetLiquidMonitorState(0);	// 读取0号液路
    06599 940E 372D CALL	_SetBeepWarning
    0659B 9180 00C1 LDS	R24,0xC1
    0659D 7E8F      ANDI	R24,0xEF
(4628) 					if(ucTmp==INFO_LIQ_EMPTY || ucTmp==INFO_LIQ_BUBBLE)
    0659E 9380 00C1 STS	0xC1,R24
    065A0 E825      LDI	R18,0x85
    065A1 E134      LDI	R19,0x14
    065A2 E80F      LDI	R16,0x8F
(4629) 					{
(4630) 						SetDelayTime(15, 30);	// 液路有空气，重新开始计时
    065A3 E016      LDI	R17,6
    065A4 940E A90D CALL	_uart_Printf
    065A6 9180 00C1 LDS	R24,0xC1
(4631) 					}
(4632) 				}
    065A8 6180      ORI	R24,0x10
(4633) 				else
(4634) 				{
(4635) 					// 灌注完成
(4636) 					MotStop(MOT_DILUENT);
    065A9 9380 00C1 STS	0xC1,R24
    065AB E185      LDI	R24,0x15
(4637) 					MotStop(MOT_EFFLUENT);
    065AC 9380 053A STS	stopTestFlag+6,R24
    065AE C01F      RJMP	0x65CE
(4638) 					SetBeepAck();
    065AF ED2C      LDI	R18,0xDC
    065B0 E104      LDI	R16,0x14
(4639) 					Uart0ReUnable;
    065B1 E010      LDI	R17,0
    065B2 DCD6      RCALL	__EffluentMotRun
    065B3 E081      LDI	R24,1
    065B4 9380 1656 STS	CardScanfSW,R24
(4640) 					uart_Printf("%s\r\n",strM2102);
    065B6 9380 165A STS	dustbinOldState+3,R24
    065B8 2422      CLR	R2
    065B9 9220 053A STS	stopTestFlag+6,R2
    065BB E001      LDI	R16,1
(4641) 					Uart0ReEnable;
    065BC C012      RJMP	0x65CF
    065BD ED2C      LDI	R18,0xDC
    065BE E104      LDI	R16,0x14
    065BF E010      LDI	R17,0
    065C0 DCC8      RCALL	__EffluentMotRun
(4642) 					mainStep = 3;
    065C1 E081      LDI	R24,1
    065C2 9380 1656 STS	CardScanfSW,R24
(4643) 				}
(4644) 			}
    065C4 9380 165A STS	dustbinOldState+3,R24
(4645) 			else
(4646) 			{
(4647) 				if(runNum!=0)		// 因为稀释液泵流量小，需要最多灌注3遍
    065C6 2422      CLR	R2
    065C7 9220 053A STS	stopTestFlag+6,R2
(4648) 				{
(4649) 					MotStop(MOT_DILUENT);
    065C9 EF0F      LDI	R16,0xFF
    065CA C004      RJMP	0x65CF
    065CB 2422      CLR	R2
(4650) 					MotStop(MOT_EFFLUENT);
    065CC 9220 053A STS	stopTestFlag+6,R2
    065CE 2700      CLR	R16
(4651) 				//	_EffluentMotRun(5, 220);
(4652) 					SetDelayTime(MOT_DILUENT, 20);
    065CF 9623      ADIW	R28,3
    065D0 940C AE88 JMP	pop_xgset300C
__PrimingFluid:
    065D2 940E AE83 CALL	push_xgset300C
(4653) 					mainStep = 1;
    065D4 9723      SBIW	R28,3
    065D5 9020 165B LDS	R2,dustbinOldState+4
(4654) 					runNum --;
    065D7 2022      TST	R2
    065D8 F051      BEQ	0x65E3
    065D9 E002      LDI	R16,2
    065DA 940E 6A0C CALL	_GetMotState
(4655) 					break;
    065DC 3001      CPI	R16,1
(4656) 				}
(4657) 				// 供液已经停止，灌注失败
(4658) 				MotStop(MOT_DILUENT);
    065DD F011      BEQ	0x65E0
    065DE 2700      CLR	R16
    065DF C243      RJMP	0x6823
(4659) 				MotStop(MOT_EFFLUENT);
    065E0 2422      CLR	R2
    065E1 9220 165B STS	dustbinOldState+4,R2
(4660) 				//MotInitCheck(MOT_SAMP_NEEDLE);
(4661) 				SetBeepWarning();
    065E3 9020 165A LDS	R2,dustbinOldState+3
(4662) 				Uart0ReUnable;
    065E5 2022      TST	R2
    065E6 F051      BEQ	0x65F1
    065E7 E003      LDI	R16,3
    065E8 940E 6A0C CALL	_GetMotState
(4663) //				uart_Printf("!2910\r\n");	// 稀释液灌注失败， 请检查稀释液供给，如果供给正常则请重新调试稀释液传感器后重试灌注
(4664) 				uart_Printf("%s\r\n",strE3912);
    065EA 3001      CPI	R16,1
    065EB F011      BEQ	0x65EE
    065EC 2700      CLR	R16
    065ED C235      RJMP	0x6823
    065EE 2422      CLR	R2
    065EF 9220 165A STS	dustbinOldState+3,R2
(4665) 				Uart0ReEnable;
    065F1 9020 1658 LDS	R2,dustbinOldState+1
    065F3 2022      TST	R2
    065F4 F059      BEQ	0x6600
(4666) 				mainStep = 3;
    065F5 E00A      LDI	R16,0xA
    065F6 940E 6A0C CALL	_GetMotState
(4667) 			}
(4668) 			break;
    065F8 2F40      MOV	R20,R16
(4669) 		case 3:		// 完成退出
(4670) 			_EffluentMotRun(20, 220);
    065F9 3001      CPI	R16,1
    065FA F011      BEQ	0x65FD
    065FB 2700      CLR	R16
    065FC C226      RJMP	0x6823
(4671) 			waitEffluent = 1;
    065FD 2422      CLR	R2
    065FE 9220 1658 STS	dustbinOldState+1,R2
(4672) 			mainStep = 4;
    06600 9020 1656 LDS	R2,CardScanfSW
    06602 2022      TST	R2
(4673) 		case 4:
(4674) 			mainStep = 0;
    06603 F059      BEQ	0x660F
    06604 E00B      LDI	R16,0xB
    06605 940E 6A0C CALL	_GetMotState
(4675) 			return 1;
    06607 2F40      MOV	R20,R16
(4676) 	}
(4677) 	return 0;
    06608 3001      CPI	R16,1
    06609 F011      BEQ	0x660C
    0660A 2700      CLR	R16
__ManualPrimingFluid:
    0660B C217      RJMP	0x6823
    0660C 2422      CLR	R2
(4678) }
(4679) 
(4680) unsigned char _ManualPrimingFluid(void)
(4681) {
(4682) 	static unsigned char mainStep = 0;
(4683) 	static unsigned int i;
(4684) 	static unsigned char ucTmp;
(4685) 	static unsigned char detRetry;
(4686) 	
(4687) 	if(WaitDelayTime(MOT_EFFLUENT))		return 0;
    0660D 9220 1656 STS	CardScanfSW,R2
    0660F 9140 053B LDS	R20,stopTestFlag+7
    06611 2755      CLR	R21
    06612 3040      CPI	R20,0
    06613 0745      CPC	R20,R21
(4688) 	if(WaitDelayTime(MOT_DILUENT))		return 0;
    06614 F409      BNE	0x6616
    06615 C02E      RJMP	0x6644
    06616 3041      CPI	R20,1
    06617 E0E0      LDI	R30,0
    06618 075E      CPC	R21,R30
    06619 F409      BNE	0x661B
    0661A C049      RJMP	0x6664
(4689) 	if(waitEffluent){if(GetMotState(MOT_EFFLUENT)!=STA_SLAVE_FREE)		return 0;	waitEffluent = 0;}
    0661B 3044      CPI	R20,4
    0661C E0E0      LDI	R30,0
    0661D 075E      CPC	R21,R30
    0661E F409      BNE	0x6620
    0661F C05A      RJMP	0x667A
    06620 3045      CPI	R20,5
    06621 E0E0      LDI	R30,0
    06622 075E      CPC	R21,R30
    06623 F409      BNE	0x6625
    06624 C069      RJMP	0x668E
    06625 3046      CPI	R20,6
    06626 E0E0      LDI	R30,0
    06627 075E      CPC	R21,R30
    06628 F409      BNE	0x662A
    06629 C07C      RJMP	0x66A6
(4690) 	
(4691) 	switch(mainStep)
    0662A 3047      CPI	R20,7
    0662B E0E0      LDI	R30,0
    0662C 075E      CPC	R21,R30
    0662D F409      BNE	0x662F
    0662E C084      RJMP	0x66B3
    0662F 3048      CPI	R20,0x8
    06630 E0E0      LDI	R30,0
    06631 075E      CPC	R21,R30
    06632 F409      BNE	0x6634
    06633 C0F8      RJMP	0x672C
    06634 3049      CPI	R20,0x9
    06635 E0E0      LDI	R30,0
    06636 075E      CPC	R21,R30
    06637 F409      BNE	0x6639
    06638 C107      RJMP	0x6740
    06639 304A      CPI	R20,0xA
    0663A E0E0      LDI	R30,0
    0663B 075E      CPC	R21,R30
    0663C F409      BNE	0x663E
    0663D C1C5      RJMP	0x6803
    0663E 304B      CPI	R20,0xB
    0663F E0E0      LDI	R30,0
    06640 075E      CPC	R21,R30
    06641 F409      BNE	0x6643
    06642 C1CE      RJMP	0x6811
(4692) 	{
(4693) 		case 0:
(4694) 			runNum = 5;
    06643 C1DB      RJMP	0x681F
    06644 E083      LDI	R24,3
    06645 838A      STD	Y+2,R24
(4695) 			mainStep = 1;
    06646 E184      LDI	R24,0x14
    06647 8388      ST	Y,R24
    06648 EF20      LDI	R18,0xF0
(4696) 			break;
    06649 E003      LDI	R16,3
(4697) 		case 1:		// 启动清洗液泵和废液泵
(4698) 			_FluidMotRun(100, 60);		// 最大灌注30mL液体，超出表示灌注失败，提示用户检查供液
    0664A 940E 6A9F CALL	_SetMotRunPam
    0664C E003      LDI	R16,3
    0664D 940E 6AFA CALL	_MotInitCheck
(4699) 			_EffluentMotRun(105, 60);
    0664F 940E 82CB CALL	_GetNeedleOnMixCenterPos
    06651 0158      MOVW	R10,R16
(4700) 			SetDelayTime(15, 40);		// 设置连续供水3秒判断灌注成功
    06652 92B0 1647 STS	_NewCardStoreNum+7,R11
    06654 92A0 1646 STS	_NewCardStoreNum+6,R10
    06656 E081      LDI	R24,1
(4701) 			ReadLiquidMonitorResult(1);
    06657 9380 165A STS	dustbinOldState+3,R24
    06659 2722      CLR	R18
(4702) 			mainStep = 2;
    0665A 2700      CLR	R16
    0665B 940E 6B81 CALL	_SetEValve
(4703) 			break;
    0665D E081      LDI	R24,1
(4704) 		case 2:		// 等待液路事件
(4705) 			SetDelayTime(MOT_EFFLUENT, 3);
    0665E 9380 053B STS	stopTestFlag+7,R24
    06660 E085      LDI	R24,5
    06661 9380 165C STS	dustbinOldState+5,R24
(4706) 			ReadLiquidMonitorResult(1);
    06663 C1BE      RJMP	_MotAdjustPosition
    06664 E084      LDI	R24,4
    06665 838A      STD	Y+2,R24
(4707) 			if(GetMotState(MOT_EFFLUENT) != STA_SLAVE_FREE && GetMotState(MOT_FLUID) != STA_SLAVE_FREE) 
    06666 E08A      LDI	R24,0xA
    06667 8388      ST	Y,R24
    06668 EF20      LDI	R18,0xF0
    06669 E002      LDI	R16,2
    0666A 940E 6A9F CALL	_SetMotRunPam
    0666C 9120 1646 LDS	R18,_NewCardStoreNum+6
    0666E 9130 1647 LDS	R19,_NewCardStoreNum+7
    06670 E002      LDI	R16,2
    06671 940E 6A5B CALL	_MotRunTo
(4708) 			{
(4709) 				if(WaitDelayTime(15)!=0)
    06673 E081      LDI	R24,1
    06674 9380 165B STS	dustbinOldState+4,R24
    06676 E084      LDI	R24,4
    06677 9380 053B STS	stopTestFlag+7,R24
(4710) 				{
(4711) 					ucTmp = GetLiquidMonitorState(1);
    06679 C1A8      RJMP	_MotAdjustPosition
    0667A E001      LDI	R16,1
    0667B 940E 6BE3 CALL	_ReadLiquidMonitorResult
    0667D E002      LDI	R16,2
(4712) 					if(ucTmp==INFO_LIQ_EMPTY || ucTmp==INFO_LIQ_BUBBLE)
    0667E 940E 6BE3 CALL	_ReadLiquidMonitorResult
    06680 EF20      LDI	R18,0xF0
    06681 EC0C      LDI	R16,0xCC
    06682 E011      LDI	R17,1
    06683 DC77      RCALL	__NeedleMotRunTo
(4713) 					{
(4714) 						SetDelayTime(15, 40);	// 液路有空气，重新开始计时
    06684 E081      LDI	R24,1
    06685 9380 165A STS	dustbinOldState+3,R24
    06687 E085      LDI	R24,5
    06688 9380 053B STS	stopTestFlag+7,R24
(4715) 					}
(4716) 				}
    0668A 2422      CLR	R2
    0668B 9220 1633 STS	EvenPosChangeProcess+41,R2
(4717) 				else
(4718) 				{
(4719) 					// 灌注完成
(4720) 					MotStop(MOT_FLUID);
(4721) 					MotStop(MOT_EFFLUENT);
    0668D C194      RJMP	_MotAdjustPosition
    0668E 2722      CLR	R18
    0668F 2700      CLR	R16
(4722) 					//MotInitCheck(MOT_SAMP_NEEDLE);
(4723) 					SetBeepAck();
    06690 940E 6B81 CALL	_SetEValve
(4724) 					Uart0ReUnable;
    06692 E021      LDI	R18,1
    06693 E002      LDI	R16,2
    06694 940E 6B81 CALL	_SetEValve
    06696 E124      LDI	R18,0x14
(4725) 					uart_Printf("%s\r\n",strM2101);
    06697 EF0F      LDI	R16,0xFF
    06698 EF1F      LDI	R17,0xFF
    06699 DBCA      RCALL	__FluidMotRun
    0669A E081      LDI	R24,1
    0669B 9380 1658 STS	dustbinOldState+1,R24
(4726) 					Uart0ReEnable;
    0669D 9180 1633 LDS	R24,EvenPosChangeProcess+41
    0669F 5F8F      SUBI	R24,0xFF
    066A0 9380 1633 STS	EvenPosChangeProcess+41,R24
(4727) 					mainStep = 3;
    066A2 E086      LDI	R24,6
    066A3 9380 053B STS	stopTestFlag+7,R24
(4728) 				}
(4729) 			}
    066A5 C17C      RJMP	_MotAdjustPosition
(4730) 			else
(4731) 			{
(4732) 				if(runNum!=0)		// 因为稀释液泵流量小，需要最多灌注3遍
    066A6 E12E      LDI	R18,0x1E
    066A7 E030      LDI	R19,0
    066A8 E00A      LDI	R16,0xA
    066A9 940E 97B7 CALL	_SetDelayTime
(4733) 				{
(4734) 					MotStop(MOT_FLUID);
    066AB 2722      CLR	R18
    066AC E002      LDI	R16,2
(4735) 					MotStop(MOT_EFFLUENT);
    066AD 940E 6B81 CALL	_SetEValve
    066AF E087      LDI	R24,7
(4736) 					SetDelayTime(MOT_DILUENT, 20);
    066B0 9380 053B STS	stopTestFlag+7,R24
    066B2 C16F      RJMP	_MotAdjustPosition
    066B3 2700      CLR	R16
    066B4 940E 9A52 CALL	_getLiqDetADC
(4737) 					mainStep = 1;
    066B6 0158      MOVW	R10,R16
    066B7 92B0 165E STS	dustbinOldState+7,R11
(4738) 					runNum --;
    066B9 92A0 165D STS	dustbinOldState+6,R10
    066BB EF87      LDI	R24,0xF7
    066BC E093      LDI	R25,3
(4739) 					break;
    066BD 1780      CP	R24,R16
(4740) 				}
(4741) 				// 供液已经停止，灌注失败
(4742) 				MotStop(MOT_FLUID);
    066BE 0791      CPC	R25,R17
    066BF F4E0      BCC	0x66DC
    066C0 940E 372D CALL	_SetBeepWarning
(4743) 				MotStop(MOT_EFFLUENT);
    066C2 E003      LDI	R16,3
    066C3 940E 6AFA CALL	_MotInitCheck
(4744) 				SetBeepWarning();
    066C5 9180 00C1 LDS	R24,0xC1
(4745) 				Uart0ReUnable;
    066C7 7E8F      ANDI	R24,0xEF
    066C8 9380 00C1 STS	0xC1,R24
    066CA 9120 165D LDS	R18,dustbinOldState+6
(4746) 				uart_Printf("%s\r\n",strE3911);	// 清洗液灌注失败， 请检查清洗液供给，如果供给正常则请重新调试清洗液传感器后重试灌注
    066CC 9130 165E LDS	R19,dustbinOldState+7
    066CE E607      LDI	R16,0x67
    066CF E015      LDI	R17,5
    066D0 940E A90D CALL	_uart_Printf
(4747) 				Uart0ReEnable;
    066D2 9180 00C1 LDS	R24,0xC1
    066D4 6180      ORI	R24,0x10
    066D5 9380 00C1 STS	0xC1,R24
(4748) 				mainStep = 3;
    066D7 2422      CLR	R2
    066D8 9220 053B STS	stopTestFlag+7,R2
(4749) 			}
(4750) 			break;
    066DA EF0F      LDI	R16,0xFF
    066DB C147      RJMP	0x6823
    066DC 9180 165D LDS	R24,dustbinOldState+6
(4751) 		case 3:		// 完成/失败退出
(4752) 			_EffluentMotRun(20, 220);
(4753) 			waitEffluent = 1;
    066DE 9190 165E LDS	R25,dustbinOldState+7
    066E0 3C88      CPI	R24,0xC8
(4754) 			mainStep = 4;
    066E1 E0E0      LDI	R30,0
    066E2 079E      CPC	R25,R30
    066E3 F5A8      BCC	0x6719
(4755) 			break;
    066E4 9180 1633 LDS	R24,EvenPosChangeProcess+41
(4756) 		case 4:
(4757) 			mainStep = 0;
    066E6 3084      CPI	R24,4
    066E7 F4C8      BCC	0x6701
(4758) 			return 1;
    066E8 E021      LDI	R18,1
    066E9 E001      LDI	R16,1
(4759) 			break;
(4760) 		}
(4761) 	return 0;
    066EA 940E 6B81 CALL	_SetEValve
    066EC E124      LDI	R18,0x14
_SetCleanMode:
  m                    --> R10
    066ED EF0E      LDI	R16,0xFE
    066EE EF1F      LDI	R17,0xFF
    066EF DB74      RCALL	__FluidMotRun
(4762) }
(4763) 
(4764) 
(4765) void SetCleanMode(unsigned char m)
(4766) {
(4767) 	if(m > 2)
    066F0 E021      LDI	R18,1
    066F1 E003      LDI	R16,3
    066F2 940E 6B81 CALL	_SetEValve
(4768) 		m = 0;
    066F4 EA20      LDI	R18,0xA0
    066F5 E208      LDI	R16,0x28
    066F6 E010      LDI	R17,0
    066F7 DB91      RCALL	__EffluentMotRun
(4769) 	if(CleanMode == 0)
(4770) 	{
(4771) 		CleanMode = m;
    066F8 E081      LDI	R24,1
    066F9 9380 1658 STS	dustbinOldState+1,R24
(4772) 		Uart0ReUnable;
    066FB 9380 1656 STS	CardScanfSW,R24
    066FD E085      LDI	R24,5
    066FE 9380 053B STS	stopTestFlag+7,R24
(4773) 		uart_Printf("%s %4d\r\n",strM3156, CleanMode);
    06700 C121      RJMP	_MotAdjustPosition
    06701 940E 372D CALL	_SetBeepWarning
    06703 E003      LDI	R16,3
    06704 940E 6AFA CALL	_MotInitCheck
    06706 9180 00C1 LDS	R24,0xC1
    06708 7E8F      ANDI	R24,0xEF
(4774) 		Uart0ReEnable;
    06709 9380 00C1 STS	0xC1,R24
    0670B E40F      LDI	R16,0x4F
    0670C E015      LDI	R17,5
    0670D 940E A90D CALL	_uart_Printf
(4775) 	}
    0670F 9180 00C1 LDS	R24,0xC1
_GetMotState:
  slaveNum             --> R10
    06711 6180      ORI	R24,0x10
    06712 9380 00C1 STS	0xC1,R24
FILE: D:\Work\主控软件\2032A2~1\FunctionalInteface.c
(0001) 
(0002) 
(0003) #include <iom1280v.h>
(0004) #include <macros.h>
(0005) #include "B1404_LIB.h"
(0006) #include "LibCommon.h"
(0007) 
(0008) 
(0009) /*
(0010) 从机模块命令接口，为上层提供控制函数
(0011) */
(0012) 
(0013) /************************************** 电机控制 *********************************************/
(0014) unsigned char  GetMotState(unsigned char slaveNum){
(0015) 	return GetSlaveState(slaveNum);
    06714 2422      CLR	R2
    06715 9220 053B STS	stopTestFlag+7,R2
    06717 EF0F      LDI	R16,0xFF
_MotStop:
  command              --> Y,+0
  slaveNum             --> R20
    06718 C10A      RJMP	0x6823
    06719 2700      CLR	R16
    0671A 940E 9A52 CALL	_getLiqDetADC
(0016) }
(0017) unsigned char MotStop(unsigned char slaveNum){
(0018) 	COMMAND_STRING command;
(0019) 	if(slaveNum>=SLAVE_NUM)
    0671C 0158      MOVW	R10,R16
(0020) 		return 1;
    0671D 92B0 165E STS	dustbinOldState+7,R11
(0021) //	if(GetSlaveState(slaveNum)==STA_SLAVE_FREE){	// 在电机为空闲状态下发送
(0022) 		command.cmd = (slaveNum<<3) + 1;
    0671F 92A0 165D STS	dustbinOldState+6,R10
    06721 2722      CLR	R18
    06722 2700      CLR	R16
    06723 940E 6B81 CALL	_SetEValve
(0023) 		command.cmdLen = 1+1;
    06725 2422      CLR	R2
    06726 9220 1633 STS	EvenPosChangeProcess+41,R2
(0024) 		command.pam[0] = CMD_MOT_STOP;
    06728 E088      LDI	R24,0x8
(0025) 		InsertUrgentCommand(slaveNum, &command);
    06729 9380 053B STS	stopTestFlag+7,R24
    0672B C0F6      RJMP	_MotAdjustPosition
    0672C E32C      LDI	R18,0x3C
(0026) //		}
(0027) 	return 0;
    0672D E604      LDI	R16,0x64
    0672E E010      LDI	R17,0
    0672F DB34      RCALL	__FluidMotRun
    06730 E32C      LDI	R18,0x3C
_MotRun:
  num                  --> R12
  pChar                --> R10
  command              --> Y,+0
  n                    --> Y,+14
  slaveNum             --> R20
    06731 E609      LDI	R16,0x69
    06732 E010      LDI	R17,0
    06733 DB55      RCALL	__EffluentMotRun
    06734 E32C      LDI	R18,0x3C
    06735 E030      LDI	R19,0
    06736 E00F      LDI	R16,0xF
(0028) }
(0029) 
(0030) unsigned char MotRun(unsigned char slaveNum, signed int n){
(0031) 	COMMAND_STRING command;
(0032) 	unsigned char *pChar;
(0033) 	signed int num;
(0034) 	num = n;
    06737 940E 97B7 CALL	_SetDelayTime
(0035) 	pChar = (unsigned char *)(&n);
    06739 E001      LDI	R16,1
    0673A 940E 6BE3 CALL	_ReadLiquidMonitorResult
(0036) 	if(slaveNum>=SLAVE_NUM)
    0673C E089      LDI	R24,0x9
    0673D 9380 053B STS	stopTestFlag+7,R24
(0037) 		return 1;
    0673F C0E2      RJMP	_MotAdjustPosition
(0038) 	SetMotPosIdle(slaveNum);
    06740 E023      LDI	R18,3
    06741 E030      LDI	R19,0
    06742 E00B      LDI	R16,0xB
    06743 940E 97B7 CALL	_SetDelayTime
(0039) //	if(GetSlaveState(slaveNum)==STA_SLAVE_FREE){	// 在电机为空闲状态下发送
(0040) 		command.cmd = (slaveNum<<3) + 3;
    06745 E001      LDI	R16,1
    06746 940E 6BE3 CALL	_ReadLiquidMonitorResult
    06748 E00B      LDI	R16,0xB
    06749 940E 6A0C CALL	_GetMotState
(0041) 		command.cmdLen = 1+3;
    0674B 2F40      MOV	R20,R16
(0042) 		num = (unsigned int)n;
    0674C 3001      CPI	R16,1
    0674D F409      BNE	0x674F
(0043) 		command.pam[0] = CMD_MOT_RUN;
    0674E C03D      RJMP	0x678C
    0674F E00A      LDI	R16,0xA
(0044) 		command.pam[2] = *pChar++;
    06750 940E 6A0C CALL	_GetMotState
    06752 2F40      MOV	R20,R16
    06753 3001      CPI	R16,1
(0045) 		command.pam[1] = *pChar;
    06754 F1B9      BEQ	0x678C
    06755 E00F      LDI	R16,0xF
(0046) 		
(0047) 		InsertCommand(slaveNum, &command);
    06756 940E 97C6 CALL	_WaitDelayTime
    06758 2EA0      MOV	R10,R16
    06759 2300      TST	R16
(0048) //		}
(0049) /*	if(slaveNum == MOT_DILUENT)
(0050) 		StartLiquidMonitor(0);
(0051) 	else if(slaveNum == MOT_FLUID)
(0052) 		StartLiquidMonitor(1);
(0053) 	else if(slaveNum == MOT_EFFLUENT)
(0054) 		StartLiquidMonitor(2);*/
(0055) 	return 0;
    0675A F091      BEQ	0x676D
    0675B E001      LDI	R16,1
    0675C 940E 2DBB CALL	_GetLiquidMonitorState
    0675E 2EA0      MOV	R10,R16
    0675F 92A0 1632 STS	EvenPosChangeProcess+40,R10
    06761 2D4A      MOV	R20,R10
    06762 300E      CPI	R16,0xE
    06763 F019      BEQ	0x6767
    06764 3100      CPI	R16,0x10
(0056) }
(0057) unsigned char MotRunTo(unsigned char slaveNum, signed int x){
(0058) 	COMMAND_STRING command;
(0059) 	unsigned int num;
(0060) 	if(slaveNum>=SLAVE_NUM)
    06765 F009      BEQ	0x6767
    06766 C05B      RJMP	0x67C2
(0061) 		return 1;
    06767 E32C      LDI	R18,0x3C
    06768 E030      LDI	R19,0
(0062) 	SetMotPosIdle(slaveNum);
    06769 E00F      LDI	R16,0xF
    0676A 940E 97B7 CALL	_SetDelayTime
    0676C C055      RJMP	0x67C2
(0063) //	if(GetSlaveState(slaveNum)==STA_SLAVE_FREE){	// 在电机为空闲状态下发送
(0064) 		command.cmd = (slaveNum<<3) + 3;
    0676D E00A      LDI	R16,0xA
    0676E 940E 6A13 CALL	_MotStop
    06770 E00B      LDI	R16,0xB
    06771 940E 6A13 CALL	_MotStop
(0065) 		command.cmdLen = 1+3;
    06773 E003      LDI	R16,3
    06774 940E 6AFA CALL	_MotInitCheck
(0066) 		num = (unsigned int)x;
(0067) 		command.pam[0] = CMD_MOT_RUN_TO;
    06776 940E 3739 CALL	_SetBeepAck
(0068) 		command.pam[1] = (unsigned char)(num>>8);
    06778 9180 00C1 LDS	R24,0xC1
    0677A 7E8F      ANDI	R24,0xEF
(0069) 		command.pam[2] = (unsigned char)num;
    0677B 9380 00C1 STS	0xC1,R24
(0070) 		InsertCommand(slaveNum, &command);
    0677D E421      LDI	R18,0x41
    0677E E039      LDI	R19,0x9
    0677F E80F      LDI	R16,0x8F
(0071) //		}
(0072) 	return 0;
    06780 E016      LDI	R17,6
    06781 940E A90D CALL	_uart_Printf
    06783 9180 00C1 LDS	R24,0xC1
    06785 6180      ORI	R24,0x10
    06786 9380 00C1 STS	0xC1,R24
    06788 E08A      LDI	R24,0xA
(0073) }
(0074) unsigned char MotRunToSite(unsigned char slaveNum, unsigned char definePos){
(0075) 	COMMAND_STRING command;
(0076) 	if(slaveNum>=SLAVE_NUM)
    06789 9380 053B STS	stopTestFlag+7,R24
(0077) 		return 1;
    0678B C036      RJMP	0x67C2
    0678C 9020 165C LDS	R2,dustbinOldState+5
(0078) 	SetMotPosIdle(slaveNum);
    0678E 2022      TST	R2
    0678F F0A1      BEQ	0x67A4
    06790 E00A      LDI	R16,0xA
(0079) //	if(GetSlaveState(slaveNum)==STA_SLAVE_FREE){	// 在电机为空闲状态下发送
(0080) 		command.cmd = (slaveNum<<3) + 2;
    06791 940E 6A13 CALL	_MotStop
    06793 E00B      LDI	R16,0xB
    06794 940E 6A13 CALL	_MotStop
    06796 E124      LDI	R18,0x14
(0081) 		command.cmdLen = 1+2;
    06797 E030      LDI	R19,0
    06798 E009      LDI	R16,0x9
(0082) 		command.pam[0] = CMD_MOT_RUN_TO_SITE;
    06799 940E 97B7 CALL	_SetDelayTime
(0083) 		command.pam[1] = definePos;
    0679B E088      LDI	R24,0x8
    0679C 9380 053B STS	stopTestFlag+7,R24
    0679E 9180 165C LDS	R24,dustbinOldState+5
(0084) 		InsertCommand(slaveNum, &command);
(0085) //		}
(0086) 	return 0;
    067A0 5081      SUBI	R24,1
    067A1 9380 165C STS	dustbinOldState+5,R24
    067A3 C07E      RJMP	_MotAdjustPosition
_SetMotRunPam:
  command              --> Y,+0
  current              --> R10
  accel                --> R12
  maxVel               --> R14
  slaveNum             --> R20
    067A4 E00A      LDI	R16,0xA
    067A5 940E 6A13 CALL	_MotStop
    067A7 E00B      LDI	R16,0xB
    067A8 940E 6A13 CALL	_MotStop
    067AA E003      LDI	R16,3
(0087) }
(0088) unsigned char SetMotRunPam(unsigned char slaveNum, unsigned char maxVel, unsigned char accel, unsigned char current){
(0089) 	COMMAND_STRING command;
(0090) 	if(slaveNum>=SLAVE_NUM)
    067AB 940E 6AFA CALL	_MotInitCheck
(0091) 		return 1;
    067AD 940E 372D CALL	_SetBeepWarning
(0092) //	if(GetSlaveState(slaveNum)==STA_SLAVE_FREE){	// 在电机为空闲状态下发送
(0093) 		command.cmd = (slaveNum<<3) + 4;
    067AF 9180 00C1 LDS	R24,0xC1
    067B1 7E8F      ANDI	R24,0xEF
    067B2 9380 00C1 STS	0xC1,R24
    067B4 E626      LDI	R18,0x66
(0094) 		command.pam[0] = CMD_MOT_SET_PAM;
    067B5 E134      LDI	R19,0x14
    067B6 E80F      LDI	R16,0x8F
(0095) 		command.pam[1] = maxVel;
    067B7 E016      LDI	R17,6
(0096) 		command.pam[2] = accel;
    067B8 940E A90D CALL	_uart_Printf
(0097) 		command.pam[3] = current;
    067BA 9180 00C1 LDS	R24,0xC1
(0098) 		command.cmdLen = 5;
(0099) 		InsertCommand(slaveNum, &command);
    067BC 6180      ORI	R24,0x10
    067BD 9380 00C1 STS	0xC1,R24
    067BF E08B      LDI	R24,0xB
(0100) //		}
(0101) 	return 0;
    067C0 9380 053B STS	stopTestFlag+7,R24
    067C2 2700      CLR	R16
    067C3 940E 9A52 CALL	_getLiqDetADC
    067C5 0158      MOVW	R10,R16
    067C6 92B0 1631 STS	EvenPosChangeProcess+39,R11
    067C8 92A0 1630 STS	EvenPosChangeProcess+38,R10
(0102) }
(0103) unsigned char MotSetLock(unsigned char slaveNum, unsigned char lock){
(0104) 	COMMAND_STRING command;
(0105) 	if(slaveNum>=SLAVE_NUM)
    067CA 9020 165D LDS	R2,dustbinOldState+6
(0106) 		return 1;
    067CC 9030 165E LDS	R3,dustbinOldState+7
(0107) //	if(GetSlaveState(slaveNum)==STA_SLAVE_FREE){	// 在电机为空闲状态下发送
(0108) 		command.cmd = (slaveNum<<3) + 2;
    067CE 0125      MOVW	R4,R10
    067CF 1502      CP	R16,R2
    067D0 0513      CPC	R17,R3
    067D1 F008      BCS	0x67D3
    067D2 C04F      RJMP	_MotAdjustPosition
(0109) 		command.cmdLen = 1+2;
    067D3 0121      MOVW	R4,R2
    067D4 1A40      SUB	R4,R16
(0110) 		command.pam[0] = CMD_MOT_ENABLE;
    067D5 0A51      SBC	R5,R17
    067D6 9250 1631 STS	EvenPosChangeProcess+39,R5
(0111) 		command.pam[1] = lock;
    067D8 9240 1630 STS	EvenPosChangeProcess+38,R4
    067DA E986      LDI	R24,0x96
    067DB E090      LDI	R25,0
(0112) 		InsertCommand(slaveNum, &command);
(0113) //		}
(0114) 	return 0;
    067DC 1584      CP	R24,R4
    067DD 0595      CPC	R25,R5
    067DE F500      BCC	0x67FF
    067DF 9180 1633 LDS	R24,EvenPosChangeProcess+41
_MotSetEnable:
  enable               --> Y,+2
  slaveNum             --> Y,+0
    067E1 308A      CPI	R24,0xA
    067E2 F420      BCC	0x67E7
(0115) }
(0116) unsigned char MotSetEnable(unsigned char slaveNum, unsigned char enable){
(0117) /*	COMMAND_STRING command;
(0118) 	command.cmd = (slaveNum<<3) | CMD_MOT_ENABLE;
(0119) 	command.cmdLen = 1+1;
(0120) 	command.pam[0] = enable;
(0121) 	InsertCommand(slaveNum, &command);*/
(0122) 	return 0;
    067E3 5F8F      SUBI	R24,0xFF
    067E4 9380 1633 STS	EvenPosChangeProcess+41,R24
_GetMotPositionFromSlave:
  command              --> Y,+0
  slaveNum             --> R20
    067E6 C03B      RJMP	_MotAdjustPosition
    067E7 E00A      LDI	R16,0xA
    067E8 940E 6A13 CALL	_MotStop
(0123) }
(0124) unsigned char GetMotPositionFromSlave(unsigned char slaveNum){
(0125) 	COMMAND_STRING command;
(0126) 	if(slaveNum>=SLAVE_NUM)
    067EA E00B      LDI	R16,0xB
(0127) 		return 1;
    067EB 940E 6A13 CALL	_MotStop
(0128) //	if(GetSlaveState(slaveNum)==(STA_SLAVE_FREE)){	// 在电机为空闲状态下发送
(0129) 		command.cmd = (slaveNum<<3) + 1;
    067ED E003      LDI	R16,3
    067EE 940E 6AFA CALL	_MotInitCheck
    067F0 940E 372D CALL	_SetBeepWarning
    067F2 E025      LDI	R18,5
(0130) 		command.cmdLen = 1+1;
    067F3 E030      LDI	R19,0
    067F4 E003      LDI	R16,3
(0131) 		command.pam[0] = CMD_MOT_GET_POS;
    067F5 940E 97B7 CALL	_SetDelayTime
(0132) 		InsertCommand(slaveNum, &command);
    067F7 E407      LDI	R16,0x47
    067F8 E015      LDI	R17,5
    067F9 940E A90D CALL	_uart_Printf
(0133) //		}
(0134) 	return 0;
    067FB E08B      LDI	R24,0xB
    067FC 9380 053B STS	stopTestFlag+7,R24
    067FE C023      RJMP	_MotAdjustPosition
_MotInitCheck:
  state                --> R10
  command              --> Y,+0
  slaveNum             --> R20
    067FF 2422      CLR	R2
    06800 9220 1633 STS	EvenPosChangeProcess+41,R2
    06802 C01F      RJMP	_MotAdjustPosition
(0135) }
(0136) 
(0137) unsigned char MotInitCheck(unsigned char slaveNum){
(0138) 	COMMAND_STRING command;
(0139) 	unsigned char state;
(0140) 	if(slaveNum>=SLAVE_NUM)
    06803 ED2C      LDI	R18,0xDC
    06804 E104      LDI	R16,0x14
(0141) 		return 1;
    06805 E010      LDI	R17,0
    06806 DA82      RCALL	__EffluentMotRun
(0142) 	state = GetSlaveState(slaveNum);
    06807 E081      LDI	R24,1
    06808 9380 1656 STS	CardScanfSW,R24
    0680A 9380 165A STS	dustbinOldState+3,R24
(0143) 	SetMotPosIdle(slaveNum);
    0680C 2422      CLR	R2
    0680D 9220 053B STS	stopTestFlag+7,R2
(0144) //	if(state==STA_SLAVE_FREE){	// 在电机为空闲状态下发送
(0145) 		command.cmd = (slaveNum<<3) + 1;
    0680F E001      LDI	R16,1
    06810 C012      RJMP	0x6823
    06811 ED2C      LDI	R18,0xDC
    06812 E104      LDI	R16,0x14
    06813 E010      LDI	R17,0
    06814 DA74      RCALL	__EffluentMotRun
(0146) 		command.cmdLen = 1+1;
    06815 E081      LDI	R24,1
    06816 9380 1656 STS	CardScanfSW,R24
(0147) 		command.pam[0] = CMD_MOT_INIT;
    06818 9380 165A STS	dustbinOldState+3,R24
(0148) 		InsertCommand(slaveNum, &command);	
    0681A 2422      CLR	R2
    0681B 9220 053B STS	stopTestFlag+7,R2
(0149) //		}
(0150) 	return 0;
    0681D EF0F      LDI	R16,0xFF
    0681E C004      RJMP	0x6823
    0681F 2422      CLR	R2
    06820 9220 053B STS	stopTestFlag+7,R2
_MotAdjustPosition:
  state                --> R12
  command              --> Y,+0
  posNum               --> R10
  slaveNum             --> R20
    06822 2700      CLR	R16
    06823 9623      ADIW	R28,3
    06824 940C AE88 JMP	pop_xgset300C
__ManualPrimingDiluent:
    06826 940E AE83 CALL	push_xgset300C
(0151) }
(0152) unsigned char MotAdjustPosition(unsigned char slaveNum, unsigned posNum){
(0153) 	COMMAND_STRING command;
(0154) 	unsigned char state;
(0155) 	if(slaveNum>=SLAVE_NUM)
    06828 E00B      LDI	R16,0xB
(0156) 		return 1;
    06829 940E 97C6 CALL	_WaitDelayTime
(0157) 	state = GetSlaveState(slaveNum);
    0682B 2300      TST	R16
    0682C F011      BEQ	0x682F
    0682D 2700      CLR	R16
    0682E C0D5      RJMP	0x6904
(0158) 	SetMotPosIdle(slaveNum);
    0682F E009      LDI	R16,0x9
    06830 940E 97C6 CALL	_WaitDelayTime
    06832 2300      TST	R16
(0159) //	if(state==STA_SLAVE_FREE){	// 在电机为空闲状态下发送
(0160) 		command.cmd = (slaveNum<<3) + 2;
    06833 F011      BEQ	0x6836
    06834 2700      CLR	R16
    06835 C0CE      RJMP	0x6904
    06836 9020 1656 LDS	R2,CardScanfSW
    06838 2022      TST	R2
(0161) 		command.cmdLen = 1+2;
    06839 F059      BEQ	0x6845
    0683A E00B      LDI	R16,0xB
(0162) 		command.pam[0] = CMD_MOT_ADJUST;
    0683B 940E 6A0C CALL	_GetMotState
(0163) 		command.pam[1] = posNum;
    0683D 2F40      MOV	R20,R16
(0164) 		
(0165) 		InsertCommand(slaveNum, &command);
    0683E 3001      CPI	R16,1
    0683F F011      BEQ	0x6842
    06840 2700      CLR	R16
    06841 C0C2      RJMP	0x6904
(0166) //		}
(0167) 	return 0;
    06842 2422      CLR	R2
    06843 9220 1656 STS	CardScanfSW,R2
    06845 9140 053C LDS	R20,stopTestFlag+8
    06847 2755      CLR	R21
    06848 3040      CPI	R20,0
    06849 0745      CPC	R20,R21
    0684A F099      BEQ	0x685E
    0684B 3041      CPI	R20,1
(0168) }
(0169) unsigned char MotSetPam(unsigned char slaveNum, unsigned char pam0, unsigned char pam1){
(0170) 	COMMAND_STRING command;
(0171) 	unsigned char state;
(0172) 	if(slaveNum>=SLAVE_NUM)
    0684C E0E0      LDI	R30,0
    0684D 075E      CPC	R21,R30
(0173) 		return 1;
    0684E F0B1      BEQ	0x6865
    0684F 3042      CPI	R20,2
(0174) 	state = GetSlaveState(slaveNum);
    06850 E0E0      LDI	R30,0
    06851 075E      CPC	R21,R30
    06852 F139      BEQ	0x687A
    06853 3043      CPI	R20,3
(0175) //	if(state==STA_SLAVE_FREE){	// 在电机为空闲状态下发送
(0176) 		command.cmd = (slaveNum<<3) + 3;
    06854 E0E0      LDI	R30,0
    06855 075E      CPC	R21,R30
    06856 F409      BNE	0x6858
    06857 C09C      RJMP	0x68F4
    06858 3044      CPI	R20,4
    06859 E0E0      LDI	R30,0
(0177) 		command.cmdLen = 1+3;
    0685A 075E      CPC	R21,R30
    0685B F409      BNE	0x685D
(0178) 		command.pam[0] = CMD_MOT_SET_BASE_PAM;
    0685C C0A1      RJMP	0x68FE
    0685D C0A5      RJMP	0x6903
(0179) 		command.pam[1] = pam0;
    0685E E085      LDI	R24,5
(0180) 		command.pam[2] = pam1;
    0685F 9380 165C STS	dustbinOldState+5,R24
(0181) 		InsertCommand(slaveNum, &command);
    06861 E081      LDI	R24,1
    06862 9380 053C STS	stopTestFlag+8,R24
(0182) //		}
(0183) 	return 0;
    06864 C09E      RJMP	0x6903
    06865 2722      CLR	R18
    06866 2700      CLR	R16
    06867 940E 6B81 CALL	_SetEValve
    06869 E728      LDI	R18,0x78
    0686A E708      LDI	R16,0x78
(0184) }
(0185) unsigned char SlaveSetAddress(unsigned char address){
(0186) 	COMMAND_STRING command;
(0187) 	if(address>SLAVE_NUM)
    0686B E010      LDI	R17,0
    0686C DA35      RCALL	__DiluentMotRun
    0686D E82C      LDI	R18,0x8C
(0188) 		return 1;
    0686E EC08      LDI	R16,0xC8
    0686F E010      LDI	R17,0
(0189) 	command.cmd = COMMON_ADDRESS + 3;
    06870 DA18      RCALL	__EffluentMotRun
    06871 E12E      LDI	R18,0x1E
(0190) 	command.cmdLen = 1+3;
    06872 E030      LDI	R19,0
    06873 E00F      LDI	R16,0xF
(0191) 	command.pam[0] = CMD_MOT_SET_ADD;
    06874 940E 97B7 CALL	_SetDelayTime
(0192) 	command.pam[1] = address;
    06876 E082      LDI	R24,2
(0193) 	command.pam[2] = 0xff - address;
    06877 9380 053C STS	stopTestFlag+8,R24
    06879 C089      RJMP	0x6903
    0687A E023      LDI	R18,3
    0687B E030      LDI	R19,0
    0687C E00B      LDI	R16,0xB
    0687D 940E 97B7 CALL	_SetDelayTime
(0194) 	//InsertCommand(COMMON_ADDRESS, &command);
(0195) 	InsertCommand(COMMON_ADDRESS, &command);
    0687F 2700      CLR	R16
    06880 940E 6BE3 CALL	_ReadLiquidMonitorResult
(0196) 	//InsertUrgentCommand(address, &command);
(0197) 	return 0;
    06882 E009      LDI	R16,0x9
    06883 940E 6A0C CALL	_GetMotState
    06885 2F40      MOV	R20,R16
_SetEValve:
  state                --> R14
  command              --> Y,+0
  sw                   --> R10
  evNum                --> R12
    06886 3001      CPI	R16,1
    06887 F1C1      BEQ	0x68C0
    06888 E00B      LDI	R16,0xB
    06889 940E 6A0C CALL	_GetMotState
(0198) }
(0199) /*********************************************************************************************/
(0200) 
(0201) /************************************* 液路控制 **********************************************/
(0202) unsigned char SetEValve(unsigned char evNum, unsigned char sw){
(0203) 	// evNum:[1:5]阀编号，[0]为所有阀;
(0204) 	// sw:开光状态，0关闭，1打开
(0205) 	COMMAND_STRING command;
(0206) 	unsigned char state;
(0207) 	state = GetSlaveState(LIQUID_CONTROL);
    0688B 2F40      MOV	R20,R16
    0688C 3001      CPI	R16,1
    0688D F191      BEQ	0x68C0
    0688E E00F      LDI	R16,0xF
(0208) //	if(state==STA_SLAVE_FREE){	// 在电机为空闲状态下发送
(0209) 		command.cmd = (LIQUID_CONTROL << 3) + 3;
    0688F 940E 97C6 CALL	_WaitDelayTime
(0210) 		command.pam[0] = CMD_LIQ_SET_VALVE;
    06891 2EA0      MOV	R10,R16
    06892 2300      TST	R16
(0211) 		command.pam[1] = evNum;
    06893 F081      BEQ	0x68A4
(0212) 		command.pam[2] = sw;
    06894 2700      CLR	R16
(0213) 		command.cmdLen = 4;
    06895 940E 2DBB CALL	_GetLiquidMonitorState
(0214) 		
(0215) 		InsertCommand(LIQUID_CONTROL, &command);
    06897 2EA0      MOV	R10,R16
    06898 2D4A      MOV	R20,R10
    06899 300E      CPI	R16,0xE
    0689A F019      BEQ	0x689E
(0216) //		}
(0217) 	return 0;
    0689B 3100      CPI	R16,0x10
    0689C F009      BEQ	0x689E
    0689D C065      RJMP	0x6903
    0689E E12E      LDI	R18,0x1E
_GetLiquidState:
  state                --> R12
  command              --> Y,+0
  phNum                --> R10
    0689F E030      LDI	R19,0
    068A0 E00F      LDI	R16,0xF
    068A1 940E 97B7 CALL	_SetDelayTime
(0218) }
(0219) 
(0220) unsigned char GetLiquidState(unsigned char phNum){
(0221) 	// 获取液路传感器状态
(0222) 	COMMAND_STRING command;
(0223) 	unsigned char state;
(0224) 	state = GetSlaveState(LIQUID_CONTROL);
    068A3 C05F      RJMP	0x6903
    068A4 E009      LDI	R16,0x9
    068A5 940E 6A13 CALL	_MotStop
(0225) //	if(state==STA_SLAVE_FREE){	// 在电机为空闲状态下发送
(0226) 		command.cmd = (LIQUID_CONTROL<<3) + 2;
    068A7 E00B      LDI	R16,0xB
    068A8 940E 6A13 CALL	_MotStop
(0227) 		command.pam[0] = CMD_LIQ_GET_STATE;
    068AA 940E 3739 CALL	_SetBeepAck
(0228) 		command.pam[1] = phNum;
    068AC 9180 00C1 LDS	R24,0xC1
(0229) 		command.cmdLen = 3;
(0230) 		InsertCommand(LIQUID_CONTROL, &command);
    068AE 7E8F      ANDI	R24,0xEF
    068AF 9380 00C1 STS	0xC1,R24
    068B1 E529      LDI	R18,0x59
(0231) //		}
(0232) 	return 0;
    068B2 E039      LDI	R19,0x9
    068B3 E80F      LDI	R16,0x8F
    068B4 E016      LDI	R17,6
    068B5 940E A90D CALL	_uart_Printf
_SetLiquidMonitor:
  state                --> R14
  command              --> Y,+0
  mode                 --> R10
  phNum                --> R12
    068B7 9180 00C1 LDS	R24,0xC1
    068B9 6180      ORI	R24,0x10
    068BA 9380 00C1 STS	0xC1,R24
(0233) }
(0234) 
(0235) unsigned char SetLiquidMonitor(unsigned char phNum, unsigned char mode){
(0236) 	// 设置液路传感器监测模式
(0237) 	COMMAND_STRING command;
(0238) 	unsigned char state;
(0239) 	state = GetSlaveState(LIQUID_CONTROL);
    068BC E083      LDI	R24,3
    068BD 9380 053C STS	stopTestFlag+8,R24
    068BF C043      RJMP	0x6903
(0240) 	command.cmd = (LIQUID_CONTROL<<3) + 3;
    068C0 9020 165C LDS	R2,dustbinOldState+5
(0241) 	command.pam[0] = CMD_LIQ_SET_MONITOR;
    068C2 2022      TST	R2
    068C3 F0A1      BEQ	0x68D8
(0242) 	command.pam[1] = phNum;
    068C4 E009      LDI	R16,0x9
(0243) 	command.pam[2] = mode;		// 传感器工作模式 0：无效状态，1：普通模式，2：智能监测模式
    068C5 940E 6A13 CALL	_MotStop
(0244) 	command.cmdLen = 4;
    068C7 E00B      LDI	R16,0xB
(0245) 	InsertCommand(LIQUID_CONTROL, &command);
    068C8 940E 6A13 CALL	_MotStop
    068CA E124      LDI	R18,0x14
    068CB E030      LDI	R19,0
(0246) 	return 0;
    068CC E009      LDI	R16,0x9
    068CD 940E 97B7 CALL	_SetDelayTime
    068CF E081      LDI	R24,1
_StartLiquidMonitor:
  state                --> R12
  command              --> Y,+0
  phNum                --> R10
    068D0 9380 053C STS	stopTestFlag+8,R24
    068D2 9180 165C LDS	R24,dustbinOldState+5
(0247) }
(0248) 
(0249) unsigned char StartLiquidMonitor(unsigned char phNum){
(0250) 	// 启动液路传感器监测
(0251) 	COMMAND_STRING command;
(0252) 	unsigned char state;
(0253) 	state = GetSlaveState(LIQUID_CONTROL);
    068D4 5081      SUBI	R24,1
    068D5 9380 165C STS	dustbinOldState+5,R24
    068D7 C02B      RJMP	0x6903
(0254) 	command.cmd = (LIQUID_CONTROL<<3) + 2;
    068D8 E009      LDI	R16,0x9
    068D9 940E 6A13 CALL	_MotStop
(0255) 	command.pam[0] = CMD_LIQ_START_MONITOR;
    068DB E00B      LDI	R16,0xB
(0256) 	command.pam[1] = phNum;
    068DC 940E 6A13 CALL	_MotStop
(0257) 	command.cmdLen = 3;
    068DE 940E 372D CALL	_SetBeepWarning
(0258) 	InsertCommand(LIQUID_CONTROL, &command);
    068E0 9180 00C1 LDS	R24,0xC1
    068E2 7E8F      ANDI	R24,0xEF
(0259) 	return 0;
    068E3 9380 00C1 STS	0xC1,R24
    068E5 EF2C      LDI	R18,0xFC
    068E6 E134      LDI	R19,0x14
    068E7 E80F      LDI	R16,0x8F
_ReadLiquidMonitorResult:
  state                --> R12
  command              --> Y,+0
  phNum                --> R10
    068E8 E016      LDI	R17,6
    068E9 940E A90D CALL	_uart_Printf
    068EB 9180 00C1 LDS	R24,0xC1
(0260) }
(0261) 
(0262) unsigned char ReadLiquidMonitorResult(unsigned char phNum){
(0263) 	// 读取液路传感器监测结果
(0264) 	COMMAND_STRING command;
(0265) 	unsigned char state;
(0266) 	state = GetSlaveState(LIQUID_CONTROL);
    068ED 6180      ORI	R24,0x10
    068EE 9380 00C1 STS	0xC1,R24
(0267) 	command.cmd = (LIQUID_CONTROL<<3) + 2;
    068F0 E083      LDI	R24,3
    068F1 9380 053C STS	stopTestFlag+8,R24
(0268) 	command.pam[0] = CMD_LIQ_READ_MONITOR;
    068F3 C00F      RJMP	0x6903
(0269) 	command.pam[1] = phNum;
    068F4 ED2C      LDI	R18,0xDC
(0270) 	command.cmdLen = 3;
    068F5 E104      LDI	R16,0x14
    068F6 E010      LDI	R17,0
(0271) 	InsertCommand(LIQUID_CONTROL, &command);
    068F7 D991      RCALL	__EffluentMotRun
    068F8 E081      LDI	R24,1
    068F9 9380 1656 STS	CardScanfSW,R24
(0272) 	return 0;
    068FB E084      LDI	R24,4
    068FC 9380 053C STS	stopTestFlag+8,R24
    068FE 2422      CLR	R2
    068FF 9220 053C STS	stopTestFlag+8,R2
    06901 E001      LDI	R16,1
    06902 C001      RJMP	0x6904
(0273) }
(0274) 
(0275) unsigned char SetLiquidPhotoAdjust(unsigned char phNum){
(0276) 	// 校准液路光耦
(0277) 	COMMAND_STRING command;
(0278) 	
(0279) 	command.cmd = (LIQUID_CONTROL<<3) + 2;
    06903 2700      CLR	R16
    06904 940C AE88 JMP	pop_xgset300C
(0280) 	command.pam[0] = CMD_LIQ_CAL_PHOTO;
__ManualPrimingFluid:
    06906 940E AE83 CALL	push_xgset300C
(0281) 	command.pam[1] = phNum;
    06908 E00B      LDI	R16,0xB
    06909 940E 97C6 CALL	_WaitDelayTime
(0282) 	command.cmdLen = 3;
(0283) 	InsertCommand(LIQUID_CONTROL, &command);
    0690B 2300      TST	R16
    0690C F011      BEQ	0x690F
    0690D 2700      CLR	R16
(0284) 	return 0;
    0690E C0D7      RJMP	0x69E6
    0690F E009      LDI	R16,0x9
    06910 940E 97C6 CALL	_WaitDelayTime
_GetLiquidPhotoInfo:
  command              --> Y,+0
    06912 2300      TST	R16
(0285) }
(0286) 
(0287) unsigned char GetLiquidPhotoInfo(void){
(0288) 	// 获取液路传感器输出值
(0289) 	COMMAND_STRING command;
(0290) 	
(0291) 	command.cmd = (LIQUID_CONTROL<<3) + 1;
    06913 F011      BEQ	0x6916
    06914 2700      CLR	R16
(0292) 	command.pam[0] = CMD_LIQ_GET_PHOTO;
    06915 C0D0      RJMP	0x69E6
    06916 9020 1656 LDS	R2,CardScanfSW
(0293) 	command.cmdLen = 2;
    06918 2022      TST	R2
(0294) 	InsertCommand(LIQUID_CONTROL, &command);
    06919 F059      BEQ	0x6925
    0691A E00B      LDI	R16,0xB
    0691B 940E 6A0C CALL	_GetMotState
(0295) 	return 0;
    0691D 2F40      MOV	R20,R16
    0691E 3001      CPI	R16,1
    0691F F011      BEQ	0x6922
_LiquidFlowCheck:
  command              --> Y,+0
  liqNum               --> R10
    06920 2700      CLR	R16
    06921 C0C4      RJMP	0x69E6
    06922 2422      CLR	R2
(0296) }
(0297) 
(0298) unsigned char LiquidFlowCheck(unsigned char liqNum){
(0299) 	// 液路流量检查
(0300) 	COMMAND_STRING command;
(0301) 
(0302) 	command.cmd = (LIQUID_CONTROL<<3) + 2;
    06923 9220 1656 STS	CardScanfSW,R2
(0303) 	command.pam[0] = CMD_LIQ_FLOW_CHECK;
    06925 9140 053D LDS	R20,stopTestFlag+9
(0304) 	command.pam[1] = liqNum;
    06927 2755      CLR	R21
(0305) 	command.cmdLen = 3;
    06928 3040      CPI	R20,0
    06929 0745      CPC	R20,R21
(0306) 	InsertCommand(LIQUID_CONTROL, &command);
    0692A F099      BEQ	0x693E
    0692B 3041      CPI	R20,1
    0692C E0E0      LDI	R30,0
    0692D 075E      CPC	R21,R30
(0307) 	return 0;
    0692E F0B1      BEQ	0x6945
    0692F 3042      CPI	R20,2
    06930 E0E0      LDI	R30,0
    06931 075E      CPC	R21,R30
_GetStoreState:
  command              --> Y,+0
  chNum                --> R20
    06932 F131      BEQ	0x6959
    06933 3043      CPI	R20,3
    06934 E0E0      LDI	R30,0
(0308) }
(0309) /*********************************************************************************************/
(0310) 
(0311) /************************************* 片仓控制 **********************************************/
(0312) 
(0313) unsigned char GetStoreState(unsigned  char chNum){
(0314) 	// 获取片仓状态,0:所有片仓状态;1:指定片仓状态.
(0315) 	// 0xff:片仓打开,状态无效
(0316) 	// 0/
(0317) 	// 0~3:片仓状态
(0318) 	COMMAND_STRING command;
(0319) 	if(chNum>6)
    06935 075E      CPC	R21,R30
    06936 F409      BNE	0x6938
    06937 C09D      RJMP	0x69D5
(0320) 		chNum = 6;
    06938 3044      CPI	R20,4
(0321) 	command.cmd = (STORE_MONITOR<<3) + 2;
    06939 E0E0      LDI	R30,0
    0693A 075E      CPC	R21,R30
(0322) 	command.pam[0] = CMD_STORE_GET_STATE;
    0693B F409      BNE	0x693D
    0693C C0A3      RJMP	0x69E0
(0323) 	command.pam[1] = chNum;
    0693D C0A7      RJMP	0x69E5
(0324) 	command.cmdLen = 3;
    0693E E085      LDI	R24,5
    0693F 9380 165C STS	dustbinOldState+5,R24
(0325) 	InsertCommand(STORE_MONITOR, &command);
    06941 E081      LDI	R24,1
    06942 9380 053D STS	stopTestFlag+9,R24
(0326) 	return 0;
    06944 C0A0      RJMP	0x69E5
    06945 E32C      LDI	R18,0x3C
    06946 E604      LDI	R16,0x64
    06947 E010      LDI	R17,0
_SetStoreCAL:
  command              --> Y,+0
  num                  --> R10
    06948 D91B      RCALL	__FluidMotRun
    06949 E32C      LDI	R18,0x3C
    0694A E609      LDI	R16,0x69
(0327) }
(0328) 
(0329) unsigned char SetStoreCAL(unsigned char num){
(0330) 	// 片仓光路校准
(0331) 	COMMAND_STRING command;
(0332) 
(0333) 	command.cmd = (STORE_MONITOR<<3) + 2;
    0694B E010      LDI	R17,0
    0694C D93C      RCALL	__EffluentMotRun
(0334) 	command.pam[0] = CMD_STORE_CAL;
    0694D E228      LDI	R18,0x28
    0694E E030      LDI	R19,0
(0335) 	command.pam[1] = num;
    0694F E00F      LDI	R16,0xF
(0336) 	command.cmdLen = 3;
    06950 940E 97B7 CALL	_SetDelayTime
(0337) 	InsertCommand(STORE_MONITOR, &command);
    06952 E001      LDI	R16,1
    06953 940E 6BE3 CALL	_ReadLiquidMonitorResult
(0338) 	return 0;
    06955 E082      LDI	R24,2
    06956 9380 053D STS	stopTestFlag+9,R24
    06958 C08C      RJMP	0x69E5
_GetStorePhoVol:
  command              --> Y,+0
  num                  --> R10
    06959 E023      LDI	R18,3
    0695A E030      LDI	R19,0
    0695B E00B      LDI	R16,0xB
(0339) }
(0340) 
(0341) unsigned char GetStorePhoVol(unsigned char num){
(0342) 	// 获取光路电压值
(0343) 	COMMAND_STRING command;
(0344) //	if(num == 0)
(0345) //		num = 1;
(0346) //	if(num>6)
(0347) //		num = 6;
(0348) 	command.cmd = (STORE_MONITOR<<3) + 2;
    0695C 940E 97B7 CALL	_SetDelayTime
(0349) 	command.pam[0] = CMD_STORE_GET_VOL;
    0695E E001      LDI	R16,1
    0695F 940E 6BE3 CALL	_ReadLiquidMonitorResult
(0350) 	command.pam[1] = num;
    06961 E00B      LDI	R16,0xB
    06962 940E 6A0C CALL	_GetMotState
(0351) 	command.cmdLen = 3;
(0352) 	InsertCommand(STORE_MONITOR, &command);
    06964 2F40      MOV	R20,R16
    06965 3001      CPI	R16,1
    06966 F1D1      BEQ	0x69A1
(0353) 	return 0;
    06967 E00A      LDI	R16,0xA
    06968 940E 6A0C CALL	_GetMotState
    0696A 2F40      MOV	R20,R16
_SetStoreDoorOpen:
  command              --> Y,+0
  num                  --> R10
    0696B 3001      CPI	R16,1
    0696C F1A1      BEQ	0x69A1
    0696D E00F      LDI	R16,0xF
(0354) }
(0355) 
(0356) unsigned char SetStoreDoorOpen(unsigned char num){
(0357) 	// 开启片仓门
(0358) 	COMMAND_STRING command;
(0359) //	if(num == 0)
(0360) //		num = 1;
(0361) //	if(num>6)
(0362) //		num = 6;
(0363) 	command.cmd = (STORE_MONITOR<<3) + 2;
    0696E 940E 97C6 CALL	_WaitDelayTime
(0364) 	command.pam[0] = CMD_STORE_OPEN;
    06970 2EA0      MOV	R10,R16
    06971 2300      TST	R16
(0365) 	command.pam[1] = num;
    06972 F091      BEQ	0x6985
(0366) 	command.cmdLen = 3;
    06973 E001      LDI	R16,1
    06974 940E 2DBB CALL	_GetLiquidMonitorState
(0367) 	InsertCommand(STORE_MONITOR, &command);
    06976 2EA0      MOV	R10,R16
    06977 92A0 1636 STS	EvenPosChangeProcess+44,R10
(0368) 	return 0;
    06979 2D4A      MOV	R20,R10
    0697A 300E      CPI	R16,0xE
    0697B F019      BEQ	0x697F
    0697C 3100      CPI	R16,0x10
_TWI_RW:
  i                    --> Y,+1
  len                  --> R10
  ptr                  --> R12
  addr                 --> R18
  sla                  --> R16
    0697D F009      BEQ	0x697F
    0697E C066      RJMP	0x69E5
    0697F E228      LDI	R18,0x28
    06980 E030      LDI	R19,0
    06981 E00F      LDI	R16,0xF
    06982 940E 97B7 CALL	_SetDelayTime
FILE: D:\Work\主控软件\2032A2~1\IIC.c
(0001) 
(0002) 
(0003) #include <iom1280v.h>
(0004) #include "B1404_LIB.h"
(0005) #include "LibCommon.h"
(0006) 
(0007) 
(0008) 
(0009) /* Master */
(0010) #define TW_START			0x08	//START已发送
(0011) #define TW_REP_START		0x10//重复START已发送
(0012) /* Master Transmitter */
(0013) #define TW_MT_SLA_ACK		0x18//SLA+W 已发送收到ACK  
(0014) #define TW_MT_SLA_NACK		0x20//SLA+W 已发送接收到NOT ACK 
(0015) #define TW_MT_DATA_ACK		0x28//数据已发送接收到ACK  
(0016) #define TW_MT_DATA_NACK		0x30//数据已发送接收到NOT ACK 
(0017) #define TW_MT_ARB_LOST		0x38//SLA+W 或数据的仲裁失败从发送状态码
(0018) /* Master Receiver */
(0019) #define TW_MR_ARB_LOST		0x38	//
(0020) #define TW_MR_SLA_ACK		0x40
(0021) #define TW_MR_SLA_NACK		0x48	//
(0022) #define TW_MR_DATA_ACK		0x50	//
(0023) #define TW_MR_DATA_NACK		0x58	//
(0024) /* Slave Receiver */
(0025) #define TW_SR_SLA_ACK				0x60	//
(0026) #define TW_SR_ARB_LOST_SLA_ACK		0x68	//
(0027) #define TW_SR_GCALL_ACK				0x70	//
(0028) #define TW_SR_ARB_LOST_GCALL_ACK	0x78	//
(0029) #define TW_SR_DATA_ACK				0x80	//
(0030) #define TW_SR_DATA_NACK				0x88	//
(0031) #define TW_SR_GCALL_DATA_ACK		0x90	//
(0032) #define TW_SR_GCALL_DATA_NACK		0x98	//
(0033) #define TW_SR_STOP					0xA0	//
(0034) /* Slave Transmitter */
(0035) #define TW_ST_SLA_ACK			0xA8	//自己的SLA+R 已经被接收ACK 已返回
(0036) #define TW_ST_ARB_LOST_SLA_ACK	0xB0	//SLA+R/W 作为主机的仲裁失败；自己的SLA+R 已经被接收ACK 已返回
(0037) #define TW_ST_DATA_ACK			0xB8	//TWDR 里数据已经发送接收到ACK  
(0038) #define TW_ST_DATA_NACK			0xC0	//TWDR 里数据已经发送接收到NOT ACK  
(0039) #define TW_ST_LAST_DATA			0xC8	//TWDR 的一字节数据已经发送(TWAE = “0”);接收到ACK 
(0040) 
(0041) //管脚定义 
(0042) #define  pinSCL    0     //PC0 SCL 
(0043) #define  pinSDA    1     //PC1 SDA  
(0044) #define F_CPU	14745600
(0045) #define fSCL    100000    			 
(0046) #if F_CPU < fSCL*36   
(0047) 	#define TWBR_SET    10;     	
(0048) #else   
(0049) 	#define TWBR_SET    (F_CPU/fSCL-16)/2;			//计算TWBR值 
(0050) #endif 
(0051) #define TW_ACT    (1<<TWINT)|(1<<TWEN)|(1<<TWIE) 	
(0052) 
(0053) #define SLA_24CXX   	0xA0    	
(0054) #define ADDR_24C256		0x00 
(0055) //TWI_操作状态 
(0056) #define TW_BUSY		0 
(0057) #define TW_OK		1 
(0058) #define TW_FAIL		2 
(0059) //TWI_读写命令状态 
(0060) #define OP_BUSY		0 
(0061) #define OP_RUN		1  
(0062) 
(0063) //TWI读写操作公共步骤 
(0064) #define ST_FAIL		0 		// 出错状态 
(0065) #define ST_START	1 		// START状态检查 
(0066) #define ST_SLAW		2 		// SLAW状态检查 
(0067) #define ST_WADDR_H	3		// 
(0068) #define ST_WADDR_L	4 		// ADDR状态检查 
(0069) //TWI读操作步骤 
(0070) #define ST_RESTART  5 		// RESTART状态检查 
(0071) #define ST_SLAR		6		// SLAR状态检查 
(0072) #define ST_RDATA	7		// 读取数据状态检查，循环n字节 
(0073) //TWI写操作步骤 
(0074) #define ST_WDATA	8		// 写数据状态检查，循环n字节 
(0075) #define FAIL_MAX	20		// 重试次数最大值  
(0076) 
(0077) #define TW_READ		1
(0078) #define TW_WRITE	0
(0079) 
(0080) //定义全局变量 
(0081) unsigned char ORGDATA[8]={0xAA,0xA5,0x55,0x5A,0x01,0x02,0x03,0x04}; //原始数据 
(0082) unsigned char CMPDATA[8];      	//比较数据 
(0083) unsigned char BUFFER[256];      //缓冲区，可以装载整个AC24C02的数据 
(0084) struct str_TWI{         //TWI数据结构 
(0085) 	volatile unsigned char STATUS;	//TWI_操作状态     
(0086) 	unsigned char SLA;      		//从设备的器件地址     
(0087) 	unsigned int ADDR;				//从设备的数据地址     
(0088) 	unsigned char *pBUF;			//数据缓冲区指针     
(0089) 	unsigned int DATALEN;			//数据长度     
(0090) 	unsigned char STATE;			//TWI读写操作步骤     
(0091) 	unsigned char FAILCNT;			//失败重试次数 
(0092) }; 
(0093) struct str_TWI strTWI;       //TWI的数据结构变量 
(0094) 
(0095) unsigned char TWI_RW(unsigned char sla,unsigned int addr,unsigned char *ptr,unsigned int len) {
(0096) 	unsigned char i;     
(0097) 	if (strTWI.STATUS==TW_BUSY){//TWI忙，不能进行操作         
    06984 C060      RJMP	0x69E5
    06985 E00A      LDI	R16,0xA
    06986 940E 6A13 CALL	_MotStop
(0098) 		return OP_BUSY;     
    06988 E00B      LDI	R16,0xB
(0099) 		}     
(0100) 	strTWI.STATUS=TW_BUSY;     
    06989 940E 6A13 CALL	_MotStop
    0698B 940E 3739 CALL	_SetBeepAck
(0101) //	i=(addr>>8)<<1;     
(0102) //	i&=0x06;         //考虑了24C04/08的EEPROM地址高位放在SLA里面     
(0103) //	strTWI.SLA=sla+i;    
(0104) 	strTWI.SLA=sla; 
    0698D 9180 00C1 LDS	R24,0xC1
(0105) 	strTWI.ADDR=addr;     
    0698F 7E8F      ANDI	R24,0xEF
    06990 9380 00C1 STS	0xC1,R24
(0106) 	strTWI.pBUF=ptr;     
    06992 E421      LDI	R18,0x41
    06993 E039      LDI	R19,0x9
    06994 E80F      LDI	R16,0x8F
    06995 E016      LDI	R17,6
(0107) 	strTWI.DATALEN=len;     
    06996 940E A90D CALL	_uart_Printf
    06998 9180 00C1 LDS	R24,0xC1
(0108) 	strTWI.STATE=ST_START; 
    0699A 6180      ORI	R24,0x10
    0699B 9380 00C1 STS	0xC1,R24
(0109) 	strTWI.FAILCNT=0;     
    0699D E083      LDI	R24,3
    0699E 9380 053D STS	stopTestFlag+9,R24
(0110) 	TWCR=(1<<TWSTA)|TW_ACT; 
    069A0 C044      RJMP	0x69E5
    069A1 9020 165C LDS	R2,dustbinOldState+5
(0111) 	return OP_RUN; 
    069A3 2022      TST	R2
    069A4 F0A1      BEQ	0x69B9
_twi_isr:
  action               --> R20
  status               --> R18
  state                --> R16
    069A5 E00A      LDI	R16,0xA
    069A6 940E 6A13 CALL	_MotStop
    069A8 E00B      LDI	R16,0xB
    069A9 940E 6A13 CALL	_MotStop
    069AB E124      LDI	R18,0x14
    069AC E030      LDI	R19,0
    069AD E009      LDI	R16,0x9
    069AE 940E 97B7 CALL	_SetDelayTime
    069B0 E081      LDI	R24,1
    069B1 9380 053D STS	stopTestFlag+9,R24
(0112) }  
(0113) 
(0114) #pragma interrupt_handler twi_isr:iv_TWI
(0115) void twi_isr(void) {
(0116) 	//IIC中断     
(0117) 	unsigned char action,state,status;     
(0118) 	action = strTWI.SLA & TW_READ;    
    069B3 9180 165C LDS	R24,dustbinOldState+5
(0119) 	state = strTWI.STATE;     
    069B5 5081      SUBI	R24,1
    069B6 9380 165C STS	dustbinOldState+5,R24
(0120) 	status = TWSR & 0xF8;  
    069B8 C02C      RJMP	0x69E5
    069B9 E00A      LDI	R16,0xA
(0121) 	if ((status>=0x60)||(status==0x00)){  
    069BA 940E 6A13 CALL	_MotStop
    069BC E00B      LDI	R16,0xB
    069BD 940E 6A13 CALL	_MotStop
(0122) 		return;     
    069BF 940E 372D CALL	_SetBeepWarning
    069C1 9180 00C1 LDS	R24,0xC1
    069C3 7E8F      ANDI	R24,0xEF
    069C4 9380 00C1 STS	0xC1,R24
    069C6 ED2B      LDI	R18,0xDB
    069C7 E134      LDI	R19,0x14
    069C8 E80F      LDI	R16,0x8F
    069C9 E016      LDI	R17,6
    069CA 940E A90D CALL	_uart_Printf
    069CC 9180 00C1 LDS	R24,0xC1
    069CE 6180      ORI	R24,0x10
    069CF 9380 00C1 STS	0xC1,R24
    069D1 E083      LDI	R24,3
    069D2 9380 053D STS	stopTestFlag+9,R24
    069D4 C010      RJMP	0x69E5
    069D5 ED2C      LDI	R18,0xDC
    069D6 E104      LDI	R16,0x14
    069D7 E010      LDI	R17,0
    069D8 D8B0      RCALL	__EffluentMotRun
    069D9 E081      LDI	R24,1
    069DA 9380 1656 STS	CardScanfSW,R24
    069DC E084      LDI	R24,4
    069DD 9380 053D STS	stopTestFlag+9,R24
    069DF C005      RJMP	0x69E5
    069E0 2422      CLR	R2
    069E1 9220 053D STS	stopTestFlag+9,R2
    069E3 E001      LDI	R16,1
    069E4 C001      RJMP	0x69E6
    069E5 2700      CLR	R16
    069E6 940C AE88 JMP	pop_xgset300C
(0123) 		}     
(0124) 	switch(state){     
(0125) 		case ST_START:						//START状态检查         
(0126) 			if(status==TW_START) {			
_SetCleanMode:
    069E8 92AA      ST	-Y,R10
    069E9 2EA0      MOV	R10,R16
(0127) 				TWDR = strTWI.SLA & 0xFE;	         
    069EA 9722      SBIW	R28,2
    069EB E082      LDI	R24,2
    069EC 158A      CP	R24,R10
    069ED F408      BCC	0x69EF
    069EE 24AA      CLR	R10
(0128) 				TWCR = TW_ACT;				      
    069EF 9020 0530 LDS	R2,_AutoTestCycleNum+2
    069F1 2022      TST	R2
(0129) 				}         
    069F2 F4B1      BNE	0x6A09
(0130) 			else{	//发送start信号出错            
(0131) 				state=ST_FAIL;         
    069F3 92A0 0530 STS	_AutoTestCycleNum+2,R10
(0132) 				}
(0133) 			break;
    069F5 9180 00C1 LDS	R24,0xC1
(0134) 		case ST_SLAW: //SLAW状态检查
(0135) 			if(status==TW_MT_SLA_ACK){		//发送器件地址成功 
(0136) 				TWDR = (strTWI.ADDR&0xff00)>>8;    
    069F7 7E8F      ANDI	R24,0xEF
    069F8 9380 00C1 STS	0xC1,R24
    069FA 2C2A      MOV	R2,R10
    069FB 2433      CLR	R3
    069FC 8239      STD	Y+1,R3
    069FD 8228      ST	Y,R2
    069FE E725      LDI	R18,0x75
    069FF E131      LDI	R19,0x11
    06A00 E30E      LDI	R16,0x3E
(0137) 				TWCR = TW_ACT;                  
    06A01 E015      LDI	R17,5
    06A02 940E A90D CALL	_uart_Printf
(0138) 				}         
    06A04 9180 00C1 LDS	R24,0xC1
(0139) 			else{		//发送器件地址出错             
(0140) 				state=ST_FAIL;         
    06A06 6180      ORI	R24,0x10
(0141) 				}         
(0142) 			break;  
(0143) 		case ST_WADDR_H:	// 高字节地址已写入，开始写低字节地址
(0144) 			if(status==TW_MT_DATA_ACK){		
    06A07 9380 00C1 STS	0xC1,R24
(0145) 				TWDR = strTWI.ADDR&0x00ff; 
    06A09 9622      ADIW	R28,2
    06A0A 90A9      LD	R10,Y+
    06A0B 9508      RET
_GetMotState:
    06A0C 92AA      ST	-Y,R10
    06A0D 2EA0      MOV	R10,R16
    06A0E 2D0A      MOV	R16,R10
    06A0F 940E 1755 CALL	_GetSlaveState
(0146) 				TWCR = TW_ACT;                   
    06A11 90A9      LD	R10,Y+
    06A12 9508      RET
(0147) 				}         
_MotStop:
    06A13 934A      ST	-Y,R20
(0148) 			else{		//发送器件地址出错             
(0149) 				state=ST_FAIL;         
    06A14 2F40      MOV	R20,R16
(0150) 				}         
(0151) 			break;
    06A15 9728      SBIW	R28,0x8
(0152) 		case ST_WADDR_L:	// 低字节地址已写入
(0153) 			if(status==TW_MT_DATA_ACK){			//发送eeprom地址成功 
    06A16 304F      CPI	R20,0xF
    06A17 F010      BCS	0x6A1A
(0154) 				if (action==TW_READ){			
    06A18 E001      LDI	R16,1
    06A19 C00F      RJMP	0x6A29
(0155) 					TWCR=(1<<TWSTA)|TW_ACT;		
    06A1A 2F84      MOV	R24,R20
    06A1B 0F88      LSL	R24
    06A1C 0F88      LSL	R24
(0156) 					}             
    06A1D 0F88      LSL	R24
(0157) 				else{							
(0158) 					TWDR=*strTWI.pBUF++;		
    06A1E 5F8F      SUBI	R24,0xFF
    06A1F 8388      ST	Y,R24
    06A20 E082      LDI	R24,2
    06A21 838F      STD	Y+7,R24
    06A22 E089      LDI	R24,0x9
    06A23 8389      STD	Y+1,R24
    06A24 019E      MOVW	R18,R28
    06A25 2F04      MOV	R16,R20
    06A26 940E 1714 CALL	_InsertUrgentCommand
    06A28 2700      CLR	R16
(0159) 					strTWI.DATALEN--;
    06A29 9628      ADIW	R28,0x8
    06A2A 9149      LD	R20,Y+
    06A2B 9508      RET
_MotRun:
    06A2C 933A      ST	-Y,R19
    06A2D 932A      ST	-Y,R18
    06A2E 940E AEA5 CALL	push_xgset303C
    06A30 2F40      MOV	R20,R16
    06A31 9728      SBIW	R28,0x8
(0160) 					state=ST_WDATA-1;			
    06A32 84CE      LDD	R12,Y+14
(0161) 					TWCR=TW_ACT;				
    06A33 84DF      LDD	R13,Y+15
    06A34 01CE      MOVW	R24,R28
    06A35 960E      ADIW	R24,0xE
(0162) 					}
(0163) 				}
    06A36 015C      MOVW	R10,R24
(0164) 			else{								//发送eeprom地址出错
(0165) 				state=ST_FAIL;
    06A37 304F      CPI	R20,0xF
(0166) 				}
(0167) 			break;
    06A38 F010      BCS	0x6A3B
(0168) 		case ST_RESTART:					//RESTART状态检查，只有读操作模式才能跳到这里
(0169) 			if(status==TW_REP_START){		
    06A39 E001      LDI	R16,1
    06A3A C01B      RJMP	0x6A56
(0170) 				TWDR=strTWI.SLA;			
    06A3B 2F04      MOV	R16,R20
    06A3C 2711      CLR	R17
    06A3D 940E 2D92 CALL	_SetMotPosIdle
(0171) 				TWCR=TW_ACT;				
    06A3F 2F84      MOV	R24,R20
    06A40 0F88      LSL	R24
    06A41 0F88      LSL	R24
(0172) 				}
    06A42 0F88      LSL	R24
(0173) 			else{							
(0174) 				state=ST_FAIL;
    06A43 5F8D      SUBI	R24,0xFD
(0175) 				}
(0176) 			break;
    06A44 8388      ST	Y,R24
(0177) 		case ST_SLAR:						//SLAR状态检查，只有读操作模式才能跳到这里 
(0178) 			if(status==TW_MR_SLA_ACK){		
    06A45 E084      LDI	R24,4
    06A46 838F      STD	Y+7,R24
(0179) 				if (strTWI.DATALEN--){		
    06A47 84CE      LDD	R12,Y+14
    06A48 84DF      LDD	R13,Y+15
    06A49 E081      LDI	R24,1
    06A4A 8389      STD	Y+1,R24
    06A4B 01F5      MOVW	R30,R10
    06A4C 9021      LD	R2,Z+
    06A4D 015F      MOVW	R10,R30
    06A4E 822B      STD	Y+3,R2
    06A4F 8020      LD	R2,Z
    06A50 822A      STD	Y+2,R2
    06A51 019E      MOVW	R18,R28
    06A52 2F04      MOV	R16,R20
    06A53 940E 16BA CALL	_InsertCommand
(0180) 					TWCR=(1<<TWEA)|TW_ACT;	
    06A55 2700      CLR	R16
    06A56 9628      ADIW	R28,0x8
    06A57 940E AEAC CALL	pop_xgset303C
(0181) 					}
    06A59 9622      ADIW	R28,2
    06A5A 9508      RET
_MotRunTo:
    06A5B 940E AE83 CALL	push_xgset300C
(0182) 				else{						
(0183) 					TWCR=TW_ACT;			
(0184) 					}
(0185) 				}
    06A5D 0159      MOVW	R10,R18
(0186) 			else{							//发送器件地址出错
(0187) 				state=ST_FAIL;
(0188) 				}
(0189) 			break;
    06A5E 2F40      MOV	R20,R16
(0190) 		case ST_RDATA:						//读取数据状态检查，只有读操作模式才能跳到这里
(0191) 			state--;						
    06A5F 9728      SBIW	R28,0x8
(0192) 			if(status==TW_MR_DATA_ACK){		
    06A60 304F      CPI	R20,0xF
    06A61 F010      BCS	0x6A64
(0193) 				*strTWI.pBUF++=TWDR;
    06A62 E001      LDI	R16,1
    06A63 C018      RJMP	0x6A7C
    06A64 2F04      MOV	R16,R20
    06A65 2711      CLR	R17
    06A66 940E 2D92 CALL	_SetMotPosIdle
    06A68 2F84      MOV	R24,R20
    06A69 0F88      LSL	R24
    06A6A 0F88      LSL	R24
    06A6B 0F88      LSL	R24
    06A6C 5F8D      SUBI	R24,0xFD
(0194) 				if (strTWI.DATALEN--){		
    06A6D 8388      ST	Y,R24
    06A6E E084      LDI	R24,4
    06A6F 838F      STD	Y+7,R24
    06A70 E082      LDI	R24,2
    06A71 8389      STD	Y+1,R24
    06A72 0115      MOVW	R2,R10
    06A73 2C23      MOV	R2,R3
    06A74 2433      CLR	R3
    06A75 822A      STD	Y+2,R2
    06A76 82AB      STD	Y+3,R10
    06A77 019E      MOVW	R18,R28
    06A78 2F04      MOV	R16,R20
    06A79 940E 16BA CALL	_InsertCommand
(0195) 					TWCR=(1<<TWEA)|TW_ACT;
    06A7B 2700      CLR	R16
    06A7C 9628      ADIW	R28,0x8
    06A7D 940C AE88 JMP	pop_xgset300C
(0196) 					}
_MotRunToSite:
    06A7F 92AA      ST	-Y,R10
    06A80 934A      ST	-Y,R20
    06A81 2EA2      MOV	R10,R18
(0197) 				else{						
(0198) 					TWCR=TW_ACT;			
(0199) 					}
(0200) 				} 
    06A82 2F40      MOV	R20,R16
(0201) 			else if(status==TW_MR_DATA_NACK){	
    06A83 9728      SBIW	R28,0x8
    06A84 304F      CPI	R20,0xF
(0202) 				*strTWI.pBUF++=TWDR;
    06A85 F010      BCS	0x6A88
    06A86 E001      LDI	R16,1
    06A87 C013      RJMP	0x6A9B
    06A88 2F04      MOV	R16,R20
    06A89 2711      CLR	R17
    06A8A 940E 2D92 CALL	_SetMotPosIdle
    06A8C 2F84      MOV	R24,R20
    06A8D 0F88      LSL	R24
    06A8E 0F88      LSL	R24
    06A8F 0F88      LSL	R24
(0203) 				TWCR=(1<<TWSTO)|TW_ACT;   
    06A90 5F8E      SUBI	R24,0xFE
    06A91 8388      ST	Y,R24
    06A92 E083      LDI	R24,3
(0204) 				strTWI.STATUS=TW_OK;
    06A93 838F      STD	Y+7,R24
    06A94 8389      STD	Y+1,R24
    06A95 82AA      STD	Y+2,R10
(0205) 				}
    06A96 019E      MOVW	R18,R28
(0206) 			else{							//读取数据出错
(0207) 				state=ST_FAIL;
    06A97 2F04      MOV	R16,R20
(0208) 				}
(0209) 			break; 
    06A98 940E 16BA CALL	_InsertCommand
(0210) 		case ST_WDATA:						//写数据状态检查，只有写操作模式才能跳到这里
(0211) 			state--;						
    06A9A 2700      CLR	R16
    06A9B 9628      ADIW	R28,0x8
(0212) 			if(status==TW_MT_DATA_ACK) {	
(0213) 				if (strTWI.DATALEN) {		
    06A9C 9149      LD	R20,Y+
    06A9D 90A9      LD	R10,Y+
    06A9E 9508      RET
_SetMotRunPam:
    06A9F 940E AE7A CALL	push_xgset30FC
    06AA1 2EE2      MOV	R14,R18
    06AA2 2F40      MOV	R20,R16
    06AA3 9728      SBIW	R28,0x8
(0214) 					TWDR=*strTWI.pBUF++; 
    06AA4 88C8      LDD	R12,Y+16
    06AA5 88AA      LDD	R10,Y+18
    06AA6 304F      CPI	R20,0xF
    06AA7 F010      BCS	0x6AAA
    06AA8 E001      LDI	R16,1
    06AA9 C012      RJMP	0x6ABC
    06AAA 2F84      MOV	R24,R20
    06AAB 0F88      LSL	R24
    06AAC 0F88      LSL	R24
    06AAD 0F88      LSL	R24
    06AAE 5F8C      SUBI	R24,0xFC
(0215) 					strTWI.DATALEN--;  
    06AAF 8388      ST	Y,R24
    06AB0 E084      LDI	R24,4
    06AB1 8389      STD	Y+1,R24
    06AB2 82EA      STD	Y+2,R14
    06AB3 82CB      STD	Y+3,R12
    06AB4 82AC      STD	Y+4,R10
    06AB5 E085      LDI	R24,5
    06AB6 838F      STD	Y+7,R24
    06AB7 019E      MOVW	R18,R28
(0216) 					TWCR=TW_ACT;
    06AB8 2F04      MOV	R16,R20
    06AB9 940E 16BA CALL	_InsertCommand
(0217) 					//触发下一步动作
(0218) 					} 
    06ABB 2700      CLR	R16
(0219) 				else  {						//写够了
(0220) 					TWCR=(1<<TWSTO)|TW_ACT;
    06ABC 9628      ADIW	R28,0x8
    06ABD 940C AE64 JMP	pop_xgset30FC
(0221) 					strTWI.STATUS=TW_OK;  
_MotSetLock:
    06ABF 92AA      ST	-Y,R10
    06AC0 934A      ST	-Y,R20
    06AC1 2EA2      MOV	R10,R18
(0222) 					} 
(0223) 				} 
    06AC2 2F40      MOV	R20,R16
(0224) 			else  {							//写数据失败
(0225) 				state=ST_FAIL; 
    06AC3 9728      SBIW	R28,0x8
(0226) 				}  
(0227) 			break; 
    06AC4 304F      CPI	R20,0xF
(0228) 		default:						//错误状态
(0229) 			state=ST_FAIL; 
    06AC5 F010      BCS	0x6AC8
(0230) 			break; 
(0231) 		}  
(0232) 	if (state==ST_FAIL) {				//错误处理
    06AC6 E001      LDI	R16,1
    06AC7 C010      RJMP	0x6AD8
(0233) 		strTWI.FAILCNT++;  
    06AC8 2F84      MOV	R24,R20
    06AC9 0F88      LSL	R24
    06ACA 0F88      LSL	R24
    06ACB 0F88      LSL	R24
    06ACC 5F8E      SUBI	R24,0xFE
(0234) 		if (strTWI.FAILCNT<FAIL_MAX) {	
    06ACD 8388      ST	Y,R24
    06ACE E083      LDI	R24,3
(0235) 			TWCR=(1<<TWSTA)|TW_ACT;		
    06ACF 838F      STD	Y+7,R24
    06AD0 2422      CLR	R2
    06AD1 8229      STD	Y+1,R2
(0236) 			} 
    06AD2 82AA      STD	Y+2,R10
(0237) 		else  {							
(0238) 			TWCR=(1<<TWSTO)|TW_ACT;		
    06AD3 019E      MOVW	R18,R28
    06AD4 2F04      MOV	R16,R20
    06AD5 940E 16BA CALL	_InsertCommand
(0239) 			strTWI.STATUS=TW_FAIL; 
    06AD7 2700      CLR	R16
    06AD8 9628      ADIW	R28,0x8
(0240) 			}
(0241) 		}  
(0242) 	state++;  
    06AD9 9149      LD	R20,Y+
(0243) 	strTWI.STATE=state;					//保存状态
    06ADA 90A9      LD	R10,Y+
    06ADB 9508      RET
_MotSetEnable:
    06ADC 940E AD5F CALL	push_arg4
    06ADE 2700      CLR	R16
    06ADF 9624      ADIW	R28,4
    06AE0 9508      RET
_GetMotPositionFromSlave:
    06AE1 934A      ST	-Y,R20
    06AE2 2F40      MOV	R20,R16
    06AE3 9728      SBIW	R28,0x8
    06AE4 304F      CPI	R20,0xF
    06AE5 F010      BCS	0x6AE8
    06AE6 E001      LDI	R16,1
    06AE7 C00F      RJMP	0x6AF7
    06AE8 2F84      MOV	R24,R20
    06AE9 0F88      LSL	R24
(0244) }  
(0245) 
(0246) void TWI_Init(void){  
(0247) 	PORTD |= 0x03;		//SCL,SDA使能了内部的10K上拉电阻
_TWI_Init:
    06AEA 0F88      LSL	R24
    06AEB 0F88      LSL	R24
    06AEC 5F8F      SUBI	R24,0xFF
(0248) 	DDRD &= 0xFC; 		// 配置为输入引脚
    06AED 8388      ST	Y,R24
    06AEE E082      LDI	R24,2
    06AEF 838F      STD	Y+7,R24
(0249) 	//TWI初始化
(0250) 	TWSR=0x00;			//预分频=0^4=1 
    06AF0 E085      LDI	R24,5
    06AF1 8389      STD	Y+1,R24
    06AF2 019E      MOVW	R18,R28
(0251) 	TWBR=TWBR_SET;   
    06AF3 2F04      MOV	R16,R20
    06AF4 940E 16BA CALL	_InsertCommand
(0252) 	TWAR=0x00;			//主机模式，该地址无效
    06AF6 2700      CLR	R16
    06AF7 9628      ADIW	R28,0x8
(0253) 	TWCR=0x00;			//关闭TWI模块
    06AF8 9149      LD	R20,Y+
    06AF9 9508      RET
(0254) 	strTWI.STATUS=TW_OK; 
_MotInitCheck:
    06AFA 92AA      ST	-Y,R10
    06AFB 934A      ST	-Y,R20
    06AFC 2F40      MOV	R20,R16
    06AFD 9728      SBIW	R28,0x8
_AT24C256_Read:
  len                  --> R14
  ptr                  --> R12
  addr                 --> R10
    06AFE 304F      CPI	R20,0xF
    06AFF F010      BCS	0x6B02
    06B00 E001      LDI	R16,1
    06B01 C017      RJMP	0x6B19
    06B02 2F04      MOV	R16,R20
    06B03 940E 1755 CALL	_GetSlaveState
(0255) }
(0256) 
(0257) unsigned char AT24C256_Read(unsigned int addr,unsigned char *ptr,unsigned int len){
(0258) 	return TWI_RW(SLA_24CXX+(ADDR_24C256<<1)+TW_READ,addr,ptr,len);	
    06B05 2EA0      MOV	R10,R16
    06B06 2F04      MOV	R16,R20
    06B07 2711      CLR	R17
    06B08 940E 2D92 CALL	_SetMotPosIdle
    06B0A 2F84      MOV	R24,R20
    06B0B 0F88      LSL	R24
    06B0C 0F88      LSL	R24
    06B0D 0F88      LSL	R24
    06B0E 5F8F      SUBI	R24,0xFF
_AT24C256_Write:
  len                  --> R14
  ptr                  --> R12
  addr                 --> R10
    06B0F 8388      ST	Y,R24
    06B10 E082      LDI	R24,2
    06B11 838F      STD	Y+7,R24
    06B12 E086      LDI	R24,6
    06B13 8389      STD	Y+1,R24
    06B14 019E      MOVW	R18,R28
    06B15 2F04      MOV	R16,R20
(0259) }
(0260) unsigned char AT24C256_Write(unsigned int addr,unsigned char *ptr,unsigned int len){
(0261) 	return TWI_RW(SLA_24CXX+(ADDR_24C256<<1)+TW_WRITE,addr,ptr,len);	
    06B16 940E 16BA CALL	_InsertCommand
    06B18 2700      CLR	R16
    06B19 9628      ADIW	R28,0x8
    06B1A 9149      LD	R20,Y+
    06B1B 90A9      LD	R10,Y+
    06B1C 9508      RET
_MotAdjustPosition:
    06B1D 940E AEA5 CALL	push_xgset303C
    06B1F 0159      MOVW	R10,R18
FILE: D:\Work\主控软件\2032A2~1\Libcommon.c
(0001) 
(0002) #include <iom1280v.h>
(0003) #include "B1404_LIB.h"
(0004) #include "LibCommon.h"
(0005) #include "eeprom.h"
(0006) 
(0007) 
(0008) /*********************** 泵定标 ****************************/
(0009) 
(0010) FLOW_CAL_CHART _DiluentCalChart;
(0011) unsigned int DiluentCoff[14];		// 稀释校准因数，校准吸样量，反向因数，值越大调整结果越小
(0012) 
(0013) unsigned int _FlowNum0, _FlowNum1;
(0014) 
(0015) // 初始化流量定标判断
(0016) void InitFlowMeter(void){
(0017) 	_FlowNum0 = 0;
_InitFlowMeter:
    06B20 2F40      MOV	R20,R16
    06B21 9728      SBIW	R28,0x8
    06B22 304F      CPI	R20,0xF
    06B23 F010      BCS	0x6B26
    06B24 E001      LDI	R16,1
    06B25 C018      RJMP	0x6B3E
(0018) 	_FlowNum1 = 0;
    06B26 2F04      MOV	R16,R20
    06B27 940E 1755 CALL	_GetSlaveState
    06B29 2EC0      MOV	R12,R16
    06B2A 2F04      MOV	R16,R20
_JudgeFlowMeter:
  m                    --> R14
  n                    --> R10
  i                    --> R12
    06B2B 2711      CLR	R17
    06B2C 940E 2D92 CALL	_SetMotPosIdle
(0019) }
(0020) 
(0021) // 流量定标数据判断处理
(0022) unsigned int JudgeFlowMeter(unsigned int i)
(0023) {
(0024) 	unsigned int m, n;
(0025) 	if(_FlowNum0 == 0)
    06B2E 2F84      MOV	R24,R20
    06B2F 0F88      LSL	R24
    06B30 0F88      LSL	R24
    06B31 0F88      LSL	R24
    06B32 5F8E      SUBI	R24,0xFE
    06B33 8388      ST	Y,R24
    06B34 E083      LDI	R24,3
    06B35 838F      STD	Y+7,R24
(0026) 	{
(0027) 		_FlowNum0 = i;
    06B36 E087      LDI	R24,7
    06B37 8389      STD	Y+1,R24
    06B38 82AA      STD	Y+2,R10
    06B39 019E      MOVW	R18,R28
(0028) 		return 0;
    06B3A 2F04      MOV	R16,R20
    06B3B 940E 16BA CALL	_InsertCommand
(0029) 	}
(0030) 	if(_FlowNum1 == 0)
    06B3D 2700      CLR	R16
    06B3E 9628      ADIW	R28,0x8
    06B3F 940C AEAC JMP	pop_xgset303C
_MotSetPam:
    06B41 940E AE7A CALL	push_xgset30FC
    06B43 2EC2      MOV	R12,R18
    06B44 2F40      MOV	R20,R16
(0031) 	{
(0032) 		_FlowNum1 = i;
    06B45 9728      SBIW	R28,0x8
    06B46 88A8      LDD	R10,Y+16
    06B47 304F      CPI	R20,0xF
    06B48 F010      BCS	0x6B4B
(0033) 	}
    06B49 E001      LDI	R16,1
(0034) 	else
(0035) 	{
(0036) 		m = AbsDifference(i, _FlowNum0);
    06B4A C015      RJMP	0x6B60
    06B4B 2F04      MOV	R16,R20
    06B4C 940E 1755 CALL	_GetSlaveState
    06B4E 2EE0      MOV	R14,R16
    06B4F 2F84      MOV	R24,R20
    06B50 0F88      LSL	R24
(0037) 		n = AbsDifference(i, _FlowNum1);
    06B51 0F88      LSL	R24
    06B52 0F88      LSL	R24
    06B53 5F8D      SUBI	R24,0xFD
    06B54 8388      ST	Y,R24
    06B55 E084      LDI	R24,4
    06B56 838F      STD	Y+7,R24
    06B57 E088      LDI	R24,0x8
(0038) 		if(m > n)
    06B58 8389      STD	Y+1,R24
    06B59 82CA      STD	Y+2,R12
    06B5A 82AB      STD	Y+3,R10
(0039) 		{
(0040) 			if(n <= 8)
    06B5B 019E      MOVW	R18,R28
    06B5C 2F04      MOV	R16,R20
    06B5D 940E 16BA CALL	_InsertCommand
    06B5F 2700      CLR	R16
(0041) 				_FlowNum0 = i;
    06B60 9628      ADIW	R28,0x8
    06B61 940C AE64 JMP	pop_xgset30FC
_SlaveSetAddress:
    06B63 92AA      ST	-Y,R10
    06B64 2EA0      MOV	R10,R16
(0042) 			else
(0043) 			{
(0044) 				_FlowNum0 = 0;
    06B65 9728      SBIW	R28,0x8
    06B66 E08F      LDI	R24,0xF
    06B67 158A      CP	R24,R10
    06B68 F410      BCC	0x6B6B
    06B69 E001      LDI	R16,1
    06B6A C013      RJMP	0x6B7E
(0045) 				_FlowNum1 = 0;
    06B6B E083      LDI	R24,3
    06B6C 8388      ST	Y,R24
    06B6D E084      LDI	R24,4
    06B6E 838F      STD	Y+7,R24
(0046) 				return 0;
    06B6F E087      LDI	R24,7
    06B70 8389      STD	Y+1,R24
    06B71 82AA      STD	Y+2,R10
(0047) 			}
(0048) 		}
(0049) 		else
(0050) 		{
(0051) 			if(m <= 8)
    06B72 2C2A      MOV	R2,R10
    06B73 2433      CLR	R3
    06B74 EF8F      LDI	R24,0xFF
    06B75 E090      LDI	R25,0
    06B76 1982      SUB	R24,R2
(0052) 				_FlowNum1 = i;
    06B77 0993      SBC	R25,R3
    06B78 838B      STD	Y+3,R24
    06B79 019E      MOVW	R18,R28
    06B7A 2700      CLR	R16
    06B7B 940E 16BA CALL	_InsertCommand
(0053) 			else
(0054) 			{
(0055) 				_FlowNum0 = 0;
    06B7D 2700      CLR	R16
    06B7E 9628      ADIW	R28,0x8
    06B7F 90A9      LD	R10,Y+
    06B80 9508      RET
_SetEValve:
    06B81 940E AE7C CALL	push_xgset00FC
(0056) 				_FlowNum1 = 0;
    06B83 2EA2      MOV	R10,R18
    06B84 2EC0      MOV	R12,R16
    06B85 9728      SBIW	R28,0x8
(0057) 				return 0;
    06B86 E00D      LDI	R16,0xD
    06B87 940E 1755 CALL	_GetSlaveState
(0058) 			}
(0059) 		}
(0060) 	}
(0061) 	n = AbsDifference(_FlowNum0, _FlowNum1);
    06B89 2EE0      MOV	R14,R16
    06B8A E68B      LDI	R24,0x6B
    06B8B 8388      ST	Y,R24
    06B8C E081      LDI	R24,1
    06B8D 8389      STD	Y+1,R24
    06B8E 82CA      STD	Y+2,R12
    06B8F 82AB      STD	Y+3,R10
    06B90 E084      LDI	R24,4
    06B91 838F      STD	Y+7,R24
    06B92 019E      MOVW	R18,R28
    06B93 E00D      LDI	R16,0xD
(0062) 	if(n <= 8)
    06B94 940E 16BA CALL	_InsertCommand
    06B96 2700      CLR	R16
    06B97 9628      ADIW	R28,0x8
    06B98 940C AE5D JMP	pop_xgset00FC
(0063) 	{
(0064) 		n = (_FlowNum0 + _FlowNum1) / 2;
_GetLiquidState:
    06B9A 92AA      ST	-Y,R10
    06B9B 92CA      ST	-Y,R12
    06B9C 2EA0      MOV	R10,R16
    06B9D 9728      SBIW	R28,0x8
    06B9E E00D      LDI	R16,0xD
    06B9F 940E 1755 CALL	_GetSlaveState
    06BA1 2EC0      MOV	R12,R16
    06BA2 E68A      LDI	R24,0x6A
    06BA3 8388      ST	Y,R24
    06BA4 E082      LDI	R24,2
(0065) 		_FlowNum0 = 0;
    06BA5 8389      STD	Y+1,R24
    06BA6 82AA      STD	Y+2,R10
    06BA7 E083      LDI	R24,3
    06BA8 838F      STD	Y+7,R24
    06BA9 019E      MOVW	R18,R28
    06BAA E00D      LDI	R16,0xD
(0066) 		_FlowNum1 = 0;
    06BAB 940E 16BA CALL	_InsertCommand
    06BAD 2700      CLR	R16
    06BAE 9628      ADIW	R28,0x8
(0067) 		return n;
    06BAF 90C9      LD	R12,Y+
    06BB0 90A9      LD	R10,Y+
(0068) 	}
(0069) 	else
(0070) 		return 0;
    06BB1 9508      RET
_SetLiquidMonitor:
    06BB2 940E AE7C CALL	push_xgset00FC
    06BB4 2EA2      MOV	R10,R18
_InsetrDiluentFlowCalValue:
  cal                  --> R20
  calLD                --> R12
  calHD                --> R10
  sum                  --> Y,+2
  cnt                  --> R14
  i                    --> R22
  n                    --> Y,+14
    06BB5 2EC0      MOV	R12,R16
    06BB6 9728      SBIW	R28,0x8
    06BB7 E00D      LDI	R16,0xD
    06BB8 940E 1755 CALL	_GetSlaveState
(0071) }
(0072) 
(0073) unsigned int InsetrDiluentFlowCalValue(unsigned int n)
(0074) {
(0075) 	unsigned int sum, cal, calHD, calLD;
(0076) 	unsigned char cnt, i;
(0077) 
(0078) 	Read_DiluentCalChart();
    06BBA 2EE0      MOV	R14,R16
(0079) 
(0080) 	if(_DiluentCalChart.pnt >= _FLOW_CAL_LIST_NUM)
    06BBB E68B      LDI	R24,0x6B
    06BBC 8388      ST	Y,R24
    06BBD E083      LDI	R24,3
    06BBE 8389      STD	Y+1,R24
(0081) 		_DiluentCalChart.pnt = 0;
    06BBF 82CA      STD	Y+2,R12
    06BC0 82AB      STD	Y+3,R10
    06BC1 E084      LDI	R24,4
(0082) 	_DiluentCalChart.list[_DiluentCalChart.pnt] = n;	// 存入新的定标值
    06BC2 838F      STD	Y+7,R24
    06BC3 019E      MOVW	R18,R28
    06BC4 E00D      LDI	R16,0xD
    06BC5 940E 16BA CALL	_InsertCommand
    06BC7 2700      CLR	R16
    06BC8 9628      ADIW	R28,0x8
    06BC9 940C AE5D JMP	pop_xgset00FC
_StartLiquidMonitor:
    06BCB 92AA      ST	-Y,R10
    06BCC 92CA      ST	-Y,R12
    06BCD 2EA0      MOV	R10,R16
    06BCE 9728      SBIW	R28,0x8
(0083) 	_DiluentCalChart.pnt ++;
    06BCF E00D      LDI	R16,0xD
    06BD0 940E 1755 CALL	_GetSlaveState
    06BD2 2EC0      MOV	R12,R16
    06BD3 E68A      LDI	R24,0x6A
(0084) 	
(0085) 	// 计算新的定标结果
(0086) 	sum = 0;	
    06BD4 8388      ST	Y,R24
    06BD5 E084      LDI	R24,4
    06BD6 8389      STD	Y+1,R24
    06BD7 82AA      STD	Y+2,R10
(0087) 	cnt = 0;
    06BD8 E083      LDI	R24,3
(0088) 	for(i=0; i<_FLOW_CAL_LIST_NUM; i++)
    06BD9 838F      STD	Y+7,R24
    06BDA 019E      MOVW	R18,R28
(0089) 	{
(0090) 		if(_DiluentCalChart.list[i]>_DILUENT_PUMP_BASE_COEFF_DOWN && _DiluentCalChart.list[i]<_DILUENT_PUMP_BASE_COEFF_UP)
    06BDB E00D      LDI	R16,0xD
    06BDC 940E 16BA CALL	_InsertCommand
    06BDE 2700      CLR	R16
    06BDF 9628      ADIW	R28,0x8
    06BE0 90C9      LD	R12,Y+
    06BE1 90A9      LD	R10,Y+
    06BE2 9508      RET
_ReadLiquidMonitorResult:
    06BE3 92AA      ST	-Y,R10
    06BE4 92CA      ST	-Y,R12
    06BE5 2EA0      MOV	R10,R16
    06BE6 9728      SBIW	R28,0x8
    06BE7 E00D      LDI	R16,0xD
    06BE8 940E 1755 CALL	_GetSlaveState
    06BEA 2EC0      MOV	R12,R16
    06BEB E68A      LDI	R24,0x6A
    06BEC 8388      ST	Y,R24
    06BED E085      LDI	R24,5
    06BEE 8389      STD	Y+1,R24
(0091) 		{
(0092) 			sum += _DiluentCalChart.list[i];
    06BEF 82AA      STD	Y+2,R10
    06BF0 E083      LDI	R24,3
    06BF1 838F      STD	Y+7,R24
    06BF2 019E      MOVW	R18,R28
    06BF3 E00D      LDI	R16,0xD
    06BF4 940E 16BA CALL	_InsertCommand
    06BF6 2700      CLR	R16
    06BF7 9628      ADIW	R28,0x8
    06BF8 90C9      LD	R12,Y+
    06BF9 90A9      LD	R10,Y+
    06BFA 9508      RET
_SetLiquidPhotoAdjust:
    06BFB 92AA      ST	-Y,R10
    06BFC 2EA0      MOV	R10,R16
    06BFD 9728      SBIW	R28,0x8
    06BFE E68A      LDI	R24,0x6A
(0093) 			cnt ++;
    06BFF 8388      ST	Y,R24
    06C00 E086      LDI	R24,6
    06C01 8389      STD	Y+1,R24
    06C02 82AA      STD	Y+2,R10
(0094) 		}
(0095) 	}
(0096) 	cal = sum/cnt;
    06C03 E083      LDI	R24,3
    06C04 838F      STD	Y+7,R24
    06C05 019E      MOVW	R18,R28
    06C06 E00D      LDI	R16,0xD
    06C07 940E 16BA CALL	_InsertCommand
    06C09 2700      CLR	R16
(0097) 	sum = 0;	
    06C0A 9628      ADIW	R28,0x8
    06C0B 90A9      LD	R10,Y+
    06C0C 9508      RET
_GetLiquidPhotoInfo:
    06C0D 9728      SBIW	R28,0x8
(0098) 	cnt = 0;
    06C0E E689      LDI	R24,0x69
(0099) 	calHD = cal + 6;
    06C0F 8388      ST	Y,R24
    06C10 E087      LDI	R24,7
    06C11 8389      STD	Y+1,R24
(0100) 	calLD = cal - 6;
    06C12 E082      LDI	R24,2
    06C13 838F      STD	Y+7,R24
    06C14 019E      MOVW	R18,R28
(0101) 	for(i=0; i<_FLOW_CAL_LIST_NUM; i++)
    06C15 E00D      LDI	R16,0xD
    06C16 940E 16BA CALL	_InsertCommand
(0102) 	{
(0103) 		if(_DiluentCalChart.list[i]>calLD && _DiluentCalChart.list[i] < calHD)
    06C18 2700      CLR	R16
    06C19 9628      ADIW	R28,0x8
    06C1A 9508      RET
_LiquidFlowCheck:
    06C1B 92AA      ST	-Y,R10
    06C1C 2EA0      MOV	R10,R16
    06C1D 9728      SBIW	R28,0x8
    06C1E E68A      LDI	R24,0x6A
    06C1F 8388      ST	Y,R24
    06C20 E088      LDI	R24,0x8
    06C21 8389      STD	Y+1,R24
    06C22 82AA      STD	Y+2,R10
    06C23 E083      LDI	R24,3
    06C24 838F      STD	Y+7,R24
    06C25 019E      MOVW	R18,R28
    06C26 E00D      LDI	R16,0xD
(0104) 		{
(0105) 			sum += _DiluentCalChart.list[i];
    06C27 940E 16BA CALL	_InsertCommand
    06C29 2700      CLR	R16
    06C2A 9628      ADIW	R28,0x8
    06C2B 90A9      LD	R10,Y+
    06C2C 9508      RET
_GetStoreState:
    06C2D 934A      ST	-Y,R20
    06C2E 2F40      MOV	R20,R16
    06C2F 9728      SBIW	R28,0x8
    06C30 E086      LDI	R24,6
    06C31 1784      CP	R24,R20
    06C32 F408      BCC	0x6C34
    06C33 E046      LDI	R20,6
    06C34 E782      LDI	R24,0x72
(0106) 			cnt ++;
    06C35 8388      ST	Y,R24
    06C36 E081      LDI	R24,1
    06C37 8389      STD	Y+1,R24
    06C38 834A      STD	Y+2,R20
(0107) 			}
(0108) 	}
(0109) 	if(cnt != 0)
    06C39 E083      LDI	R24,3
    06C3A 838F      STD	Y+7,R24
(0110) 		cal = sum/cnt;
    06C3B 019E      MOVW	R18,R28
    06C3C E00E      LDI	R16,0xE
    06C3D 940E 16BA CALL	_InsertCommand
    06C3F 2700      CLR	R16
    06C40 9628      ADIW	R28,0x8
    06C41 9149      LD	R20,Y+
    06C42 9508      RET
(0111) 	else
(0112) 		cal = 0;
_SetStoreCAL:
    06C43 92AA      ST	-Y,R10
    06C44 2EA0      MOV	R10,R16
(0113) 	Uart0ReUnable;
    06C45 9728      SBIW	R28,0x8
    06C46 E782      LDI	R24,0x72
    06C47 8388      ST	Y,R24
    06C48 E083      LDI	R24,3
    06C49 8389      STD	Y+1,R24
(0114) 	uart_Printf("// CurCalib:[cal]%d [n]%d\r\n", cal, n);
    06C4A 82AA      STD	Y+2,R10
    06C4B 838F      STD	Y+7,R24
    06C4C 019E      MOVW	R18,R28
    06C4D E00E      LDI	R16,0xE
    06C4E 940E 16BA CALL	_InsertCommand
    06C50 2700      CLR	R16
    06C51 9628      ADIW	R28,0x8
    06C52 90A9      LD	R10,Y+
(0115) 	Uart0ReEnable; ;
    06C53 9508      RET
_GetStorePhoVol:
    06C54 92AA      ST	-Y,R10
    06C55 2EA0      MOV	R10,R16
    06C56 9728      SBIW	R28,0x8
    06C57 E782      LDI	R24,0x72
(0116) 	if(cal)
    06C58 8388      ST	Y,R24
    06C59 E084      LDI	R24,4
    06C5A 8389      STD	Y+1,R24
(0117) 	{
(0118) 		if((n > (cal-6)) && (n < (cal+6)))
    06C5B 82AA      STD	Y+2,R10
    06C5C E083      LDI	R24,3
    06C5D 838F      STD	Y+7,R24
    06C5E 019E      MOVW	R18,R28
    06C5F E00E      LDI	R16,0xE
    06C60 940E 16BA CALL	_InsertCommand
    06C62 2700      CLR	R16
    06C63 9628      ADIW	R28,0x8
    06C64 90A9      LD	R10,Y+
    06C65 9508      RET
_SetStoreDoorOpen:
    06C66 92AA      ST	-Y,R10
(0119) 		{
(0120) 			_DiluentCalChart.calValue = cal;
    06C67 2EA0      MOV	R10,R16
    06C68 9728      SBIW	R28,0x8
    06C69 E782      LDI	R24,0x72
    06C6A 8388      ST	Y,R24
(0121) 		}
    06C6B E085      LDI	R24,5
(0122) 		else
(0123) 		{
(0124) 			cal = 0;
    06C6C 8389      STD	Y+1,R24
    06C6D 82AA      STD	Y+2,R10
(0125) 		}
(0126) 	}
(0127) 	Save_DiluentCalChart(9);
    06C6E E083      LDI	R24,3
    06C6F 838F      STD	Y+7,R24
    06C70 019E      MOVW	R18,R28
(0128) 	return cal;
    06C71 E00E      LDI	R16,0xE
    06C72 940E 16BA CALL	_InsertCommand
    06C74 2700      CLR	R16
    06C75 9628      ADIW	R28,0x8
    06C76 90A9      LD	R10,Y+
_Read_DiluentCalChart:
  l2                   --> Y,+6
  l1                   --> Y,+2
  i                    --> R10
    06C77 9508      RET
_TWI_RW:
    06C78 940E AE7E CALL	push_xgset003C
(0129) }
(0130) 
(0131) void Read_DiluentCalChart(void)
(0132) {
(0133) 	unsigned long l1, l2;
(0134) 	unsigned int i;
(0135) 	EEPROM_READ(EEP_ADD_CAL_DAT, _DiluentCalChart);
    06C7A 80CC      LDD	R12,Y+4
    06C7B 80DD      LDD	R13,Y+5
    06C7C 80AE      LDD	R10,Y+6
    06C7D 80BF      LDD	R11,Y+7
    06C7E 9020 166F LDS	R2,strTWI|PRecBuf
    06C80 2022      TST	R2
    06C81 F411      BNE	0x6C84
    06C82 2700      CLR	R16
    06C83 C01A      RJMP	0x6C9E
(0136) 	// 检查仪器校准因数和法性
(0137) 	for(i = 1;i < 15;++i)
    06C84 2422      CLR	R2
    06C85 9220 166F STS	strTWI|PRecBuf,R2
    06C87 9300 1670 STS	strTWI|PRecBuf+1,R16
(0138) 	{
(0139) 		if(_DiluentCalChart.calStand[i] < _DILUENT_MIX_BASE_COEFF_DOWN || _DiluentCalChart.calStand[i] > _DILUENT_MIX_BASE_COEFF_UP)
    06C89 9330 1672 STS	strTWI|PRecBuf+3,R19
    06C8B 9320 1671 STS	strTWI|PRecBuf+2,R18
    06C8D 92D0 1674 STS	strTWI|PRecBuf+5,R13
    06C8F 92C0 1673 STS	strTWI|PRecBuf+4,R12
    06C91 92B0 1676 STS	strTWI|PRecBuf+7,R11
    06C93 92A0 1675 STS	strTWI|PRecBuf+6,R10
    06C95 E081      LDI	R24,1
    06C96 9380 1677 STS	strTWI|PRecBuf+8,R24
    06C98 9220 1678 STS	strTWI|PRecBuf+9,R2
    06C9A EA85      LDI	R24,0xA5
    06C9B 9380 00BC STS	0xBC,R24
    06C9D E001      LDI	R16,1
    06C9E 940C AE58 JMP	pop_xgset003C
_twi_isr:
    06CA0 922A      ST	-Y,R2
    06CA1 923A      ST	-Y,R3
(0140) 		{
(0141) 			_DiluentCalChart.calStand[i] = _DILUENT_MIX_BASE_COEFF;
    06CA2 930A      ST	-Y,R16
    06CA3 932A      ST	-Y,R18
    06CA4 938A      ST	-Y,R24
    06CA5 939A      ST	-Y,R25
    06CA6 93AA      ST	-Y,R26
    06CA7 93EA      ST	-Y,R30
    06CA8 93FA      ST	-Y,R31
    06CA9 B62F      IN	R2,0x3F
    06CAA 922A      ST	-Y,R2
    06CAB 940E AE8D CALL	push_xgsetF000
    06CAD 9140 1670 LDS	R20,strTWI|PRecBuf+1
    06CAF 7041      ANDI	R20,1
    06CB0 9100 1677 LDS	R16,strTWI|PRecBuf+8
    06CB2 9120 00B9 LDS	R18,0xB9
    06CB4 7F28      ANDI	R18,0xF8
    06CB5 3620      CPI	R18,0x60
(0142) 		}
(0143) 	}
(0144) 	EEPROM_WRITE(EEP_ADD_CAL_DAT, _DiluentCalChart);
    06CB6 F410      BCC	0x6CB9
    06CB7 2322      TST	R18
    06CB8 F409      BNE	0x6CBA
    06CB9 C11D      RJMP	0x6DD7
    06CBA 2F60      MOV	R22,R16
    06CBB 2777      CLR	R23
    06CBC 3061      CPI	R22,1
    06CBD E0E0      LDI	R30,0
    06CBE 077E      CPC	R23,R30
    06CBF F119      BEQ	0x6CE3
(0145) 	// 检查稀释液泵校准因数和法性
(0146) 	if(_DiluentCalChart.calValue < _DILUENT_PUMP_BASE_COEFF_DOWN || _DiluentCalChart.calValue > _DILUENT_PUMP_BASE_COEFF_UP)
    06CC0 3062      CPI	R22,2
    06CC1 E0E0      LDI	R30,0
    06CC2 077E      CPC	R23,R30
    06CC3 F161      BEQ	0x6CF0
    06CC4 3063      CPI	R22,3
    06CC5 E0E0      LDI	R30,0
    06CC6 077E      CPC	R23,R30
    06CC7 F409      BNE	0x6CC9
    06CC8 C039      RJMP	0x6D02
    06CC9 3064      CPI	R22,4
    06CCA E0E0      LDI	R30,0
    06CCB 077E      CPC	R23,R30
    06CCC F409      BNE	0x6CCE
    06CCD C043      RJMP	0x6D11
    06CCE 3065      CPI	R22,5
    06CCF E0E0      LDI	R30,0
    06CD0 077E      CPC	R23,R30
(0147) 	{
(0148) 		// 初始化校准数据
(0149) 		_DiluentCalChart.calValue = _DILUENT_PUMP_BASE_COEFF;
    06CD1 F409      BNE	0x6CD3
    06CD2 C061      RJMP	0x6D34
    06CD3 3066      CPI	R22,6
    06CD4 E0E0      LDI	R30,0
    06CD5 077E      CPC	R23,R30
    06CD6 F409      BNE	0x6CD8
(0150) 		_DiluentCalChart.pnt = 0;
    06CD7 C068      RJMP	0x6D40
    06CD8 3067      CPI	R22,7
    06CD9 E0E0      LDI	R30,0
(0151) 		_DiluentCalChart.list[0] = _DILUENT_PUMP_BASE_COEFF;
    06CDA 077E      CPC	R23,R30
    06CDB F409      BNE	0x6CDD
    06CDC C07D      RJMP	0x6D5A
    06CDD 3068      CPI	R22,0x8
(0152) 		_DiluentCalChart.pnt ++;
    06CDE E0E0      LDI	R30,0
    06CDF 077E      CPC	R23,R30
    06CE0 F409      BNE	0x6CE2
    06CE1 C0B2      RJMP	0x6D94
(0153) 		EEPROM_WRITE(EEP_ADD_CAL_DAT, _DiluentCalChart);
    06CE2 C0DD      RJMP	0x6DC0
    06CE3 3028      CPI	R18,0x8
    06CE4 F449      BNE	0x6CEE
    06CE5 9180 1670 LDS	R24,strTWI|PRecBuf+1
    06CE7 7F8E      ANDI	R24,0xFE
    06CE8 9380 00BB STS	0xBB,R24
    06CEA E885      LDI	R24,0x85
    06CEB 9380 00BC STS	0xBC,R24
(0154) 	}
(0155) 	// 计算当前稀释校准因数
(0156) 	l1 = _DiluentCalChart.calValue;
    06CED C0D3      RJMP	0x6DC1
    06CEE 2700      CLR	R16
    06CEF C0D1      RJMP	0x6DC1
    06CF0 3128      CPI	R18,0x18
    06CF1 F471      BNE	0x6D00
    06CF2 9180 1671 LDS	R24,strTWI|PRecBuf+2
    06CF4 9190 1672 LDS	R25,strTWI|PRecBuf+3
(0157) 	for(i = 1;i < 15;++i)
    06CF6 7080      ANDI	R24,0
    06CF7 011C      MOVW	R2,R24
    06CF8 2C23      MOV	R2,R3
    06CF9 2433      CLR	R3
(0158) 	{
(0159) 		l2 = _DiluentCalChart.calStand[i];
    06CFA 9220 00BB STS	0xBB,R2
    06CFC E885      LDI	R24,0x85
    06CFD 9380 00BC STS	0xBC,R24
    06CFF C0C1      RJMP	0x6DC1
    06D00 2700      CLR	R16
    06D01 C0BF      RJMP	0x6DC1
    06D02 3228      CPI	R18,0x28
    06D03 F459      BNE	0x6D0F
    06D04 9180 1671 LDS	R24,strTWI|PRecBuf+2
    06D06 9190 1672 LDS	R25,strTWI|PRecBuf+3
    06D08 7090      ANDI	R25,0
(0160) 		l1 = (l1*l2)/_DILUENT_MIX_BASE_COEFF;
    06D09 9380 00BB STS	0xBB,R24
    06D0B E885      LDI	R24,0x85
    06D0C 9380 00BC STS	0xBC,R24
    06D0E C0B2      RJMP	0x6DC1
    06D0F 2700      CLR	R16
    06D10 C0B0      RJMP	0x6DC1
    06D11 3228      CPI	R18,0x28
    06D12 F4F9      BNE	0x6D32
    06D13 3041      CPI	R20,1
    06D14 F421      BNE	0x6D19
    06D15 EA85      LDI	R24,0xA5
    06D16 9380 00BC STS	0xBC,R24
    06D18 C0A8      RJMP	0x6DC1
    06D19 91E0 1673 LDS	R30,strTWI|PRecBuf+4
    06D1B 91F0 1674 LDS	R31,strTWI|PRecBuf+5
    06D1D 9021      LD	R2,Z+
    06D1E 93F0 1674 STS	strTWI|PRecBuf+5,R31
    06D20 93E0 1673 STS	strTWI|PRecBuf+4,R30
    06D22 9220 00BB STS	0xBB,R2
    06D24 9180 1675 LDS	R24,strTWI|PRecBuf+6
(0161) 		DiluentCoff[i] = (unsigned int)l1;
    06D26 9190 1676 LDS	R25,strTWI|PRecBuf+7
    06D28 9701      SBIW	R24,1
    06D29 9390 1676 STS	strTWI|PRecBuf+7,R25
    06D2B 9380 1675 STS	strTWI|PRecBuf+6,R24
    06D2D E007      LDI	R16,7
    06D2E E885      LDI	R24,0x85
    06D2F 9380 00BC STS	0xBC,R24
    06D31 C08F      RJMP	0x6DC1
    06D32 2700      CLR	R16
    06D33 C08D      RJMP	0x6DC1
    06D34 3120      CPI	R18,0x10
    06D35 F441      BNE	0x6D3E
    06D36 9020 1670 LDS	R2,strTWI|PRecBuf+1
    06D38 9220 00BB STS	0xBB,R2
    06D3A E885      LDI	R24,0x85
    06D3B 9380 00BC STS	0xBC,R24
    06D3D C083      RJMP	0x6DC1
    06D3E 2700      CLR	R16
    06D3F C081      RJMP	0x6DC1
(0162) 	}
(0163) }
(0164) /*
(0165) void Save_DiluentCalChart(void){
(0166) 	unsigned long l1, l2;
(0167) 	// 检查仪器校准因数和法性
(0168) 	if(_DiluentCalChart.calStand < _DILUENT_MIX_BASE_COEFF_DOWN)
(0169) 		_DiluentCalChart.calStand = _DILUENT_MIX_BASE_COEFF_DOWN;
(0170) 	if(_DiluentCalChart.calStand > _DILUENT_MIX_BASE_COEFF_UP)
(0171) 		_DiluentCalChart.calStand = _DILUENT_MIX_BASE_COEFF_UP;
(0172) 	// 检查稀释液泵校准因数和法性
(0173) 	if(_DiluentCalChart.calValue < _DILUENT_PUMP_BASE_COEFF_DOWN)
(0174) 		_DiluentCalChart.calValue = _DILUENT_PUMP_BASE_COEFF_DOWN;
(0175) 	if(_DiluentCalChart.calValue > _DILUENT_PUMP_BASE_COEFF_UP)
(0176) 		_DiluentCalChart.calValue = _DILUENT_PUMP_BASE_COEFF_UP;
(0177) 	EEPROM_WRITE(EEP_ADD_CAL_DAT, _DiluentCalChart);
(0178) 	// 重新计算当前稀释校准因数
(0179) 	l1 = _DiluentCalChart.calValue;
(0180) 	l2 = _DiluentCalChart.calStand;
(0181) 	l1 = (l1*l2)/_DILUENT_MIX_BASE_COEFF;
(0182) 	DiluentCoff = (unsigned int)l1;
(0183) }
(0184) */
(0185) // 2016-06-21 Save_DiluentCalChart 改为返回值函数，返回稀释校准因素
(0186) unsigned int Save_DiluentCalChart(unsigned int m)
(0187) {
(0188) 	unsigned long l1, l2;
(0189) 	// 检查仪器校准因数和法性
(0190) //#ifndef Puncture
(0191) 	if(m == 0)		m = 9;
    06D40 3420      CPI	R18,0x40
    06D41 F4B1      BNE	0x6D58
    06D42 9020 1675 LDS	R2,strTWI|PRecBuf+6
    06D44 9030 1676 LDS	R3,strTWI|PRecBuf+7
    06D46 01C1      MOVW	R24,R2
    06D47 9701      SBIW	R24,1
(0192) 	else if(m > 13)	m = 13;
    06D48 9390 1676 STS	strTWI|PRecBuf+7,R25
    06D4A 9380 1675 STS	strTWI|PRecBuf+6,R24
    06D4C 2022      TST	R2
    06D4D F411      BNE	0x6D50
(0193) 	if(_DiluentCalChart.calStand[m] < _DILUENT_MIX_BASE_COEFF_DOWN)
    06D4E 2033      TST	R3
    06D4F F021      BEQ	0x6D54
    06D50 EC85      LDI	R24,0xC5
    06D51 9380 00BC STS	0xBC,R24
    06D53 C06D      RJMP	0x6DC1
    06D54 E885      LDI	R24,0x85
    06D55 9380 00BC STS	0xBC,R24
    06D57 C069      RJMP	0x6DC1
    06D58 2700      CLR	R16
    06D59 C067      RJMP	0x6DC1
    06D5A 950A      DEC	R16
(0194) 		_DiluentCalChart.calStand[m] = _DILUENT_MIX_BASE_COEFF_DOWN;
    06D5B 3520      CPI	R18,0x50
    06D5C F509      BNE	0x6D7E
    06D5D 9020 00BB LDS	R2,0xBB
    06D5F 91E0 1673 LDS	R30,strTWI|PRecBuf+4
    06D61 91F0 1674 LDS	R31,strTWI|PRecBuf+5
    06D63 9221      ST	Z+,R2
    06D64 93F0 1674 STS	strTWI|PRecBuf+5,R31
(0195) 	if(_DiluentCalChart.calStand[m] > _DILUENT_MIX_BASE_COEFF_UP)
    06D66 93E0 1673 STS	strTWI|PRecBuf+4,R30
    06D68 9020 1675 LDS	R2,strTWI|PRecBuf+6
    06D6A 9030 1676 LDS	R3,strTWI|PRecBuf+7
    06D6C 01C1      MOVW	R24,R2
    06D6D 9701      SBIW	R24,1
    06D6E 9390 1676 STS	strTWI|PRecBuf+7,R25
    06D70 9380 1675 STS	strTWI|PRecBuf+6,R24
    06D72 2022      TST	R2
    06D73 F411      BNE	0x6D76
(0196) 		_DiluentCalChart.calStand[m] = _DILUENT_MIX_BASE_COEFF_UP;
    06D74 2033      TST	R3
    06D75 F021      BEQ	0x6D7A
    06D76 EC85      LDI	R24,0xC5
    06D77 9380 00BC STS	0xBC,R24
    06D79 C047      RJMP	0x6DC1
    06D7A E885      LDI	R24,0x85
    06D7B 9380 00BC STS	0xBC,R24
    06D7D C043      RJMP	0x6DC1
    06D7E 3528      CPI	R18,0x58
(0197) 	// 检查稀释液泵校准因数和法性
(0198) 	if(_DiluentCalChart.calValue < _DILUENT_PUMP_BASE_COEFF_DOWN)
    06D7F F491      BNE	0x6D92
    06D80 9020 00BB LDS	R2,0xBB
    06D82 91E0 1673 LDS	R30,strTWI|PRecBuf+4
    06D84 91F0 1674 LDS	R31,strTWI|PRecBuf+5
    06D86 9221      ST	Z+,R2
(0199) 		_DiluentCalChart.calValue = _DILUENT_PUMP_BASE_COEFF_DOWN;
    06D87 93F0 1674 STS	strTWI|PRecBuf+5,R31
    06D89 93E0 1673 STS	strTWI|PRecBuf+4,R30
    06D8B E985      LDI	R24,0x95
    06D8C 9380 00BC STS	0xBC,R24
(0200) 	if(_DiluentCalChart.calValue > _DILUENT_PUMP_BASE_COEFF_UP)
    06D8E E081      LDI	R24,1
    06D8F 9380 166F STS	strTWI|PRecBuf,R24
    06D91 C02F      RJMP	0x6DC1
    06D92 2700      CLR	R16
    06D93 C02D      RJMP	0x6DC1
    06D94 950A      DEC	R16
    06D95 3228      CPI	R18,0x28
(0201) 		_DiluentCalChart.calValue = _DILUENT_PUMP_BASE_COEFF_UP;
    06D96 F539      BNE	0x6DBE
    06D97 9020 1675 LDS	R2,strTWI|PRecBuf+6
    06D99 9030 1676 LDS	R3,strTWI|PRecBuf+7
(0202) 	EEPROM_WRITE(EEP_ADD_CAL_DAT, _DiluentCalChart);
    06D9B 2022      TST	R2
    06D9C F411      BNE	0x6D9F
    06D9D 2033      TST	R3
    06D9E F0C1      BEQ	0x6DB7
    06D9F 91E0 1673 LDS	R30,strTWI|PRecBuf+4
    06DA1 91F0 1674 LDS	R31,strTWI|PRecBuf+5
    06DA3 9021      LD	R2,Z+
(0203) 	// 重新计算当前稀释校准因数
(0204) 	l1 = _DiluentCalChart.calValue;
    06DA4 93F0 1674 STS	strTWI|PRecBuf+5,R31
    06DA6 93E0 1673 STS	strTWI|PRecBuf+4,R30
    06DA8 9220 00BB STS	0xBB,R2
    06DAA 9180 1675 LDS	R24,strTWI|PRecBuf+6
    06DAC 9190 1676 LDS	R25,strTWI|PRecBuf+7
(0205) 	l2 = _DiluentCalChart.calStand[m];
    06DAE 9701      SBIW	R24,1
    06DAF 9390 1676 STS	strTWI|PRecBuf+7,R25
    06DB1 9380 1675 STS	strTWI|PRecBuf+6,R24
    06DB3 E885      LDI	R24,0x85
    06DB4 9380 00BC STS	0xBC,R24
    06DB6 C00A      RJMP	0x6DC1
    06DB7 E985      LDI	R24,0x95
    06DB8 9380 00BC STS	0xBC,R24
    06DBA E081      LDI	R24,1
    06DBB 9380 166F STS	strTWI|PRecBuf,R24
(0206) 	l1 = (l1*l2)/_DILUENT_MIX_BASE_COEFF;
    06DBD C003      RJMP	0x6DC1
    06DBE 2700      CLR	R16
    06DBF C001      RJMP	0x6DC1
    06DC0 2700      CLR	R16
    06DC1 2300      TST	R16
    06DC2 F489      BNE	0x6DD4
    06DC3 9180 1678 LDS	R24,strTWI|PRecBuf+9
    06DC5 5F8F      SUBI	R24,0xFF
    06DC6 9380 1678 STS	strTWI|PRecBuf+9,R24
    06DC8 3184      CPI	R24,0x14
    06DC9 F420      BCC	0x6DCE
    06DCA EA85      LDI	R24,0xA5
    06DCB 9380 00BC STS	0xBC,R24
    06DCD C006      RJMP	0x6DD4
    06DCE E985      LDI	R24,0x95
    06DCF 9380 00BC STS	0xBC,R24
    06DD1 E082      LDI	R24,2
    06DD2 9380 166F STS	strTWI|PRecBuf,R24
    06DD4 9503      INC	R16
    06DD5 9300 1677 STS	strTWI|PRecBuf+8,R16
    06DD7 940E AE92 CALL	pop_xgsetF000
(0207) 	DiluentCoff[m] = (unsigned int)l1;
    06DD9 9029      LD	R2,Y+
    06DDA BE2F      OUT	0x3F,R2
    06DDB 91F9      LD	R31,Y+
    06DDC 91E9      LD	R30,Y+
    06DDD 91A9      LD	R26,Y+
    06DDE 9199      LD	R25,Y+
    06DDF 9189      LD	R24,Y+
    06DE0 9129      LD	R18,Y+
    06DE1 9109      LD	R16,Y+
    06DE2 9039      LD	R3,Y+
    06DE3 9029      LD	R2,Y+
(0208) 	return DiluentCoff[m];
    06DE4 9518      RETI
_TWI_Init:
    06DE5 B18B      IN	R24,0x0B
    06DE6 6083      ORI	R24,3
    06DE7 B98B      OUT	0x0B,R24
    06DE8 B18A      IN	R24,0x0A
    06DE9 7F8C      ANDI	R24,0xFC
    06DEA B98A      OUT	0x0A,R24
    06DEB 2422      CLR	R2
    06DEC 9220 00B9 STS	0xB9,R2
_MemCopy:
  p2                   --> R12
  p1                   --> R10
  n                    --> R14
  pt                   --> R18
  ps                   --> R16
    06DEE E481      LDI	R24,0x41
    06DEF 9380 00B8 STS	0xB8,R24
(0209) /*
(0210) #else
(0211) {
(0212) 	if(WithoutPuncture != 0)		// 无需穿刺
(0213) 	{
(0214) 		if(m == 0)		m = 9;
(0215) 		else if(m > 13)	m = 13;
(0216) 		if(_DiluentCalChart.calStand[m] < _DILUENT_MIX_BASE_COEFF_DOWN)
(0217) 		_DiluentCalChart.calStand[m] = _DILUENT_MIX_BASE_COEFF_DOWN;
(0218) 		if(_DiluentCalChart.calStand[m] > _DILUENT_MIX_BASE_COEFF_UP)
(0219) 		_DiluentCalChart.calStand[m] = _DILUENT_MIX_BASE_COEFF_UP;
(0220) 	// 检查稀释液泵校准因数和法性
(0221) 	if(_DiluentCalChart.calValue < _DILUENT_PUMP_BASE_COEFF_DOWN)
(0222) 		_DiluentCalChart.calValue = _DILUENT_PUMP_BASE_COEFF_DOWN;
(0223) 	if(_DiluentCalChart.calValue > _DILUENT_PUMP_BASE_COEFF_UP)
(0224) 		_DiluentCalChart.calValue = _DILUENT_PUMP_BASE_COEFF_UP;
(0225) 	EEPROM_WRITE(EEP_ADD_CAL_DAT, _DiluentCalChart);
(0226) 	// 重新计算当前稀释校准因数
(0227) 	l1 = _DiluentCalChart.calValue;
(0228) 	uart_Printf("*9922 $%4d\r\n", l1);
(0229) 	l2 = _DiluentCalChart.calStand[m];
(0230) 	l1 = (l1*l2)/_DILUENT_MIX_BASE_COEFF;
(0231) 	DiluentCoff[m] = (unsigned int)l1;
(0232) 	return DiluentCoff[m];
(0233) 	}
(0234) 	else
(0235) 	{
(0236) 		if(_DiluentCalChart.calStand[8] < _DILUENT_MIX_BASE_COEFF_DOWN)
(0237) 		_DiluentCalChart.calStand[8] = _DILUENT_MIX_BASE_COEFF_DOWN;
(0238) 	if(_DiluentCalChart.calStand[8] > _DILUENT_MIX_BASE_COEFF_UP)
(0239) 		_DiluentCalChart.calStand[8] = _DILUENT_MIX_BASE_COEFF_UP;
(0240) 	// 检查稀释液泵校准因数和法性
(0241) 	if(_DiluentCalChart.calValue < _DILUENT_PUMP_BASE_COEFF_DOWN)
(0242) 		_DiluentCalChart.calValue = _DILUENT_PUMP_BASE_COEFF_DOWN;
(0243) 	if(_DiluentCalChart.calValue > _DILUENT_PUMP_BASE_COEFF_UP)
(0244) 		_DiluentCalChart.calValue = _DILUENT_PUMP_BASE_COEFF_UP;
(0245) 	EEPROM_WRITE(EEP_ADD_CAL_DAT, _DiluentCalChart);
(0246) 	// 重新计算当前稀释校准因数
(0247) 	l1 = _DiluentCalChart.calValue;
(0248) 	
(0249) 	l2 = _DiluentCalChart.calStand[8];
(0250) 	
(0251) 	l1 = (l1*l2)/_DILUENT_MIX_BASE_COEFF;
(0252) 	uart_Printf("*9933 $%4d\r\n", l1);
(0253) 	DiluentCoff[8] = (unsigned int)l1;
(0254) 	return DiluentCoff[8];
(0255) 	}
(0256) }
(0257) #endif
(0258) */
(0259) }
(0260) /***************************************************************/
(0261) 
(0262) void MemCopy(void *ps, void *pt, unsigned char n){
(0263) 	unsigned char *p1, *p2;
(0264) 	p1 = (unsigned char *)ps;
    06DF1 9220 00BA STS	0xBA,R2
(0265) 	p2 = (unsigned char *)pt;
    06DF3 9220 00BC STS	0xBC,R2
(0266) 	while(n){
(0267) 		*(p2++) = *(p1++);
    06DF5 E081      LDI	R24,1
    06DF6 9380 166F STS	strTWI|PRecBuf,R24
    06DF8 9508      RET
_AT24C256_Read:
    06DF9 940E AE7C CALL	push_xgset00FC
(0268) 		n--;
    06DFB 0169      MOVW	R12,R18
    06DFC 0158      MOVW	R10,R16
    06DFD 9724      SBIW	R28,4
    06DFE 84EA      LDD	R14,Y+10
(0269) 		}
(0270) }
(0271) 
(0272) unsigned char StringMatching(_CONST char * str1, char * str2){
_StringMatching:
  str2                 --> R18
  str1                 --> R16
    06DFF 84FB      LDD	R15,Y+11
(0273) 	// 字符串匹配
(0274) 	while(*str1){
(0275) 		if(*str2 == 0)
    06E00 82FB      STD	Y+3,R15
    06E01 82EA      STD	Y+2,R14
    06E02 82D9      STD	Y+1,R13
    06E03 82C8      ST	Y,R12
(0276) 			return 0;
    06E04 0195      MOVW	R18,R10
    06E05 EA01      LDI	R16,0xA1
(0277) 		if(*str1 == *str2){
    06E06 DE71      RCALL	_TWI_RW
    06E07 9624      ADIW	R28,4
    06E08 940C AE5D JMP	pop_xgset00FC
_AT24C256_Write:
    06E0A 940E AE7C CALL	push_xgset00FC
(0278) 			str1 ++;	str2 ++;
    06E0C 0169      MOVW	R12,R18
    06E0D 0158      MOVW	R10,R16
    06E0E 9724      SBIW	R28,4
    06E0F 84EA      LDD	R14,Y+10
(0279) 			}
    06E10 84FB      LDD	R15,Y+11
(0280) 		else
(0281) 			return 0;
    06E11 82FB      STD	Y+3,R15
    06E12 82EA      STD	Y+2,R14
    06E13 82D9      STD	Y+1,R13
    06E14 82C8      ST	Y,R12
    06E15 0195      MOVW	R18,R10
    06E16 EA00      LDI	R16,0xA0
(0282) 		}
(0283) 	if(*str1 == *str2)
    06E17 DE60      RCALL	_TWI_RW
    06E18 9624      ADIW	R28,4
    06E19 940C AE5D JMP	pop_xgset00FC
_InitFlowMeter:
    06E1B 2422      CLR	R2
    06E1C 2433      CLR	R3
(0284) 		return 1;
    06E1D 9230 1784 STS	_FlowNum0+1,R3
(0285) 	else
(0286) 		return 0;
    06E1F 9220 1783 STS	_FlowNum0,R2
_StringToInt:
  i                    --> Y,+1
  neg                  --> R20
  n                    --> R10
  pStr                 --> R22
    06E21 9230 1782 STS	_FlowNum1+1,R3
    06E23 9220 1781 STS	_FlowNum1,R2
(0287) }
(0288) 
(0289) unsigned int  StringToInt(const char * pStr){
(0290) 	// 字符串转数值
(0291) 	unsigned char i, neg=0;
    06E25 9508      RET
_JudgeFlowMeter:
    06E26 940E AE7C CALL	push_xgset00FC
    06E28 0168      MOVW	R12,R16
(0292) 	int n;
(0293) 	if(*pStr=='-'){
(0294) 		pStr ++;
    06E29 9020 1783 LDS	R2,_FlowNum0
(0295) 		neg = 1;
    06E2B 9030 1784 LDS	R3,_FlowNum0+1
(0296) 		}
(0297) 	n = 0;
    06E2D 2022      TST	R2
    06E2E F449      BNE	0x6E38
(0298) 	while(*pStr){
(0299) 		if(*pStr>='0' && *pStr<='9'){
    06E2F 2033      TST	R3
    06E30 F439      BNE	0x6E38
    06E31 92D0 1784 STS	_FlowNum0+1,R13
    06E33 92C0 1783 STS	_FlowNum0,R12
    06E35 2700      CLR	R16
    06E36 2711      CLR	R17
    06E37 C076      RJMP	0x6EAE
(0300) 			n = n*10;
    06E38 9020 1781 LDS	R2,_FlowNum1
    06E3A 9030 1782 LDS	R3,_FlowNum1+1
    06E3C 2022      TST	R2
    06E3D F439      BNE	0x6E45
(0301) 			n += (*pStr-0x30);
    06E3E 2033      TST	R3
    06E3F F429      BNE	0x6E45
    06E40 92D0 1782 STS	_FlowNum1+1,R13
    06E42 92C0 1781 STS	_FlowNum1,R12
(0302) 			}
(0303) 		pStr ++;
    06E44 C03F      RJMP	0x6E84
    06E45 9120 1783 LDS	R18,_FlowNum0
    06E47 9130 1784 LDS	R19,_FlowNum0+1
    06E49 0186      MOVW	R16,R12
(0304) 		}
(0305) 	if(neg)
    06E4A D357      RCALL	_AbsDifference
    06E4B 0178      MOVW	R14,R16
(0306) 		n = 0-n;
    06E4C 9120 1781 LDS	R18,_FlowNum1
    06E4E 9130 1782 LDS	R19,_FlowNum1+1
    06E50 0186      MOVW	R16,R12
(0307) 	return n;
    06E51 D350      RCALL	_AbsDifference
    06E52 0158      MOVW	R10,R16
    06E53 150E      CP	R16,R14
_StringToInt2:
  i                    --> Y,+1
  n                    --> R10
  pStr                 --> R20
    06E54 051F      CPC	R17,R15
    06E55 F4B8      BCC	0x6E6D
    06E56 E088      LDI	R24,0x8
(0308) }
(0309) 
(0310) unsigned int  StringToInt2(const char * pStr){
(0311) 	// 字符串转数值
(0312) 	unsigned char i;
(0313) 	unsigned int n = 0;
    06E57 E090      LDI	R25,0
    06E58 1780      CP	R24,R16
    06E59 0791      CPC	R25,R17
(0314) 	while(*pStr != '$'){
(0315) 		if(*pStr>='0' && *pStr<='9'){
    06E5A F028      BCS	0x6E60
    06E5B 92D0 1784 STS	_FlowNum0+1,R13
    06E5D 92C0 1783 STS	_FlowNum0,R12
    06E5F C024      RJMP	0x6E84
    06E60 2422      CLR	R2
    06E61 2433      CLR	R3
    06E62 9230 1784 STS	_FlowNum0+1,R3
(0316) 			n = n*10;
    06E64 9220 1783 STS	_FlowNum0,R2
    06E66 9230 1782 STS	_FlowNum1+1,R3
    06E68 9220 1781 STS	_FlowNum1,R2
(0317) 			n += (*pStr-0x30);
    06E6A 2700      CLR	R16
    06E6B 2711      CLR	R17
    06E6C C041      RJMP	0x6EAE
    06E6D E088      LDI	R24,0x8
    06E6E E090      LDI	R25,0
(0318) 			}
(0319) 		pStr ++;
    06E6F 158E      CP	R24,R14
    06E70 059F      CPC	R25,R15
    06E71 F028      BCS	0x6E77
    06E72 92D0 1782 STS	_FlowNum1+1,R13
    06E74 92C0 1781 STS	_FlowNum1,R12
(0320) 		}
(0321) 	return n;
    06E76 C00D      RJMP	0x6E84
    06E77 2422      CLR	R2
_AbsDifference:
  i                    --> R10
  b                    --> R18
  a                    --> R16
    06E78 2433      CLR	R3
    06E79 9230 1784 STS	_FlowNum0+1,R3
(0322) }
(0323) 
(0324) unsigned int AbsDifference(unsigned int a, unsigned int b){
(0325) 	unsigned int i;
(0326) 	if(a>b)
    06E7B 9220 1783 STS	_FlowNum0,R2
(0327) 		i = a-b;
    06E7D 9230 1782 STS	_FlowNum1+1,R3
    06E7F 9220 1781 STS	_FlowNum1,R2
(0328) 	else
(0329) 		i = b-a;
    06E81 2700      CLR	R16
    06E82 2711      CLR	R17
    06E83 C02A      RJMP	0x6EAE
(0330) 	return i;
    06E84 9120 1781 LDS	R18,_FlowNum1
    06E86 9130 1782 LDS	R19,_FlowNum1+1
_ReStart:
  i                    --> Y,+2
  type                 --> R10
    06E88 9100 1783 LDS	R16,_FlowNum0
    06E8A 9110 1784 LDS	R17,_FlowNum0+1
FILE: D:\Work\主控软件\2032A2~1\main.c
(0001) #include "B1404_LIB.h"
(0002) #include <iom1280v.h>
(0003) #include "Common.h"
(0004) #include <macros.h>
(0005) #include "eeprom.h"
(0006) 
(0007) unsigned char ControlModel;					// 0:正常， 1:超级终端调试
(0008) unsigned char WorkProcessStep;				// 工作进程号
(0009) extern unsigned char CardStoreOpenLook;		// 片仓工作状态
(0010) extern unsigned char JumpMode;				// 调整测试模式
(0011) 
(0012) 
(0013) //**************************************
(0014) unsigned char CardNoneUseful = 0;			// 老化模式
(0015) unsigned char workSwitch = 1;				// 停止工作开关
(0016) extern unsigned char CardStoreTestFlag;		// 取片测试模式
(0017) //**************************************
(0018) 
(0019) unsigned char primeProcessSW;		// 灌注开关，1:灌注稀释液； 2:灌注清洗液；3:测试模式下的液路自检
(0020) 
(0021) void init_devices(void);
(0022) void StartWork(void);
(0023) void MotorModelConfig(void);
(0024) void SetWorkStep(unsigned char n);
(0025) void CommandClear(void);
(0026) 
(0027) extern unsigned char GetNewTestCard;		// 取新的测试卡，0:无, 1:取插入卡, 2:取仓1卡, 3:取仓2卡, 4:取仓3卡, 5:取仓4卡, 6:取仓5卡， 255:取卡完成
(0028) extern unsigned char TurnPlateUsedLock;		// 转盘使用锁
(0029) unsigned char EchoSW = 1;
(0030) 
(0031) unsigned char (*miantianSubFunction)(void);
(0032) unsigned int MaintainSubFunParam;
(0033) 
(0034) void ReStart(unsigned char type)
(0035) {
(0036) 	unsigned char i;
(0037) 	CLI();
    06E8C D315      RCALL	_AbsDifference
    06E8D 0168      MOVW	R12,R16
    06E8E 0156      MOVW	R10,R12
    06E8F E088      LDI	R24,0x8
    06E90 E090      LDI	R25,0
(0038) 	Uart0ReUnable;
(0039) 	uart_Printf("%s\r\n", strM0199);
    06E91 1780      CP	R24,R16
    06E92 0791      CPC	R25,R17
    06E93 F0C0      BCS	0x6EAC
    06E94 9020 1781 LDS	R2,_FlowNum1
    06E96 9030 1782 LDS	R3,_FlowNum1+1
(0040) 	Uart0ReEnable;
    06E98 90A0 1783 LDS	R10,_FlowNum0
    06E9A 90B0 1784 LDS	R11,_FlowNum0+1
(0041) 	if(type != 0)
    06E9C 0CA2      ADD	R10,R2
    06E9D 1CB3      ADC	R11,R3
(0042) 	{
(0043) 		// 设置下载程序模式标识
(0044) 		i = 1;
    06E9E 94B6      LSR	R11
    06E9F 94A7      ROR	R10
(0045) 		EEPROM_WRITE(EEP_ADD_DOWNLOAD_FLAG, i);
    06EA0 2422      CLR	R2
    06EA1 2433      CLR	R3
    06EA2 9230 1784 STS	_FlowNum0+1,R3
    06EA4 9220 1783 STS	_FlowNum0,R2
    06EA6 9230 1782 STS	_FlowNum1+1,R3
    06EA8 9220 1781 STS	_FlowNum1,R2
(0046) 	}
(0047) 	WDR (); //this prevents a timeout on enabling
    06EAA 0185      MOVW	R16,R10
(0048) 	WDTCSR |= (1<<WDCE) | (1<<WDE); //30-Oct-2006 Umesh 
    06EAB C002      RJMP	0x6EAE
    06EAC 2700      CLR	R16
    06EAD 2711      CLR	R17
    06EAE 940C AE5D JMP	pop_xgset00FC
(0049) 	WDTCSR = 0x0F; // 0x08 WATCHDOG ENABLED - dont forget to issue WDRs
_InsetrDiluentFlowCalValue:
    06EB0 931A      ST	-Y,R17
    06EB1 930A      ST	-Y,R16
    06EB2 940E AE78 CALL	push_xgsetF0FC
(0050) 	SEI();
    06EB4 9724      SBIW	R28,4
    06EB5 D0BC      RCALL	_Read_DiluentCalChart
    06EB6 9180 17AB LDS	R24,_DiluentCalChart+10
(0051) }
(0052) 
(0053) 
(0054) /*************************************************************************************************/
(0055) 
(0056) /******************************************* 主函数 **********************************************/
(0057) extern unsigned long SecondCount;
(0058) unsigned int cmd;
(0059) unsigned char uart[] = {'#','3','0','0','2','$','3',0x20,'G','B'};
(0060) void main(void)
(0061) {
(0062) 	static unsigned char cmdState;
(0063) 	static unsigned char taskSate;
(0064) 	static unsigned char diluteProcessState;	// 稀释主程序执行状态
(0065) 	static unsigned char GetNewPieceProcessState;//取片程序执行状态
(0066) 	static unsigned char CardScanfSW;			// 试剂片条码检测位置调节
(0067) //	static unsigned char workSwitch=1;			// 停止工作开关
(0068) 	static unsigned char dustbinOldState;
(0069) 
(0070) 	int iPam;
(0071) 	unsigned char dat, i;
(0072) 	signed char si;
(0073) 	unsigned int iTmp0, iTmp1;
(0074) 
(0075) 	unsigned char workStep = 0;
    06EB8 3085      CPI	R24,5
(0076) 	_CONST char * pFlash;
(0077) 	
(0078) 	miantianSubFunction = 0;	
    06EB9 F018      BCS	0x6EBD
    06EBA 2422      CLR	R2
    06EBB 9220 17AB STS	_DiluentCalChart+10,R2
    06EBD EA81      LDI	R24,0xA1
    06EBE E197      LDI	R25,0x17
(0079) 
(0080) 	DiluteProcDatInit();
    06EBF 91E0 17AB LDS	R30,_DiluentCalChart+10
(0081) 	RingQueueDatInit();
    06EC1 27FF      CLR	R31
    06EC2 0FEE      LSL	R30
(0082) 	TestQueueDatInit();
    06EC3 1FFF      ROL	R31
    06EC4 0FE8      ADD	R30,R24
(0083) 	UnloadQueueDatInit();
    06EC5 1FF9      ADC	R31,R25
    06EC6 840E      LDD	R0,Y+14
(0084) 	InitCommandTransferData();
    06EC7 841F      LDD	R1,Y+15
    06EC8 8211      STD	Z+1,R1
(0085) 	InitControlLayerData();
    06EC9 8200      ST	Z,R0
    06ECA 9180 17AB LDS	R24,_DiluentCalChart+10
(0086) 	init_devices();
    06ECC 5F8F      SUBI	R24,0xFF
(0087) 	
(0088) 	Uart0ReUnable;
    06ECD 9380 17AB STS	_DiluentCalChart+10,R24
    06ECF 2400      CLR	R0
    06ED0 2411      CLR	R1
    06ED1 821B      STD	Y+3,R1
(0089) 	uart_Printf("%s $%s\r\n", strM0100, strVersion);
    06ED2 820A      STD	Y+2,R0
    06ED3 24EE      CLR	R14
    06ED4 2766      CLR	R22
    06ED5 C026      RJMP	0x6EFC
    06ED6 EA81      LDI	R24,0xA1
    06ED7 E197      LDI	R25,0x17
    06ED8 2FE6      MOV	R30,R22
    06ED9 27FF      CLR	R31
    06EDA 0FEE      LSL	R30
    06EDB 1FFF      ROL	R31
(0090) 	Uart0ReEnable;
    06EDC 0FE8      ADD	R30,R24
    06EDD 1FF9      ADC	R31,R25
    06EDE 8020      LD	R2,Z
    06EDF 8031      LDD	R3,Z+1
    06EE0 EC87      LDI	R24,0xC7
(0091) 	
(0092) 	ControlModel = 1;
    06EE1 E091      LDI	R25,1
    06EE2 1582      CP	R24,R2
    06EE3 0593      CPC	R25,R3
(0093) 	SetCardTrolleyState(0);
    06EE4 F4B0      BCC	0x6EFB
    06EE5 01C1      MOVW	R24,R2
    06EE6 3280      CPI	R24,0x20
(0094) 	SetBeepAck();
    06EE7 E0E3      LDI	R30,3
    06EE8 079E      CPC	R25,R30
(0095) 	SetStateLedBusy();
    06EE9 F488      BCC	0x6EFB
    06EEA EA81      LDI	R24,0xA1
(0096) 	WorkProcessStep = 255;
    06EEB E197      LDI	R25,0x17
    06EEC 2FE6      MOV	R30,R22
    06EED 27FF      CLR	R31
    06EEE 0FEE      LSL	R30
    06EEF 1FFF      ROL	R31
(0097) 	// 进入工作循环
(0098) 	while(1)
(0099) 	{
(0100) 		// 进程命令执行
(0101) 		switch(WorkProcessStep)
    06EF0 0FE8      ADD	R30,R24
    06EF1 1FF9      ADC	R31,R25
    06EF2 8020      LD	R2,Z
    06EF3 8031      LDD	R3,Z+1
    06EF4 800A      LDD	R0,Y+2
    06EF5 801B      LDD	R1,Y+3
    06EF6 0C02      ADD	R0,R2
    06EF7 1C13      ADC	R1,R3
    06EF8 821B      STD	Y+3,R1
    06EF9 820A      STD	Y+2,R0
    06EFA 94E3      INC	R14
    06EFB 9563      INC	R22
    06EFC 3065      CPI	R22,5
    06EFD F2C0      BCS	0x6ED6
    06EFE 2D2E      MOV	R18,R14
    06EFF 2733      CLR	R19
    06F00 810A      LDD	R16,Y+2
    06F01 811B      LDD	R17,Y+3
    06F02 940E AD66 CALL	div16u
    06F04 01A8      MOVW	R20,R16
    06F05 2400      CLR	R0
    06F06 2411      CLR	R1
    06F07 821B      STD	Y+3,R1
    06F08 820A      STD	Y+2,R0
    06F09 24EE      CLR	R14
    06F0A 01CA      MOVW	R24,R20
    06F0B 9606      ADIW	R24,6
    06F0C 015C      MOVW	R10,R24
    06F0D 01CA      MOVW	R24,R20
    06F0E 9706      SBIW	R24,6
    06F0F 016C      MOVW	R12,R24
    06F10 2766      CLR	R22
    06F11 C020      RJMP	0x6F32
    06F12 EA81      LDI	R24,0xA1
    06F13 E197      LDI	R25,0x17
    06F14 2FE6      MOV	R30,R22
    06F15 27FF      CLR	R31
    06F16 0FEE      LSL	R30
    06F17 1FFF      ROL	R31
(0102) 		{
(0103) 		/**************** 空闲  *****************/
(0104) 			case 255:
(0105) 				if(ControlCmd.cmdState == 2)
    06F18 0FE8      ADD	R30,R24
    06F19 1FF9      ADC	R31,R25
    06F1A 8020      LD	R2,Z
    06F1B 8031      LDD	R3,Z+1
    06F1C 14C2      CP	R12,R2
    06F1D 04D3      CPC	R13,R3
(0106) 				{
(0107) 					cmdState = 0;
    06F1E F490      BCC	0x6F31
    06F1F 142A      CP	R2,R10
    06F20 043B      CPC	R3,R11
(0108) 					Uart0ReUnable;
    06F21 F478      BCC	0x6F31
    06F22 2FE6      MOV	R30,R22
    06F23 27FF      CLR	R31
    06F24 0FEE      LSL	R30
    06F25 1FFF      ROL	R31
(0109) 					uart_Printf("#%4d CommandReceive $   0\r\n",ControlCmd.cmdIdx);
    06F26 0FE8      ADD	R30,R24
    06F27 1FF9      ADC	R31,R25
    06F28 8020      LD	R2,Z
    06F29 8031      LDD	R3,Z+1
    06F2A 800A      LDD	R0,Y+2
    06F2B 801B      LDD	R1,Y+3
    06F2C 0C02      ADD	R0,R2
    06F2D 1C13      ADC	R1,R3
(0110) 					Uart0ReEnable;
    06F2E 821B      STD	Y+3,R1
    06F2F 820A      STD	Y+2,R0
    06F30 94E3      INC	R14
    06F31 9563      INC	R22
    06F32 3065      CPI	R22,5
(0111) 					switch(ControlCmd.cmdIdx)
    06F33 F2F0      BCS	0x6F12
    06F34 20EE      TST	R14
    06F35 F041      BEQ	0x6F3E
    06F36 2D2E      MOV	R18,R14
    06F37 2733      CLR	R19
    06F38 810A      LDD	R16,Y+2
    06F39 811B      LDD	R17,Y+3
    06F3A 940E AD66 CALL	div16u
    06F3C 01A8      MOVW	R20,R16
    06F3D C002      RJMP	0x6F40
    06F3E 2744      CLR	R20
    06F3F 2755      CLR	R21
    06F40 9180 00C1 LDS	R24,0xC1
    06F42 7E8F      ANDI	R24,0xEF
    06F43 9380 00C1 STS	0xC1,R24
    06F45 840E      LDD	R0,Y+14
    06F46 841F      LDD	R1,Y+15
    06F47 8219      STD	Y+1,R1
    06F48 8208      ST	Y,R0
    06F49 019A      MOVW	R18,R20
    06F4A ED0A      LDI	R16,0xDA
    06F4B E016      LDI	R17,6
    06F4C 940E A90D CALL	_uart_Printf
    06F4E 9180 00C1 LDS	R24,0xC1
    06F50 6180      ORI	R24,0x10
    06F51 9380 00C1 STS	0xC1,R24
(0112) 					{
(0113) 						case 0:		// 回显开关
(0114) 							if(ControlCmd.pam[0]==0)
    06F53 3040      CPI	R20,0
    06F54 0745      CPC	R20,R21
    06F55 F099      BEQ	0x6F69
    06F56 01CA      MOVW	R24,R20
    06F57 9706      SBIW	R24,6
    06F58 840E      LDD	R0,Y+14
    06F59 841F      LDD	R1,Y+15
(0115) 								EchoSW = 0;
    06F5A 1580      CP	R24,R0
    06F5B 0591      CPC	R25,R1
    06F5C F450      BCC	0x6F67
    06F5D 01CA      MOVW	R24,R20
(0116) 							else
(0117) 								EchoSW = 1;
    06F5E 9606      ADIW	R24,6
    06F5F 1608      CP	R0,R24
    06F60 0619      CPC	R1,R25
(0118) 							break;
    06F61 F428      BCC	0x6F67
(0119) 						case 1:		// #0001 启动工作
(0120) 							StartWork();
    06F62 9350 17AD STS	_DiluentCalChart+12,R21
(0121) 							SetWorkStep(0);		// 设置零工作状态
    06F64 9340 17AC STS	_DiluentCalChart+11,R20
    06F66 C002      RJMP	0x6F69
(0122) 							GetStoreState(0);	// 初始化时读取片仓信息
    06F67 2744      CLR	R20
    06F68 2755      CLR	R21
    06F69 E009      LDI	R16,0x9
(0123) 							cmdState = 0;
    06F6A E010      LDI	R17,0
    06F6B D0FA      RCALL	_Save_DiluentCalChart
    06F6C 018A      MOVW	R16,R20
(0124) 							break;
    06F6D 9624      ADIW	R28,4
(0125) 						case 3:		// #0003 查询工作进程
(0126) 							Uart0ReUnable;
    06F6E 940E AE6D CALL	pop_xgsetF0FC
    06F70 9622      ADIW	R28,2
    06F71 9508      RET
_Read_DiluentCalChart:
    06F72 940E AE97 CALL	push_xgsetF00C
(0127) 							uart_Printf("%s $ 255 [Invalid]\r\n",strM0110);
    06F74 972E      SBIW	R28,0xE
    06F75 E289      LDI	R24,0x29
    06F76 E090      LDI	R25,0
    06F77 8399      STD	Y+1,R25
    06F78 8388      ST	Y,R24
(0128) 							Uart0ReEnable;
    06F79 EA21      LDI	R18,0xA1
    06F7A E137      LDI	R19,0x17
    06F7B E604      LDI	R16,0x64
    06F7C E010      LDI	R17,0
    06F7D 940E AF2A CALL	_EEPROMReadBytes_extIO
(0129) 							break;
    06F7F E081      LDI	R24,1
    06F80 E090      LDI	R25,0
    06F81 015C      MOVW	R10,R24
    06F82 C028      RJMP	0x6FAB
    06F83 0115      MOVW	R2,R10
(0130) 						case 99:	// 重启, 设置看门狗
(0131) 							ReStart(ControlCmd.pam[0]);
(0132) 							break;
    06F84 0C22      LSL	R2
(0133) 						default:
(0134) 							SetBeepWarning();
    06F85 1C33      ROL	R3
    06F86 EA8E      LDI	R24,0xAE
(0135) 							Uart0ReUnable;
    06F87 E197      LDI	R25,0x17
    06F88 01F1      MOVW	R30,R2
    06F89 0FE8      ADD	R30,R24
    06F8A 1FF9      ADC	R31,R25
    06F8B 8180      LD	R24,Z
(0136) 							uart_Printf("#%d CommandUnknown $   2\r\n",ControlCmd.cmdIdx);
    06F8C 8191      LDD	R25,Z+1
    06F8D 308A      CPI	R24,0xA
    06F8E E0E0      LDI	R30,0
    06F8F 079E      CPC	R25,R30
    06F90 F060      BCS	0x6F9D
    06F91 EA8E      LDI	R24,0xAE
    06F92 E197      LDI	R25,0x17
    06F93 01F1      MOVW	R30,R2
(0137) 							Uart0ReEnable;
    06F94 0FE8      ADD	R30,R24
    06F95 1FF9      ADC	R31,R25
    06F96 8020      LD	R2,Z
    06F97 8031      LDD	R3,Z+1
    06F98 EF8A      LDI	R24,0xFA
(0138) 							break;
(0139) 					}
(0140) 					if(cmdState)
    06F99 E090      LDI	R25,0
    06F9A 1582      CP	R24,R2
    06F9B 0593      CPC	R25,R3
    06F9C F458      BCC	0x6FA8
(0141) 					{
(0142) 						SetBeepWarning();
    06F9D EA8E      LDI	R24,0xAE
    06F9E E197      LDI	R25,0x17
(0143) 						Uart0ReUnable;
    06F9F 01F5      MOVW	R30,R10
    06FA0 0FEE      LSL	R30
    06FA1 1FFF      ROL	R31
    06FA2 0FE8      ADD	R30,R24
    06FA3 1FF9      ADC	R31,R25
(0144) 						uart_Printf("#%4d CommandError $   1\r\n",ControlCmd.cmdIdx);
    06FA4 E684      LDI	R24,0x64
    06FA5 E090      LDI	R25,0
    06FA6 8391      STD	Z+1,R25
    06FA7 8380      ST	Z,R24
    06FA8 01C5      MOVW	R24,R10
    06FA9 9601      ADIW	R24,1
    06FAA 015C      MOVW	R10,R24
    06FAB 01C5      MOVW	R24,R10
(0145) 						Uart0ReEnable;
    06FAC 308E      CPI	R24,0xE
    06FAD E0E0      LDI	R30,0
    06FAE 079E      CPC	R25,R30
    06FAF F408      BCC	0x6FB1
    06FB0 CFD2      RJMP	0x6F83
(0146) 					}
    06FB1 E289      LDI	R24,0x29
(0147) 					else
(0148) 					{
(0149) 						SetBeepAck();
    06FB2 E090      LDI	R25,0
    06FB3 8399      STD	Y+1,R25
(0150) 						Uart0ReUnable;
    06FB4 8388      ST	Y,R24
    06FB5 EA21      LDI	R18,0xA1
    06FB6 E137      LDI	R19,0x17
    06FB7 E604      LDI	R16,0x64
    06FB8 E010      LDI	R17,0
(0151) 						uart_Printf("#%4d CommandDone $   3\r\n",ControlCmd.cmdIdx);
    06FB9 940E AF45 CALL	_EEPROMWriteBytes_extIO
    06FBB 9180 17AC LDS	R24,_DiluentCalChart+11
    06FBD 9190 17AD LDS	R25,_DiluentCalChart+12
    06FBF 3C87      CPI	R24,0xC7
    06FC0 E0E1      LDI	R30,1
(0152) 						Uart0ReEnable;
    06FC1 079E      CPC	R25,R30
    06FC2 F048      BCS	0x6FCC
    06FC3 E280      LDI	R24,0x20
    06FC4 E093      LDI	R25,3
    06FC5 9020 17AC LDS	R2,_DiluentCalChart+11
(0153) 					}
(0154) 					CommandClear();
    06FC7 9030 17AD LDS	R3,_DiluentCalChart+12
(0155) 				}
(0156) 				break;
    06FC9 1582      CP	R24,R2
(0157) 			case 0:	
(0158) 				if(ControlCmd.cmdState==2)
    06FCA 0593      CPC	R25,R3
    06FCB F4D8      BCC	0x6FE7
    06FCC E781      LDI	R24,0x71
    06FCD E092      LDI	R25,2
    06FCE 9390 17AD STS	_DiluentCalChart+12,R25
(0159) 				{
(0160) 					cmdState = 0;
    06FD0 9380 17AC STS	_DiluentCalChart+11,R24
    06FD2 2422      CLR	R2
(0161) 					Uart0ReUnable;
    06FD3 9220 17AB STS	_DiluentCalChart+10,R2
    06FD5 9390 17A2 STS	_DiluentCalChart+1,R25
    06FD7 9380 17A1 STS	_DiluentCalChart,R24
(0162) 					uart_Printf("#%4d CommandReceive $   0\r\n",ControlCmd.cmdIdx);
    06FD9 2D82      MOV	R24,R2
    06FDA 5F8F      SUBI	R24,0xFF
    06FDB 9380 17AB STS	_DiluentCalChart+10,R24
    06FDD E289      LDI	R24,0x29
    06FDE E090      LDI	R25,0
    06FDF 8399      STD	Y+1,R25
(0163) 					Uart0ReEnable;
    06FE0 8388      ST	Y,R24
    06FE1 EA21      LDI	R18,0xA1
    06FE2 E137      LDI	R19,0x17
    06FE3 E604      LDI	R16,0x64
    06FE4 E010      LDI	R17,0
(0164) 					switch(ControlCmd.cmdIdx)
    06FE5 940E AF45 CALL	_EEPROMWriteBytes_extIO
    06FE7 9020 17AC LDS	R2,_DiluentCalChart+11
    06FE9 9030 17AD LDS	R3,_DiluentCalChart+12
    06FEB 2444      CLR	R4
    06FEC 2455      CLR	R5
    06FED 862A      STD	Y+10,R2
    06FEE 863B      STD	Y+11,R3
    06FEF 864C      STD	Y+12,R4
    06FF0 865D      STD	Y+13,R5
    06FF1 9180 00C1 LDS	R24,0xC1
    06FF3 7E8F      ANDI	R24,0xEF
    06FF4 9380 00C1 STS	0xC1,R24
    06FF6 842A      LDD	R2,Y+10
    06FF7 843B      LDD	R3,Y+11
    06FF8 844C      LDD	R4,Y+12
    06FF9 845D      LDD	R5,Y+13
    06FFA 8248      ST	Y,R4
    06FFB 8259      STD	Y+1,R5
    06FFC 0191      MOVW	R18,R2
    06FFD EC04      LDI	R16,0xC4
    06FFE E016      LDI	R17,6
    06FFF 940E A90D CALL	_uart_Printf
    07001 9180 00C1 LDS	R24,0xC1
    07003 6180      ORI	R24,0x10
    07004 9380 00C1 STS	0xC1,R24
    07006 E081      LDI	R24,1
    07007 E090      LDI	R25,0
    07008 015C      MOVW	R10,R24
    07009 C053      RJMP	0x705D
    0700A EA8E      LDI	R24,0xAE
    0700B E197      LDI	R25,0x17
    0700C 01F5      MOVW	R30,R10
    0700D 0FEE      LSL	R30
    0700E 1FFF      ROL	R31
    0700F 0FE8      ADD	R30,R24
    07010 1FF9      ADC	R31,R25
    07011 8020      LD	R2,Z
    07012 8031      LDD	R3,Z+1
    07013 2444      CLR	R4
    07014 2455      CLR	R5
    07015 822E      STD	Y+6,R2
(0165) 					{
(0166) 						case 0:		// 回显开关
(0167) 							if(ControlCmd.pam[0]==0)
    07016 823F      STD	Y+7,R3
    07017 8648      STD	Y+8,R4
    07018 8659      STD	Y+9,R5
    07019 802E      LDD	R2,Y+6
    0701A 803F      LDD	R3,Y+7
    0701B 8448      LDD	R4,Y+8
    0701C 8459      LDD	R5,Y+9
    0701D 850A      LDD	R16,Y+10
(0168) 								EchoSW = 0;
    0701E 851B      LDD	R17,Y+11
    0701F 852C      LDD	R18,Y+12
    07020 853D      LDD	R19,Y+13
    07021 925A      ST	-Y,R5
(0169) 							else
(0170) 								EchoSW = 1;
    07022 924A      ST	-Y,R4
    07023 923A      ST	-Y,R3
    07024 922A      ST	-Y,R2
(0171) 							break;
    07025 940E AE24 CALL	empy32s|empy32u
(0172) 						case 1:		// #0001 启动工作
(0173) 							StartWork();
    07027 E644      LDI	R20,0x64
(0174) 							cmdState = 0;
    07028 E050      LDI	R21,0
    07029 E060      LDI	R22,0
    0702A E070      LDI	R23,0
(0175) 							break;
    0702B 937A      ST	-Y,R23
(0176) 						case 2:		// #0002 设置工作进程
(0177) 							if(ControlCmd.pam[0] < 5 || ControlCmd.pam[0] == 9)
    0702C 936A      ST	-Y,R22
    0702D 935A      ST	-Y,R21
    0702E 934A      ST	-Y,R20
    0702F 940E AD80 CALL	div32u
    07031 830A      STD	Y+2,R16
    07032 831B      STD	Y+3,R17
    07033 832C      STD	Y+4,R18
    07034 833D      STD	Y+5,R19
    07035 E885      LDI	R24,0x85
    07036 E197      LDI	R25,0x17
    07037 01F5      MOVW	R30,R10
(0178) 							{
(0179) 								SetWorkStep(ControlCmd.pam[0]);
    07038 0FEE      LSL	R30
    07039 1FFF      ROL	R31
    0703A 0FE8      ADD	R30,R24
    0703B 1FF9      ADC	R31,R25
    0703C 802A      LDD	R2,Y+2
    0703D 803B      LDD	R3,Y+3
(0180) 							}
    0703E 8231      STD	Z+1,R3
(0181) 							else
(0182) 								cmdState = 1;	// 设置参数错误
    0703F 8220      ST	Z,R2
    07040 9180 00C1 LDS	R24,0xC1
(0183) 							break;
    07042 7E8F      ANDI	R24,0xEF
(0184) 						case 3:		// #0003 查询工作进程
(0185) 							Uart0ReUnable;
    07043 9380 00C1 STS	0xC1,R24
    07045 E885      LDI	R24,0x85
    07046 E197      LDI	R25,0x17
    07047 01F5      MOVW	R30,R10
(0186) 							uart_Printf("%s $   0 [Free]\r\n",strM0110);
    07048 0FEE      LSL	R30
    07049 1FFF      ROL	R31
    0704A 0FE8      ADD	R30,R24
    0704B 1FF9      ADC	R31,R25
    0704C 8020      LD	R2,Z
    0704D 8031      LDD	R3,Z+1
(0187) 							Uart0ReEnable;
    0704E 8239      STD	Y+1,R3
    0704F 8228      ST	Y,R2
    07050 0195      MOVW	R18,R10
    07051 EB05      LDI	R16,0xB5
    07052 E016      LDI	R17,6
(0188) 							break;
    07053 940E A90D CALL	_uart_Printf
(0189) 						case 10:	// #0010	开启片仓
(0190) 							if(CardStoreOpenLook == 0)
    07055 9180 00C1 LDS	R24,0xC1
    07057 6180      ORI	R24,0x10
(0191) 								SetStoreDoorOpen(ControlCmd.pam[0]);
    07058 9380 00C1 STS	0xC1,R24
    0705A 01C5      MOVW	R24,R10
    0705B 9601      ADIW	R24,1
    0705C 015C      MOVW	R10,R24
    0705D 01C5      MOVW	R24,R10
    0705E 308E      CPI	R24,0xE
(0192) 							else
(0193) 							{
(0194) 								Uart0ReUnable;
    0705F E0E0      LDI	R30,0
    07060 079E      CPC	R25,R30
    07061 F408      BCC	0x7063
    07062 CFA7      RJMP	0x700A
    07063 962E      ADIW	R28,0xE
(0195) 								uart_Printf("%s\r\n",strM0112);
    07064 940C AE9E JMP	pop_xgsetF00C
_Save_DiluentCalChart:
    07066 940E AE97 CALL	push_xgsetF00C
    07068 0158      MOVW	R10,R16
    07069 972A      SBIW	R28,0xA
(0196) 								Uart0ReEnable;
    0706A 20AA      TST	R10
    0706B F431      BNE	0x7072
    0706C 20BB      TST	R11
    0706D F421      BNE	0x7072
    0706E E089      LDI	R24,0x9
(0197) 							}
(0198) 							break;
    0706F E090      LDI	R25,0
(0199) 						case 11:	// #0011	读取片仓温湿度
(0200) 							Uart0ReUnable;
    07070 015C      MOVW	R10,R24
    07071 C006      RJMP	0x7078
    07072 E08D      LDI	R24,0xD
    07073 E090      LDI	R25,0
    07074 158A      CP	R24,R10
(0201) 							uart_Printf("%s $%4d $%4d\r\n", strM0111, GetStoreHumi(), GetStoreTemp());
    07075 059B      CPC	R25,R11
    07076 F408      BCC	0x7078
    07077 015C      MOVW	R10,R24
    07078 EA8E      LDI	R24,0xAE
    07079 E197      LDI	R25,0x17
    0707A 01F5      MOVW	R30,R10
    0707B 0FEE      LSL	R30
    0707C 1FFF      ROL	R31
    0707D 0FE8      ADD	R30,R24
    0707E 1FF9      ADC	R31,R25
    0707F 8180      LD	R24,Z
    07080 8191      LDD	R25,Z+1
    07081 308A      CPI	R24,0xA
    07082 E0E0      LDI	R30,0
    07083 079E      CPC	R25,R30
    07084 F458      BCC	0x7090
    07085 EA8E      LDI	R24,0xAE
    07086 E197      LDI	R25,0x17
    07087 01F5      MOVW	R30,R10
    07088 0FEE      LSL	R30
(0202) 							Uart0ReEnable;
    07089 1FFF      ROL	R31
    0708A 0FE8      ADD	R30,R24
    0708B 1FF9      ADC	R31,R25
    0708C E08A      LDI	R24,0xA
    0708D E090      LDI	R25,0
(0203) 							break;
    0708E 8391      STD	Z+1,R25
(0204) 						case 99:	// 重起, 设置看门狗
(0205) 							ReStart(ControlCmd.pam[0]);
    0708F 8380      ST	Z,R24
    07090 EA8E      LDI	R24,0xAE
    07091 E197      LDI	R25,0x17
    07092 01F5      MOVW	R30,R10
    07093 0FEE      LSL	R30
(0206) 							break;
    07094 1FFF      ROL	R31
(0207) 						default:
(0208) 							SetBeepWarning();
    07095 0FE8      ADD	R30,R24
    07096 1FF9      ADC	R31,R25
(0209) 							Uart0ReUnable;
    07097 8020      LD	R2,Z
    07098 8031      LDD	R3,Z+1
    07099 EF8A      LDI	R24,0xFA
    0709A E090      LDI	R25,0
    0709B 1582      CP	R24,R2
(0210) 							uart_Printf("#%d CommandUnknown $   2\r\n",ControlCmd.cmdIdx);
    0709C 0593      CPC	R25,R3
    0709D F458      BCC	0x70A9
    0709E EA8E      LDI	R24,0xAE
    0709F E197      LDI	R25,0x17
    070A0 01F5      MOVW	R30,R10
    070A1 0FEE      LSL	R30
    070A2 1FFF      ROL	R31
    070A3 0FE8      ADD	R30,R24
(0211) 							Uart0ReEnable;
    070A4 1FF9      ADC	R31,R25
    070A5 EF8A      LDI	R24,0xFA
    070A6 E090      LDI	R25,0
    070A7 8391      STD	Z+1,R25
    070A8 8380      ST	Z,R24
(0212) 							break;
(0213) 						}
(0214) 					if(cmdState)
    070A9 9180 17AC LDS	R24,_DiluentCalChart+11
    070AB 9190 17AD LDS	R25,_DiluentCalChart+12
(0215) 					{
(0216) 						SetBeepWarning();
    070AD 3C87      CPI	R24,0xC7
    070AE E0E1      LDI	R30,1
(0217) 						Uart0ReUnable;
    070AF 079E      CPC	R25,R30
    070B0 F430      BCC	0x70B7
    070B1 EC87      LDI	R24,0xC7
    070B2 E091      LDI	R25,1
    070B3 9390 17AD STS	_DiluentCalChart+12,R25
(0218) 						uart_Printf("#%4d CommandError $   1\r\n",ControlCmd.cmdIdx);
    070B5 9380 17AC STS	_DiluentCalChart+11,R24
    070B7 E280      LDI	R24,0x20
    070B8 E093      LDI	R25,3
    070B9 9020 17AC LDS	R2,_DiluentCalChart+11
    070BB 9030 17AD LDS	R3,_DiluentCalChart+12
(0219) 						Uart0ReEnable;
    070BD 1582      CP	R24,R2
    070BE 0593      CPC	R25,R3
    070BF F420      BCC	0x70C4
    070C0 9390 17AD STS	_DiluentCalChart+12,R25
(0220) 					}
    070C2 9380 17AC STS	_DiluentCalChart+11,R24
(0221) 					else
(0222) 					{
(0223) 						SetBeepAck();
(0224) 						Uart0ReUnable;
    070C4 E289      LDI	R24,0x29
    070C5 E090      LDI	R25,0
    070C6 8399      STD	Y+1,R25
    070C7 8388      ST	Y,R24
    070C8 EA21      LDI	R18,0xA1
(0225) 						uart_Printf("#%4d CommandDone $   3\r\n",ControlCmd.cmdIdx);
    070C9 E137      LDI	R19,0x17
    070CA E604      LDI	R16,0x64
    070CB E010      LDI	R17,0
    070CC 940E AF45 CALL	_EEPROMWriteBytes_extIO
    070CE 9020 17AC LDS	R2,_DiluentCalChart+11
    070D0 9030 17AD LDS	R3,_DiluentCalChart+12
(0226) 						Uart0ReEnable;
    070D2 2444      CLR	R4
    070D3 2455      CLR	R5
    070D4 822A      STD	Y+2,R2
    070D5 823B      STD	Y+3,R3
(0227) 					}
(0228) 				//	if(ControlCmd.cmdIdx)
(0229) 						CommandClear();
    070D6 824C      STD	Y+4,R4
    070D7 825D      STD	Y+5,R5
(0230) 					}
(0231) 				break;
    070D8 EA8E      LDI	R24,0xAE
    070D9 E197      LDI	R25,0x17
(0232) 		/************** 机械自检  ***************/
(0233) 			case 1:		
(0234) 				if(ControlCmd.cmdState==2)
    070DA 01F5      MOVW	R30,R10
    070DB 0FEE      LSL	R30
    070DC 1FFF      ROL	R31
    070DD 0FE8      ADD	R30,R24
    070DE 1FF9      ADC	R31,R25
(0235) 				{
(0236) 					cmdState = 0;
    070DF 8020      LD	R2,Z
    070E0 8031      LDD	R3,Z+1
    070E1 2444      CLR	R4
(0237) 					Uart0ReUnable;
    070E2 2455      CLR	R5
    070E3 822E      STD	Y+6,R2
    070E4 823F      STD	Y+7,R3
    070E5 8648      STD	Y+8,R4
    070E6 8659      STD	Y+9,R5
(0238) 					uart_Printf("#%4d CommandReceive $   0\r\n",ControlCmd.cmdIdx);
    070E7 802E      LDD	R2,Y+6
    070E8 803F      LDD	R3,Y+7
    070E9 8448      LDD	R4,Y+8
    070EA 8459      LDD	R5,Y+9
    070EB 810A      LDD	R16,Y+2
    070EC 811B      LDD	R17,Y+3
    070ED 812C      LDD	R18,Y+4
    070EE 813D      LDD	R19,Y+5
(0239) 					Uart0ReEnable;
    070EF 925A      ST	-Y,R5
    070F0 924A      ST	-Y,R4
    070F1 923A      ST	-Y,R3
    070F2 922A      ST	-Y,R2
    070F3 940E AE24 CALL	empy32s|empy32u
(0240) 					switch(ControlCmd.cmdIdx){
    070F5 E644      LDI	R20,0x64
    070F6 E050      LDI	R21,0
    070F7 E060      LDI	R22,0
    070F8 E070      LDI	R23,0
    070F9 937A      ST	-Y,R23
    070FA 936A      ST	-Y,R22
    070FB 935A      ST	-Y,R21
    070FC 934A      ST	-Y,R20
    070FD 940E AD80 CALL	div32u
    070FF 830A      STD	Y+2,R16
    07100 831B      STD	Y+3,R17
    07101 832C      STD	Y+4,R18
    07102 833D      STD	Y+5,R19
    07103 E885      LDI	R24,0x85
    07104 E197      LDI	R25,0x17
    07105 01F5      MOVW	R30,R10
    07106 0FEE      LSL	R30
    07107 1FFF      ROL	R31
    07108 0FE8      ADD	R30,R24
    07109 1FF9      ADC	R31,R25
    0710A 802A      LDD	R2,Y+2
    0710B 803B      LDD	R3,Y+3
    0710C 8231      STD	Z+1,R3
    0710D 8220      ST	Z,R2
    0710E 01F5      MOVW	R30,R10
(0241) 						case 3:		// #0003 查询工作进程
(0242) 							Uart0ReUnable;
    0710F 0FEE      LSL	R30
    07110 1FFF      ROL	R31
    07111 0FE8      ADD	R30,R24
    07112 1FF9      ADC	R31,R25
    07113 8100      LD	R16,Z
(0243) 							uart_Printf("%s $   1 [MechineCheck]\r\n",strM0110);
    07114 8111      LDD	R17,Z+1
    07115 962A      ADIW	R28,0xA
    07116 940C AE9E JMP	pop_xgsetF00C
_MemCopy:
    07118 940E AE7C CALL	push_xgset00FC
(0244) 							Uart0ReEnable;
    0711A 80EE      LDD	R14,Y+6
    0711B 0158      MOVW	R10,R16
    0711C 0169      MOVW	R12,R18
    0711D C007      RJMP	0x7125
    0711E 01F5      MOVW	R30,R10
(0245) 							break;
    0711F 01D6      MOVW	R26,R12
(0246) 						case 5:
(0247) 							if(ControlCmd.pam[0] == 0)
    07120 9001      LD	R0,Z+
    07121 015F      MOVW	R10,R30
    07122 920D      ST	X+,R0
    07123 016D      MOVW	R12,R26
    07124 94EA      DEC	R14
    07125 20EE      TST	R14
    07126 F7B9      BNE	0x711E
    07127 940C AE5D JMP	pop_xgset00FC
(0248) 							{
(0249) 								workSwitch = 1;
_StringMatching:
    07129 C013      RJMP	0x713D
    0712A 01F9      MOVW	R30,R18
(0250) 								Uart0ReUnable;
    0712B 8020      LD	R2,Z
    0712C 2022      TST	R2
    0712D F411      BNE	0x7130
    0712E 2700      CLR	R16
    0712F C01A      RJMP	0x714A
(0251) 								uart_Printf("%s\r\n",strM0105);
    07130 01F9      MOVW	R30,R18
    07131 8020      LD	R2,Z
    07132 01F8      MOVW	R30,R16
    07133 9036      ELPM	R3,Z
    07134 1432      CP	R3,R2
    07135 F429      BNE	0x713B
(0252) 								Uart0ReEnable;
    07136 5F0F      SUBI	R16,0xFF
    07137 4F1F      SBCI	R17,0xFF
    07138 5F2F      SUBI	R18,0xFF
    07139 4F3F      SBCI	R19,0xFF
    0713A C002      RJMP	0x713D
(0253) 							}
    0713B 2700      CLR	R16
(0254) 							else
(0255) 							{
(0256) 								workSwitch = 0;
    0713C C00D      RJMP	0x714A
    0713D 01F8      MOVW	R30,R16
    0713E 9026      ELPM	R2,Z
(0257) 								Uart0ReUnable;
    0713F 2022      TST	R2
    07140 F749      BNE	0x712A
    07141 01F9      MOVW	R30,R18
    07142 8020      LD	R2,Z
    07143 01F8      MOVW	R30,R16
(0258) 								uart_Printf("%s\r\n",strM0106);
    07144 9036      ELPM	R3,Z
    07145 1432      CP	R3,R2
    07146 F411      BNE	0x7149
    07147 E001      LDI	R16,1
    07148 C001      RJMP	0x714A
    07149 2700      CLR	R16
(0259) 								Uart0ReEnable;
    0714A 9508      RET
_StringToInt:
    0714B 940E AE97 CALL	push_xgsetF00C
    0714D 01B8      MOVW	R22,R16
    0714E 2744      CLR	R20
(0260) 							}
(0261) 							break;
    0714F 01FB      MOVW	R30,R22
(0262) 						case 99:	// 重启, 设置看门狗
(0263) 							ReStart(ControlCmd.pam[0]);
    07150 8180      LD	R24,Z
    07151 328D      CPI	R24,0x2D
    07152 F419      BNE	0x7156
    07153 5F6F      SUBI	R22,0xFF
    07154 4F7F      SBCI	R23,0xFF
(0264) 							break;
    07155 E041      LDI	R20,1
(0265) 						default:
(0266) 							SetBeepWarning();
    07156 24AA      CLR	R10
    07157 24BB      CLR	R11
(0267) 							Uart0ReUnable;
    07158 C017      RJMP	0x7170
    07159 01FB      MOVW	R30,R22
    0715A 8020      LD	R2,Z
    0715B 2433      CLR	R3
    0715C 2D82      MOV	R24,R2
(0268) 							uart_Printf("#%d CommandUnknown $   2\r\n",ControlCmd.cmdIdx);
    0715D 3380      CPI	R24,0x30
    0715E F078      BCS	0x716E
    0715F E389      LDI	R24,0x39
    07160 1582      CP	R24,R2
    07161 F060      BCS	0x716E
    07162 E00A      LDI	R16,0xA
    07163 E010      LDI	R17,0
    07164 0195      MOVW	R18,R10
(0269) 							Uart0ReEnable;
    07165 940E AE14 CALL	empy16s
    07167 0158      MOVW	R10,R16
    07168 01FB      MOVW	R30,R22
    07169 8180      LD	R24,Z
(0270) 							break;
(0271) 						}
(0272) 					if(cmdState){
    0716A 2799      CLR	R25
    0716B 97C0      SBIW	R24,0x30
    0716C 0EA8      ADD	R10,R24
    0716D 1EB9      ADC	R11,R25
(0273) 						SetBeepWarning();
    0716E 5F6F      SUBI	R22,0xFF
    0716F 4F7F      SBCI	R23,0xFF
(0274) 						Uart0ReUnable;
    07170 01FB      MOVW	R30,R22
    07171 8020      LD	R2,Z
    07172 2022      TST	R2
    07173 F729      BNE	0x7159
    07174 2344      TST	R20
(0275) 						uart_Printf("#%4d CommandError $   1\r\n",ControlCmd.cmdIdx);
    07175 F029      BEQ	0x717B
    07176 2422      CLR	R2
    07177 2433      CLR	R3
    07178 182A      SUB	R2,R10
    07179 083B      SBC	R3,R11
    0717A 0151      MOVW	R10,R2
    0717B 0185      MOVW	R16,R10
    0717C 940C AE9E JMP	pop_xgsetF00C
(0276) 						Uart0ReEnable;
_StringToInt2:
    0717E 940E AE83 CALL	push_xgset300C
    07180 01A8      MOVW	R20,R16
    07181 24AA      CLR	R10
(0277) 						}
    07182 24BB      CLR	R11
(0278) 					else{
(0279) 						SetBeepAck();
    07183 C017      RJMP	0x719B
    07184 01FA      MOVW	R30,R20
(0280) 						Uart0ReUnable;
    07185 8020      LD	R2,Z
    07186 2433      CLR	R3
    07187 2D82      MOV	R24,R2
    07188 3380      CPI	R24,0x30
    07189 F078      BCS	0x7199
(0281) 						uart_Printf("#%4d CommandDone $   3\r\n",ControlCmd.cmdIdx);
    0718A E389      LDI	R24,0x39
    0718B 1582      CP	R24,R2
    0718C F060      BCS	0x7199
    0718D E00A      LDI	R16,0xA
    0718E E010      LDI	R17,0
    0718F 0195      MOVW	R18,R10
    07190 940E AE14 CALL	empy16s
(0282) 						Uart0ReEnable;
    07192 0158      MOVW	R10,R16
    07193 01FA      MOVW	R30,R20
    07194 8180      LD	R24,Z
    07195 2799      CLR	R25
    07196 97C0      SBIW	R24,0x30
(0283) 						}
(0284) 				//	if(ControlCmd.cmdIdx)
(0285) 						CommandClear();
    07197 0EA8      ADD	R10,R24
    07198 1EB9      ADC	R11,R25
(0286) 					}
(0287) 				if(workSwitch)
    07199 5F4F      SUBI	R20,0xFF
    0719A 4F5F      SBCI	R21,0xFF
    0719B 01FA      MOVW	R30,R20
    0719C 8180      LD	R24,Z
    0719D 3284      CPI	R24,0x24
    0719E F729      BNE	0x7184
(0288) 				{
(0289) 					if(MachinePositionInit() == 1)
    0719F 0185      MOVW	R16,R10
    071A0 940C AE88 JMP	pop_xgset300C
_AbsDifference:
    071A2 92AA      ST	-Y,R10
    071A3 92BA      ST	-Y,R11
    071A4 1720      CP	R18,R16
    071A5 0731      CPC	R19,R17
(0290) 					{
(0291) 						SetWorkStep(0);
    071A6 F420      BCC	0x71AB
    071A7 0158      MOVW	R10,R16
    071A8 1AA2      SUB	R10,R18
(0292) 					}
(0293) 				}
(0294) 				break;
    071A9 0AB3      SBC	R11,R19
    071AA C003      RJMP	0x71AE
(0295) 		/*************** 液路自检 ***************/
(0296) 			case 2:		
(0297) 				if(ControlCmd.cmdState==2)
    071AB 0159      MOVW	R10,R18
    071AC 1AA0      SUB	R10,R16
    071AD 0AB1      SBC	R11,R17
    071AE 0185      MOVW	R16,R10
    071AF 90B9      LD	R11,Y+
(0298) 				{
(0299) 					cmdState = 0;
    071B0 90A9      LD	R10,Y+
    071B1 9508      RET
_ReStart:
    071B2 92AA      ST	-Y,R10
(0300) 					Uart0ReUnable;
    071B3 2EA0      MOV	R10,R16
    071B4 9723      SBIW	R28,3
    071B5 94F8      BCLR	7
    071B6 9180 00C1 LDS	R24,0xC1
(0301) 					uart_Printf("#%4d CommandReceive $   0\r\n",ControlCmd.cmdIdx);
    071B8 7E8F      ANDI	R24,0xEF
    071B9 9380 00C1 STS	0xC1,R24
    071BB EE29      LDI	R18,0xE9
    071BC E035      LDI	R19,5
    071BD EE05      LDI	R16,0xE5
    071BE E018      LDI	R17,0x8
    071BF 940E A90D CALL	_uart_Printf
(0302) 					Uart0ReEnable;
    071C1 9180 00C1 LDS	R24,0xC1
    071C3 6180      ORI	R24,0x10
    071C4 9380 00C1 STS	0xC1,R24
(0303) 					switch(ControlCmd.cmdIdx)
    071C6 20AA      TST	R10
    071C7 F061      BEQ	0x71D4
    071C8 E081      LDI	R24,1
    071C9 838A      STD	Y+2,R24
    071CA 2799      CLR	R25
    071CB 8399      STD	Y+1,R25
    071CC 8388      ST	Y,R24
    071CD 019E      MOVW	R18,R28
    071CE 5F2E      SUBI	R18,0xFE
    071CF 4F3F      SBCI	R19,0xFF
    071D0 E302      LDI	R16,0x32
    071D1 E010      LDI	R17,0
    071D2 940E AF45 CALL	_EEPROMWriteBytes_extIO
    071D4 95A8      WDR
    071D5 9180 0060 LDS	R24,0x60
    071D7 6188      ORI	R24,0x18
    071D8 9380 0060 STS	0x60,R24
    071DA E08F      LDI	R24,0xF
    071DB 9380 0060 STS	0x60,R24
    071DD 9478      BSET	7
    071DE 9623      ADIW	R28,3
    071DF 90A9      LD	R10,Y+
(0304) 					{
(0305) 						case 3:		// #0003 查询工作进程
(0306) 							Uart0ReUnable;
    071E0 9508      RET
_main:
    071E1 9726      SBIW	R28,6
    071E2 24AA      CLR	R10
    071E3 2422      CLR	R2
    071E4 2433      CLR	R3
(0307) 							uart_Printf("%s $   2 [LiquidCheck]\r\n",strM0110);
    071E5 9230 17D5 STS	miantianSubFunction+1,R3
    071E7 9220 17D4 STS	miantianSubFunction,R2
    071E9 940E 61ED CALL	_DiluteProcDatInit
(0308) 							Uart0ReEnable;
    071EB 940E 9E94 CALL	_RingQueueDatInit
    071ED 940E 9FFB CALL	_TestQueueDatInit
    071EF 940E A99E CALL	_UnloadQueueDatInit
(0309) 							break;
    071F1 940E 132C CALL	_InitCommandTransferData
    071F3 940E 2D56 CALL	_InitControlLayerData
    071F5 940E 9B70 CALL	_init_devices
    071F7 9180 00C1 LDS	R24,0xC1
(0310) 						case 5:
(0311) 							if(ControlCmd.pam[0] == 0)
(0312) 							{
(0313) 								workSwitch = 1;
    071F9 7E8F      ANDI	R24,0xEF
    071FA 9380 00C1 STS	0xC1,R24
(0314) 								Uart0ReUnable;
    071FC E18E      LDI	R24,0x1E
    071FD E095      LDI	R25,5
    071FE 8399      STD	Y+1,R25
    071FF 8388      ST	Y,R24
    07200 E32A      LDI	R18,0x3A
(0315) 								uart_Printf("%s\r\n",strM0105);
    07201 E035      LDI	R19,5
    07202 ED0C      LDI	R16,0xDC
    07203 E018      LDI	R17,0x8
    07204 940E A90D CALL	_uart_Printf
    07206 9180 00C1 LDS	R24,0xC1
(0316) 								Uart0ReEnable;
    07208 6180      ORI	R24,0x10
    07209 9380 00C1 STS	0xC1,R24
    0720B E081      LDI	R24,1
(0317) 							}
    0720C 9380 17D8 STS	ControlModel,R24
(0318) 							else
(0319) 							{
(0320) 								workSwitch = 0;
    0720E 2700      CLR	R16
    0720F 940E 18A0 CALL	_SetCardTrolleyState
(0321) 								Uart0ReUnable;
    07211 940E 3739 CALL	_SetBeepAck
    07213 940E 38F8 CALL	_SetStateLedBusy
(0322) 								uart_Printf("%s\r\n",strM0106);
    07215 EF8F      LDI	R24,0xFF
    07216 9380 17D7 STS	WorkProcessStep,R24
    07218 940C 8104 JMP	0x8104
    0721A 9140 17D7 LDS	R20,WorkProcessStep
(0323) 								Uart0ReEnable;
    0721C 2755      CLR	R21
    0721D 3040      CPI	R20,0
    0721E 0745      CPC	R20,R21
    0721F F409      BNE	0x7221
(0324) 							}
(0325) 							break;
    07220 C0D3      RJMP	0x72F4
(0326) 						case 99:	// 重起, 设置看门狗
(0327) 							ReStart(ControlCmd.pam[0]);
    07221 3041      CPI	R20,1
    07222 E0E0      LDI	R30,0
    07223 075E      CPC	R21,R30
    07224 F409      BNE	0x7226
    07225 C1DE      RJMP	0x7404
(0328) 							break;
    07226 3042      CPI	R20,2
(0329) 						default:
(0330) 							SetBeepWarning();
    07227 E0E0      LDI	R30,0
    07228 075E      CPC	R21,R30
(0331) 							Uart0ReUnable;
    07229 F409      BNE	0x722B
    0722A C2C3      RJMP	0x74EE
    0722B 3043      CPI	R20,3
    0722C E0E0      LDI	R30,0
    0722D 075E      CPC	R21,R30
(0332) 							uart_Printf("#%d CommandUnknown $   2\r\n",ControlCmd.cmdIdx);
    0722E F409      BNE	0x7230
    0722F C3AA      RJMP	0x75DA
    07230 3044      CPI	R20,4
    07231 E0E0      LDI	R30,0
    07232 075E      CPC	R21,R30
    07233 F411      BNE	0x7236
    07234 940C 7B9A JMP	0x7B9A
(0333) 							Uart0ReEnable;
    07236 3040      CPI	R20,0
    07237 E0E0      LDI	R30,0
    07238 075E      CPC	R21,R30
    07239 F414      BGE	0x723C
    0723A 940C 80B7 JMP	0x80B7
(0334) 							break;
(0335) 						}
(0336) 					if(cmdState){
    0723C 3F4F      CPI	R20,0xFF
    0723D E0E0      LDI	R30,0
    0723E 075E      CPC	R21,R30
(0337) 						SetBeepWarning();
    0723F F011      BEQ	0x7242
    07240 940C 80B7 JMP	0x80B7
(0338) 						Uart0ReUnable;
    07242 9180 1566 LDS	R24,ControlCmd
    07244 3082      CPI	R24,2
    07245 F011      BEQ	0x7248
(0339) 						uart_Printf("#%4d CommandError $   1\r\n",ControlCmd.cmdIdx);
    07246 940C 80B7 JMP	0x80B7
    07248 2422      CLR	R2
    07249 9220 17CA STS	_DiluentCalChart+41,R2
    0724B 9180 00C1 LDS	R24,0xC1
    0724D 7E8F      ANDI	R24,0xEF
(0340) 						Uart0ReEnable;
    0724E 9380 00C1 STS	0xC1,R24
    07250 9120 1567 LDS	R18,ControlCmd+1
    07252 9130 1568 LDS	R19,ControlCmd+2
(0341) 						}
    07254 EC00      LDI	R16,0xC0
    07255 E018      LDI	R17,0x8
(0342) 					else{
(0343) 						SetBeepAck();
(0344) 						Uart0ReUnable;
    07256 940E A90D CALL	_uart_Printf
    07258 9180 00C1 LDS	R24,0xC1
    0725A 6180      ORI	R24,0x10
(0345) 						uart_Printf("#%4d CommandDone $   3\r\n",ControlCmd.cmdIdx);
    0725B 9380 00C1 STS	0xC1,R24
    0725D 9020 1567 LDS	R2,ControlCmd+1
    0725F 9030 1568 LDS	R3,ControlCmd+2
    07261 2022      TST	R2
    07262 F411      BNE	0x7265
(0346) 						Uart0ReEnable;
    07263 2033      TST	R3
    07264 F0B9      BEQ	0x727C
    07265 01C1      MOVW	R24,R2
    07266 3081      CPI	R24,1
    07267 E0E0      LDI	R30,0
(0347) 						}
(0348) 				//	if(ControlCmd.cmdIdx)
(0349) 						CommandClear();
    07268 079E      CPC	R25,R30
    07269 F111      BEQ	0x728C
(0350) 					}
(0351) 				if(workSwitch)
    0726A 3083      CPI	R24,3
    0726B E0E0      LDI	R30,0
    0726C 079E      CPC	R25,R30
    0726D F151      BEQ	0x7298
    0726E 3080      CPI	R24,0
    0726F E0E0      LDI	R30,0
(0352) 				{
(0353) 					if(DiluteStartCheck(0) == 1)	// 函数返回1表示处理完毕
    07270 079E      CPC	R25,R30
    07271 F40C      BGE	0x7273
    07272 C03C      RJMP	0x72AF
    07273 9180 1567 LDS	R24,ControlCmd+1
    07275 9190 1568 LDS	R25,ControlCmd+2
    07277 3683      CPI	R24,0x63
    07278 E0E0      LDI	R30,0
(0354) 					{
(0355) 						SetWorkStep(0);
    07279 079E      CPC	R25,R30
    0727A F171      BEQ	0x72A9
    0727B C033      RJMP	0x72AF
(0356) 					}
(0357) 				}
(0358) 				break;
    0727C 9020 1569 LDS	R2,ControlCmd+3
(0359) 		/************ 正常测试 *************/
(0360) 			case 3:		
(0361) 				if(ControlCmd.cmdState==2)
    0727E 9030 156A LDS	R3,ControlCmd+4
    07280 2022      TST	R2
    07281 F431      BNE	0x7288
    07282 2033      TST	R3
(0362) 				{
(0363) 					cmdState = 0;
    07283 F421      BNE	0x7288
    07284 2422      CLR	R2
    07285 9220 06F8 STS	EchoSW,R2
(0364) 					Uart0ReUnable;
    07287 C03B      RJMP	0x72C3
    07288 E081      LDI	R24,1
    07289 9380 06F8 STS	EchoSW,R24
(0365) 					uart_Printf("#%4d CommandReceive $   0\r\n",ControlCmd.cmdIdx);
    0728B C037      RJMP	0x72C3
    0728C 940E 81A8 CALL	_StartWork
    0728E 2700      CLR	R16
    0728F 940E 8108 CALL	_SetWorkStep
    07291 2700      CLR	R16
    07292 940E 6C2D CALL	_GetStoreState
(0366) 					Uart0ReEnable;
    07294 2422      CLR	R2
    07295 9220 17CA STS	_DiluentCalChart+41,R2
    07297 C02B      RJMP	0x72C3
(0367) 					switch(ControlCmd.cmdIdx)
    07298 9180 00C1 LDS	R24,0xC1
    0729A 7E8F      ANDI	R24,0xEF
    0729B 9380 00C1 STS	0xC1,R24
    0729D EA2F      LDI	R18,0xAF
    0729E E035      LDI	R19,5
    0729F EA0B      LDI	R16,0xAB
    072A0 E018      LDI	R17,0x8
    072A1 940E A90D CALL	_uart_Printf
    072A3 9180 00C1 LDS	R24,0xC1
    072A5 6180      ORI	R24,0x10
    072A6 9380 00C1 STS	0xC1,R24
    072A8 C01A      RJMP	0x72C3
    072A9 9100 1569 LDS	R16,ControlCmd+3
    072AB 9110 156A LDS	R17,ControlCmd+4
    072AD DF04      RCALL	_ReStart
    072AE C014      RJMP	0x72C3
    072AF 940E 372D CALL	_SetBeepWarning
    072B1 9180 00C1 LDS	R24,0xC1
    072B3 7E8F      ANDI	R24,0xEF
    072B4 9380 00C1 STS	0xC1,R24
    072B6 9120 1567 LDS	R18,ControlCmd+1
    072B8 9130 1568 LDS	R19,ControlCmd+2
    072BA E900      LDI	R16,0x90
    072BB E018      LDI	R17,0x8
    072BC 940E A90D CALL	_uart_Printf
    072BE 9180 00C1 LDS	R24,0xC1
    072C0 6180      ORI	R24,0x10
    072C1 9380 00C1 STS	0xC1,R24
    072C3 9020 17CA LDS	R2,_DiluentCalChart+41
    072C5 2022      TST	R2
    072C6 F0A9      BEQ	0x72DC
    072C7 940E 372D CALL	_SetBeepWarning
    072C9 9180 00C1 LDS	R24,0xC1
    072CB 7E8F      ANDI	R24,0xEF
    072CC 9380 00C1 STS	0xC1,R24
    072CE 9120 1567 LDS	R18,ControlCmd+1
    072D0 9130 1568 LDS	R19,ControlCmd+2
    072D2 E706      LDI	R16,0x76
    072D3 E018      LDI	R17,0x8
    072D4 940E A90D CALL	_uart_Printf
    072D6 9180 00C1 LDS	R24,0xC1
    072D8 6180      ORI	R24,0x10
    072D9 9380 00C1 STS	0xC1,R24
    072DB C014      RJMP	0x72F0
    072DC 940E 3739 CALL	_SetBeepAck
    072DE 9180 00C1 LDS	R24,0xC1
    072E0 7E8F      ANDI	R24,0xEF
    072E1 9380 00C1 STS	0xC1,R24
    072E3 9120 1567 LDS	R18,ControlCmd+1
    072E5 9130 1568 LDS	R19,ControlCmd+2
    072E7 E50D      LDI	R16,0x5D
    072E8 E018      LDI	R17,0x8
    072E9 940E A90D CALL	_uart_Printf
    072EB 9180 00C1 LDS	R24,0xC1
    072ED 6180      ORI	R24,0x10
    072EE 9380 00C1 STS	0xC1,R24
    072F0 940E 29D2 CALL	_CommandClear
    072F2 940C 80B7 JMP	0x80B7
    072F4 9180 1566 LDS	R24,ControlCmd
    072F6 3082      CPI	R24,2
    072F7 F011      BEQ	0x72FA
    072F8 940C 80B7 JMP	0x80B7
    072FA 2422      CLR	R2
    072FB 9220 17CA STS	_DiluentCalChart+41,R2
    072FD 9180 00C1 LDS	R24,0xC1
    072FF 7E8F      ANDI	R24,0xEF
    07300 9380 00C1 STS	0xC1,R24
    07302 9120 1567 LDS	R18,ControlCmd+1
    07304 9130 1568 LDS	R19,ControlCmd+2
    07306 EC00      LDI	R16,0xC0
    07307 E018      LDI	R17,0x8
    07308 940E A90D CALL	_uart_Printf
    0730A 9180 00C1 LDS	R24,0xC1
    0730C 6180      ORI	R24,0x10
    0730D 9380 00C1 STS	0xC1,R24
    0730F 9020 1567 LDS	R2,ControlCmd+1
(0368) 					{
(0369) 						case 3:		// #0003 查询工作进程
(0370) 							Uart0ReUnable;
    07311 9030 1568 LDS	R3,ControlCmd+2
    07313 2022      TST	R2
    07314 F411      BNE	0x7317
    07315 2033      TST	R3
(0371) 							uart_Printf("%s $   3 [Test]\r\n",strM0110);
    07316 F149      BEQ	0x7340
    07317 01C1      MOVW	R24,R2
    07318 3081      CPI	R24,1
    07319 E0E0      LDI	R30,0
    0731A 079E      CPC	R25,R30
    0731B F409      BNE	0x731D
(0372) 							Uart0ReEnable;
    0731C C033      RJMP	0x7350
    0731D 3082      CPI	R24,2
    0731E E0E0      LDI	R30,0
    0731F 079E      CPC	R25,R30
    07320 F409      BNE	0x7322
(0373) 							if(taskSate >= 2)
    07321 C034      RJMP	0x7356
    07322 3083      CPI	R24,3
    07323 E0E0      LDI	R30,0
    07324 079E      CPC	R25,R30
(0374) 							{
(0375) 								Uart0ReUnable;
    07325 F409      BNE	0x7327
    07326 C046      RJMP	0x736D
    07327 308A      CPI	R24,0xA
    07328 E0E0      LDI	R30,0
    07329 079E      CPC	R25,R30
(0376) 								uart_Printf("%s $   0 [Free]\r\n",strM3120);
    0732A F409      BNE	0x732C
    0732B C052      RJMP	0x737E
    0732C 308B      CPI	R24,0xB
    0732D E0E0      LDI	R30,0
    0732E 079E      CPC	R25,R30
    0732F F409      BNE	0x7331
(0377) 								Uart0ReEnable;
    07330 C069      RJMP	0x739A
    07331 3080      CPI	R24,0
    07332 E0E0      LDI	R30,0
    07333 079E      CPC	R25,R30
    07334 F40C      BGE	0x7336
(0378) 							}
    07335 C089      RJMP	0x73BF
(0379) 							else
(0380) 							{
(0381) 								Uart0ReUnable;
    07336 9180 1567 LDS	R24,ControlCmd+1
    07338 9190 1568 LDS	R25,ControlCmd+2
    0733A 3683      CPI	R24,0x63
(0382) 								uart_Printf("%s $   1 [Busy]\r\n",strM3120);
    0733B E0E0      LDI	R30,0
    0733C 079E      CPC	R25,R30
    0733D F409      BNE	0x733F
    0733E C07A      RJMP	0x73B9
    0733F C07F      RJMP	0x73BF
    07340 9020 1569 LDS	R2,ControlCmd+3
(0383) 								//DiluteProcess 函数
(0384) 								printf_DiluteProcess_StepState();
    07342 9030 156A LDS	R3,ControlCmd+4
(0385) 								//CardStoreProcess 函数
(0386) 								printf_CardstoreProcess_StepState();
    07344 2022      TST	R2
(0387) 								//TestQueueProcess 函数
(0388) 								printf_TestProcess_StepState();
    07345 F431      BNE	0x734C
    07346 2033      TST	R3
(0389) 								//UnLoadProcess 函数
(0390) 								printf_UnloadProcess_StepState();
    07347 F421      BNE	0x734C
    07348 2422      CLR	R2
(0391) 								Uart0ReEnable;
    07349 9220 06F8 STS	EchoSW,R2
    0734B C087      RJMP	0x73D3
    0734C E081      LDI	R24,1
    0734D 9380 06F8 STS	EchoSW,R24
(0392) 							}
(0393) 							break;
    0734F C083      RJMP	0x73D3
    07350 940E 81A8 CALL	_StartWork
    07352 2422      CLR	R2
(0394) 						case 4:	// 测试退出
(0395) 							if(taskSate >= 2)
(0396) 							{
(0397) 								SetDiluentQuit();
    07353 9220 17CA STS	_DiluentCalChart+41,R2
(0398) 								SetStateLedBusy();
    07355 C07D      RJMP	0x73D3
    07356 9180 1569 LDS	R24,ControlCmd+3
(0399) 							}
    07358 9190 156A LDS	R25,ControlCmd+4
    0735A 3085      CPI	R24,5
    0735B E0E0      LDI	R30,0
    0735C 079E      CPC	R25,R30
(0400) 							else
(0401) 							{
(0402) 								Uart0ReUnable;
(0403) 								uart_Printf("%s $   1 [Busy]\r\n",strM3120);
    0735D F020      BCS	0x7362
    0735E 3089      CPI	R24,0x9
    0735F E0E0      LDI	R30,0
    07360 079E      CPC	R25,R30
    07361 F439      BNE	0x7369
    07362 9100 1569 LDS	R16,ControlCmd+3
(0404) 								Uart0ReEnable;
    07364 9110 156A LDS	R17,ControlCmd+4
    07366 940E 8108 CALL	_SetWorkStep
(0405) 							}
(0406) 							break;
    07368 C06A      RJMP	0x73D3
(0407) 						case 5:	// 整机暂停
(0408) 							if(ControlCmd.pam[0] == 0)
    07369 E081      LDI	R24,1
    0736A 9380 17CA STS	_DiluentCalChart+41,R24
    0736C C066      RJMP	0x73D3
    0736D 9180 00C1 LDS	R24,0xC1
    0736F 7E8F      ANDI	R24,0xEF
    07370 9380 00C1 STS	0xC1,R24
(0409) 							{
(0410) 								workSwitch = 1;
    07372 EA2F      LDI	R18,0xAF
    07373 E035      LDI	R19,5
(0411) 								clearstopFlag();
    07374 E40B      LDI	R16,0x4B
    07375 E018      LDI	R17,0x8
(0412) 								Uart0ReUnable;
    07376 940E A90D CALL	_uart_Printf
    07378 9180 00C1 LDS	R24,0xC1
    0737A 6180      ORI	R24,0x10
(0413) 								uart_Printf("%s\r\n",strM0105);
    0737B 9380 00C1 STS	0xC1,R24
    0737D C055      RJMP	0x73D3
    0737E 9020 02E0 LDS	R2,CardStoreOpenLook
    07380 2022      TST	R2
(0414) 								Uart0ReEnable;
    07381 F439      BNE	0x7389
    07382 9100 1569 LDS	R16,ControlCmd+3
    07384 9110 156A LDS	R17,ControlCmd+4
(0415) 								SetStateLedFree();
    07386 940E 6C66 CALL	_SetStoreDoorOpen
(0416) 							}
    07388 C04A      RJMP	0x73D3
(0417) 							else
(0418) 							{
(0419) 								workSwitch = 0;
    07389 9180 00C1 LDS	R24,0xC1
    0738B 7E8F      ANDI	R24,0xEF
(0420) 								Uart0ReUnable;
    0738C 9380 00C1 STS	0xC1,R24
    0738E ED25      LDI	R18,0xD5
    0738F E035      LDI	R19,5
    07390 EE05      LDI	R16,0xE5
(0421) 								uart_Printf("%s\r\n",strM0106);
    07391 E018      LDI	R17,0x8
    07392 940E A90D CALL	_uart_Printf
    07394 9180 00C1 LDS	R24,0xC1
    07396 6180      ORI	R24,0x10
(0422) 								Uart0ReEnable;
    07397 9380 00C1 STS	0xC1,R24
    07399 C039      RJMP	0x73D3
    0739A 9180 00C1 LDS	R24,0xC1
(0423) 								SetStateLedBusy();
    0739C 7E8F      ANDI	R24,0xEF
    0739D 9380 00C1 STS	0xC1,R24
(0424) 							}
(0425) 							break;
    0739F 940E 2D8C CALL	_GetStoreHumi
    073A1 2EA0      MOV	R10,R16
    073A2 940E 2D8F CALL	_GetStoreTemp
(0426) 						case 10:	// 开启片仓
(0427) 							if(CardStoreOpenLook == 0)
(0428) 								SetStoreDoorOpen(ControlCmd.pam[0]);
    073A4 2EC0      MOV	R12,R16
    073A5 2C2C      MOV	R2,R12
    073A6 2433      CLR	R3
    073A7 823B      STD	Y+3,R3
    073A8 822A      STD	Y+2,R2
    073A9 2C2A      MOV	R2,R10
(0429) 							else
(0430) 							{
(0431) 								Uart0ReUnable;
    073AA 2433      CLR	R3
    073AB 8239      STD	Y+1,R3
    073AC 8228      ST	Y,R2
    073AD EC21      LDI	R18,0xC1
    073AE E035      LDI	R19,5
(0432) 								uart_Printf("%s\r\n",strM0112);
    073AF E30C      LDI	R16,0x3C
    073B0 E018      LDI	R17,0x8
    073B1 940E A90D CALL	_uart_Printf
    073B3 9180 00C1 LDS	R24,0xC1
(0433) 								Uart0ReEnable;
    073B5 6180      ORI	R24,0x10
    073B6 9380 00C1 STS	0xC1,R24
    073B8 C01A      RJMP	0x73D3
    073B9 9100 1569 LDS	R16,ControlCmd+3
(0434) 							}
(0435) 							break;
    073BB 9110 156A LDS	R17,ControlCmd+4
    073BD DDF4      RCALL	_ReStart
    073BE C014      RJMP	0x73D3
    073BF 940E 372D CALL	_SetBeepWarning
(0436) 						case 99:	// 重启, 设置看门狗
(0437) 							ReStart(ControlCmd.pam[0]);
(0438) 							break;
    073C1 9180 00C1 LDS	R24,0xC1
    073C3 7E8F      ANDI	R24,0xEF
    073C4 9380 00C1 STS	0xC1,R24
(0439) 						case 3001:	// #3001 设置测试参数
(0440) 							if(ControlCmd.pamLen>=4)
(0441) 							{
(0442) 								SetDiluentRatio((unsigned char)ControlCmd.pam[0]);
    073C6 9120 1567 LDS	R18,ControlCmd+1
    073C8 9130 1568 LDS	R19,ControlCmd+2
    073CA E900      LDI	R16,0x90
(0443) 								SetWorkStoreNum((unsigned char)ControlCmd.pam[1]);
    073CB E018      LDI	R17,0x8
    073CC 940E A90D CALL	_uart_Printf
    073CE 9180 00C1 LDS	R24,0xC1
    073D0 6180      ORI	R24,0x10
(0444) 								SetReadMolule(ControlCmd.pam[2]);
    073D1 9380 00C1 STS	0xC1,R24
    073D3 9020 17CA LDS	R2,_DiluentCalChart+41
    073D5 2022      TST	R2
    073D6 F0A9      BEQ	0x73EC
(0445) 								SetReadTime0(ControlCmd.pam[3]);
    073D7 940E 372D CALL	_SetBeepWarning
    073D9 9180 00C1 LDS	R24,0xC1
    073DB 7E8F      ANDI	R24,0xEF
    073DC 9380 00C1 STS	0xC1,R24
(0446) 								SetReadTime1(ControlCmd.pam[4]);
    073DE 9120 1567 LDS	R18,ControlCmd+1
    073E0 9130 1568 LDS	R19,ControlCmd+2
    073E2 E706      LDI	R16,0x76
(0447) 							}
    073E3 E018      LDI	R17,0x8
(0448) 							else
(0449) 								cmdState =  1;
    073E4 940E A90D CALL	_uart_Printf
    073E6 9180 00C1 LDS	R24,0xC1
(0450) 							break;
    073E8 6180      ORI	R24,0x10
    073E9 9380 00C1 STS	0xC1,R24
    073EB C014      RJMP	0x7400
    073EC 940E 3739 CALL	_SetBeepAck
(0451) 						case 3002:	// #3002 设置片仓号
(0452) 							SetWorkStoreNum(ControlCmd.pam[0]);
(0453) 							break;
    073EE 9180 00C1 LDS	R24,0xC1
(0454) 						case 3003:	// #3003 设置稀释比例
(0455) 							SetDiluentRatio(ControlCmd.pam[0]);
    073F0 7E8F      ANDI	R24,0xEF
    073F1 9380 00C1 STS	0xC1,R24
    073F3 9120 1567 LDS	R18,ControlCmd+1
(0456) 							break;
    073F5 9130 1568 LDS	R19,ControlCmd+2
(0457) 						case 3004:	// #3004 设置第一读数时间
(0458) 							SetReadTime0(ControlCmd.pam[0]);
    073F7 E50D      LDI	R16,0x5D
    073F8 E018      LDI	R17,0x8
    073F9 940E A90D CALL	_uart_Printf
    073FB 9180 00C1 LDS	R24,0xC1
(0459) 							break;
    073FD 6180      ORI	R24,0x10
    073FE 9380 00C1 STS	0xC1,R24
    07400 940E 29D2 CALL	_CommandClear
    07402 940C 80B7 JMP	0x80B7
(0460) 						case 3005:	// #3005 设置第二读数时间
(0461) 							SetReadTime1(ControlCmd.pam[0]);
(0462) 							break;
    07404 9180 1566 LDS	R24,ControlCmd
    07406 3082      CPI	R24,2
    07407 F009      BEQ	0x7409
    07408 C0D3      RJMP	0x74DC
    07409 2422      CLR	R2
(0463) 						case 3006:	// 设置读数模块
(0464) 							SetReadMolule(ControlCmd.pam[0]);
(0465) 							break;
    0740A 9220 17CA STS	_DiluentCalChart+41,R2
(0466) 						case 3007:	// 设置滴液量
(0467) 							SetDropVolume(ControlCmd.pam[0]);
    0740C 9180 00C1 LDS	R24,0xC1
    0740E 7E8F      ANDI	R24,0xEF
    0740F 9380 00C1 STS	0xC1,R24
(0468) 							break;
    07411 9120 1567 LDS	R18,ControlCmd+1
(0469) 						case 3008:	// 设置滴样模式
(0470) 							SetDropMode(ControlCmd.pam[0]);
    07413 9130 1568 LDS	R19,ControlCmd+2
    07415 EC00      LDI	R16,0xC0
    07416 E018      LDI	R17,0x8
    07417 940E A90D CALL	_uart_Printf
(0471) 							break;
    07419 9180 00C1 LDS	R24,0xC1
    0741B 6180      ORI	R24,0x10
    0741C 9380 00C1 STS	0xC1,R24
    0741E 9140 1567 LDS	R20,ControlCmd+1
(0472) 						case 3009:	// 设置抽打混匀次数
(0473) 							SetReMixNum(ControlCmd.pam[0]);
(0474) 							break;
    07420 9150 1568 LDS	R21,ControlCmd+2
    07422 3041      CPI	R20,1
    07423 E0E0      LDI	R30,0
    07424 075E      CPC	R21,R30
    07425 F0B9      BEQ	0x743D
(0475) 						case 3010:	// 设置自动连续测试
(0476) 							SetAutoTestCycle(ControlCmd.pam[0]);
(0477) 							break;
    07426 3043      CPI	R20,3
(0478) 						case 3011:	// 获取片仓状态信息
(0479) 							ReportCardStoreState(ControlCmd.pam[0]);
    07427 E0E0      LDI	R30,0
    07428 075E      CPC	R21,R30
    07429 F141      BEQ	0x7452
    0742A 3045      CPI	R20,5
    0742B E0E0      LDI	R30,0
    0742C 075E      CPC	R21,R30
(0480) 							break;
    0742D F1A9      BEQ	0x7463
(0481) 						case 3012:	// SetLampLum
(0482) 							if(ControlCmd.pam[0] == 0)
    0742E 3041      CPI	R20,1
    0742F E0E0      LDI	R30,0
    07430 075E      CPC	R21,R30
    07431 F40C      BGE	0x7433
    07432 C066      RJMP	0x7499
    07433 9180 1567 LDS	R24,ControlCmd+1
    07435 9190 1568 LDS	R25,ControlCmd+2
(0483) 							{
(0484) 								iTmp0 = AdjustTestLamp(0, ControlCmd.pam[1]);
    07437 3683      CPI	R24,0x63
    07438 E0E0      LDI	R30,0
    07439 079E      CPC	R25,R30
    0743A F409      BNE	0x743C
    0743B C057      RJMP	0x7493
    0743C C05C      RJMP	0x7499
    0743D 9180 00C1 LDS	R24,0xC1
    0743F 7E8F      ANDI	R24,0xEF
(0485) 								iTmp1 = AdjustTestLamp(1, ControlCmd.pam[2]);
    07440 9380 00C1 STS	0xC1,R24
    07442 E18E      LDI	R24,0x1E
    07443 E095      LDI	R25,5
    07444 8399      STD	Y+1,R25
    07445 8388      ST	Y,R24
    07446 E32A      LDI	R18,0x3A
    07447 E035      LDI	R19,5
    07448 E204      LDI	R16,0x24
(0486) 							}
    07449 E018      LDI	R17,0x8
(0487) 							else
(0488) 							{
(0489) 								iTmp0 = AdjustTestLamp(2, ControlCmd.pam[1]);
    0744A 940E A90D CALL	_uart_Printf
    0744C 9180 00C1 LDS	R24,0xC1
    0744E 6180      ORI	R24,0x10
    0744F 9380 00C1 STS	0xC1,R24
    07451 C05B      RJMP	0x74AD
    07452 9180 00C1 LDS	R24,0xC1
(0490) 								iTmp1 = AdjustTestLamp(3, ControlCmd.pam[2]);
    07454 7E8F      ANDI	R24,0xEF
    07455 9380 00C1 STS	0xC1,R24
    07457 EA2F      LDI	R18,0xAF
    07458 E035      LDI	R19,5
    07459 E00A      LDI	R16,0xA
    0745A E018      LDI	R17,0x8
    0745B 940E A90D CALL	_uart_Printf
(0491) 							}
(0492) 							Uart0ReUnable;
    0745D 9180 00C1 LDS	R24,0xC1
    0745F 6180      ORI	R24,0x10
    07460 9380 00C1 STS	0xC1,R24
(0493) 							uart_Printf("%s $%4d $%4d\r\n", strM4114, iTmp0, iTmp1);
    07462 C04A      RJMP	0x74AD
    07463 9020 1569 LDS	R2,ControlCmd+3
    07465 9030 156A LDS	R3,ControlCmd+4
    07467 2022      TST	R2
    07468 F4B1      BNE	0x747F
    07469 2033      TST	R3
    0746A F4A1      BNE	0x747F
    0746B E081      LDI	R24,1
    0746C 9380 06F7 STS	workSwitch,R24
(0494) 							Uart0ReEnable;
    0746E 9180 00C1 LDS	R24,0xC1
    07470 7E8F      ANDI	R24,0xEF
    07471 9380 00C1 STS	0xC1,R24
(0495) 							break;
    07473 E923      LDI	R18,0x93
(0496) 						case 3013:		// TurnOnLamp
(0497) 							if(ControlCmd.pam[0] == 0)
    07474 E035      LDI	R19,5
    07475 EE05      LDI	R16,0xE5
    07476 E018      LDI	R17,0x8
    07477 940E A90D CALL	_uart_Printf
    07479 9180 00C1 LDS	R24,0xC1
    0747B 6180      ORI	R24,0x10
(0498) 								TestALampOpen();
    0747C 9380 00C1 STS	0xC1,R24
    0747E C02E      RJMP	0x74AD
(0499) 							else	
(0500) 								TestBLampOpen();
    0747F 2422      CLR	R2
    07480 9220 06F7 STS	workSwitch,R2
(0501) 							break;
    07482 9180 00C1 LDS	R24,0xC1
    07484 7E8F      ANDI	R24,0xEF
    07485 9380 00C1 STS	0xC1,R24
    07487 EA21      LDI	R18,0xA1
    07488 E035      LDI	R19,5
    07489 EE05      LDI	R16,0xE5
(0502) 						case 3014:		// TurnOffLamp
(0503) 							if(ControlCmd.pam[0] == 0)
(0504) 								TestALampClose();
    0748A E018      LDI	R17,0x8
    0748B 940E A90D CALL	_uart_Printf
(0505) 							else	
(0506) 								TestBLampClose();
    0748D 9180 00C1 LDS	R24,0xC1
(0507) 							break;
    0748F 6180      ORI	R24,0x10
(0508) 						case 3015:
(0509) 							Uart0ReUnable;
    07490 9380 00C1 STS	0xC1,R24
    07492 C01A      RJMP	0x74AD
    07493 9100 1569 LDS	R16,ControlCmd+3
(0510) 							uart_Printf("%s $%4d\r\n",strM3137, GetWorkStoreNum());
    07495 9110 156A LDS	R17,ControlCmd+4
    07497 DD1A      RCALL	_ReStart
    07498 C014      RJMP	0x74AD
    07499 940E 372D CALL	_SetBeepWarning
    0749B 9180 00C1 LDS	R24,0xC1
    0749D 7E8F      ANDI	R24,0xEF
    0749E 9380 00C1 STS	0xC1,R24
    074A0 9120 1567 LDS	R18,ControlCmd+1
(0511) 							Uart0ReEnable;
    074A2 9130 1568 LDS	R19,ControlCmd+2
    074A4 E900      LDI	R16,0x90
    074A5 E018      LDI	R17,0x8
    074A6 940E A90D CALL	_uart_Printf
(0512) 							break;
    074A8 9180 00C1 LDS	R24,0xC1
    074AA 6180      ORI	R24,0x10
    074AB 9380 00C1 STS	0xC1,R24
    074AD 9020 17CA LDS	R2,_DiluentCalChart+41
    074AF 2022      TST	R2
    074B0 F0A9      BEQ	0x74C6
    074B1 940E 372D CALL	_SetBeepWarning
    074B3 9180 00C1 LDS	R24,0xC1
(0513) 						//case 3016:	// 设置条码扫描
(0514) 						//	SetCardScanf(ControlCmd.pam[0]);
(0515) 						//	break;
(0516) 						case 3017:	// 设置稀释参数和4015指令一样
(0517) 							iTmp0 = CalculateCalStandCoeff(ControlCmd.pam[0],ControlCmd.pam[1]);
(0518) 							iTmp1 = Save_DiluentCalChart(ControlCmd.pam[0]);
    074B5 7E8F      ANDI	R24,0xEF
    074B6 9380 00C1 STS	0xC1,R24
    074B8 9120 1567 LDS	R18,ControlCmd+1
    074BA 9130 1568 LDS	R19,ControlCmd+2
    074BC E706      LDI	R16,0x76
(0519) 							if(ControlCmd.pam[0] == 0)
    074BD E018      LDI	R17,0x8
    074BE 940E A90D CALL	_uart_Printf
    074C0 9180 00C1 LDS	R24,0xC1
    074C2 6180      ORI	R24,0x10
    074C3 9380 00C1 STS	0xC1,R24
(0520) 								ControlCmd.pam[0] = 9;
    074C5 C014      RJMP	0x74DA
    074C6 940E 3739 CALL	_SetBeepAck
    074C8 9180 00C1 LDS	R24,0xC1
    074CA 7E8F      ANDI	R24,0xEF
    074CB 9380 00C1 STS	0xC1,R24
(0521) 							else if(ControlCmd.pam[0] > 13)
    074CD 9120 1567 LDS	R18,ControlCmd+1
    074CF 9130 1568 LDS	R19,ControlCmd+2
    074D1 E50D      LDI	R16,0x5D
    074D2 E018      LDI	R17,0x8
    074D3 940E A90D CALL	_uart_Printf
(0522) 								ControlCmd.pam[0] = 13;
    074D5 9180 00C1 LDS	R24,0xC1
    074D7 6180      ORI	R24,0x10
    074D8 9380 00C1 STS	0xC1,R24
(0523) 							Uart0ReUnable;
    074DA 940E 29D2 CALL	_CommandClear
    074DC 9020 06F7 LDS	R2,workSwitch
(0524) 							uart_Printf("%s $%4d $%4d $%4d\r\n", strM4117, ControlCmd.pam[0],iTmp0,iTmp1);
    074DE 2022      TST	R2
    074DF F411      BNE	0x74E2
    074E0 940C 80B7 JMP	0x80B7
    074E2 940E 334B CALL	_MachinePositionInit
    074E4 2F40      MOV	R20,R16
    074E5 3001      CPI	R16,1
    074E6 F011      BEQ	0x74E9
    074E7 940C 80B7 JMP	0x80B7
    074E9 2700      CLR	R16
    074EA 940E 8108 CALL	_SetWorkStep
    074EC 940C 80B7 JMP	0x80B7
    074EE 9180 1566 LDS	R24,ControlCmd
(0525) 							Uart0ReEnable;
    074F0 3082      CPI	R24,2
    074F1 F009      BEQ	0x74F3
    074F2 C0D3      RJMP	0x75C6
    074F3 2422      CLR	R2
    074F4 9220 17CA STS	_DiluentCalChart+41,R2
(0526) 							break;
    074F6 9180 00C1 LDS	R24,0xC1
    074F8 7E8F      ANDI	R24,0xEF
    074F9 9380 00C1 STS	0xC1,R24
    074FB 9120 1567 LDS	R18,ControlCmd+1
(0527) 						//case 3018:  // 设置重复条码扫描
(0528) 						//	SetReCardScanf(1);
(0529) 						//	break;
(0530) 						//case 3019:  // 条码扫描位置调整
(0531) 						//	if(GetNewPieceProcessState == 1)
(0532) 						//	{
(0533) 						//		iPam = SetCardScanfPos((signed char)ControlCmd.pam[0]);
(0534) 						//		Uart0ReUnable;
(0535) 						//		uart_Printf("%s $%4d\r\n",strM3124, iPam);
(0536) 						//		Uart0ReEnable;
(0537) 						//		CardScanfSW = 1;
(0538) 						//	}
(0539) 						//	else
(0540) 						//	{
(0541) 						//		Uart0ReUnable;
(0542) 						//		uart_Printf("%s $1\r\n",strM3120);
(0543) 						//		Uart0ReEnable;
(0544) 						//	}
(0545) 						//	break;
(0546) 						case 3020:
(0547) 							SetTestDebugMode(ControlCmd.pam[0]);
(0548) 							break;
    074FD 9130 1568 LDS	R19,ControlCmd+2
    074FF EC00      LDI	R16,0xC0
    07500 E018      LDI	R17,0x8
    07501 940E A90D CALL	_uart_Printf
(0549) 						case 3021:	// 设置取片测试模式
(0550) 							SetGetCardTestMode(ControlCmd.pam[0]);
(0551) 							break;
    07503 9180 00C1 LDS	R24,0xC1
(0552) 						case 3022:	// 设置1:1模式下,是否需要进行抽打混匀
(0553) 							SetMixtureMode(ControlCmd.pam[0]);
    07505 6180      ORI	R24,0x10
    07506 9380 00C1 STS	0xC1,R24
    07508 9140 1567 LDS	R20,ControlCmd+1
(0554) 							break;
    0750A 9150 1568 LDS	R21,ControlCmd+2
(0555) 						case 3023:	// 设置多排模式下,废片盒无效
(0556) 							SetWasteCardState(ControlCmd.pam[0]);
    0750C 3041      CPI	R20,1
    0750D E0E0      LDI	R30,0
    0750E 075E      CPC	R21,R30
    0750F F0B9      BEQ	0x7527
    07510 3043      CPI	R20,3
(0557) 							break;
    07511 E0E0      LDI	R30,0
(0558) #ifdef Puncture
(0559) 						case 3024:	// 设置是否需要穿刺
(0560) 							SetPunctureState(ControlCmd.pam[0]);
(0561) 							break;
(0562) #endif
(0563) 
(0564) 						case 3030:
(0565) 							// 设置吸样量
(0566) 							SetSamplingVolume(ControlCmd.pam[0]);
    07512 075E      CPC	R21,R30
    07513 F141      BEQ	0x753C
    07514 3045      CPI	R20,5
    07515 E0E0      LDI	R30,0
    07516 075E      CPC	R21,R30
    07517 F1A9      BEQ	0x754D
(0567) 							break;
    07518 3041      CPI	R20,1
(0568) 						case 3050:		// 休眠
(0569) 							TestSleep();
    07519 E0E0      LDI	R30,0
    0751A 075E      CPC	R21,R30
(0570) 							break;
    0751B F40C      BGE	0x751D
(0571) 						case 3051:		// 恢复
(0572) 							TestStartup();
    0751C C066      RJMP	0x7583
    0751D 9180 1567 LDS	R24,ControlCmd+1
(0573) 							break;
    0751F 9190 1568 LDS	R25,ControlCmd+2
    07521 3683      CPI	R24,0x63
    07522 E0E0      LDI	R30,0
    07523 079E      CPC	R25,R30
    07524 F409      BNE	0x7526
(0574) 						case 3052:		// 设置休眠时间
(0575) 							SetSleepTime(ControlCmd.pam[0]);
(0576) 							break;
    07525 C057      RJMP	0x757D
(0577) 						case 3053:		// 设置取样功能开关
(0578) 							if(ControlCmd.pam[0])
    07526 C05C      RJMP	0x7583
    07527 9180 00C1 LDS	R24,0xC1
    07529 7E8F      ANDI	R24,0xEF
    0752A 9380 00C1 STS	0xC1,R24
    0752C E18E      LDI	R24,0x1E
    0752D E095      LDI	R25,5
(0579) 							{
(0580) 								SamplingSwitch(0);
    0752E 8399      STD	Y+1,R25
    0752F 8388      ST	Y,R24
    07530 E32A      LDI	R18,0x3A
(0581) 								Uart0ReUnable;
    07531 E035      LDI	R19,5
    07532 EF03      LDI	R16,0xF3
    07533 E017      LDI	R17,7
    07534 940E A90D CALL	_uart_Printf
(0582) 								uart_Printf("%s\r\n",strM3153);
    07536 9180 00C1 LDS	R24,0xC1
    07538 6180      ORI	R24,0x10
    07539 9380 00C1 STS	0xC1,R24
    0753B C05B      RJMP	0x7597
(0583) 								Uart0ReEnable;
    0753C 9180 00C1 LDS	R24,0xC1
    0753E 7E8F      ANDI	R24,0xEF
    0753F 9380 00C1 STS	0xC1,R24
(0584) 							}
    07541 EA2F      LDI	R18,0xAF
(0585) 							else
(0586) 							{
(0587) 								Uart0ReUnable;
    07542 E035      LDI	R19,5
    07543 ED0A      LDI	R16,0xDA
    07544 E017      LDI	R17,7
    07545 940E A90D CALL	_uart_Printf
(0588) 								uart_Printf("%s\r\n",strM3154);
    07547 9180 00C1 LDS	R24,0xC1
    07549 6180      ORI	R24,0x10
    0754A 9380 00C1 STS	0xC1,R24
    0754C C04A      RJMP	0x7597
(0589) 								Uart0ReEnable;
    0754D 9020 1569 LDS	R2,ControlCmd+3
    0754F 9030 156A LDS	R3,ControlCmd+4
    07551 2022      TST	R2
(0590) 								SamplingSwitch(1);
    07552 F4B1      BNE	0x7569
    07553 2033      TST	R3
    07554 F4A1      BNE	0x7569
(0591) 							}
(0592) 							break;
    07555 E081      LDI	R24,1
(0593) 						case 3054:	// 设置当前测试重测标识
(0594) 							SetReReadFlag(); 
    07556 9380 06F7 STS	workSwitch,R24
(0595) 
(0596) 							break;
    07558 9180 00C1 LDS	R24,0xC1
(0597) 						case 3055:	// 设置清洗模式
(0598) 							SetCleanMode(ControlCmd.pam[0]);
    0755A 7E8F      ANDI	R24,0xEF
    0755B 9380 00C1 STS	0xC1,R24
    0755D E923      LDI	R18,0x93
    0755E E035      LDI	R19,5
(0599) 							break;
    0755F EE05      LDI	R16,0xE5
(0600) 						case 3056:	// 设置读取结束应答信号
(0601) 							SetReadCloseAnswer();	
    07560 E018      LDI	R17,0x8
    07561 940E A90D CALL	_uart_Printf
(0602) 							break;
    07563 9180 00C1 LDS	R24,0xC1
    07565 6180      ORI	R24,0x10
    07566 9380 00C1 STS	0xC1,R24
(0603) 						case 3060:		// 手动灌注稀释液
(0604) 							if(diluteProcessState == 1) 
(0605) 							{
(0606) 								if(primeProcessSW == 0)
    07568 C02E      RJMP	0x7597
    07569 2422      CLR	R2
    0756A 9220 06F7 STS	workSwitch,R2
(0607) 								{
(0608) 									Uart0ReUnable;
    0756C 9180 00C1 LDS	R24,0xC1
    0756E 7E8F      ANDI	R24,0xEF
    0756F 9380 00C1 STS	0xC1,R24
(0609) 									uart_Printf("%s\r\n",strM3160);
    07571 EA21      LDI	R18,0xA1
    07572 E035      LDI	R19,5
    07573 EE05      LDI	R16,0xE5
    07574 E018      LDI	R17,0x8
    07575 940E A90D CALL	_uart_Printf
(0610) 									Uart0ReEnable;
    07577 9180 00C1 LDS	R24,0xC1
    07579 6180      ORI	R24,0x10
    0757A 9380 00C1 STS	0xC1,R24
(0611) 									SetStateLedBusy();
    0757C C01A      RJMP	0x7597
    0757D 9100 1569 LDS	R16,ControlCmd+3
(0612) 									primeProcessSW = 1;
    0757F 9110 156A LDS	R17,ControlCmd+4
(0613) 								}
    07581 DC30      RCALL	_ReStart
(0614) 								else if(primeProcessSW == 1)
    07582 C014      RJMP	0x7597
    07583 940E 372D CALL	_SetBeepWarning
    07585 9180 00C1 LDS	R24,0xC1
(0615) 								{
(0616) 									Uart0ReUnable;
    07587 7E8F      ANDI	R24,0xEF
    07588 9380 00C1 STS	0xC1,R24
    0758A 9120 1567 LDS	R18,ControlCmd+1
(0617) 									uart_Printf("%s\r\n",strM3171);
    0758C 9130 1568 LDS	R19,ControlCmd+2
    0758E E900      LDI	R16,0x90
    0758F E018      LDI	R17,0x8
    07590 940E A90D CALL	_uart_Printf
(0618) 									Uart0ReEnable;
    07592 9180 00C1 LDS	R24,0xC1
    07594 6180      ORI	R24,0x10
    07595 9380 00C1 STS	0xC1,R24
(0619) 								}
    07597 9020 17CA LDS	R2,_DiluentCalChart+41
    07599 2022      TST	R2
    0759A F0A9      BEQ	0x75B0
(0620) 								else if(primeProcessSW == 2)
(0621) 								{
(0622) 									Uart0ReUnable;
    0759B 940E 372D CALL	_SetBeepWarning
    0759D 9180 00C1 LDS	R24,0xC1
    0759F 7E8F      ANDI	R24,0xEF
(0623) 									uart_Printf("%s\r\n",strM3172);
    075A0 9380 00C1 STS	0xC1,R24
    075A2 9120 1567 LDS	R18,ControlCmd+1
    075A4 9130 1568 LDS	R19,ControlCmd+2
(0624) 									Uart0ReEnable;
    075A6 E706      LDI	R16,0x76
    075A7 E018      LDI	R17,0x8
    075A8 940E A90D CALL	_uart_Printf
    075AA 9180 00C1 LDS	R24,0xC1
(0625) 								}
    075AC 6180      ORI	R24,0x10
    075AD 9380 00C1 STS	0xC1,R24
    075AF C014      RJMP	0x75C4
    075B0 940E 3739 CALL	_SetBeepAck
(0626) 								else if(primeProcessSW == 3)
(0627) 								{
(0628) 									Uart0ReUnable;
    075B2 9180 00C1 LDS	R24,0xC1
    075B4 7E8F      ANDI	R24,0xEF
    075B5 9380 00C1 STS	0xC1,R24
(0629) 									uart_Printf("%s\r\n",strM3173);
    075B7 9120 1567 LDS	R18,ControlCmd+1
    075B9 9130 1568 LDS	R19,ControlCmd+2
    075BB E50D      LDI	R16,0x5D
(0630) 									Uart0ReEnable;
    075BC E018      LDI	R17,0x8
    075BD 940E A90D CALL	_uart_Printf
    075BF 9180 00C1 LDS	R24,0xC1
(0631) 								}
(0632) 							}
    075C1 6180      ORI	R24,0x10
(0633) 							else
(0634) 							{
(0635) 								Uart0ReUnable;
    075C2 9380 00C1 STS	0xC1,R24
    075C4 940E 29D2 CALL	_CommandClear
    075C6 9020 06F7 LDS	R2,workSwitch
(0636) 								uart_Printf("%s $1\r\n",strM3120);
    075C8 2022      TST	R2
    075C9 F411      BNE	0x75CC
    075CA 940C 80B7 JMP	0x80B7
    075CC 2700      CLR	R16
(0637) 								Uart0ReEnable;
    075CD 2711      CLR	R17
    075CE 940E 56BD CALL	_DiluteStartCheck
    075D0 2F40      MOV	R20,R16
    075D1 3001      CPI	R16,1
(0638) 							}
(0639) 							break;
    075D2 F011      BEQ	0x75D5
(0640) 						case 3061:		// 手动灌注清洗液
(0641) 							if(diluteProcessState == 1) 
    075D3 940C 80B7 JMP	0x80B7
    075D5 2700      CLR	R16
    075D6 940E 8108 CALL	_SetWorkStep
(0642) 							{
(0643) 								if(primeProcessSW == 0)
    075D8 940C 80B7 JMP	0x80B7
    075DA 9180 1566 LDS	R24,ControlCmd
(0644) 								{
(0645) 									Uart0ReUnable;
    075DC 3082      CPI	R24,2
    075DD F009      BEQ	0x75DF
    075DE C4F0      RJMP	0x7ACF
    075DF 2422      CLR	R2
    075E0 9220 17CA STS	_DiluentCalChart+41,R2
(0646) 									uart_Printf("%s\r\n",strM3161);
    075E2 9180 00C1 LDS	R24,0xC1
    075E4 7E8F      ANDI	R24,0xEF
    075E5 9380 00C1 STS	0xC1,R24
(0647) 									Uart0ReEnable;
    075E7 9120 1567 LDS	R18,ControlCmd+1
    075E9 9130 1568 LDS	R19,ControlCmd+2
    075EB EC00      LDI	R16,0xC0
(0648) 									SetStateLedBusy();
    075EC E018      LDI	R17,0x8
    075ED 940E A90D CALL	_uart_Printf
(0649) 									primeProcessSW = 2;
    075EF 9180 00C1 LDS	R24,0xC1
(0650) 								}
    075F1 6180      ORI	R24,0x10
(0651) 								else if(primeProcessSW == 1)
    075F2 9380 00C1 STS	0xC1,R24
    075F4 9140 1567 LDS	R20,ControlCmd+1
(0652) 								{
(0653) 									Uart0ReUnable;
    075F6 9150 1568 LDS	R21,ControlCmd+2
    075F8 3E4A      CPI	R20,0xEA
    075F9 E0EB      LDI	R30,0xB
    075FA 075E      CPC	R21,R30
(0654) 									uart_Printf("%s\r\n",strM3171);
    075FB F409      BNE	0x75FD
    075FC C2B7      RJMP	0x78B4
    075FD 3E4B      CPI	R20,0xEB
    075FE E0EB      LDI	R30,0xB
    075FF 075E      CPC	R21,R30
    07600 F409      BNE	0x7602
(0655) 									Uart0ReEnable;
    07601 C2B5      RJMP	0x78B7
    07602 3E4D      CPI	R20,0xED
    07603 E0EB      LDI	R30,0xB
    07604 075E      CPC	R21,R30
    07605 F409      BNE	0x7607
(0656) 								}
    07606 C2B3      RJMP	0x78BA
(0657) 								else if(primeProcessSW == 2)
    07607 3E4E      CPI	R20,0xEE
    07608 E0EB      LDI	R30,0xB
    07609 075E      CPC	R21,R30
    0760A F409      BNE	0x760C
(0658) 								{
(0659) 									Uart0ReUnable;
    0760B C2E7      RJMP	0x78F3
    0760C 3E4F      CPI	R20,0xEF
    0760D E0EB      LDI	R30,0xB
    0760E 075E      CPC	R21,R30
    0760F F409      BNE	0x7611
(0660) 									uart_Printf("%s\r\n",strM3172);
    07610 C2E5      RJMP	0x78F6
    07611 3F40      CPI	R20,0xF0
    07612 E0EB      LDI	R30,0xB
    07613 075E      CPC	R21,R30
    07614 F409      BNE	0x7616
    07615 C2E7      RJMP	0x78FD
(0661) 									Uart0ReEnable;
    07616 3F44      CPI	R20,0xF4
    07617 E0EB      LDI	R30,0xB
    07618 075E      CPC	R21,R30
    07619 F409      BNE	0x761B
    0761A C2E5      RJMP	0x7900
(0662) 								}
    0761B 3F45      CPI	R20,0xF5
(0663) 								else if(primeProcessSW == 3)
    0761C E0EB      LDI	R30,0xB
    0761D 075E      CPC	R21,R30
    0761E F409      BNE	0x7620
    0761F C350      RJMP	0x7970
    07620 EF85      LDI	R24,0xF5
(0664) 								{
(0665) 									Uart0ReUnable;
    07621 E09B      LDI	R25,0xB
    07622 1784      CP	R24,R20
    07623 0795      CPC	R25,R21
    07624 F40C      BGE	0x7626
    07625 C048      RJMP	0x766E
(0666) 									uart_Printf("%s\r\n",strM3173);
    07626 9140 1567 LDS	R20,ControlCmd+1
    07628 9150 1568 LDS	R21,ControlCmd+2
    0762A 3643      CPI	R20,0x63
    0762B E0E0      LDI	R30,0
(0667) 									Uart0ReEnable;
    0762C 075E      CPC	R21,R30
    0762D F409      BNE	0x762F
    0762E C130      RJMP	0x775F
    0762F E683      LDI	R24,0x63
    07630 E090      LDI	R25,0
(0668) 								}
(0669) 							}
    07631 1784      CP	R24,R20
(0670) 							else
(0671) 							{
(0672) 								Uart0ReUnable;
    07632 0795      CPC	R25,R21
    07633 F0F4      BLT	0x7652
    07634 9140 1567 LDS	R20,ControlCmd+1
    07636 9150 1568 LDS	R21,ControlCmd+2
(0673) 								uart_Printf("%s $1\r\n",strM3120);
    07638 3041      CPI	R20,1
    07639 E0E0      LDI	R30,0
    0763A 075E      CPC	R21,R30
    0763B F409      BNE	0x763D
    0763C C058      RJMP	0x7695
(0674) 								Uart0ReEnable;
    0763D 3043      CPI	R20,3
    0763E E0E0      LDI	R30,0
    0763F 075E      CPC	R21,R30
    07640 F409      BNE	0x7642
    07641 C068      RJMP	0x76AA
(0675) 							}
(0676) 							break;
    07642 3044      CPI	R20,4
(0677) 						case 3107:		// 滴样量调节因子设定
(0678) 							si = SetDropVolumeFactor((signed char)ControlCmd.pam[0]);
    07643 E0E0      LDI	R30,0
    07644 075E      CPC	R21,R30
    07645 F409      BNE	0x7647
    07646 C0AC      RJMP	0x76F3
    07647 3045      CPI	R20,5
    07648 E0E0      LDI	R30,0
    07649 075E      CPC	R21,R30
    0764A F409      BNE	0x764C
    0764B C0C1      RJMP	0x770D
    0764C 304A      CPI	R20,0xA
(0679) 							Uart0ReUnable;
    0764D E0E0      LDI	R30,0
    0764E 075E      CPC	R21,R30
    0764F F409      BNE	0x7651
    07650 C0F2      RJMP	0x7743
    07651 C43A      RJMP	0x7A8C
(0680) 							uart_Printf("%s $%4d\r\n", strM3218, si);
    07652 9140 1567 LDS	R20,ControlCmd+1
    07654 9150 1568 LDS	R21,ControlCmd+2
    07656 3B49      CPI	R20,0xB9
    07657 E0EB      LDI	R30,0xB
    07658 075E      CPC	R21,R30
    07659 F40C      BGE	0x765B
    0765A C431      RJMP	0x7A8C
    0765B ED86      LDI	R24,0xD6
    0765C E09B      LDI	R25,0xB
    0765D 1784      CP	R24,R20
(0681) 							Uart0ReEnable;
    0765E 0795      CPC	R25,R21
    0765F F40C      BGE	0x7661
    07660 C42B      RJMP	0x7A8C
    07661 EB8C      LDI	R24,0xBC
    07662 E093      LDI	R25,3
(0682) 							break;
    07663 01FA      MOVW	R30,R20
(0683) 						case 3322:
(0684) 							if(diluteProcessState == 1) 
    07664 5BE9      SUBI	R30,0xB9
    07665 40FB      SBCI	R31,0xB
    07666 0FEE      LSL	R30
    07667 1FFF      ROL	R31
    07668 0FE8      ADD	R30,R24
(0685) 							{
(0686) 								if(primeProcessSW == 0)
    07669 1FF9      ADC	R31,R25
    0766A 9027      ELPM	R2,Z+
    0766B 9036      ELPM	R3,Z
    0766C 01F1      MOVW	R30,R2
(0687) 								{
(0688) 									Uart0ReUnable;
    0766D 9409      IJMP
    0766E 9140 1567 LDS	R20,ControlCmd+1
    07670 9150 1568 LDS	R21,ControlCmd+2
(0689) 									uart_Printf("%s $ 3 [LiquidCheck] $ 3322\r\n",strM0110);
    07672 3F4A      CPI	R20,0xFA
    07673 E0EC      LDI	R30,0xC
    07674 075E      CPC	R21,R30
    07675 F409      BNE	0x7677
    07676 C37B      RJMP	0x79F2
    07677 EF8A      LDI	R24,0xFA
(0690) 									Uart0ReEnable;
    07678 E09C      LDI	R25,0xC
    07679 1784      CP	R24,R20
    0767A 0795      CPC	R25,R21
    0767B F07C      BLT	0x768B
    0767C 9140 1567 LDS	R20,ControlCmd+1
(0691) 									SetStateLedBusy();
    0767E 9150 1568 LDS	R21,ControlCmd+2
(0692) 									primeProcessSW = 3;
    07680 3243      CPI	R20,0x23
    07681 E0EC      LDI	R30,0xC
(0693) 								}
    07682 075E      CPC	R21,R30
(0694) 								else if(primeProcessSW == 1)
    07683 F409      BNE	0x7685
    07684 C35B      RJMP	0x79E0
    07685 3244      CPI	R20,0x24
    07686 E0EC      LDI	R30,0xC
(0695) 								{
(0696) 									Uart0ReUnable;
    07687 075E      CPC	R21,R30
    07688 F409      BNE	0x768A
    07689 C35D      RJMP	0x79E7
    0768A C401      RJMP	0x7A8C
    0768B 9180 1567 LDS	R24,ControlCmd+1
(0697) 									uart_Printf("%s\r\n",strM3171);
    0768D 9190 1568 LDS	R25,ControlCmd+2
    0768F 3085      CPI	R24,5
    07690 E0ED      LDI	R30,0xD
    07691 079E      CPC	R25,R30
(0698) 									Uart0ReEnable;
    07692 F409      BNE	0x7694
    07693 C3CE      RJMP	0x7A62
    07694 C3F7      RJMP	0x7A8C
    07695 9180 00C1 LDS	R24,0xC1
(0699) 								}
    07697 7E8F      ANDI	R24,0xEF
(0700) 								else if(primeProcessSW == 2)
    07698 9380 00C1 STS	0xC1,R24
    0769A E18E      LDI	R24,0x1E
    0769B E095      LDI	R25,5
(0701) 								{
(0702) 									Uart0ReUnable;
    0769C 8399      STD	Y+1,R25
    0769D 8388      ST	Y,R24
    0769E E32A      LDI	R18,0x3A
    0769F E035      LDI	R19,5
    076A0 EC04      LDI	R16,0xC4
(0703) 									uart_Printf("%s\r\n",strM3172);
    076A1 E017      LDI	R17,7
    076A2 940E A90D CALL	_uart_Printf
    076A4 9180 00C1 LDS	R24,0xC1
    076A6 6180      ORI	R24,0x10
(0704) 									Uart0ReEnable;
    076A7 9380 00C1 STS	0xC1,R24
    076A9 C3F6      RJMP	0x7AA0
    076AA 9180 00C1 LDS	R24,0xC1
(0705) 								}
    076AC 7E8F      ANDI	R24,0xEF
(0706) 								else if(primeProcessSW == 3)
    076AD 9380 00C1 STS	0xC1,R24
    076AF 9180 0533 LDS	R24,JumpMode
    076B1 3082      CPI	R24,2
(0707) 								{
(0708) 									Uart0ReUnable;
    076B2 F439      BNE	0x76BA
    076B3 EA2F      LDI	R18,0xAF
    076B4 E035      LDI	R19,5
    076B5 EB01      LDI	R16,0xB1
    076B6 E017      LDI	R17,7
(0709) 									uart_Printf("%s\r\n",strM3173);
    076B7 940E A90D CALL	_uart_Printf
    076B9 C006      RJMP	0x76C0
    076BA EA2F      LDI	R18,0xAF
    076BB E035      LDI	R19,5
    076BC E90F      LDI	R16,0x9F
(0710) 									Uart0ReEnable;
    076BD E017      LDI	R17,7
    076BE 940E A90D CALL	_uart_Printf
    076C0 9180 00C1 LDS	R24,0xC1
(0711) 								}
(0712) 							}
    076C2 6180      ORI	R24,0x10
(0713) 							else 
(0714) 							{
(0715) 								Uart0ReUnable;
    076C3 9380 00C1 STS	0xC1,R24
    076C5 9180 17CB LDS	R24,_DiluentCalChart+42
    076C7 3082      CPI	R24,2
(0716) 								uart_Printf("%s $1\r\n",strM3120);
    076C8 F088      BCS	0x76DA
    076C9 9180 00C1 LDS	R24,0xC1
    076CB 7E8F      ANDI	R24,0xEF
    076CC 9380 00C1 STS	0xC1,R24
(0717) 								Uart0ReEnable;
    076CE E426      LDI	R18,0x46
    076CF E03E      LDI	R19,0xE
    076D0 E40B      LDI	R16,0x4B
    076D1 E018      LDI	R17,0x8
    076D2 940E A90D CALL	_uart_Printf
(0718) 							}
(0719) 							break;
    076D4 9180 00C1 LDS	R24,0xC1
    076D6 6180      ORI	R24,0x10
    076D7 9380 00C1 STS	0xC1,R24
(0720) 						case 3333:
(0721) 							if(CardStoreTestFlag == 1)		
(0722) 								break;
    076D9 C3C6      RJMP	0x7AA0
    076DA 9180 00C1 LDS	R24,0xC1
    076DC 7E8F      ANDI	R24,0xEF
    076DD 9380 00C1 STS	0xC1,R24
    076DF E426      LDI	R18,0x46
    076E0 E03E      LDI	R19,0xE
(0723) 							if(ControlCmd.pam[0] == 0)
(0724) 								CardNoneUseful = 0;
    076E1 E80D      LDI	R16,0x8D
    076E2 E017      LDI	R17,7
    076E3 940E A90D CALL	_uart_Printf
(0725) 							else
(0726) 							{	
(0727) 								CardNoneUseful = 1;
    076E5 940E 3920 CALL	_printf_DiluteProcess_StepState
    076E7 940E 1A67 CALL	_printf_CardstoreProcess_StepState
(0728) 							//	TestALampClose();
(0729) 							//	TestBLampClose();
(0730) 							}
(0731) 							Uart0ReUnable;
    076E9 940E A1E4 CALL	_printf_TestProcess_StepState
    076EB 940E AA92 CALL	_printf_UnloadProcess_StepState
(0732) 							uart_Printf("%s $%4d\r\n", strM3333, CardNoneUseful);
    076ED 9180 00C1 LDS	R24,0xC1
    076EF 6180      ORI	R24,0x10
    076F0 9380 00C1 STS	0xC1,R24
    076F2 C3AD      RJMP	0x7AA0
    076F3 9180 17CB LDS	R24,_DiluentCalChart+42
    076F5 3082      CPI	R24,2
    076F6 F028      BCS	0x76FC
    076F7 940E 6360 CALL	_SetDiluentQuit
(0733) 							Uart0ReEnable;
    076F9 940E 38F8 CALL	_SetStateLedBusy
    076FB C3A4      RJMP	0x7AA0
    076FC 9180 00C1 LDS	R24,0xC1
(0734) 							break;
    076FE 7E8F      ANDI	R24,0xEF
    076FF 9380 00C1 STS	0xC1,R24
(0735) 						//*******************************************************
(0736) 						default:
(0737) 							SetBeepWarning();
(0738) 							Uart0ReUnable;
    07701 E426      LDI	R18,0x46
    07702 E03E      LDI	R19,0xE
    07703 E80D      LDI	R16,0x8D
    07704 E017      LDI	R17,7
(0739) 							uart_Printf("#%d CommandUnknown $   2\r\n",ControlCmd.cmdIdx);
    07705 940E A90D CALL	_uart_Printf
    07707 9180 00C1 LDS	R24,0xC1
    07709 6180      ORI	R24,0x10
    0770A 9380 00C1 STS	0xC1,R24
    0770C C393      RJMP	0x7AA0
(0740) 							Uart0ReEnable;
    0770D 9020 1569 LDS	R2,ControlCmd+3
    0770F 9030 156A LDS	R3,ControlCmd+4
    07711 2022      TST	R2
(0741) 							break;
(0742) 						}
(0743) 					if(cmdState)
    07712 F4D1      BNE	0x772D
    07713 2033      TST	R3
    07714 F4C1      BNE	0x772D
    07715 E081      LDI	R24,1
(0744) 					{
(0745) 						SetBeepWarning();
    07716 9380 06F7 STS	workSwitch,R24
(0746) 						Uart0ReUnable;
    07718 940E 17F6 CALL	_clearstopFlag
    0771A 9180 00C1 LDS	R24,0xC1
    0771C 7E8F      ANDI	R24,0xEF
(0747) 						uart_Printf("#%4d CommandError $   1\r\n",ControlCmd.cmdIdx);
    0771D 9380 00C1 STS	0xC1,R24
    0771F E923      LDI	R18,0x93
    07720 E035      LDI	R19,5
    07721 EE05      LDI	R16,0xE5
    07722 E018      LDI	R17,0x8
    07723 940E A90D CALL	_uart_Printf
(0748) 						Uart0ReEnable;
    07725 9180 00C1 LDS	R24,0xC1
    07727 6180      ORI	R24,0x10
    07728 9380 00C1 STS	0xC1,R24
(0749) 					}
    0772A 940E 3907 CALL	_SetStateLedFree
(0750) 					else
(0751) 					{
(0752) 						SetBeepAck();
    0772C C373      RJMP	0x7AA0
(0753) 						Uart0ReUnable;
    0772D 2422      CLR	R2
    0772E 9220 06F7 STS	workSwitch,R2
    07730 9180 00C1 LDS	R24,0xC1
(0754) 						uart_Printf("#%4d CommandDone $   3\r\n",ControlCmd.cmdIdx);
    07732 7E8F      ANDI	R24,0xEF
    07733 9380 00C1 STS	0xC1,R24
    07735 EA21      LDI	R18,0xA1
    07736 E035      LDI	R19,5
    07737 EE05      LDI	R16,0xE5
    07738 E018      LDI	R17,0x8
    07739 940E A90D CALL	_uart_Printf
(0755) 						Uart0ReEnable;
    0773B 9180 00C1 LDS	R24,0xC1
    0773D 6180      ORI	R24,0x10
    0773E 9380 00C1 STS	0xC1,R24
(0756) 					}
(0757) 				//	if(ControlCmd.cmdIdx)
(0758) 						CommandClear();
    07740 940E 38F8 CALL	_SetStateLedBusy
(0759) 				}
(0760) 				if(workSwitch)
    07742 C35D      RJMP	0x7AA0
    07743 9020 02E0 LDS	R2,CardStoreOpenLook
    07745 2022      TST	R2
(0761) 				{
(0762) 					taskSate = 0;
    07746 F439      BNE	0x774E
    07747 9100 1569 LDS	R16,ControlCmd+3
(0763) 					if(primeProcessSW == 0)
    07749 9110 156A LDS	R17,ControlCmd+4
    0774B 940E 6C66 CALL	_SetStoreDoorOpen
(0764) 					{
(0765) 						diluteProcessState = DiluteProcess(0);
    0774D C352      RJMP	0x7AA0
    0774E 9180 00C1 LDS	R24,0xC1
    07750 7E8F      ANDI	R24,0xEF
    07751 9380 00C1 STS	0xC1,R24
    07753 ED25      LDI	R18,0xD5
(0766) 						taskSate += diluteProcessState;
    07754 E035      LDI	R19,5
    07755 EE05      LDI	R16,0xE5
    07756 E018      LDI	R17,0x8
    07757 940E A90D CALL	_uart_Printf
(0767) 					}
    07759 9180 00C1 LDS	R24,0xC1
(0768) 					else
(0769) 					{
(0770) 						if(primeProcessSW == 1)
    0775B 6180      ORI	R24,0x10
    0775C 9380 00C1 STS	0xC1,R24
(0771) 						{
(0772) 							i = _ManualPrimingDiluent();
    0775E C341      RJMP	0x7AA0
    0775F 9100 1569 LDS	R16,ControlCmd+3
    07761 9110 156A LDS	R17,ControlCmd+4
(0773) 							if(i == 1)
    07763 DA4E      RCALL	_ReStart
    07764 C33B      RJMP	0x7AA0
(0774) 							{
(0775) 								primeProcessSW = 0;
    07765 9180 157D LDS	R24,ControlCmd+23
    07767 3084      CPI	R24,4
(0776) 								Uart0ReUnable;
    07768 F0F8      BCS	0x7788
    07769 9100 1569 LDS	R16,ControlCmd+3
    0776B 9110 156A LDS	R17,ControlCmd+4
(0777) 								uart_Printf("%s\r\n",strM3162);
    0776D 940E 5283 CALL	_SetDiluentRatio
    0776F 9100 156B LDS	R16,ControlCmd+5
    07771 9110 156C LDS	R17,ControlCmd+6
(0778) 								Uart0ReEnable;
    07773 940E 525D CALL	_SetWorkStoreNum
    07775 9100 156D LDS	R16,ControlCmd+7
    07777 9110 156E LDS	R17,ControlCmd+8
(0779) 								if(JumpMode != 2)
    07779 940E 5313 CALL	_SetReadMolule
    0777B 9100 156F LDS	R16,ControlCmd+9
(0780) 									SetStateLedFree();
    0777D 9110 1570 LDS	R17,ControlCmd+10
(0781) 							}
(0782) 						}
    0777F 940E 52B9 CALL	_SetReadTime0
(0783) 						else if(primeProcessSW == 2)
    07781 9100 1571 LDS	R16,ControlCmd+11
    07783 9110 1572 LDS	R17,ControlCmd+12
(0784) 						{
(0785) 							i = _ManualPrimingFluid();
    07785 940E 52E5 CALL	_SetReadTime1
    07787 C318      RJMP	0x7AA0
(0786) 							if(i == 1)
    07788 E081      LDI	R24,1
    07789 9380 17CA STS	_DiluentCalChart+41,R24
(0787) 							{
(0788) 								primeProcessSW = 0;
    0778B C314      RJMP	0x7AA0
    0778C 9100 1569 LDS	R16,ControlCmd+3
(0789) 								Uart0ReUnable;
    0778E 9110 156A LDS	R17,ControlCmd+4
    07790 940E 525D CALL	_SetWorkStoreNum
(0790) 								uart_Printf("%s\r\n",strM3163);
    07792 C30D      RJMP	0x7AA0
    07793 9100 1569 LDS	R16,ControlCmd+3
    07795 9110 156A LDS	R17,ControlCmd+4
    07797 940E 5283 CALL	_SetDiluentRatio
(0791) 								Uart0ReEnable;
    07799 C306      RJMP	0x7AA0
    0779A 9100 1569 LDS	R16,ControlCmd+3
    0779C 9110 156A LDS	R17,ControlCmd+4
(0792) 								if(JumpMode != 2)
    0779E 940E 52B9 CALL	_SetReadTime0
    077A0 C2FF      RJMP	0x7AA0
(0793) 									SetStateLedFree();
    077A1 9100 1569 LDS	R16,ControlCmd+3
(0794) 							}
(0795) 						}
    077A3 9110 156A LDS	R17,ControlCmd+4
(0796) 						else if(primeProcessSW == 3)
    077A5 940E 52E5 CALL	_SetReadTime1
    077A7 C2F8      RJMP	0x7AA0
(0797) 						{
(0798) 							i = DiluteStartCheck(0);// 函数返回1表示处理完毕
    077A8 9100 1569 LDS	R16,ControlCmd+3
    077AA 9110 156A LDS	R17,ControlCmd+4
    077AC 940E 5313 CALL	_SetReadMolule
(0799) 							if(i == 1)
    077AE C2F1      RJMP	0x7AA0
    077AF 9100 1569 LDS	R16,ControlCmd+3
(0800) 							{
(0801) 								primeProcessSW = 0;
    077B1 9110 156A LDS	R17,ControlCmd+4
(0802) 								if(JumpMode == 2)
    077B3 940E 557D CALL	_SetDropVolume
    077B5 C2EA      RJMP	0x7AA0
    077B6 9100 1569 LDS	R16,ControlCmd+3
(0803) 									JumpMode = 3;
    077B8 9110 156A LDS	R17,ControlCmd+4
(0804) 								SetStateLedFree();
    077BA 940E 55E4 CALL	_SetDropMode
(0805) 							}
(0806) 						}
(0807) 					}
(0808) 					if(CardScanfSW == 0)
    077BC C2E3      RJMP	0x7AA0
    077BD 9100 1569 LDS	R16,ControlCmd+3
    077BF 9110 156A LDS	R17,ControlCmd+4
(0809) 					{
(0810) 						GetNewPieceProcessState = GetNewPieceFromStoreProcess(0);
    077C1 940E 5638 CALL	_SetReMixNum
    077C3 C2DC      RJMP	0x7AA0
    077C4 9100 1569 LDS	R16,ControlCmd+3
    077C6 9110 156A LDS	R17,ControlCmd+4
(0811) 					}
    077C8 940E 635B CALL	_SetAutoTestCycle
    077CA C2D5      RJMP	0x7AA0
    077CB 9100 1569 LDS	R16,ControlCmd+3
    077CD 9110 156A LDS	R17,ControlCmd+4
(0812) 					else
(0813) 					{
(0814) 						if(1 == CardScanfPosCheck())
(0815) 						{
(0816) 							CardScanfSW = 0;
    077CF 940E 193C CALL	_ReportCardStoreState
    077D1 C2CE      RJMP	0x7AA0
(0817) 							Uart0ReUnable;
    077D2 9020 1569 LDS	R2,ControlCmd+3
    077D4 9030 156A LDS	R3,ControlCmd+4
    077D6 2022      TST	R2
(0818) 							uart_Printf("%sDone\r\n",strM3124);
    077D7 F499      BNE	0x77EB
    077D8 2033      TST	R3
    077D9 F489      BNE	0x77EB
    077DA 9120 156B LDS	R18,ControlCmd+5
    077DC 9130 156C LDS	R19,ControlCmd+6
(0819) 							Uart0ReEnable;
    077DE 2700      CLR	R16
    077DF 940E 9FBC CALL	_AdjustTestLamp
    077E1 0158      MOVW	R10,R16
(0820) 						}
(0821) 					}
(0822) 					TestAQueueProcess();
    077E2 9120 156D LDS	R18,ControlCmd+7
(0823) 					TestBQueueProcess();
    077E4 9130 156E LDS	R19,ControlCmd+8
(0824) 					taskSate += UnloadQueueProcess();
    077E6 E001      LDI	R16,1
    077E7 940E 9FBC CALL	_AdjustTestLamp
    077E9 0168      MOVW	R12,R16
    077EA C012      RJMP	0x77FD
    077EB 9120 156B LDS	R18,ControlCmd+5
    077ED 9130 156C LDS	R19,ControlCmd+6
    077EF E002      LDI	R16,2
(0825) 					if(taskSate > 2)
    077F0 940E 9FBC CALL	_AdjustTestLamp
    077F2 0178      MOVW	R14,R16
    077F3 0157      MOVW	R10,R14
(0826) 						SetWorkStep(0);
    077F4 9120 156D LDS	R18,ControlCmd+7
(0827) 				}
(0828) 				break;
    077F6 9130 156E LDS	R19,ControlCmd+8
(0829) 		/************ 调试维护 **************/
(0830) 			case 4:		
(0831) 				if(ControlCmd.cmdState==2)
    077F8 E003      LDI	R16,3
    077F9 940E 9FBC CALL	_AdjustTestLamp
    077FB 0178      MOVW	R14,R16
(0832) 				{
(0833) 					cmdState = 0;
    077FC 0167      MOVW	R12,R14
    077FD 9180 00C1 LDS	R24,0xC1
(0834) 					Uart0ReUnable;
    077FF 7E8F      ANDI	R24,0xEF
    07800 9380 00C1 STS	0xC1,R24
    07802 82DB      STD	Y+3,R13
    07803 82CA      STD	Y+2,R12
(0835) 					uart_Printf("#%4d CommandReceive $   0\r\n",ControlCmd.cmdIdx);
    07804 82B9      STD	Y+1,R11
    07805 82A8      ST	Y,R10
    07806 E42F      LDI	R18,0x4F
    07807 E137      LDI	R19,0x17
    07808 E30C      LDI	R16,0x3C
    07809 E018      LDI	R17,0x8
    0780A 940E A90D CALL	_uart_Printf
(0836) 					Uart0ReEnable;
    0780C 9180 00C1 LDS	R24,0xC1
    0780E 6180      ORI	R24,0x10
    0780F 9380 00C1 STS	0xC1,R24
(0837) 					if(miantianSubFunction == 0)
    07811 C28E      RJMP	0x7AA0
    07812 9020 1569 LDS	R2,ControlCmd+3
    07814 9030 156A LDS	R3,ControlCmd+4
    07816 2022      TST	R2
    07817 F429      BNE	0x781D
    07818 2033      TST	R3
    07819 F419      BNE	0x781D
    0781A 940E 9F08 CALL	_TestALampOpen
(0838) 					{
(0839) 						// 空闲状态下接收命令
(0840) 						switch(ControlCmd.cmdIdx)
    0781C C283      RJMP	0x7AA0
    0781D 940E 9F29 CALL	_TestBLampOpen
    0781F C280      RJMP	0x7AA0
    07820 9020 1569 LDS	R2,ControlCmd+3
    07822 9030 156A LDS	R3,ControlCmd+4
    07824 2022      TST	R2
    07825 F429      BNE	0x782B
    07826 2033      TST	R3
    07827 F419      BNE	0x782B
    07828 940E 9F1B CALL	_TestALampClose
    0782A C275      RJMP	0x7AA0
    0782B 940E 9F3C CALL	_TestBLampClose
    0782D C272      RJMP	0x7AA0
    0782E 9180 00C1 LDS	R24,0xC1
    07830 7E8F      ANDI	R24,0xEF
    07831 9380 00C1 STS	0xC1,R24
    07833 940E 5280 CALL	_GetWorkStoreNum
    07835 2EE0      MOV	R14,R16
    07836 2C2E      MOV	R2,R14
    07837 2433      CLR	R3
    07838 8239      STD	Y+1,R3
    07839 8228      ST	Y,R2
    0783A ED2B      LDI	R18,0xDB
    0783B E03F      LDI	R19,0xF
    0783C E803      LDI	R16,0x83
    0783D E017      LDI	R17,7
    0783E 940E A90D CALL	_uart_Printf
    07840 9180 00C1 LDS	R24,0xC1
    07842 6180      ORI	R24,0x10
    07843 9380 00C1 STS	0xC1,R24
    07845 C25A      RJMP	0x7AA0
    07846 9120 156B LDS	R18,ControlCmd+5
    07848 9130 156C LDS	R19,ControlCmd+6
    0784A 9100 1569 LDS	R16,ControlCmd+3
    0784C 9110 156A LDS	R17,ControlCmd+4
    0784E 940E 5686 CALL	_CalculateCalStandCoeff
    07850 0178      MOVW	R14,R16
    07851 0157      MOVW	R10,R14
    07852 9100 1569 LDS	R16,ControlCmd+3
    07854 9110 156A LDS	R17,ControlCmd+4
    07856 940E 7066 CALL	_Save_DiluentCalChart
    07858 0178      MOVW	R14,R16
    07859 0167      MOVW	R12,R14
    0785A 9020 1569 LDS	R2,ControlCmd+3
    0785C 9030 156A LDS	R3,ControlCmd+4
    0785E 2022      TST	R2
    0785F F449      BNE	0x7869
    07860 2033      TST	R3
    07861 F439      BNE	0x7869
    07862 E089      LDI	R24,0x9
(0841) 						{
(0842) 							case 3:		// #0003 查询工作进程
(0843) 								Uart0ReUnable;
    07863 E090      LDI	R25,0
    07864 9390 156A STS	ControlCmd+4,R25
    07866 9380 1569 STS	ControlCmd+3,R24
(0844) 								uart_Printf("%s $   4 [Maintain]\r\n",strM0110);
    07868 C00D      RJMP	0x7876
    07869 E08D      LDI	R24,0xD
    0786A E090      LDI	R25,0
    0786B 9020 1569 LDS	R2,ControlCmd+3
    0786D 9030 156A LDS	R3,ControlCmd+4
(0845) 								Uart0ReEnable;
    0786F 1582      CP	R24,R2
    07870 0593      CPC	R25,R3
    07871 F420      BCC	0x7876
    07872 9390 156A STS	ControlCmd+4,R25
(0846) 								break;
    07874 9380 1569 STS	ControlCmd+3,R24
(0847) 							case 4:	// quit
(0848) 								SetWorkStep(0);
(0849) 								break;
    07876 9180 00C1 LDS	R24,0xC1
(0850) 							case 5:
(0851) 								if(ControlCmd.pam[0] == 0)
    07878 7E8F      ANDI	R24,0xEF
    07879 9380 00C1 STS	0xC1,R24
    0787B 82DD      STD	Y+5,R13
    0787C 82CC      STD	Y+4,R12
    0787D 82BB      STD	Y+3,R11
    0787E 82AA      STD	Y+2,R10
(0852) 								{
(0853) 									workSwitch = 1;
    0787F 9020 1569 LDS	R2,ControlCmd+3
    07881 9030 156A LDS	R3,ControlCmd+4
(0854) 									Uart0ReUnable;
    07883 8239      STD	Y+1,R3
    07884 8228      ST	Y,R2
    07885 E825      LDI	R18,0x85
    07886 E137      LDI	R19,0x17
(0855) 									uart_Printf("%s\r\n",strM0105);
    07887 E60F      LDI	R16,0x6F
    07888 E017      LDI	R17,7
    07889 940E A90D CALL	_uart_Printf
    0788B 9180 00C1 LDS	R24,0xC1
(0856) 									Uart0ReEnable;
    0788D 6180      ORI	R24,0x10
    0788E 9380 00C1 STS	0xC1,R24
    07890 C20F      RJMP	0x7AA0
    07891 9100 1569 LDS	R16,ControlCmd+3
(0857) 								}
    07893 9110 156A LDS	R17,ControlCmd+4
    07895 940E 3916 CALL	_SetTestDebugMode
(0858) 								else
(0859) 								{
(0860) 									workSwitch = 0;
(0861) 									Uart0ReUnable;
    07897 C208      RJMP	0x7AA0
    07898 9100 1569 LDS	R16,ControlCmd+3
    0789A 9110 156A LDS	R17,ControlCmd+4
(0862) 									uart_Printf("%s\r\n",strM0106);
    0789C 940E 1799 CALL	_SetGetCardTestMode
    0789E C201      RJMP	0x7AA0
    0789F 9100 1569 LDS	R16,ControlCmd+3
(0863) 									Uart0ReEnable;
    078A1 9110 156A LDS	R17,ControlCmd+4
    078A3 940E 560C CALL	_SetMixtureMode
    078A5 C1FA      RJMP	0x7AA0
(0864) 								}
(0865) 								break;
    078A6 9100 1569 LDS	R16,ControlCmd+3
(0866) 							case 10:	// #0010	开启片仓
(0867) 								if(CardStoreOpenLook == 0)
    078A8 9110 156A LDS	R17,ControlCmd+4
    078AA 940E A97B CALL	_SetWasteCardState
(0868) 									SetStoreDoorOpen(ControlCmd.pam[0]);
    078AC C1F3      RJMP	0x7AA0
    078AD 9100 1569 LDS	R16,ControlCmd+3
    078AF 9110 156A LDS	R17,ControlCmd+4
    078B1 940E 55B6 CALL	_SetSamplingVolume
(0869) 							else
(0870) 								Uart0ReUnable;
    078B3 C1EC      RJMP	0x7AA0
    078B4 940E 54C1 CALL	_TestSleep
    078B6 C1E9      RJMP	0x7AA0
(0871) 								uart_Printf("%s\r\n",strM0112);
    078B7 940E 54C8 CALL	_TestStartup
    078B9 C1E6      RJMP	0x7AA0
    078BA 9020 1569 LDS	R2,ControlCmd+3
    078BC 9030 156A LDS	R3,ControlCmd+4
(0872) 								Uart0ReEnable;
    078BE 2022      TST	R2
    078BF F411      BNE	0x78C2
    078C0 2033      TST	R3
    078C1 F0B1      BEQ	0x78D8
(0873) 								break;
    078C2 2700      CLR	R16
(0874) 							case 11:	// #0011	读取片仓温湿度
(0875) 								Uart0ReUnable;
    078C3 940E 391D CALL	_SamplingSwitch
    078C5 940E 38F8 CALL	_SetStateLedBusy
    078C7 9180 00C1 LDS	R24,0xC1
(0876) 								uart_Printf("%s $%4d $%4d\r\n",strM0111, GetStoreHumi(), GetStoreTemp());
    078C9 7E8F      ANDI	R24,0xEF
    078CA 9380 00C1 STS	0xC1,R24
    078CC E32C      LDI	R18,0x3C
    078CD E131      LDI	R19,0x11
    078CE EE05      LDI	R16,0xE5
    078CF E018      LDI	R17,0x8
    078D0 940E A90D CALL	_uart_Printf
    078D2 9180 00C1 LDS	R24,0xC1
    078D4 6180      ORI	R24,0x10
    078D5 9380 00C1 STS	0xC1,R24
    078D7 C1C8      RJMP	0x7AA0
    078D8 9180 00C1 LDS	R24,0xC1
    078DA 7E8F      ANDI	R24,0xEF
    078DB 9380 00C1 STS	0xC1,R24
(0877) 								Uart0ReEnable;
    078DD E520      LDI	R18,0x50
    078DE E131      LDI	R19,0x11
    078DF EE05      LDI	R16,0xE5
    078E0 E018      LDI	R17,0x8
(0878) 								break;
    078E1 940E A90D CALL	_uart_Printf
(0879) 							case 99:	// 重起, 设置看门狗
(0880) 								ReStart(ControlCmd.pam[0]);
    078E3 9180 00C1 LDS	R24,0xC1
    078E5 6180      ORI	R24,0x10
    078E6 9380 00C1 STS	0xC1,R24
(0881) 								break;
    078E8 E001      LDI	R16,1
(0882) 							case 4002:	// 取样针在混匀池右边沿位置调整
(0883) 								si = SetNeedleOnMixPos((signed char)ControlCmd.pam[0]);
    078E9 940E 391D CALL	_SamplingSwitch
    078EB 9180 03EE LDS	R24,_LEDSTATE
    078ED 3081      CPI	R24,1
    078EE F009      BEQ	0x78F0
    078EF C1B0      RJMP	0x7AA0
    078F0 940E 3907 CALL	_SetStateLedFree
(0884) 								Uart0ReUnable;
    078F2 C1AD      RJMP	0x7AA0
    078F3 940E A74B CALL	_SetReReadFlag
    078F5 C1AA      RJMP	0x7AA0
(0885) 								uart_Printf("%s $%4d\r\n",strM4102, si);
    078F6 9100 1569 LDS	R16,ControlCmd+3
    078F8 9110 156A LDS	R17,ControlCmd+4
    078FA 940E 69E8 CALL	_SetCleanMode
    078FC C1A3      RJMP	0x7AA0
    078FD 940E 9FE7 CALL	_SetReadCloseAnswer
    078FF C1A0      RJMP	0x7AA0
    07900 9180 17CC LDS	R24,_DiluentCalChart+43
(0886) 								Uart0ReEnable;
    07902 3081      CPI	R24,1
    07903 F009      BEQ	0x7905
    07904 C05A      RJMP	0x795F
    07905 9020 17D6 LDS	R2,primeProcessSW
(0887) 								break;
    07907 2022      TST	R2
(0888) 							case 4004:	// 滴样高度调整
(0889) 								si = SetDropHeight((signed char)ControlCmd.pam[0]);
    07908 F4B1      BNE	0x791F
    07909 9180 00C1 LDS	R24,0xC1
    0790B 7E8F      ANDI	R24,0xEF
    0790C 9380 00C1 STS	0xC1,R24
    0790E EC27      LDI	R18,0xC7
    0790F E131      LDI	R19,0x11
(0890) 								Uart0ReUnable;
    07910 EE05      LDI	R16,0xE5
    07911 E018      LDI	R17,0x8
    07912 940E A90D CALL	_uart_Printf
    07914 9180 00C1 LDS	R24,0xC1
(0891) 								uart_Printf("%s $%4d\r\n",strM4104, si);
    07916 6180      ORI	R24,0x10
    07917 9380 00C1 STS	0xC1,R24
    07919 940E 38F8 CALL	_SetStateLedBusy
    0791B E081      LDI	R24,1
    0791C 9380 17D6 STS	primeProcessSW,R24
    0791E C181      RJMP	0x7AA0
    0791F 9180 17D6 LDS	R24,primeProcessSW
(0892) 								Uart0ReEnable;
    07921 3081      CPI	R24,1
    07922 F489      BNE	0x7934
    07923 9180 00C1 LDS	R24,0xC1
    07925 7E8F      ANDI	R24,0xEF
(0893) 								break;
    07926 9380 00C1 STS	0xC1,R24
(0894) 							case 4005:	miantianSubFunction = CardLoadStartAdjust;		break;
    07928 EA25      LDI	R18,0xA5
    07929 E132      LDI	R19,0x12
    0792A EE05      LDI	R16,0xE5
    0792B E018      LDI	R17,0x8
    0792C 940E A90D CALL	_uart_Printf
(0895) 							case 4006:	miantianSubFunction = CardLoadEndAdjust;		break;
    0792E 9180 00C1 LDS	R24,0xC1
    07930 6180      ORI	R24,0x10
    07931 9380 00C1 STS	0xC1,R24
    07933 C16C      RJMP	0x7AA0
    07934 9180 17D6 LDS	R24,primeProcessSW
(0896) 							case 4007:	miantianSubFunction = CardUnloadStartAdjust;	break;
    07936 3082      CPI	R24,2
    07937 F489      BNE	0x7949
    07938 9180 00C1 LDS	R24,0xC1
    0793A 7E8F      ANDI	R24,0xEF
    0793B 9380 00C1 STS	0xC1,R24
(0897) 							case 4008:	miantianSubFunction = CardUnloadEndAdjust;		break;
    0793D EC22      LDI	R18,0xC2
    0793E E132      LDI	R19,0x12
    0793F EE05      LDI	R16,0xE5
    07940 E018      LDI	R17,0x8
    07941 940E A90D CALL	_uart_Printf
(0898) 							case 4009:
(0899) 								SetLiquidPhotoAdjustNum(ControlCmd.pam[0]);
    07943 9180 00C1 LDS	R24,0xC1
    07945 6180      ORI	R24,0x10
    07946 9380 00C1 STS	0xC1,R24
    07948 C157      RJMP	0x7AA0
(0900) 								miantianSubFunction = LiquidPhotoAdjust;
    07949 9180 17D6 LDS	R24,primeProcessSW
    0794B 3083      CPI	R24,3
    0794C F009      BEQ	0x794E
    0794D C152      RJMP	0x7AA0
    0794E 9180 00C1 LDS	R24,0xC1
(0901) 								break;
    07950 7E8F      ANDI	R24,0xEF
    07951 9380 00C1 STS	0xC1,R24
    07953 ED2D      LDI	R18,0xDD
    07954 E132      LDI	R19,0x12
    07955 EE05      LDI	R16,0xE5
(0902) 							case 4010:
(0903) 								SetCardStorePhotoAdjustNum(ControlCmd.pam[0]);
(0904) 								miantianSubFunction = CardStorePhotoAdjust;
    07956 E018      LDI	R17,0x8
    07957 940E A90D CALL	_uart_Printf
    07959 9180 00C1 LDS	R24,0xC1
    0795B 6180      ORI	R24,0x10
(0905) 								break;
    0795C 9380 00C1 STS	0xC1,R24
(0906) 							case 4011:		// SetLampLum
(0907) 								if(ControlCmd.pam[0] == 0)
    0795E C141      RJMP	0x7AA0
    0795F 9180 00C1 LDS	R24,0xC1
    07961 7E8F      ANDI	R24,0xEF
    07962 9380 00C1 STS	0xC1,R24
    07964 E426      LDI	R18,0x46
(0908) 								{
(0909) 									iTmp0 = AdjustTestLamp(0, ControlCmd.pam[1]);
    07965 E03E      LDI	R19,0xE
    07966 E607      LDI	R16,0x67
    07967 E017      LDI	R17,7
    07968 940E A90D CALL	_uart_Printf
    0796A 9180 00C1 LDS	R24,0xC1
    0796C 6180      ORI	R24,0x10
    0796D 9380 00C1 STS	0xC1,R24
(0910) 									iTmp1 = AdjustTestLamp(1, ControlCmd.pam[2]);
    0796F C130      RJMP	0x7AA0
    07970 9180 17CC LDS	R24,_DiluentCalChart+43
    07972 3081      CPI	R24,1
    07973 F009      BEQ	0x7975
    07974 C05A      RJMP	0x79CF
    07975 9020 17D6 LDS	R2,primeProcessSW
    07977 2022      TST	R2
(0911) 								}
    07978 F4B1      BNE	0x798F
(0912) 								else
(0913) 								{
(0914) 									iTmp0 = AdjustTestLamp(2, ControlCmd.pam[1]);
    07979 9180 00C1 LDS	R24,0xC1
    0797B 7E8F      ANDI	R24,0xEF
    0797C 9380 00C1 STS	0xC1,R24
    0797E EE25      LDI	R18,0xE5
    0797F E131      LDI	R19,0x11
    07980 EE05      LDI	R16,0xE5
    07981 E018      LDI	R17,0x8
    07982 940E A90D CALL	_uart_Printf
(0915) 									iTmp1 = AdjustTestLamp(3, ControlCmd.pam[2]);
    07984 9180 00C1 LDS	R24,0xC1
    07986 6180      ORI	R24,0x10
    07987 9380 00C1 STS	0xC1,R24
    07989 940E 38F8 CALL	_SetStateLedBusy
    0798B E082      LDI	R24,2
(0916) 								}
(0917) 								Uart0ReUnable;
    0798C 9380 17D6 STS	primeProcessSW,R24
    0798E C111      RJMP	0x7AA0
    0798F 9180 17D6 LDS	R24,primeProcessSW
(0918) 								uart_Printf("%s $%4d $%4d\r\n", strM4114, iTmp0, iTmp1);
    07991 3081      CPI	R24,1
    07992 F489      BNE	0x79A4
    07993 9180 00C1 LDS	R24,0xC1
    07995 7E8F      ANDI	R24,0xEF
    07996 9380 00C1 STS	0xC1,R24
    07998 EA25      LDI	R18,0xA5
    07999 E132      LDI	R19,0x12
    0799A EE05      LDI	R16,0xE5
    0799B E018      LDI	R17,0x8
    0799C 940E A90D CALL	_uart_Printf
(0919) 								Uart0ReEnable;
    0799E 9180 00C1 LDS	R24,0xC1
    079A0 6180      ORI	R24,0x10
    079A1 9380 00C1 STS	0xC1,R24
(0920) 								break;
    079A3 C0FC      RJMP	0x7AA0
    079A4 9180 17D6 LDS	R24,primeProcessSW
    079A6 3082      CPI	R24,2
    079A7 F489      BNE	0x79B9
    079A8 9180 00C1 LDS	R24,0xC1
    079AA 7E8F      ANDI	R24,0xEF
(0921) 							case 4012:		// GetLampLum
(0922) 								if(ControlCmd.pam[0] == 0)
(0923) 								{
(0924) 									iTmp0 = ReadTestLampPWM(0);
    079AB 9380 00C1 STS	0xC1,R24
    079AD EC22      LDI	R18,0xC2
    079AE E132      LDI	R19,0x12
    079AF EE05      LDI	R16,0xE5
    079B0 E018      LDI	R17,0x8
(0925) 									iTmp1 = ReadTestLampPWM(1);
    079B1 940E A90D CALL	_uart_Printf
    079B3 9180 00C1 LDS	R24,0xC1
    079B5 6180      ORI	R24,0x10
(0926) 								}
    079B6 9380 00C1 STS	0xC1,R24
(0927) 								else
(0928) 								{
(0929) 									iTmp0 = ReadTestLampPWM(2);
    079B8 C0E7      RJMP	0x7AA0
    079B9 9180 17D6 LDS	R24,primeProcessSW
    079BB 3083      CPI	R24,3
    079BC F009      BEQ	0x79BE
(0930) 									iTmp1 = ReadTestLampPWM(3);
    079BD C0E2      RJMP	0x7AA0
    079BE 9180 00C1 LDS	R24,0xC1
    079C0 7E8F      ANDI	R24,0xEF
    079C1 9380 00C1 STS	0xC1,R24
(0931) 								}
(0932) 								Uart0ReUnable;
    079C3 ED2D      LDI	R18,0xDD
    079C4 E132      LDI	R19,0x12
    079C5 EE05      LDI	R16,0xE5
    079C6 E018      LDI	R17,0x8
(0933) 								uart_Printf("%s $%4d $%4d\r\n", strM4114, iTmp0, iTmp1);
    079C7 940E A90D CALL	_uart_Printf
    079C9 9180 00C1 LDS	R24,0xC1
    079CB 6180      ORI	R24,0x10
    079CC 9380 00C1 STS	0xC1,R24
    079CE C0D1      RJMP	0x7AA0
    079CF 9180 00C1 LDS	R24,0xC1
    079D1 7E8F      ANDI	R24,0xEF
    079D2 9380 00C1 STS	0xC1,R24
(0934) 								Uart0ReEnable;
    079D4 E426      LDI	R18,0x46
    079D5 E03E      LDI	R19,0xE
    079D6 E607      LDI	R16,0x67
    079D7 E017      LDI	R17,7
(0935) 								break;
    079D8 940E A90D CALL	_uart_Printf
(0936) 							case 4013:		// TurnOnLamp
(0937) 								if(ControlCmd.pam[0] == 0)
    079DA 9180 00C1 LDS	R24,0xC1
    079DC 6180      ORI	R24,0x10
    079DD 9380 00C1 STS	0xC1,R24
    079DF C0C0      RJMP	0x7AA0
    079E0 9100 1569 LDS	R16,ControlCmd+3
(0938) 									TestALampOpen();
    079E2 9110 156A LDS	R17,ControlCmd+4
(0939) 								else	
(0940) 									TestBLampOpen();
    079E4 940E 54D6 CALL	_SetDropVolumeFactor
(0941) 								break;
    079E6 C0B9      RJMP	0x7AA0
(0942) 							case 4014:		// TurnOffLamp
(0943) 								if(ControlCmd.pam[0] == 0)
    079E7 9120 156B LDS	R18,ControlCmd+5
    079E9 9130 156C LDS	R19,ControlCmd+6
    079EB 9100 1569 LDS	R16,ControlCmd+3
    079ED 9110 156A LDS	R17,ControlCmd+4
(0944) 									TestALampClose();
    079EF 940E 2FEA CALL	_GetMotorMonitorState
    079F1 C0AE      RJMP	0x7AA0
(0945) 								else	
(0946) 									TestBLampClose();
    079F2 9180 17CC LDS	R24,_DiluentCalChart+43
(0947) 								break;
    079F4 3081      CPI	R24,1
(0948) 							case 4015:
(0949) 								iTmp0 = CalculateCalStandCoeff(ControlCmd.pam[0],ControlCmd.pam[1]);
    079F5 F009      BEQ	0x79F7
    079F6 C05A      RJMP	0x7A51
    079F7 9020 17D6 LDS	R2,primeProcessSW
    079F9 2022      TST	R2
    079FA F4B1      BNE	0x7A11
    079FB 9180 00C1 LDS	R24,0xC1
    079FD 7E8F      ANDI	R24,0xEF
    079FE 9380 00C1 STS	0xC1,R24
    07A00 EA2F      LDI	R18,0xAF
    07A01 E035      LDI	R19,5
(0950) 								iTmp1 = Save_DiluentCalChart(ControlCmd.pam[0]);
    07A02 E409      LDI	R16,0x49
    07A03 E017      LDI	R17,7
    07A04 940E A90D CALL	_uart_Printf
    07A06 9180 00C1 LDS	R24,0xC1
    07A08 6180      ORI	R24,0x10
    07A09 9380 00C1 STS	0xC1,R24
(0951) 								if(ControlCmd.pam[0] == 0)
    07A0B 940E 38F8 CALL	_SetStateLedBusy
    07A0D E083      LDI	R24,3
    07A0E 9380 17D6 STS	primeProcessSW,R24
    07A10 C08F      RJMP	0x7AA0
    07A11 9180 17D6 LDS	R24,primeProcessSW
(0952) 									ControlCmd.pam[0] = 9;
    07A13 3081      CPI	R24,1
    07A14 F489      BNE	0x7A26
    07A15 9180 00C1 LDS	R24,0xC1
    07A17 7E8F      ANDI	R24,0xEF
    07A18 9380 00C1 STS	0xC1,R24
(0953) 								else if(ControlCmd.pam[0] > 13)
    07A1A EA25      LDI	R18,0xA5
    07A1B E132      LDI	R19,0x12
    07A1C EE05      LDI	R16,0xE5
    07A1D E018      LDI	R17,0x8
    07A1E 940E A90D CALL	_uart_Printf
    07A20 9180 00C1 LDS	R24,0xC1
(0954) 									ControlCmd.pam[0] = 13;
    07A22 6180      ORI	R24,0x10
    07A23 9380 00C1 STS	0xC1,R24
    07A25 C07A      RJMP	0x7AA0
(0955) 								Uart0ReUnable;
    07A26 9180 17D6 LDS	R24,primeProcessSW
    07A28 3082      CPI	R24,2
    07A29 F489      BNE	0x7A3B
    07A2A 9180 00C1 LDS	R24,0xC1
(0956) 								uart_Printf("%s $%4d $%4d $%4d\r\n", strM4117, ControlCmd.pam[0],iTmp0,iTmp1);
    07A2C 7E8F      ANDI	R24,0xEF
    07A2D 9380 00C1 STS	0xC1,R24
    07A2F EC22      LDI	R18,0xC2
    07A30 E132      LDI	R19,0x12
    07A31 EE05      LDI	R16,0xE5
    07A32 E018      LDI	R17,0x8
    07A33 940E A90D CALL	_uart_Printf
    07A35 9180 00C1 LDS	R24,0xC1
    07A37 6180      ORI	R24,0x10
    07A38 9380 00C1 STS	0xC1,R24
    07A3A C065      RJMP	0x7AA0
    07A3B 9180 17D6 LDS	R24,primeProcessSW
(0957) 								Uart0ReEnable;
    07A3D 3083      CPI	R24,3
    07A3E F009      BEQ	0x7A40
    07A3F C060      RJMP	0x7AA0
    07A40 9180 00C1 LDS	R24,0xC1
(0958) 								break;
    07A42 7E8F      ANDI	R24,0xEF
(0959) 							case 4016:
(0960) 								miantianSubFunction = DiluentQuantifyTest;
    07A43 9380 00C1 STS	0xC1,R24
    07A45 ED2D      LDI	R18,0xDD
    07A46 E132      LDI	R19,0x12
    07A47 EE05      LDI	R16,0xE5
    07A48 E018      LDI	R17,0x8
(0961) 								SetDiluentQuantifyVolume(40);
    07A49 940E A90D CALL	_uart_Printf
    07A4B 9180 00C1 LDS	R24,0xC1
(0962) 								break;
    07A4D 6180      ORI	R24,0x10
    07A4E 9380 00C1 STS	0xC1,R24
    07A50 C04F      RJMP	0x7AA0
    07A51 9180 00C1 LDS	R24,0xC1
    07A53 7E8F      ANDI	R24,0xEF
    07A54 9380 00C1 STS	0xC1,R24
    07A56 E426      LDI	R18,0x46
    07A57 E03E      LDI	R19,0xE
(0963) 							case 4017:	// 抽打混匀高度调整
(0964) 								si = SetMixHeight((signed char)ControlCmd.pam[0]);
(0965) 								Uart0ReUnable;
    07A58 E607      LDI	R16,0x67
    07A59 E017      LDI	R17,7
    07A5A 940E A90D CALL	_uart_Printf
    07A5C 9180 00C1 LDS	R24,0xC1
(0966) 								uart_Printf("%s $%4d\r\n",strM4118, si);
    07A5E 6180      ORI	R24,0x10
    07A5F 9380 00C1 STS	0xC1,R24
    07A61 C03E      RJMP	0x7AA0
    07A62 9180 1559 LDS	R24,CardStoreTestFlag
    07A64 3081      CPI	R24,1
    07A65 F409      BNE	0x7A67
    07A66 C039      RJMP	0x7AA0
    07A67 9020 1569 LDS	R2,ControlCmd+3
(0967) 								Uart0ReEnable;
    07A69 9030 156A LDS	R3,ControlCmd+4
    07A6B 2022      TST	R2
    07A6C F431      BNE	0x7A73
    07A6D 2033      TST	R3
(0968) 								break;
    07A6E F421      BNE	0x7A73
(0969) 							// 
(0970) 							case 4020:	miantianSubFunction = TurnPlateCheck;		break;
    07A6F 2422      CLR	R2
    07A70 9220 06F6 STS	CardNoneUseful,R2
    07A72 C003      RJMP	0x7A76
    07A73 E081      LDI	R24,1
    07A74 9380 06F6 STS	CardNoneUseful,R24
(0971) 							case 4021:	miantianSubFunction = NeedleTurnCheck;		break;
    07A76 9180 00C1 LDS	R24,0xC1
    07A78 7E8F      ANDI	R24,0xEF
    07A79 9380 00C1 STS	0xC1,R24
    07A7B 9020 06F6 LDS	R2,CardNoneUseful
(0972) 							case 4022:	miantianSubFunction = NeedleUpdownCheck;	break;
    07A7D 2433      CLR	R3
    07A7E 8239      STD	Y+1,R3
    07A7F 8228      ST	Y,R2
    07A80 E521      LDI	R18,0x51
    07A81 E134      LDI	R19,0x14
    07A82 E803      LDI	R16,0x83
    07A83 E017      LDI	R17,7
(0973) 							case 4023:	miantianSubFunction = CardStoreMoveCheck;	break;
    07A84 940E A90D CALL	_uart_Printf
    07A86 9180 00C1 LDS	R24,0xC1
    07A88 6180      ORI	R24,0x10
    07A89 9380 00C1 STS	0xC1,R24
(0974) 							case 4024:	miantianSubFunction = CardTakeHookCheck;	break;
    07A8B C014      RJMP	0x7AA0
    07A8C 940E 372D CALL	_SetBeepWarning
    07A8E 9180 00C1 LDS	R24,0xC1
    07A90 7E8F      ANDI	R24,0xEF
    07A91 9380 00C1 STS	0xC1,R24
(0975) 							case 4025:	miantianSubFunction = CardLoadCheck;		break;
    07A93 9120 1567 LDS	R18,ControlCmd+1
    07A95 9130 1568 LDS	R19,ControlCmd+2
    07A97 E900      LDI	R16,0x90
    07A98 E018      LDI	R17,0x8
(0976) 							case 4026:	miantianSubFunction = CardUnloadCheck;		break;
    07A99 940E A90D CALL	_uart_Printf
    07A9B 9180 00C1 LDS	R24,0xC1
    07A9D 6180      ORI	R24,0x10
    07A9E 9380 00C1 STS	0xC1,R24
(0977) 							case 4029:	miantianSubFunction = DiluentPumpCheck;		break;
    07AA0 9020 17CA LDS	R2,_DiluentCalChart+41
    07AA2 2022      TST	R2
    07AA3 F0A9      BEQ	0x7AB9
    07AA4 940E 372D CALL	_SetBeepWarning
    07AA6 9180 00C1 LDS	R24,0xC1
(0978) 							case 4030:	miantianSubFunction = LeanerPumpCheck;		break;
    07AA8 7E8F      ANDI	R24,0xEF
    07AA9 9380 00C1 STS	0xC1,R24
    07AAB 9120 1567 LDS	R18,ControlCmd+1
    07AAD 9130 1568 LDS	R19,ControlCmd+2
(0979) 							case 4031:	miantianSubFunction = EffluentPumpCheck;	break;
    07AAF E706      LDI	R16,0x76
    07AB0 E018      LDI	R17,0x8
    07AB1 940E A90D CALL	_uart_Printf
    07AB3 9180 00C1 LDS	R24,0xC1
(0980) 							case 4032:	miantianSubFunction = SamplingSyringCheck;	break;
    07AB5 6180      ORI	R24,0x10
    07AB6 9380 00C1 STS	0xC1,R24
    07AB8 C014      RJMP	0x7ACD
    07AB9 940E 3739 CALL	_SetBeepAck
    07ABB 9180 00C1 LDS	R24,0xC1
(0981) 							case 4033:
(0982) 							//	SetLiquidPhotoAdjustNum(HTCmdBuf.pam[0]);
(0983) 								miantianSubFunction = LiquidPhotoCheck;
    07ABD 7E8F      ANDI	R24,0xEF
    07ABE 9380 00C1 STS	0xC1,R24
    07AC0 9120 1567 LDS	R18,ControlCmd+1
(0984) 								break;
    07AC2 9130 1568 LDS	R19,ControlCmd+2
(0985) 							case 4034:
(0986) 								SetCardStorePhotoAdjustNum(ControlCmd.pam[0]);
    07AC4 E50D      LDI	R16,0x5D
    07AC5 E018      LDI	R17,0x8
    07AC6 940E A90D CALL	_uart_Printf
    07AC8 9180 00C1 LDS	R24,0xC1
(0987) 								miantianSubFunction = CardStorePhotoCheck;
    07ACA 6180      ORI	R24,0x10
    07ACB 9380 00C1 STS	0xC1,R24
    07ACD 940E 29D2 CALL	_CommandClear
(0988) 								break;
    07ACF 9020 06F7 LDS	R2,workSwitch
(0989) 							case 4035:	miantianSubFunction = NeedleOnMixSideCheck;	break;
    07AD1 2022      TST	R2
    07AD2 F409      BNE	0x7AD4
    07AD3 C5E3      RJMP	0x80B7
    07AD4 2422      CLR	R2
    07AD5 9220 17CB STS	_DiluentCalChart+42,R2
(0990) 							case 4036:	miantianSubFunction = DropHeightCheck;	break;
    07AD7 9020 17D6 LDS	R2,primeProcessSW
    07AD9 2022      TST	R2
    07ADA F469      BNE	0x7AE8
    07ADB 2700      CLR	R16
    07ADC 2711      CLR	R17
    07ADD 940E 395D CALL	_DiluteProcess
(0991) 							case 4037:	miantianSubFunction = MixHeightCheck;	break;
    07ADF 2EE0      MOV	R14,R16
    07AE0 92E0 17CC STS	_DiluentCalChart+43,R14
    07AE2 9030 17CB LDS	R3,_DiluentCalChart+42
    07AE4 0E30      ADD	R3,R16
(0992) 							case 4099:	miantianSubFunction = GetStoreProcess;break;
    07AE5 9230 17CB STS	_DiluentCalChart+42,R3
    07AE7 C077      RJMP	0x7B5F
    07AE8 9180 17D6 LDS	R24,primeProcessSW
    07AEA 3081      CPI	R24,1
    07AEB F511      BNE	0x7B0E
(0993) 							
(0994) 							case 4050:
(0995) 								miantianSubFunction = DiluentQuantifyTest;
    07AEC 940E 6826 CALL	__ManualPrimingDiluent
    07AEE 2EE0      MOV	R14,R16
    07AEF 2D4E      MOV	R20,R14
    07AF0 3001      CPI	R16,1
    07AF1 F009      BEQ	0x7AF3
(0996) 								SetDiluentQuantifyVolume(ControlCmd.pam[0]);
    07AF2 C06C      RJMP	0x7B5F
    07AF3 2422      CLR	R2
    07AF4 9220 17D6 STS	primeProcessSW,R2
    07AF6 9180 00C1 LDS	R24,0xC1
(0997) 								break;
    07AF8 7E8F      ANDI	R24,0xEF
(0998) 							case 4051:
(0999) 								miantianSubFunction = LeanerQuantifyTest;
    07AF9 9380 00C1 STS	0xC1,R24
    07AFB E020      LDI	R18,0
    07AFC E132      LDI	R19,0x12
    07AFD EE05      LDI	R16,0xE5
    07AFE E018      LDI	R17,0x8
(1000) 								SetLeanerQuantifyVolume(ControlCmd.pam[0]);
    07AFF 940E A90D CALL	_uart_Printf
    07B01 9180 00C1 LDS	R24,0xC1
    07B03 6180      ORI	R24,0x10
    07B04 9380 00C1 STS	0xC1,R24
(1001) 								break;
    07B06 9180 0533 LDS	R24,JumpMode
    07B08 3082      CPI	R24,2
    07B09 F409      BNE	0x7B0B
    07B0A C054      RJMP	0x7B5F
    07B0B 940E 3907 CALL	_SetStateLedFree
(1002) 							case 4052:
(1003) 								miantianSubFunction = SampQuantifyTest;
(1004) 								SetSampQuantifyVolume(ControlCmd.pam[0]);
    07B0D C051      RJMP	0x7B5F
    07B0E 9180 17D6 LDS	R24,primeProcessSW
    07B10 3082      CPI	R24,2
    07B11 F509      BNE	0x7B33
(1005) 								break;
    07B12 940E 6906 CALL	__ManualPrimingFluid
(1006) 							case 4055:	// 上传传感器状态信息
(1007) 								UpLoadingModuleSensorState((unsigned char)ControlCmd.pam[0], (unsigned char)ControlCmd.pam[1]);
    07B14 2EE0      MOV	R14,R16
    07B15 2D4E      MOV	R20,R14
    07B16 3001      CPI	R16,1
    07B17 F009      BEQ	0x7B19
    07B18 C046      RJMP	0x7B5F
    07B19 2422      CLR	R2
    07B1A 9220 17D6 STS	primeProcessSW,R2
    07B1C 9180 00C1 LDS	R24,0xC1
(1008) 								break;
    07B1E 7E8F      ANDI	R24,0xEF
    07B1F 9380 00C1 STS	0xC1,R24
(1009) 							case 4056:	// 上传所有传感器状态信息
(1010) 								UpLoadingAllSensorState();
(1011) 								break;
    07B21 E12C      LDI	R18,0x1C
    07B22 E132      LDI	R19,0x12
    07B23 EE05      LDI	R16,0xE5
    07B24 E018      LDI	R17,0x8
    07B25 940E A90D CALL	_uart_Printf
    07B27 9180 00C1 LDS	R24,0xC1
    07B29 6180      ORI	R24,0x10
    07B2A 9380 00C1 STS	0xC1,R24
    07B2C 9180 0533 LDS	R24,JumpMode
    07B2E 3082      CPI	R24,2
(1012) 							// 基本命令
(1013) 							case 4060:		// 预定义位置设置
(1014) 								cmdState =  MotAdjustPosition((unsigned char)ControlCmd.pam[0], (unsigned char)ControlCmd.pam[1]);
(1015) 								break;
    07B2F F179      BEQ	0x7B5F
(1016) 							case 4061:		// 起始位检测
(1017) 								cmdState =  MotInitCheck((unsigned char)ControlCmd.pam[0]);
    07B30 940E 3907 CALL	_SetStateLedFree
    07B32 C02C      RJMP	0x7B5F
    07B33 9180 17D6 LDS	R24,primeProcessSW
    07B35 3083      CPI	R24,3
    07B36 F541      BNE	0x7B5F
    07B37 2700      CLR	R16
    07B38 2711      CLR	R17
(1018) 								break;
    07B39 940E 56BD CALL	_DiluteStartCheck
(1019) 							case 4062:		// 电机运行
(1020) 								cmdState =  MotRun((unsigned char)ControlCmd.pam[0], ControlCmd.pam[1]);
    07B3B 2EE0      MOV	R14,R16
    07B3C 2D4E      MOV	R20,R14
    07B3D 3001      CPI	R16,1
    07B3E F501      BNE	0x7B5F
    07B3F 2422      CLR	R2
    07B40 9220 17D6 STS	primeProcessSW,R2
    07B42 9180 0533 LDS	R24,JumpMode
    07B44 3082      CPI	R24,2
    07B45 F421      BNE	0x7B4A
    07B46 E083      LDI	R24,3
(1021) 								break;
    07B47 9380 0533 STS	JumpMode,R24
(1022) 							case 4063:		// 电机运行到
(1023) 								cmdState =  MotRunTo((unsigned char)ControlCmd.pam[0], ControlCmd.pam[1]);
    07B49 C003      RJMP	0x7B4D
    07B4A 2422      CLR	R2
    07B4B 9220 0533 STS	JumpMode,R2
    07B4D 9180 00C1 LDS	R24,0xC1
    07B4F 7E8F      ANDI	R24,0xEF
    07B50 9380 00C1 STS	0xC1,R24
    07B52 E026      LDI	R18,6
    07B53 E03B      LDI	R19,0xB
    07B54 E306      LDI	R16,0x36
(1024) 								break;
    07B55 E017      LDI	R17,7
(1025) 							case 4064:		// 电机运行指定位置
(1026) 								cmdState =  MotRunToSite((unsigned char)ControlCmd.pam[0], (unsigned char)ControlCmd.pam[1]);
    07B56 940E A90D CALL	_uart_Printf
    07B58 9180 00C1 LDS	R24,0xC1
    07B5A 6180      ORI	R24,0x10
    07B5B 9380 00C1 STS	0xC1,R24
    07B5D 940E 3907 CALL	_SetStateLedFree
    07B5F 9020 17CE LDS	R2,_DiluentCalChart+45
    07B61 2022      TST	R2
    07B62 F441      BNE	0x7B6B
(1027) 								break;
    07B63 2700      CLR	R16
(1028) 							case 4065:		// 设置运行时参数
(1029) 								cmdState =  SetMotRunPam((unsigned char)ControlCmd.pam[0], (unsigned char)ControlCmd.pam[1], (unsigned char)ControlCmd.pam[2],(unsigned char)ControlCmd.pam[3]);
    07B64 2711      CLR	R17
    07B65 940E 1A76 CALL	_GetNewPieceFromStoreProcess
    07B67 2EE0      MOV	R14,R16
    07B68 92E0 17CD STS	_DiluentCalChart+44,R14
    07B6A C01A      RJMP	0x7B85
    07B6B 940E 2968 CALL	_CardScanfPosCheck
    07B6D 01B8      MOVW	R22,R16
    07B6E 3001      CPI	R16,1
    07B6F E0E0      LDI	R30,0
    07B70 071E      CPC	R17,R30
    07B71 F499      BNE	0x7B85
    07B72 2422      CLR	R2
    07B73 9220 17CE STS	_DiluentCalChart+45,R2
    07B75 9180 00C1 LDS	R24,0xC1
    07B77 7E8F      ANDI	R24,0xEF
    07B78 9380 00C1 STS	0xC1,R24
    07B7A EA26      LDI	R18,0xA6
(1030) 								break;
    07B7B E03E      LDI	R19,0xE
(1031) 							case 4066:		// 设置基本参数
(1032) 								cmdState =  MotSetPam((unsigned char)ControlCmd.pam[0], (unsigned char)ControlCmd.pam[1], (unsigned char)ControlCmd.pam[2]);
    07B7C E20D      LDI	R16,0x2D
    07B7D E017      LDI	R17,7
    07B7E 940E A90D CALL	_uart_Printf
    07B80 9180 00C1 LDS	R24,0xC1
    07B82 6180      ORI	R24,0x10
    07B83 9380 00C1 STS	0xC1,R24
    07B85 940E A1FF CALL	_TestAQueueProcess
    07B87 940E A4A4 CALL	_TestBQueueProcess
    07B89 940E AAA1 CALL	_UnloadQueueProcess
    07B8B 0178      MOVW	R14,R16
    07B8C 9020 17CB LDS	R2,_DiluentCalChart+42
(1033) 								break;
    07B8E 2433      CLR	R3
(1034) 							case 4067:	// 设置从机地址
(1035) 								cmdState =  SlaveSetAddress((unsigned char)ControlCmd.pam[0]);
    07B8F 0E20      ADD	R2,R16
    07B90 1E31      ADC	R3,R17
    07B91 9220 17CB STS	_DiluentCalChart+42,R2
    07B93 E082      LDI	R24,2
    07B94 1582      CP	R24,R2
    07B95 F008      BCS	0x7B97
    07B96 C520      RJMP	0x80B7
    07B97 2700      CLR	R16
(1036) 								break;
    07B98 D56F      RCALL	_SetWorkStep
(1037) 							/****************************** 液路控制 ******************************/	
(1038) 							case 4068:	// 设置电磁阀
(1039) 								cmdState =  SetEValve((unsigned char)ControlCmd.pam[0], (unsigned char)ControlCmd.pam[1]);
    07B99 C51D      RJMP	0x80B7
    07B9A 9180 1566 LDS	R24,ControlCmd
    07B9C 3082      CPI	R24,2
    07B9D F009      BEQ	0x7B9F
    07B9E C4E3      RJMP	0x8082
    07B9F 2422      CLR	R2
    07BA0 9220 17CA STS	_DiluentCalChart+41,R2
    07BA2 9180 00C1 LDS	R24,0xC1
    07BA4 7E8F      ANDI	R24,0xEF
    07BA5 9380 00C1 STS	0xC1,R24
(1040) 								break;
    07BA7 9120 1567 LDS	R18,ControlCmd+1
    07BA9 9130 1568 LDS	R19,ControlCmd+2
    07BAB EC00      LDI	R16,0xC0
(1041) 							case 4069:	// Get photo info
(1042) 								cmdState =  GetLiquidPhotoInfo();
(1043) 								break;
    07BAC E018      LDI	R17,0x8
(1044) 							case 4070:	// Liquid photo adjust
(1045) 								cmdState =  SetLiquidPhotoAdjust((unsigned char)ControlCmd.pam[0]);
    07BAD 940E A90D CALL	_uart_Printf
    07BAF 9180 00C1 LDS	R24,0xC1
    07BB1 6180      ORI	R24,0x10
    07BB2 9380 00C1 STS	0xC1,R24
    07BB4 9020 17D4 LDS	R2,miantianSubFunction
(1046) 								break;
    07BB6 9030 17D5 LDS	R3,miantianSubFunction+1
(1047) 								/**************************** 片仓控制 *********************************/	
(1048) 							case 4071:	// 获取片仓状态信息
(1049) 								cmdState =  GetStoreState((unsigned char)ControlCmd.pam[0]);
    07BB8 2022      TST	R2
    07BB9 F009      BEQ	0x7BBB
    07BBA C41A      RJMP	0x7FD5
    07BBB 2033      TST	R3
    07BBC F009      BEQ	0x7BBE
    07BBD C417      RJMP	0x7FD5
    07BBE 9160 1567 LDS	R22,ControlCmd+1
(1050) 								break;
    07BC0 9170 1568 LDS	R23,ControlCmd+2
(1051) 							case 4072:	// 设置片仓校准
(1052) 								cmdState =  SetStoreCAL((unsigned char)ControlCmd.pam[0]);
    07BC2 3663      CPI	R22,0x63
    07BC3 E0E0      LDI	R30,0
    07BC4 077E      CPC	R23,R30
    07BC5 F409      BNE	0x7BC7
    07BC6 C0D8      RJMP	0x7C9F
    07BC7 E683      LDI	R24,0x63
    07BC8 E090      LDI	R25,0
    07BC9 1786      CP	R24,R22
(1053) 								break;
    07BCA 0797      CPC	R25,R23
(1054) 							case 4073:	// 获取片仓光电接收管信号值
(1055) 								cmdState =  GetStorePhoVol((unsigned char)ControlCmd.pam[0]);
    07BCB F11C      BLT	0x7BEF
    07BCC 9160 1567 LDS	R22,ControlCmd+1
    07BCE 9170 1568 LDS	R23,ControlCmd+2
    07BD0 3061      CPI	R22,1
    07BD1 E0E0      LDI	R30,0
    07BD2 077E      CPC	R23,R30
    07BD3 F409      BNE	0x7BD5
(1056) 								break;
    07BD4 C036      RJMP	0x7C0B
(1057) 							case 4074:	// 获取液体探测信号值
(1058) 								iPam = getLiqDetADC(NeedleChannel);
    07BD5 3063      CPI	R22,3
    07BD6 E0E0      LDI	R30,0
    07BD7 077E      CPC	R23,R30
    07BD8 F409      BNE	0x7BDA
(1059) 								Uart0ReUnable;
    07BD9 C046      RJMP	0x7C20
    07BDA 3064      CPI	R22,4
    07BDB E0E0      LDI	R30,0
    07BDC 077E      CPC	R23,R30
    07BDD F409      BNE	0x7BDF
(1060) 								uart_Printf("%s $%4d\r\n",strM4174, iPam);
    07BDE C052      RJMP	0x7C31
    07BDF 3065      CPI	R22,5
    07BE0 E0E0      LDI	R30,0
    07BE1 077E      CPC	R23,R30
    07BE2 F409      BNE	0x7BE4
    07BE3 C050      RJMP	0x7C34
    07BE4 306A      CPI	R22,0xA
    07BE5 E0E0      LDI	R30,0
(1061) 								Uart0ReEnable;
    07BE6 077E      CPC	R23,R30
    07BE7 F409      BNE	0x7BE9
    07BE8 C07B      RJMP	0x7C64
    07BE9 306B      CPI	R22,0xB
    07BEA E0E0      LDI	R30,0
(1062) 								break;
    07BEB 077E      CPC	R23,R30
(1063) 							case 4075:
(1064) 								iPam = getLiqDetADC(LoadChannel);
    07BEC F409      BNE	0x7BEE
    07BED C092      RJMP	0x7C80
    07BEE C3D1      RJMP	0x7FC0
    07BEF 9160 1567 LDS	R22,ControlCmd+1
(1065) 								Uart0ReUnable;
    07BF1 9170 1568 LDS	R23,ControlCmd+2
    07BF3 3A62      CPI	R22,0xA2
    07BF4 E0EF      LDI	R30,0xF
    07BF5 077E      CPC	R23,R30
(1066) 								uart_Printf("%s $%4d\r\n",strM4175, iPam);
    07BF6 F40C      BGE	0x7BF8
    07BF7 C3C8      RJMP	0x7FC0
    07BF8 E083      LDI	R24,3
    07BF9 E190      LDI	R25,0x10
    07BFA 1786      CP	R24,R22
    07BFB 0797      CPC	R25,R23
    07BFC F40C      BGE	0x7BFE
    07BFD C3C2      RJMP	0x7FC0
(1067) 								Uart0ReEnable;
    07BFE EF88      LDI	R24,0xF8
    07BFF E093      LDI	R25,3
    07C00 01FB      MOVW	R30,R22
    07C01 5AE2      SUBI	R30,0xA2
    07C02 40FF      SBCI	R31,0xF
(1068) 								break;
    07C03 0FEE      LSL	R30
(1069) 							case 4076:
(1070) 								iPam = getLiqDetADC(UnloadChannel);
    07C04 1FFF      ROL	R31
    07C05 0FE8      ADD	R30,R24
    07C06 1FF9      ADC	R31,R25
    07C07 9027      ELPM	R2,Z+
    07C08 9036      ELPM	R3,Z
(1071) 								Uart0ReUnable;
    07C09 01F1      MOVW	R30,R2
    07C0A 9409      IJMP
    07C0B 9180 00C1 LDS	R24,0xC1
    07C0D 7E8F      ANDI	R24,0xEF
(1072) 								uart_Printf("%s $%4d\r\n",strM4176, iPam);
    07C0E 9380 00C1 STS	0xC1,R24
    07C10 E18E      LDI	R24,0x1E
    07C11 E095      LDI	R25,5
    07C12 8399      STD	Y+1,R25
    07C13 8388      ST	Y,R24
    07C14 E32A      LDI	R18,0x3A
    07C15 E035      LDI	R19,5
(1073) 								Uart0ReEnable;
    07C16 E109      LDI	R16,0x19
    07C17 E017      LDI	R17,7
    07C18 940E A90D CALL	_uart_Printf
    07C1A 9180 00C1 LDS	R24,0xC1
(1074) 								break;
    07C1C 6180      ORI	R24,0x10
    07C1D 9380 00C1 STS	0xC1,R24
    07C1F C433      RJMP	0x8053
    07C20 9180 00C1 LDS	R24,0xC1
    07C22 7E8F      ANDI	R24,0xEF
    07C23 9380 00C1 STS	0xC1,R24
(1075) 							case 4077:
(1076) 								if(ControlCmd.pam[0] > 12)
(1077) 									ControlCmd.pam[0] = 12;
    07C25 EA2F      LDI	R18,0xAF
    07C26 E035      LDI	R19,5
    07C27 E003      LDI	R16,3
    07C28 E017      LDI	R17,7
    07C29 940E A90D CALL	_uart_Printf
(1078) 								else if(ControlCmd.pam[0] < 1)
    07C2B 9180 00C1 LDS	R24,0xC1
    07C2D 6180      ORI	R24,0x10
    07C2E 9380 00C1 STS	0xC1,R24
    07C30 C422      RJMP	0x8053
    07C31 2700      CLR	R16
(1079) 									ControlCmd.pam[0] = 1;
    07C32 D4D5      RCALL	_SetWorkStep
    07C33 C41F      RJMP	0x8053
    07C34 9020 1569 LDS	R2,ControlCmd+3
    07C36 9030 156A LDS	R3,ControlCmd+4
(1080) 								MotStop(ControlCmd.pam[0]);
    07C38 2022      TST	R2
    07C39 F4B1      BNE	0x7C50
    07C3A 2033      TST	R3
    07C3B F4A1      BNE	0x7C50
    07C3C E081      LDI	R24,1
    07C3D 9380 06F7 STS	workSwitch,R24
(1081) 								break;
    07C3F 9180 00C1 LDS	R24,0xC1
(1082) 							default:
(1083) 								SetBeepWarning();
(1084) 								Uart0ReUnable;
    07C41 7E8F      ANDI	R24,0xEF
    07C42 9380 00C1 STS	0xC1,R24
    07C44 E923      LDI	R18,0x93
    07C45 E035      LDI	R19,5
(1085) 								uart_Printf("#%d CommandUnknown $   2\r\n",ControlCmd.cmdIdx);
    07C46 EE05      LDI	R16,0xE5
    07C47 E018      LDI	R17,0x8
    07C48 940E A90D CALL	_uart_Printf
    07C4A 9180 00C1 LDS	R24,0xC1
    07C4C 6180      ORI	R24,0x10
    07C4D 9380 00C1 STS	0xC1,R24
(1086) 								Uart0ReEnable;
    07C4F C403      RJMP	0x8053
    07C50 2422      CLR	R2
    07C51 9220 06F7 STS	workSwitch,R2
(1087) 								break;	
(1088) 							}
(1089) 						}
    07C53 9180 00C1 LDS	R24,0xC1
(1090) 					else	// 工作状态下接收命令
(1091) 					{
(1092) 						switch(ControlCmd.cmdIdx)
    07C55 7E8F      ANDI	R24,0xEF
    07C56 9380 00C1 STS	0xC1,R24
    07C58 EA21      LDI	R18,0xA1
    07C59 E035      LDI	R19,5
    07C5A EE05      LDI	R16,0xE5
    07C5B E018      LDI	R17,0x8
    07C5C 940E A90D CALL	_uart_Printf
    07C5E 9180 00C1 LDS	R24,0xC1
    07C60 6180      ORI	R24,0x10
    07C61 9380 00C1 STS	0xC1,R24
    07C63 C3EF      RJMP	0x8053
    07C64 9020 02E0 LDS	R2,CardStoreOpenLook
    07C66 2022      TST	R2
    07C67 F439      BNE	0x7C6F
    07C68 9100 1569 LDS	R16,ControlCmd+3
    07C6A 9110 156A LDS	R17,ControlCmd+4
    07C6C 940E 6C66 CALL	_SetStoreDoorOpen
    07C6E C005      RJMP	0x7C74
    07C6F 9180 00C1 LDS	R24,0xC1
    07C71 7E8F      ANDI	R24,0xEF
    07C72 9380 00C1 STS	0xC1,R24
(1093) 						{
(1094) 							case 3:		// #0003 查询工作进程
(1095) 								Uart0ReUnable;
    07C74 ED25      LDI	R18,0xD5
    07C75 E035      LDI	R19,5
    07C76 EE05      LDI	R16,0xE5
    07C77 E018      LDI	R17,0x8
(1096) 								uart_Printf("%s $   4 [Maintain]\r\n",strM0110);
    07C78 940E A90D CALL	_uart_Printf
    07C7A 9180 00C1 LDS	R24,0xC1
    07C7C 6180      ORI	R24,0x10
    07C7D 9380 00C1 STS	0xC1,R24
(1097) 								Uart0ReEnable;
    07C7F C3D3      RJMP	0x8053
    07C80 9180 00C1 LDS	R24,0xC1
    07C82 7E8F      ANDI	R24,0xEF
(1098) 								break;
    07C83 9380 00C1 STS	0xC1,R24
(1099) 							case 4:	// quit
(1100) 								SetMaintianSubfunctionQuitFlag();
    07C85 940E 2D8C CALL	_GetStoreHumi
(1101) 								break;
    07C87 2EE0      MOV	R14,R16
    07C88 940E 2D8F CALL	_GetStoreTemp
    07C8A 2F60      MOV	R22,R16
    07C8B 2E26      MOV	R2,R22
    07C8C 2433      CLR	R3
    07C8D 823B      STD	Y+3,R3
    07C8E 822A      STD	Y+2,R2
(1102) 							case 5:
(1103) 								if(ControlCmd.pam[0] == 0)
(1104) 								{
(1105) 									workSwitch = 1;
    07C8F 2C2E      MOV	R2,R14
    07C90 2433      CLR	R3
    07C91 8239      STD	Y+1,R3
(1106) 									Uart0ReUnable;
    07C92 8228      ST	Y,R2
    07C93 EC21      LDI	R18,0xC1
    07C94 E035      LDI	R19,5
    07C95 E30C      LDI	R16,0x3C
    07C96 E018      LDI	R17,0x8
(1107) 									uart_Printf("%s\r\n",strM0105);
    07C97 940E A90D CALL	_uart_Printf
    07C99 9180 00C1 LDS	R24,0xC1
    07C9B 6180      ORI	R24,0x10
    07C9C 9380 00C1 STS	0xC1,R24
(1108) 									Uart0ReEnable;
    07C9E C3B4      RJMP	0x8053
    07C9F 9100 1569 LDS	R16,ControlCmd+3
    07CA1 9110 156A LDS	R17,ControlCmd+4
(1109) 								}
    07CA3 940E 71B2 CALL	_ReStart
    07CA5 C3AD      RJMP	0x8053
(1110) 								else
(1111) 								{
(1112) 									workSwitch = 0;
(1113) 									Uart0ReUnable;
    07CA6 9100 1569 LDS	R16,ControlCmd+3
    07CA8 9110 156A LDS	R17,ControlCmd+4
    07CAA 940E 8256 CALL	_SetNeedleOnMixPosFactor
(1114) 									uart_Printf("%s\r\n",strM0106);
    07CAC C3A6      RJMP	0x8053
    07CAD 9100 1569 LDS	R16,ControlCmd+3
    07CAF 9110 156A LDS	R17,ControlCmd+4
(1115) 									Uart0ReEnable;
    07CB1 940E 8325 CALL	_SetDropHeightFactor
    07CB3 C39F      RJMP	0x8053
    07CB4 EE8E      LDI	R24,0xEE
    07CB5 E094      LDI	R25,4
(1116) 								}
(1117) 								break;
    07CB6 9390 17D5 STS	miantianSubFunction+1,R25
(1118) 							case 99:	// 重起, 设置看门狗
(1119) 								ReStart(ControlCmd.pam[0]);
    07CB8 9380 17D4 STS	miantianSubFunction,R24
    07CBA C398      RJMP	0x8053
    07CBB EE8C      LDI	R24,0xEC
    07CBC E094      LDI	R25,4
(1120) 								break;
    07CBD 9390 17D5 STS	miantianSubFunction+1,R25
(1121) 							default:
(1122) 								SetBeepWarning();
    07CBF 9380 17D4 STS	miantianSubFunction,R24
(1123) 								Uart0ReUnable;
    07CC1 C391      RJMP	0x8053
    07CC2 EE8A      LDI	R24,0xEA
    07CC3 E094      LDI	R25,4
    07CC4 9390 17D5 STS	miantianSubFunction+1,R25
(1124) 								uart_Printf("#%d CommandUnknown $   2\r\n",ControlCmd.cmdIdx);
    07CC6 9380 17D4 STS	miantianSubFunction,R24
    07CC8 C38A      RJMP	0x8053
    07CC9 EE88      LDI	R24,0xE8
    07CCA E094      LDI	R25,4
    07CCB 9390 17D5 STS	miantianSubFunction+1,R25
(1125) 								Uart0ReEnable;
    07CCD 9380 17D4 STS	miantianSubFunction,R24
    07CCF C383      RJMP	0x8053
    07CD0 9100 1569 LDS	R16,ControlCmd+3
(1126) 								break;	
(1127) 						}
(1128) 					}
(1129) 					if(cmdState)
    07CD2 9110 156A LDS	R17,ControlCmd+4
    07CD4 940E 856D CALL	_SetLiquidPhotoAdjustNum
(1130) 					{
(1131) 						SetBeepWarning();
    07CD6 EE86      LDI	R24,0xE6
    07CD7 E094      LDI	R25,4
(1132) 						Uart0ReUnable;
    07CD8 9390 17D5 STS	miantianSubFunction+1,R25
    07CDA 9380 17D4 STS	miantianSubFunction,R24
    07CDC C376      RJMP	0x8053
(1133) 						uart_Printf("#%4d CommandError $   1\r\n",ControlCmd.cmdIdx);
    07CDD 9100 1569 LDS	R16,ControlCmd+3
    07CDF 9110 156A LDS	R17,ControlCmd+4
    07CE1 940E 85EB CALL	_SetCardStorePhotoAdjustNum
    07CE3 EE84      LDI	R24,0xE4
    07CE4 E094      LDI	R25,4
(1134) 						Uart0ReEnable;
    07CE5 9390 17D5 STS	miantianSubFunction+1,R25
    07CE7 9380 17D4 STS	miantianSubFunction,R24
    07CE9 C369      RJMP	0x8053
(1135) 					}
    07CEA 9020 1569 LDS	R2,ControlCmd+3
(1136) 					else
(1137) 					{
(1138) 						SetBeepAck();
    07CEC 9030 156A LDS	R3,ControlCmd+4
(1139) 						Uart0ReUnable;
    07CEE 2022      TST	R2
    07CEF F4A9      BNE	0x7D05
    07CF0 2033      TST	R3
    07CF1 F499      BNE	0x7D05
(1140) 						uart_Printf("#%4d CommandDone $   3\r\n",ControlCmd.cmdIdx);
    07CF2 9120 156B LDS	R18,ControlCmd+5
    07CF4 9130 156C LDS	R19,ControlCmd+6
    07CF6 2700      CLR	R16
    07CF7 940E 9FBC CALL	_AdjustTestLamp
    07CF9 0178      MOVW	R14,R16
(1141) 						Uart0ReEnable;
    07CFA 0157      MOVW	R10,R14
    07CFB 9120 156D LDS	R18,ControlCmd+7
    07CFD 9130 156E LDS	R19,ControlCmd+8
(1142) 					}
(1143) 				//	if(ControlCmd.cmdIdx)
(1144) 						CommandClear();
    07CFF E001      LDI	R16,1
    07D00 940E 9FBC CALL	_AdjustTestLamp
(1145) 				}
(1146) 				if(workSwitch)
    07D02 0178      MOVW	R14,R16
    07D03 0167      MOVW	R12,R14
    07D04 C012      RJMP	0x7D17
(1147) 				{
(1148) 					if(miantianSubFunction)	// 调用子功能函数，直到函数返回1终止
    07D05 9120 156B LDS	R18,ControlCmd+5
    07D07 9130 156C LDS	R19,ControlCmd+6
    07D09 E002      LDI	R16,2
    07D0A 940E 9FBC CALL	_AdjustTestLamp
    07D0C 0178      MOVW	R14,R16
(1149) 					{
(1150) 						if(ControlCmd.pamLen != 0)
    07D0D 0157      MOVW	R10,R14
    07D0E 9120 156D LDS	R18,ControlCmd+7
    07D10 9130 156E LDS	R19,ControlCmd+8
(1151) 						{
(1152) 							MaintainSubFunParam = ControlCmd.pam[0];
    07D12 E003      LDI	R16,3
    07D13 940E 9FBC CALL	_AdjustTestLamp
    07D15 0178      MOVW	R14,R16
    07D16 0167      MOVW	R12,R14
    07D17 9180 00C1 LDS	R24,0xC1
(1153) 							ControlCmd.pam[0] = 0;
    07D19 7E8F      ANDI	R24,0xEF
    07D1A 9380 00C1 STS	0xC1,R24
    07D1C 82DB      STD	Y+3,R13
    07D1D 82CA      STD	Y+2,R12
    07D1E 82B9      STD	Y+1,R11
(1154) 						}
    07D1F 82A8      ST	Y,R10
(1155) 						else
(1156) 							MaintainSubFunParam = 0;
    07D20 E42F      LDI	R18,0x4F
    07D21 E137      LDI	R19,0x17
    07D22 E30C      LDI	R16,0x3C
    07D23 E018      LDI	R17,0x8
    07D24 940E A90D CALL	_uart_Printf
(1157) 						i = miantianSubFunction();
    07D26 9180 00C1 LDS	R24,0xC1
    07D28 6180      ORI	R24,0x10
    07D29 9380 00C1 STS	0xC1,R24
    07D2B C327      RJMP	0x8053
    07D2C 9020 1569 LDS	R2,ControlCmd+3
(1158) 						if(i==1)
    07D2E 9030 156A LDS	R3,ControlCmd+4
(1159) 						{
(1160) 							miantianSubFunction = 0;
    07D30 2022      TST	R2
    07D31 F469      BNE	0x7D3F
    07D32 2033      TST	R3
    07D33 F459      BNE	0x7D3F
    07D34 2700      CLR	R16
    07D35 940E 9FA0 CALL	_ReadTestLampPWM
(1161) 						}
(1162) 					}
(1163) 				}
(1164) 				break;
(1165) 			default:
(1166) 				break;
(1167) 		}
(1168) 		
(1169) 		// 废片仓功能开启
(1170) 		if(GetwasteCardState() == 0)
    07D37 0178      MOVW	R14,R16
    07D38 0157      MOVW	R10,R14
    07D39 E001      LDI	R16,1
    07D3A 940E 9FA0 CALL	_ReadTestLampPWM
(1171) 		{
(1172) 			// 废片仓开关监测
(1173) 			if((PINK & 0x02) == 0)
    07D3C 0178      MOVW	R14,R16
    07D3D 0167      MOVW	R12,R14
    07D3E C00A      RJMP	0x7D49
    07D3F E002      LDI	R16,2
(1174) 			{
(1175) 				if(dustbinOldState > 0)
    07D40 940E 9FA0 CALL	_ReadTestLampPWM
    07D42 0178      MOVW	R14,R16
    07D43 0157      MOVW	R10,R14
    07D44 E003      LDI	R16,3
(1176) 					dustbinOldState --;
    07D45 940E 9FA0 CALL	_ReadTestLampPWM
    07D47 0178      MOVW	R14,R16
    07D48 0167      MOVW	R12,R14
(1177) 				if(dustbinOldState == 2)
    07D49 9180 00C1 LDS	R24,0xC1
    07D4B 7E8F      ANDI	R24,0xEF
    07D4C 9380 00C1 STS	0xC1,R24
(1178) 				{
(1179) 					Uart0ReUnable;
    07D4E 82DB      STD	Y+3,R13
    07D4F 82CA      STD	Y+2,R12
    07D50 82B9      STD	Y+1,R11
    07D51 82A8      ST	Y,R10
(1180) 					uart_Printf("%s $%4d\r\n",strM0200 , dustbinOldState);
    07D52 E42F      LDI	R18,0x4F
    07D53 E137      LDI	R19,0x17
    07D54 E30C      LDI	R16,0x3C
    07D55 E018      LDI	R17,0x8
    07D56 940E A90D CALL	_uart_Printf
    07D58 9180 00C1 LDS	R24,0xC1
    07D5A 6180      ORI	R24,0x10
    07D5B 9380 00C1 STS	0xC1,R24
(1181) 					Uart0ReEnable;
    07D5D C2F5      RJMP	0x8053
    07D5E 9020 1569 LDS	R2,ControlCmd+3
    07D60 9030 156A LDS	R3,ControlCmd+4
(1182) 				}
(1183) 			}
    07D62 2022      TST	R2
(1184) 			else		// 废片仓关闭
(1185) 			{
(1186) 				if(dustbinOldState < 255)
    07D63 F429      BNE	0x7D69
    07D64 2033      TST	R3
    07D65 F419      BNE	0x7D69
    07D66 940E 9F08 CALL	_TestALampOpen
(1187) 					dustbinOldState ++;
    07D68 C2EA      RJMP	0x8053
    07D69 940E 9F29 CALL	_TestBLampOpen
(1188) 				if(dustbinOldState == 253)
    07D6B C2E7      RJMP	0x8053
    07D6C 9020 1569 LDS	R2,ControlCmd+3
(1189) 				{
(1190) 					Uart0ReUnable;
    07D6E 9030 156A LDS	R3,ControlCmd+4
    07D70 2022      TST	R2
    07D71 F429      BNE	0x7D77
    07D72 2033      TST	R3
(1191) 					uart_Printf("%s $%4d\r\n",strM0200 , dustbinOldState);
    07D73 F419      BNE	0x7D77
    07D74 940E 9F1B CALL	_TestALampClose
    07D76 C2DC      RJMP	0x8053
    07D77 940E 9F3C CALL	_TestBLampClose
    07D79 C2D9      RJMP	0x8053
    07D7A 9120 156B LDS	R18,ControlCmd+5
    07D7C 9130 156C LDS	R19,ControlCmd+6
(1192) 					Uart0ReEnable;
    07D7E 9100 1569 LDS	R16,ControlCmd+3
    07D80 9110 156A LDS	R17,ControlCmd+4
    07D82 940E 5686 CALL	_CalculateCalStandCoeff
    07D84 0178      MOVW	R14,R16
    07D85 0157      MOVW	R10,R14
    07D86 9100 1569 LDS	R16,ControlCmd+3
    07D88 9110 156A LDS	R17,ControlCmd+4
(1193) 				}
(1194) 			}
(1195) 		}
(1196) 	}
(1197) }
(1198) 
(1199) void SetWorkStep(unsigned char n)
(1200) {
(1201) 	if(n > 4 && n != 9)
    07D8A 940E 7066 CALL	_Save_DiluentCalChart
    07D8C 0178      MOVW	R14,R16
    07D8D 0167      MOVW	R12,R14
    07D8E 9020 1569 LDS	R2,ControlCmd+3
(1202) 		n = 0;
    07D90 9030 156A LDS	R3,ControlCmd+4
    07D92 2022      TST	R2
    07D93 F449      BNE	0x7D9D
    07D94 2033      TST	R3
(1203) 	if(n != WorkProcessStep)
(1204) 	{
(1205) 		WorkProcessStep = n;
    07D95 F439      BNE	0x7D9D
    07D96 E089      LDI	R24,0x9
(1206) 		switch(WorkProcessStep)
    07D97 E090      LDI	R25,0
    07D98 9390 156A STS	ControlCmd+4,R25
    07D9A 9380 1569 STS	ControlCmd+3,R24
    07D9C C00D      RJMP	0x7DAA
    07D9D E08D      LDI	R24,0xD
    07D9E E090      LDI	R25,0
    07D9F 9020 1569 LDS	R2,ControlCmd+3
    07DA1 9030 156A LDS	R3,ControlCmd+4
    07DA3 1582      CP	R24,R2
    07DA4 0593      CPC	R25,R3
    07DA5 F420      BCC	0x7DAA
    07DA6 9390 156A STS	ControlCmd+4,R25
    07DA8 9380 1569 STS	ControlCmd+3,R24
    07DAA 9180 00C1 LDS	R24,0xC1
    07DAC 7E8F      ANDI	R24,0xEF
    07DAD 9380 00C1 STS	0xC1,R24
    07DAF 82DD      STD	Y+5,R13
    07DB0 82CC      STD	Y+4,R12
    07DB1 82BB      STD	Y+3,R11
    07DB2 82AA      STD	Y+2,R10
(1207) 		{
(1208) 			case 0:	Uart0ReUnable;uart_Printf("%s $   0 [Free]\r\n",strM0110);Uart0ReEnable;
    07DB3 9020 1569 LDS	R2,ControlCmd+3
    07DB5 9030 156A LDS	R3,ControlCmd+4
    07DB7 8239      STD	Y+1,R3
    07DB8 8228      ST	Y,R2
    07DB9 E825      LDI	R18,0x85
    07DBA E137      LDI	R19,0x17
    07DBB E60F      LDI	R16,0x6F
    07DBC E017      LDI	R17,7
    07DBD 940E A90D CALL	_uart_Printf
    07DBF 9180 00C1 LDS	R24,0xC1
    07DC1 6180      ORI	R24,0x10
    07DC2 9380 00C1 STS	0xC1,R24
(1209) 				break;
    07DC4 C28E      RJMP	0x8053
    07DC5 EE82      LDI	R24,0xE2
    07DC6 E094      LDI	R25,4
    07DC7 9390 17D5 STS	miantianSubFunction+1,R25
(1210) 			case 1:	Uart0ReUnable;uart_Printf("%s $   1 [MechineCheck]\r\n",strM0110);Uart0ReEnable;
    07DC9 9380 17D4 STS	miantianSubFunction,R24
    07DCB E208      LDI	R16,0x28
    07DCC 940E 914B CALL	_SetDiluentQuantifyVolume
    07DCE C284      RJMP	0x8053
    07DCF 9100 1569 LDS	R16,ControlCmd+3
    07DD1 9110 156A LDS	R17,ControlCmd+4
    07DD3 2711      CLR	R17
(1211) 				break;
    07DD4 FD07      SBRC	R16,7
(1212) 			case 2:	Uart0ReUnable;uart_Printf("%s $   2 [LiquidCheck]\r\n",strM0110);Uart0ReEnable;
    07DD5 9510      COM	R17
    07DD6 940E 83E9 CALL	_SetMixHeight
    07DD8 0158      MOVW	R10,R16
    07DD9 9180 00C1 LDS	R24,0xC1
    07DDB 7E8F      ANDI	R24,0xEF
    07DDC 9380 00C1 STS	0xC1,R24
    07DDE 2C2A      MOV	R2,R10
    07DDF 2433      CLR	R3
    07DE0 FC27      SBRC	R2,7
    07DE1 9430      COM	R3
    07DE2 8239      STD	Y+1,R3
    07DE3 8228      ST	Y,R2
    07DE4 E927      LDI	R18,0x97
(1213) 				break;
    07DE5 E137      LDI	R19,0x17
(1214) 			case 3:	GetStoreState(0);	Uart0ReUnable;uart_Printf("%s $   3 [Test]\r\n",strM0110);Uart0ReEnable;
    07DE6 E803      LDI	R16,0x83
    07DE7 E017      LDI	R17,7
    07DE8 940E A90D CALL	_uart_Printf
    07DEA 9180 00C1 LDS	R24,0xC1
    07DEC 6180      ORI	R24,0x10
    07DED 9380 00C1 STS	0xC1,R24
    07DEF C263      RJMP	0x8053
    07DF0 EE80      LDI	R24,0xE0
    07DF1 E094      LDI	R25,4
    07DF2 9390 17D5 STS	miantianSubFunction+1,R25
    07DF4 9380 17D4 STS	miantianSubFunction,R24
    07DF6 C25C      RJMP	0x8053
    07DF7 ED8E      LDI	R24,0xDE
    07DF8 E094      LDI	R25,4
(1215) 				break;
    07DF9 9390 17D5 STS	miantianSubFunction+1,R25
(1216) 			case 4:	Uart0ReUnable;uart_Printf("%s $   4 [Maintain]\r\n",strM0110);Uart0ReEnable;
    07DFB 9380 17D4 STS	miantianSubFunction,R24
    07DFD C255      RJMP	0x8053
    07DFE ED8C      LDI	R24,0xDC
    07DFF E094      LDI	R25,4
    07E00 9390 17D5 STS	miantianSubFunction+1,R25
    07E02 9380 17D4 STS	miantianSubFunction,R24
    07E04 C24E      RJMP	0x8053
    07E05 ED8A      LDI	R24,0xDA
    07E06 E094      LDI	R25,4
    07E07 9390 17D5 STS	miantianSubFunction+1,R25
    07E09 9380 17D4 STS	miantianSubFunction,R24
(1217) 				break;
    07E0B C247      RJMP	0x8053
    07E0C ED88      LDI	R24,0xD8
    07E0D E094      LDI	R25,4
(1218) 			case 9:	JumpMode = 1;GetStoreState(0);	WorkProcessStep = 3; Uart0ReUnable;uart_Printf("%s $   3 [Test]\r\n",strM0110);Uart0ReEnable;
    07E0E 9390 17D5 STS	miantianSubFunction+1,R25
    07E10 9380 17D4 STS	miantianSubFunction,R24
    07E12 C240      RJMP	0x8053
    07E13 ED86      LDI	R24,0xD6
    07E14 E094      LDI	R25,4
    07E15 9390 17D5 STS	miantianSubFunction+1,R25
    07E17 9380 17D4 STS	miantianSubFunction,R24
    07E19 C239      RJMP	0x8053
    07E1A ED84      LDI	R24,0xD4
    07E1B E094      LDI	R25,4
    07E1C 9390 17D5 STS	miantianSubFunction+1,R25
    07E1E 9380 17D4 STS	miantianSubFunction,R24
    07E20 C232      RJMP	0x8053
    07E21 ED82      LDI	R24,0xD2
    07E22 E094      LDI	R25,4
    07E23 9390 17D5 STS	miantianSubFunction+1,R25
(1219) 				break;
(1220) 		}
(1221) 	}
    07E25 9380 17D4 STS	miantianSubFunction,R24
_StartWork:
    07E27 C22B      RJMP	0x8053
(1222) }
(1223) 
(1224) 
(1225) /*************************************************************************************************/
(1226) 
(1227) /*************************************************************************************************/
(1228) void StartWork(void)
(1229) {
(1230) 	CLI();
    07E28 ED80      LDI	R24,0xD0
(1231) 
(1232) 	// 初始化应用层数据
(1233) 	DiluteProcDatInit();
    07E29 E094      LDI	R25,4
    07E2A 9390 17D5 STS	miantianSubFunction+1,R25
(1234) 	RingQueueDatInit();
    07E2C 9380 17D4 STS	miantianSubFunction,R24
(1235) 	TestQueueDatInit();
    07E2E C224      RJMP	0x8053
(1236) 	UnloadQueueDatInit();
    07E2F EC8E      LDI	R24,0xCE
    07E30 E094      LDI	R25,4
(1237) 	
(1238) 	InitControlLayerData();
    07E31 9390 17D5 STS	miantianSubFunction+1,R25
(1239) 	InitCommandTransferData();
    07E33 9380 17D4 STS	miantianSubFunction,R24
(1240) 
(1241) //	RegisterSlave(COMMON_ADDRESS);
(1242) 	RegisterSlave(MOT_TURN_PLATE);
    07E35 C21D      RJMP	0x8053
    07E36 EC8C      LDI	R24,0xCC
    07E37 E094      LDI	R25,4
(1243) 	RegisterSlave(MOT_SAMP_TRUN);
    07E38 9390 17D5 STS	miantianSubFunction+1,R25
    07E3A 9380 17D4 STS	miantianSubFunction,R24
(1244) 	RegisterSlave(MOT_SAMP_NEEDLE);
    07E3C C216      RJMP	0x8053
    07E3D EC8A      LDI	R24,0xCA
(1245) 	RegisterSlave(MOT_CARD_LOAD);
    07E3E E094      LDI	R25,4
    07E3F 9390 17D5 STS	miantianSubFunction+1,R25
(1246) 	RegisterSlave(MOT_CARD_UNLOAD);
    07E41 9380 17D4 STS	miantianSubFunction,R24
    07E43 C20F      RJMP	0x8053
(1247) 	RegisterSlave(MOT_STORE_CARD_MOVE);
    07E44 9100 1569 LDS	R16,ControlCmd+3
    07E46 9110 156A LDS	R17,ControlCmd+4
(1248) 	RegisterSlave(MOT_DILUENT);
    07E48 940E 85EB CALL	_SetCardStorePhotoAdjustNum
(1249) 	RegisterSlave(MOT_FLUID);
    07E4A EC88      LDI	R24,0xC8
    07E4B E094      LDI	R25,4
    07E4C 9390 17D5 STS	miantianSubFunction+1,R25
(1250) 	RegisterSlave(MOT_EFFLUENT);
    07E4E 9380 17D4 STS	miantianSubFunction,R24
(1251) 	RegisterSlave(MOT_SAMP_PUMP);
    07E50 C202      RJMP	0x8053
    07E51 EC86      LDI	R24,0xC6
    07E52 E094      LDI	R25,4
(1252) 	RegisterSlave(LIQUID_CONTROL);
    07E53 9390 17D5 STS	miantianSubFunction+1,R25
    07E55 9380 17D4 STS	miantianSubFunction,R24
(1253) 	RegisterSlave(STORE_MONITOR);
    07E57 C1FB      RJMP	0x8053
    07E58 EC84      LDI	R24,0xC4
(1254) 
(1255) 	StartCommandTransfer();
    07E59 E094      LDI	R25,4
    07E5A 9390 17D5 STS	miantianSubFunction+1,R25
(1256) 	SEI();
    07E5C 9380 17D4 STS	miantianSubFunction,R24
    07E5E C1F4      RJMP	0x8053
    07E5F EC82      LDI	R24,0xC2
    07E60 E094      LDI	R25,4
(1257) 
(1258) 	//MotorModelConfig();
(1259) 	Uart0ReUnable;
(1260) 	uart_Printf("%s $%s\r\n", strM0101, strVersion);
    07E61 9390 17D5 STS	miantianSubFunction+1,R25
    07E63 9380 17D4 STS	miantianSubFunction,R24
    07E65 C1ED      RJMP	0x8053
    07E66 EC80      LDI	R24,0xC0
    07E67 E094      LDI	R25,4
    07E68 9390 17D5 STS	miantianSubFunction+1,R25
    07E6A 9380 17D4 STS	miantianSubFunction,R24
(1261) 	uart_Printf("%s\r\n", strM0103);
    07E6C C1E6      RJMP	0x8053
    07E6D EE82      LDI	R24,0xE2
    07E6E E094      LDI	R25,4
    07E6F 9390 17D5 STS	miantianSubFunction+1,R25
(1262) 	uart_Printf("%s\r\n", strM0104);
    07E71 9380 17D4 STS	miantianSubFunction,R24
    07E73 9100 1569 LDS	R16,ControlCmd+3
    07E75 9110 156A LDS	R17,ControlCmd+4
(1263) 	Uart0ReEnable;
    07E77 940E 914B CALL	_SetDiluentQuantifyVolume
    07E79 C1D9      RJMP	0x8053
    07E7A EB8E      LDI	R24,0xBE
    07E7B E094      LDI	R25,4
    07E7C 9390 17D5 STS	miantianSubFunction+1,R25
_MotorModelConfig:
    07E7E 9380 17D4 STS	miantianSubFunction,R24
(1264) 	
(1265) }
(1266) 
(1267) void MotorModelConfig(void)
(1268) {
(1269) 	// 设置基本参数
(1270) 	/*	参数0：bit[7]停止锁开关
(1271) 		bit[6:5]运行方式,[00]直线复式,[01]圆周循环式
(1272) 		Bit[4:3]限位传感器类型，[00]无传感器，[01]槽型光耦，[10]微动开关；
(1273) 		Bit[2:1]零位传感器类型，[00]无传感器，[01]槽型光耦，[10]微动开关；
(1274) 		Bit[0]正反转设置，[0]正转，[1]反转；
(1275) 		参数1：圆周等分数。
(1276) 	*/
(1277) 	SetMotRunPam(MOT_TURN_PLATE,120,10,CURRENT_TURN_PLATE);
    07E80 9100 1569 LDS	R16,ControlCmd+3
    07E82 9110 156A LDS	R17,ControlCmd+4
    07E84 940E 924A CALL	_SetLeanerQuantifyVolume
    07E86 C1CC      RJMP	0x8053
(1278) 	SetMotRunPam(MOT_SAMP_TRUN,50,40,CURRENT_SAMP_TRUN);
    07E87 EB8C      LDI	R24,0xBC
    07E88 E094      LDI	R25,4
    07E89 9390 17D5 STS	miantianSubFunction+1,R25
    07E8B 9380 17D4 STS	miantianSubFunction,R24
    07E8D 9100 1569 LDS	R16,ControlCmd+3
(1279) 	SetMotRunPam(MOT_SAMP_NEEDLE,200,10,CURRENT_SAMP_NEEDLE);
    07E8F 9110 156A LDS	R17,ControlCmd+4
    07E91 940E 9358 CALL	_SetSampQuantifyVolume
    07E93 C1BF      RJMP	0x8053
    07E94 9120 156B LDS	R18,ControlCmd+5
    07E96 9130 156C LDS	R19,ControlCmd+6
(1280) 	SetMotRunPam(MOT_CARD_LOAD,160,20,CURRENT_CARD_LOAD);
    07E98 9100 1569 LDS	R16,ControlCmd+3
    07E9A 9110 156A LDS	R17,ControlCmd+4
    07E9C 940E 2DFB CALL	_UpLoadingModuleSensorState
    07E9E C1B4      RJMP	0x8053
(1281) 	SetMotRunPam(MOT_CARD_UNLOAD,160,20,CURRENT_CARD_UNLOAD);
    07E9F 940E 30AC CALL	_UpLoadingAllSensorState
    07EA1 C1B1      RJMP	0x8053
    07EA2 9120 156B LDS	R18,ControlCmd+5
    07EA4 9130 156C LDS	R19,ControlCmd+6
    07EA6 2733      CLR	R19
(1282) 	SetMotRunPam(MOT_STORE_CARD_MOVE,32,10,CURRENT_STORE_MOVE);
    07EA7 9100 1569 LDS	R16,ControlCmd+3
    07EA9 9110 156A LDS	R17,ControlCmd+4
    07EAB 940E 6B1D CALL	_MotAdjustPosition
    07EAD 2EA0      MOV	R10,R16
(1283) 	SetMotRunPam(MOT_DILUENT,200,20,CURRENT_DILUENT);
    07EAE 92A0 17CA STS	_DiluentCalChart+41,R10
    07EB0 C1A2      RJMP	0x8053
    07EB1 9100 1569 LDS	R16,ControlCmd+3
    07EB3 9110 156A LDS	R17,ControlCmd+4
    07EB5 940E 6AFA CALL	_MotInitCheck
(1284) 	SetMotRunPam(MOT_FLUID,128,60,CURRENT_FLUID);
    07EB7 2EA0      MOV	R10,R16
    07EB8 92A0 17CA STS	_DiluentCalChart+41,R10
    07EBA C198      RJMP	0x8053
    07EBB 9120 156B LDS	R18,ControlCmd+5
    07EBD 9130 156C LDS	R19,ControlCmd+6
(1285) 	SetMotRunPam(MOT_EFFLUENT,128,60,CURRENT_EFFLUENT);
    07EBF 9100 1569 LDS	R16,ControlCmd+3
    07EC1 9110 156A LDS	R17,ControlCmd+4
    07EC3 940E 6A2C CALL	_MotRun
    07EC5 2EA0      MOV	R10,R16
(1286) 	SetMotRunPam(MOT_SAMP_PUMP,64,60,CURRENT_SAMP_PUMP);
    07EC6 92A0 17CA STS	_DiluentCalChart+41,R10
    07EC8 C18A      RJMP	0x8053
    07EC9 9120 156B LDS	R18,ControlCmd+5
    07ECB 9130 156C LDS	R19,ControlCmd+6
    07ECD 9100 1569 LDS	R16,ControlCmd+3
    07ECF 9110 156A LDS	R17,ControlCmd+4
FILE: D:\Work\主控软件\2032A2~1\maintain.c
(0001) 
(0002) 
(0003) #include <iom1280v.h>
(0004) #include "B1404_LIB.h"
(0005) #include "Common.h"
(0006) #include "eeprom.h"
(0007) 
(0008) 
(0009) // 维护功能程序
(0010) 
(0011) static unsigned char mainStep = 0;
(0012) static unsigned char workStep = 0;
(0013) static unsigned char subStep = 0;
(0014) 
(0015) static unsigned char waitMotor0 = 0;
(0016) static unsigned char waitMotor1 = 0;
(0017) static unsigned char waitMotor2 = 0;
(0018) static unsigned char waitMotor3 = 0;
(0019) static unsigned char waitMotor4 = 0;
(0020) static unsigned char waitStartKey = 0;
(0021) 
(0022) static unsigned char quitFlag;
(0023) static unsigned char timeOut;
(0024) 
(0025) extern unsigned int MaintainSubFunParam;
(0026) 
(0027) unsigned char SetMaintianSubfunctionQuitFlag(void){
(0028) 	quitFlag = 1;
    07ED1 940E 6A5B CALL	_MotRunTo
(0029) 	return 0;
    07ED3 2EA0      MOV	R10,R16
    07ED4 92A0 17CA STS	_DiluentCalChart+41,R10
    07ED6 C17C      RJMP	0x8053
    07ED7 9120 156B LDS	R18,ControlCmd+5
(0030) }
(0031) 
(0032) signed char SetNeedleOnMixPos(signed char n)
(0033) {
(0034) 	signed char i;
(0035) 	if(n < 30 && n > -30) // 参数范围判断
    07ED9 9130 156C LDS	R19,ControlCmd+6
    07EDB 9100 1569 LDS	R16,ControlCmd+3
    07EDD 9110 156A LDS	R17,ControlCmd+4
    07EDF 940E 6A7F CALL	_MotRunToSite
    07EE1 2EA0      MOV	R10,R16
    07EE2 92A0 17CA STS	_DiluentCalChart+41,R10
(0036) 	{	
(0037) 		EEPROM_WRITE(EEP_ADD_NEEDLE_MIX_ADJ, n);
    07EE4 C16E      RJMP	0x8053
    07EE5 9020 156F LDS	R2,ControlCmd+9
    07EE7 9030 1570 LDS	R3,ControlCmd+10
    07EE9 822A      STD	Y+2,R2
    07EEA 9020 156D LDS	R2,ControlCmd+7
    07EEC 9030 156E LDS	R3,ControlCmd+8
    07EEE 8228      ST	Y,R2
(0038) 	}
(0039) 	EEPROM_READ(EEP_ADD_NEEDLE_MIX_ADJ, i);		// 重新读取写入的设置值
    07EEF 9120 156B LDS	R18,ControlCmd+5
    07EF1 9130 156C LDS	R19,ControlCmd+6
    07EF3 9100 1569 LDS	R16,ControlCmd+3
    07EF5 9110 156A LDS	R17,ControlCmd+4
    07EF7 940E 6A9F CALL	_SetMotRunPam
    07EF9 2EA0      MOV	R10,R16
(0040) 	if(i > 30 || i < -30) // 保存的值有异常
    07EFA 92A0 17CA STS	_DiluentCalChart+41,R10
    07EFC C156      RJMP	0x8053
    07EFD 9020 156D LDS	R2,ControlCmd+7
    07EFF 9030 156E LDS	R3,ControlCmd+8
(0041) 	{		
(0042) 		i = 0;
    07F01 8228      ST	Y,R2
    07F02 9120 156B LDS	R18,ControlCmd+5
(0043) 		EEPROM_WRITE(EEP_ADD_NEEDLE_MIX_ADJ, i);
    07F04 9130 156C LDS	R19,ControlCmd+6
    07F06 9100 1569 LDS	R16,ControlCmd+3
    07F08 9110 156A LDS	R17,ControlCmd+4
    07F0A 940E 6B41 CALL	_MotSetPam
    07F0C 2EA0      MOV	R10,R16
    07F0D 92A0 17CA STS	_DiluentCalChart+41,R10
(0044) 	}
(0045) 	return i;
    07F0F C143      RJMP	0x8053
    07F10 9100 1569 LDS	R16,ControlCmd+3
    07F12 9110 156A LDS	R17,ControlCmd+4
(0046) }
(0047) signed int GetNeedleOnMixCenterPos(void)
(0048) {
(0049) 	signed int si;
(0050) 	signed char sc;
(0051) 	EEPROM_READ(EEP_ADD_NEEDLE_MIX_ADJ, sc);		// 重新读取写入的设置值
    07F14 940E 6B63 CALL	_SlaveSetAddress
    07F16 2EA0      MOV	R10,R16
    07F17 92A0 17CA STS	_DiluentCalChart+41,R10
    07F19 C139      RJMP	0x8053
    07F1A 9120 156B LDS	R18,ControlCmd+5
    07F1C 9130 156C LDS	R19,ControlCmd+6
    07F1E 9100 1569 LDS	R16,ControlCmd+3
(0052) 	if(sc>30 || sc<-30){		// 保存的值有异常
    07F20 9110 156A LDS	R17,ControlCmd+4
    07F22 940E 6B81 CALL	_SetEValve
    07F24 2EA0      MOV	R10,R16
    07F25 92A0 17CA STS	_DiluentCalChart+41,R10
(0053) 		sc = 0;
    07F27 C12B      RJMP	0x8053
(0054) 		EEPROM_WRITE(EEP_ADD_NEEDLE_MIX_ADJ, sc);
    07F28 940E 6C0D CALL	_GetLiquidPhotoInfo
    07F2A 2EA0      MOV	R10,R16
    07F2B 92A0 17CA STS	_DiluentCalChart+41,R10
    07F2D C125      RJMP	0x8053
    07F2E 9100 1569 LDS	R16,ControlCmd+3
    07F30 9110 156A LDS	R17,ControlCmd+4
    07F32 940E 6BFB CALL	_SetLiquidPhotoAdjust
(0055) 		}
(0056) 	si = _POS_NEEDLE_ON_MIXCENTRE + (signed int)sc;
    07F34 2EA0      MOV	R10,R16
    07F35 92A0 17CA STS	_DiluentCalChart+41,R10
    07F37 C11B      RJMP	0x8053
    07F38 9100 1569 LDS	R16,ControlCmd+3
(0057) 	return si;
    07F3A 9110 156A LDS	R17,ControlCmd+4
    07F3C 940E 6C2D CALL	_GetStoreState
_GetNeedleOnMixSidePos:
  si                   --> R20
  sc                   --> Y,+2
    07F3E 2EA0      MOV	R10,R16
    07F3F 92A0 17CA STS	_DiluentCalChart+41,R10
(0058) }
(0059) signed int GetNeedleOnMixSidePos(void)
(0060) {
(0061) 	signed int si;
(0062) 	signed char sc;
(0063) 	EEPROM_READ(EEP_ADD_NEEDLE_MIX_ADJ, sc);		// 重新读取写入的设置值
    07F41 C111      RJMP	0x8053
    07F42 9100 1569 LDS	R16,ControlCmd+3
    07F44 9110 156A LDS	R17,ControlCmd+4
    07F46 940E 6C43 CALL	_SetStoreCAL
    07F48 2EA0      MOV	R10,R16
    07F49 92A0 17CA STS	_DiluentCalChart+41,R10
    07F4B C107      RJMP	0x8053
(0064) 	if(sc>30 || sc<-30){		// 保存的值有异常
    07F4C 9100 1569 LDS	R16,ControlCmd+3
    07F4E 9110 156A LDS	R17,ControlCmd+4
    07F50 940E 6C54 CALL	_GetStorePhoVol
    07F52 2EA0      MOV	R10,R16
(0065) 		sc = 0;
    07F53 92A0 17CA STS	_DiluentCalChart+41,R10
(0066) 		EEPROM_WRITE(EEP_ADD_NEEDLE_MIX_ADJ, sc);
    07F55 C0FD      RJMP	0x8053
    07F56 2700      CLR	R16
    07F57 940E 9A52 CALL	_getLiqDetADC
    07F59 0158      MOVW	R10,R16
    07F5A 9180 00C1 LDS	R24,0xC1
    07F5C 7E8F      ANDI	R24,0xEF
    07F5D 9380 00C1 STS	0xC1,R24
    07F5F 82B9      STD	Y+1,R11
(0067) 		}
(0068) 	si = _POS_NEEDLE_ON_MIXSIDE + (signed int)sc;
    07F60 82A8      ST	Y,R10
    07F61 E52E      LDI	R18,0x5E
    07F62 E13A      LDI	R19,0x1A
    07F63 E803      LDI	R16,0x83
    07F64 E017      LDI	R17,7
    07F65 940E A90D CALL	_uart_Printf
(0069) 	return si;
    07F67 9180 00C1 LDS	R24,0xC1
    07F69 6180      ORI	R24,0x10
    07F6A 9380 00C1 STS	0xC1,R24
    07F6C C0E6      RJMP	0x8053
    07F6D E001      LDI	R16,1
(0070) }
(0071) 
(0072) /*
(0073) signed char SetDropHeight(signed char n)
(0074) {
(0075) 	signed char i;
(0076) 	if(n<30 && n>-30){	// 参数范围判断
(0077) 		EEPROM_WRITE(EEP_ADD_DROP_HEIGHT_ADJ, n);
(0078) 		}
(0079) 	EEPROM_READ(EEP_ADD_DROP_HEIGHT_ADJ, i);		// 重新读取写入的设置值
(0080) 	if(i>30 || i<-30){		// 保存的值有异常
(0081) 		i = 0;
(0082) 		EEPROM_WRITE(EEP_ADD_DROP_HEIGHT_ADJ, i);
(0083) 		}
(0084) 	return i;
(0085) }
(0086) */
(0087) 
(0088) signed char SetDropHeight(signed char n)
(0089) {
(0090) 	signed char i;
(0091) 	if(n <= 200 && n >= -100)
    07F6E 940E 9A52 CALL	_getLiqDetADC
    07F70 0168      MOVW	R12,R16
    07F71 0156      MOVW	R10,R12
    07F72 9180 00C1 LDS	R24,0xC1
    07F74 7E8F      ANDI	R24,0xEF
    07F75 9380 00C1 STS	0xC1,R24
    07F77 82B9      STD	Y+1,R11
    07F78 82A8      ST	Y,R10
    07F79 E724      LDI	R18,0x74
(0092) 	{	// 参数范围判断
(0093) 		EEPROM_WRITE(EEP_ADD_DROP_HEIGHT_ADJ, n);
    07F7A E13A      LDI	R19,0x1A
    07F7B E803      LDI	R16,0x83
    07F7C E017      LDI	R17,7
    07F7D 940E A90D CALL	_uart_Printf
    07F7F 9180 00C1 LDS	R24,0xC1
    07F81 6180      ORI	R24,0x10
    07F82 9380 00C1 STS	0xC1,R24
(0094) 	}
(0095) 	EEPROM_READ(EEP_ADD_DROP_HEIGHT_ADJ, i);		// 重新读取写入的设置值
    07F84 C0CE      RJMP	0x8053
    07F85 E002      LDI	R16,2
    07F86 940E 9A52 CALL	_getLiqDetADC
    07F88 0168      MOVW	R12,R16
    07F89 0156      MOVW	R10,R12
    07F8A 9180 00C1 LDS	R24,0xC1
    07F8C 7E8F      ANDI	R24,0xEF
    07F8D 9380 00C1 STS	0xC1,R24
(0096) 	if(i > 200 || i < -100)
    07F8F 82B9      STD	Y+1,R11
    07F90 82A8      ST	Y,R10
    07F91 E82C      LDI	R18,0x8C
    07F92 E13A      LDI	R19,0x1A
    07F93 E803      LDI	R16,0x83
    07F94 E017      LDI	R17,7
    07F95 940E A90D CALL	_uart_Printf
    07F97 9180 00C1 LDS	R24,0xC1
    07F99 6180      ORI	R24,0x10
    07F9A 9380 00C1 STS	0xC1,R24
(0097) 	{		// 保存的值有异常
(0098) 		i = 0;
    07F9C C0B6      RJMP	0x8053
(0099) 		EEPROM_WRITE(EEP_ADD_DROP_HEIGHT_ADJ, i);
    07F9D E08C      LDI	R24,0xC
    07F9E E090      LDI	R25,0
    07F9F 9020 1569 LDS	R2,ControlCmd+3
    07FA1 9030 156A LDS	R3,ControlCmd+4
    07FA3 1582      CP	R24,R2
    07FA4 0593      CPC	R25,R3
    07FA5 F428      BCC	0x7FAB
    07FA6 9390 156A STS	ControlCmd+4,R25
(0100) 	}
(0101) 	return i;
    07FA8 9380 1569 STS	ControlCmd+3,R24
    07FAA C00E      RJMP	0x7FB9
_GetDropHeight:
  si                   --> R20
  sc                   --> Y,+2
    07FAB 9180 1569 LDS	R24,ControlCmd+3
    07FAD 9190 156A LDS	R25,ControlCmd+4
(0102) }
(0103) 
(0104) signed int GetDropHeight(void)
(0105) {
(0106) 	signed int si;
(0107) 	signed char sc;
(0108) 	EEPROM_READ(EEP_ADD_DROP_HEIGHT_ADJ, sc);		// 重新读取写入的设置值
    07FAF 3081      CPI	R24,1
    07FB0 E0E0      LDI	R30,0
    07FB1 079E      CPC	R25,R30
    07FB2 F430      BCC	0x7FB9
    07FB3 E081      LDI	R24,1
    07FB4 E090      LDI	R25,0
    07FB5 9390 156A STS	ControlCmd+4,R25
    07FB7 9380 1569 STS	ControlCmd+3,R24
(0109) 	if(sc > 200 || sc < -100)
    07FB9 9100 1569 LDS	R16,ControlCmd+3
    07FBB 9110 156A LDS	R17,ControlCmd+4
    07FBD 940E 6A13 CALL	_MotStop
    07FBF C093      RJMP	0x8053
    07FC0 940E 372D CALL	_SetBeepWarning
    07FC2 9180 00C1 LDS	R24,0xC1
    07FC4 7E8F      ANDI	R24,0xEF
(0110) 	{		// 保存的值有异常
(0111) 		sc = 0;
    07FC5 9380 00C1 STS	0xC1,R24
(0112) 		EEPROM_WRITE(EEP_ADD_DROP_HEIGHT_ADJ, sc);
    07FC7 9120 1567 LDS	R18,ControlCmd+1
    07FC9 9130 1568 LDS	R19,ControlCmd+2
    07FCB E900      LDI	R16,0x90
    07FCC E018      LDI	R17,0x8
    07FCD 940E A90D CALL	_uart_Printf
    07FCF 9180 00C1 LDS	R24,0xC1
    07FD1 6180      ORI	R24,0x10
(0113) 		}
(0114) 	si = _POS_CARD_DROP + (signed int)sc;
    07FD2 9380 00C1 STS	0xC1,R24
    07FD4 C07E      RJMP	0x8053
    07FD5 9160 1567 LDS	R22,ControlCmd+1
    07FD7 9170 1568 LDS	R23,ControlCmd+2
(0115) 	return si;
    07FD9 3063      CPI	R22,3
    07FDA E0E0      LDI	R30,0
    07FDB 077E      CPC	R23,R30
    07FDC F0B9      BEQ	0x7FF4
_SetMixHeight:
  i                    --> Y,+2
  n                    --> Y,+3
    07FDD 3064      CPI	R22,4
    07FDE E0E0      LDI	R30,0
    07FDF 077E      CPC	R23,R30
(0116) }
(0117) 
(0118) signed char SetMixHeight(signed char n)
(0119) {
(0120) 	signed char i;
(0121) 	if(n <= 100 && n >= -100)
    07FE0 F121      BEQ	0x8005
    07FE1 3065      CPI	R22,5
    07FE2 E0E0      LDI	R30,0
    07FE3 077E      CPC	R23,R30
    07FE4 F119      BEQ	0x8008
    07FE5 3063      CPI	R22,3
    07FE6 E0E0      LDI	R30,0
(0122) 	{	// 参数范围判断
(0123) 		EEPROM_WRITE(EEP_ADD_MIX_HEIGHT_ADJ, n);
    07FE7 077E      CPC	R23,R30
    07FE8 F40C      BGE	0x7FEA
    07FE9 C055      RJMP	0x803F
    07FEA 9180 1567 LDS	R24,ControlCmd+1
    07FEC 9190 1568 LDS	R25,ControlCmd+2
    07FEE 3683      CPI	R24,0x63
    07FEF E0E0      LDI	R30,0
    07FF0 079E      CPC	R25,R30
    07FF1 F409      BNE	0x7FF3
(0124) 	}
(0125) 	EEPROM_READ(EEP_ADD_MIX_HEIGHT_ADJ, i);		// 重新读取写入的设置值
    07FF2 C045      RJMP	0x8038
    07FF3 C04B      RJMP	0x803F
    07FF4 9180 00C1 LDS	R24,0xC1
    07FF6 7E8F      ANDI	R24,0xEF
    07FF7 9380 00C1 STS	0xC1,R24
    07FF9 EA2F      LDI	R18,0xAF
    07FFA E035      LDI	R19,5
    07FFB E003      LDI	R16,3
    07FFC E017      LDI	R17,7
(0126) 	if(i > 100 || i < -100)
    07FFD 940E A90D CALL	_uart_Printf
    07FFF 9180 00C1 LDS	R24,0xC1
    08001 6180      ORI	R24,0x10
    08002 9380 00C1 STS	0xC1,R24
(0127) 	{		// 保存的值有异常
(0128) 		i = 0;
    08004 C04E      RJMP	0x8053
    08005 940E 8251 CALL	_SetMaintianSubfunctionQuitFlag
(0129) 		EEPROM_WRITE(EEP_ADD_MIX_HEIGHT_ADJ, i);
    08007 C04B      RJMP	0x8053
    08008 9020 1569 LDS	R2,ControlCmd+3
    0800A 9030 156A LDS	R3,ControlCmd+4
    0800C 2022      TST	R2
    0800D F4B1      BNE	0x8024
    0800E 2033      TST	R3
    0800F F4A1      BNE	0x8024
    08010 E081      LDI	R24,1
(0130) 	}
(0131) 	return i;
    08011 9380 06F7 STS	workSwitch,R24
    08013 9180 00C1 LDS	R24,0xC1
    08015 7E8F      ANDI	R24,0xEF
    08016 9380 00C1 STS	0xC1,R24
(0132) }
(0133) 
(0134) signed int GetMixHeight(void)
(0135) {
(0136) 	signed int si;
(0137) 	signed char sc;
(0138) 	EEPROM_READ(EEP_ADD_MIX_HEIGHT_ADJ, sc);		// 重新读取写入的设置值
    08018 E923      LDI	R18,0x93
    08019 E035      LDI	R19,5
    0801A EE05      LDI	R16,0xE5
    0801B E018      LDI	R17,0x8
    0801C 940E A90D CALL	_uart_Printf
    0801E 9180 00C1 LDS	R24,0xC1
    08020 6180      ORI	R24,0x10
    08021 9380 00C1 STS	0xC1,R24
(0139) 	if(sc > 100 || sc < -100)
    08023 C02F      RJMP	0x8053
    08024 2422      CLR	R2
    08025 9220 06F7 STS	workSwitch,R2
    08027 9180 00C1 LDS	R24,0xC1
(0140) 	{		// 保存的值有异常
(0141) 		sc = 0;
    08029 7E8F      ANDI	R24,0xEF
    0802A 9380 00C1 STS	0xC1,R24
(0142) 		EEPROM_WRITE(EEP_ADD_MIX_HEIGHT_ADJ, sc);
    0802C EA21      LDI	R18,0xA1
    0802D E035      LDI	R19,5
    0802E EE05      LDI	R16,0xE5
    0802F E018      LDI	R17,0x8
    08030 940E A90D CALL	_uart_Printf
    08032 9180 00C1 LDS	R24,0xC1
    08034 6180      ORI	R24,0x10
    08035 9380 00C1 STS	0xC1,R24
(0143) 	}
(0144) 	si = _POS_CARD_MIX + (signed int)sc;
    08037 C01B      RJMP	0x8053
    08038 9100 1569 LDS	R16,ControlCmd+3
    0803A 9110 156A LDS	R17,ControlCmd+4
(0145) 	return si;
    0803C 940E 71B2 CALL	_ReStart
    0803E C014      RJMP	0x8053
    0803F 940E 372D CALL	_SetBeepWarning
_CardLoadStartAdjust:
    08041 9180 00C1 LDS	R24,0xC1
    08043 7E8F      ANDI	R24,0xEF
(0146) }
(0147) 
(0148) unsigned char CardLoadStartAdjust(void){
(0149) 	// 卡片装载起始位调整
(0150) 	if(waitMotor0){	if(GetMotState(MOT_CARD_LOAD)!=STA_SLAVE_FREE)	return 0;	waitMotor0 = 0;	}
    08044 9380 00C1 STS	0xC1,R24
    08046 9120 1567 LDS	R18,ControlCmd+1
    08048 9130 1568 LDS	R19,ControlCmd+2
    0804A E900      LDI	R16,0x90
    0804B E018      LDI	R17,0x8
    0804C 940E A90D CALL	_uart_Printf
    0804E 9180 00C1 LDS	R24,0xC1
    08050 6180      ORI	R24,0x10
    08051 9380 00C1 STS	0xC1,R24
(0151) 
(0152) 	switch(mainStep){
    08053 9020 17CA LDS	R2,_DiluentCalChart+41
    08055 2022      TST	R2
    08056 F0A9      BEQ	0x806C
    08057 940E 372D CALL	_SetBeepWarning
    08059 9180 00C1 LDS	R24,0xC1
    0805B 7E8F      ANDI	R24,0xEF
    0805C 9380 00C1 STS	0xC1,R24
(0153) 		case 0:
(0154) 			SetMotRunPam(MOT_CARD_LOAD, 64, 20, CURRENT_CARD_LOAD);
    0805E 9120 1567 LDS	R18,ControlCmd+1
    08060 9130 1568 LDS	R19,ControlCmd+2
    08062 E706      LDI	R16,0x76
    08063 E018      LDI	R17,0x8
    08064 940E A90D CALL	_uart_Printf
(0155) 			MotInitCheck(MOT_CARD_LOAD);	// 卡片装载小车回到起始位等待调整
    08066 9180 00C1 LDS	R24,0xC1
(0156) 			waitMotor0 = 1;
    08068 6180      ORI	R24,0x10
    08069 9380 00C1 STS	0xC1,R24
(0157) 			mainStep = 1;
    0806B C014      RJMP	0x8080
    0806C 940E 3739 CALL	_SetBeepAck
(0158) 			break;
    0806E 9180 00C1 LDS	R24,0xC1
    08070 7E8F      ANDI	R24,0xEF
    08071 9380 00C1 STS	0xC1,R24
(0159) 		case 1:
(0160) 			Uart0ReUnable;
(0161) 			uart_Printf("%s\r\n",strM4105);
    08073 9120 1567 LDS	R18,ControlCmd+1
    08075 9130 1568 LDS	R19,ControlCmd+2
    08077 E50D      LDI	R16,0x5D
    08078 E018      LDI	R17,0x8
(0162) 			Uart0ReEnable;
    08079 940E A90D CALL	_uart_Printf
    0807B 9180 00C1 LDS	R24,0xC1
    0807D 6180      ORI	R24,0x10
(0163) 			mainStep = 0;
    0807E 9380 00C1 STS	0xC1,R24
    08080 940E 29D2 CALL	_CommandClear
(0164) 			return 1;
    08082 9020 06F7 LDS	R2,workSwitch
(0165) 			break;
(0166) 		default:
(0167) 			break;
(0168) 		}
(0169) 	return 0;
    08084 2022      TST	R2
    08085 F189      BEQ	0x80B7
    08086 9020 17D4 LDS	R2,miantianSubFunction
_CardLoadEndAdjust:
    08088 9030 17D5 LDS	R3,miantianSubFunction+1
    0808A 2022      TST	R2
(0170) }
(0171) 
(0172) unsigned char CardLoadEndAdjust(void){
(0173) 	// 卡片装载终点位调整
(0174) 	if(waitMotor0){	if(GetMotState(MOT_CARD_LOAD)!=STA_SLAVE_FREE)	return 0;	waitMotor0 = 0;	}
    0808B F411      BNE	0x808E
    0808C 2033      TST	R3
    0808D F149      BEQ	0x80B7
    0808E 9020 157D LDS	R2,ControlCmd+23
    08090 2022      TST	R2
    08091 F079      BEQ	0x80A1
    08092 9020 1569 LDS	R2,ControlCmd+3
    08094 9030 156A LDS	R3,ControlCmd+4
    08096 9230 17D3 STS	MaintainSubFunParam+1,R3
    08098 9220 17D2 STS	MaintainSubFunParam,R2
(0175) 
(0176) 	switch(mainStep){
    0809A 2422      CLR	R2
    0809B 2433      CLR	R3
    0809C 9230 156A STS	ControlCmd+4,R3
    0809E 9220 1569 STS	ControlCmd+3,R2
    080A0 C006      RJMP	0x80A7
    080A1 2422      CLR	R2
    080A2 2433      CLR	R3
    080A3 9230 17D3 STS	MaintainSubFunParam+1,R3
(0177) 		case 0:
(0178) 			SetMotRunPam(MOT_CARD_LOAD, 64, 20, CURRENT_CARD_LOAD);
    080A5 9220 17D2 STS	MaintainSubFunParam,R2
    080A7 91E0 17D4 LDS	R30,miantianSubFunction
    080A9 91F0 17D5 LDS	R31,miantianSubFunction+1
    080AB 940E AEC5 CALL	xicallx
(0179) 			MotAdjustPosition(MOT_CARD_LOAD,_POS_CARDLOAD_RING);	// 卡片装载小冲位置调整
    080AD 2EA0      MOV	R10,R16
    080AE 2D4A      MOV	R20,R10
    080AF 3001      CPI	R16,1
    080B0 F431      BNE	0x80B7
(0180) 			waitMotor0 = 1;
    080B1 2422      CLR	R2
    080B2 2433      CLR	R3
    080B3 9230 17D5 STS	miantianSubFunction+1,R3
(0181) 			mainStep = 1;
    080B5 9220 17D4 STS	miantianSubFunction,R2
(0182) 			break;
    080B7 940E A99B CALL	_GetwasteCardState
    080B9 2EA0      MOV	R10,R16
    080BA 2300      TST	R16
    080BB F009      BEQ	0x80BD
(0183) 		case 1:
(0184) 			Uart0ReUnable;
(0185) 			uart_Printf("%s\r\n",strM4106);
    080BC C047      RJMP	0x8104
    080BD 9020 0106 LDS	R2,0x106
    080BF FC21      SBRC	R2,1
    080C0 C023      RJMP	0x80E4
    080C1 E080      LDI	R24,0
(0186) 			Uart0ReEnable;
    080C2 9020 17CF LDS	R2,_DiluentCalChart+46
    080C4 1582      CP	R24,R2
    080C5 F420      BCC	0x80CA
    080C6 2D82      MOV	R24,R2
(0187) 			mainStep = 0;
    080C7 5081      SUBI	R24,1
    080C8 9380 17CF STS	_DiluentCalChart+46,R24
(0188) 			return 1;
    080CA 9180 17CF LDS	R24,_DiluentCalChart+46
(0189) 			break;
(0190) 		default:
(0191) 			break;
(0192) 		}
(0193) 	return 0;
    080CC 3082      CPI	R24,2
    080CD F5B1      BNE	0x8104
    080CE 9180 00C1 LDS	R24,0xC1
    080D0 7E8F      ANDI	R24,0xEF
_CardUnloadStartAdjust:
    080D1 9380 00C1 STS	0xC1,R24
    080D3 9020 17CF LDS	R2,_DiluentCalChart+46
(0194) }
(0195) 
(0196) unsigned char CardUnloadStartAdjust(void){
(0197) 	// 卡片卸载起始位调整
(0198) 	if(waitMotor0){	if(GetMotState(MOT_CARD_UNLOAD)!=STA_SLAVE_FREE)	return 0;	waitMotor0 = 0;	}
    080D5 2433      CLR	R3
    080D6 8239      STD	Y+1,R3
    080D7 8228      ST	Y,R2
    080D8 EF27      LDI	R18,0xF7
    080D9 E035      LDI	R19,5
    080DA E803      LDI	R16,0x83
    080DB E017      LDI	R17,7
    080DC 940E A90D CALL	_uart_Printf
    080DE 9180 00C1 LDS	R24,0xC1
    080E0 6180      ORI	R24,0x10
    080E1 9380 00C1 STS	0xC1,R24
(0199) 
(0200) 	switch(mainStep){
    080E3 C020      RJMP	0x8104
    080E4 9180 17CF LDS	R24,_DiluentCalChart+46
    080E6 3F8F      CPI	R24,0xFF
    080E7 F418      BCC	0x80EB
    080E8 5F8F      SUBI	R24,0xFF
    080E9 9380 17CF STS	_DiluentCalChart+46,R24
    080EB 9180 17CF LDS	R24,_DiluentCalChart+46
(0201) 		case 0:
(0202) 			SetMotRunPam(MOT_CARD_UNLOAD, 64, 20, CURRENT_CARD_UNLOAD);
    080ED 3F8D      CPI	R24,0xFD
    080EE F4A9      BNE	0x8104
    080EF 9180 00C1 LDS	R24,0xC1
    080F1 7E8F      ANDI	R24,0xEF
    080F2 9380 00C1 STS	0xC1,R24
    080F4 9020 17CF LDS	R2,_DiluentCalChart+46
(0203) 			MotInitCheck(MOT_CARD_UNLOAD);	// 卡片装载小车回到起始位等待调整
    080F6 2433      CLR	R3
    080F7 8239      STD	Y+1,R3
(0204) 			waitMotor0 = 1;
    080F8 8228      ST	Y,R2
    080F9 EF27      LDI	R18,0xF7
    080FA E035      LDI	R19,5
(0205) 			mainStep = 1;
    080FB E803      LDI	R16,0x83
    080FC E017      LDI	R17,7
(0206) 			break;
    080FD 940E A90D CALL	_uart_Printf
(0207) 		case 1:
(0208) 			Uart0ReUnable;
    080FF 9180 00C1 LDS	R24,0xC1
    08101 6180      ORI	R24,0x10
    08102 9380 00C1 STS	0xC1,R24
(0209) 			uart_Printf("%s\r\n",strM4107);
    08104 940C 721A JMP	0x721A
    08106 9626      ADIW	R28,6
    08107 9508      RET
_SetWorkStep:
    08108 934A      ST	-Y,R20
(0210) 			Uart0ReEnable;;
    08109 935A      ST	-Y,R21
    0810A 2F40      MOV	R20,R16
    0810B E084      LDI	R24,4
    0810C 1784      CP	R24,R20
    0810D F418      BCC	0x8111
(0211) 			mainStep = 0;
    0810E 3049      CPI	R20,0x9
    0810F F009      BEQ	0x8111
    08110 2744      CLR	R20
(0212) 			return 1;
    08111 9020 17D7 LDS	R2,WorkProcessStep
(0213) 			break;
(0214) 		default:
(0215) 			break;
(0216) 		}
(0217) 	return 0;
    08113 1542      CP	R20,R2
    08114 F409      BNE	0x8116
    08115 C08F      RJMP	0x81A5
    08116 9340 17D7 STS	WorkProcessStep,R20
_CardUnloadEndAdjust:
    08118 2755      CLR	R21
    08119 3040      CPI	R20,0
    0811A 0745      CPC	R20,R21
(0218) }
(0219) 
(0220) unsigned char CardUnloadEndAdjust(void){
(0221) 	// 卡片卸载终点位调整
(0222) 	if(waitMotor0){	if(GetMotState(MOT_CARD_UNLOAD)!=STA_SLAVE_FREE)	return 0;	waitMotor0 = 0;	}
    0811B F0C1      BEQ	0x8134
    0811C 3041      CPI	R20,1
    0811D E0E0      LDI	R30,0
    0811E 075E      CPC	R21,R30
    0811F F129      BEQ	0x8145
    08120 3042      CPI	R20,2
    08121 E0E0      LDI	R30,0
    08122 075E      CPC	R21,R30
    08123 F191      BEQ	0x8156
    08124 3043      CPI	R20,3
    08125 E0E0      LDI	R30,0
    08126 075E      CPC	R21,R30
    08127 F409      BNE	0x8129
    08128 C03E      RJMP	0x8167
(0223) 
(0224) 	switch(mainStep){
    08129 3044      CPI	R20,4
    0812A E0E0      LDI	R30,0
    0812B 075E      CPC	R21,R30
    0812C F409      BNE	0x812E
    0812D C04D      RJMP	0x817B
    0812E 3049      CPI	R20,0x9
    0812F E0E0      LDI	R30,0
    08130 075E      CPC	R21,R30
    08131 F409      BNE	0x8133
    08132 C059      RJMP	0x818C
    08133 C071      RJMP	0x81A5
(0225) 		case 0:
(0226) 			SetMotRunPam(MOT_CARD_UNLOAD, 64, 20, CURRENT_CARD_UNLOAD);
    08134 9180 00C1 LDS	R24,0xC1
    08136 7E8F      ANDI	R24,0xEF
    08137 9380 00C1 STS	0xC1,R24
    08139 EA2F      LDI	R18,0xAF
    0813A E035      LDI	R19,5
    0813B E40B      LDI	R16,0x4B
(0227) 			MotAdjustPosition(MOT_CARD_UNLOAD,_POS_UNLOAD_OUT);	// 卡片装载小冲位置调整
    0813C E018      LDI	R17,0x8
    0813D 940E A90D CALL	_uart_Printf
    0813F 9180 00C1 LDS	R24,0xC1
(0228) 			waitMotor0 = 1;
    08141 6180      ORI	R24,0x10
    08142 9380 00C1 STS	0xC1,R24
(0229) 			mainStep = 1;
    08144 C060      RJMP	0x81A5
    08145 9180 00C1 LDS	R24,0xC1
(0230) 			break;
    08147 7E8F      ANDI	R24,0xEF
    08148 9380 00C1 STS	0xC1,R24
    0814A EA2F      LDI	R18,0xAF
    0814B E035      LDI	R19,5
(0231) 		case 1:
(0232) 			Uart0ReUnable;
(0233) 			uart_Printf("%s\r\n",strM4108);
    0814C E00A      LDI	R16,0xA
    0814D E018      LDI	R17,0x8
    0814E 940E A90D CALL	_uart_Printf
    08150 9180 00C1 LDS	R24,0xC1
(0234) 			Uart0ReEnable;
    08152 6180      ORI	R24,0x10
    08153 9380 00C1 STS	0xC1,R24
    08155 C04F      RJMP	0x81A5
    08156 9180 00C1 LDS	R24,0xC1
(0235) 			mainStep = 0;
    08158 7E8F      ANDI	R24,0xEF
    08159 9380 00C1 STS	0xC1,R24
(0236) 			return 1;
    0815B EA2F      LDI	R18,0xAF
(0237) 			break;
(0238) 		default:
(0239) 			break;
(0240) 		}
(0241) 	return 0;
    0815C E035      LDI	R19,5
    0815D ED0A      LDI	R16,0xDA
    0815E E017      LDI	R17,7
    0815F 940E A90D CALL	_uart_Printf
(0242) }
(0243) 
(0244) static unsigned char LiquidPhoNum;
(0245) void SetLiquidPhotoAdjustNum(unsigned char n){
(0246) 	if(n>2)
_SetLiquidPhotoAdjustNum:
  n                    --> R16
    08161 9180 00C1 LDS	R24,0xC1
    08163 6180      ORI	R24,0x10
(0247) 		n = 2;
    08164 9380 00C1 STS	0xC1,R24
(0248) 	LiquidPhoNum = n;
    08166 C03E      RJMP	0x81A5
    08167 2700      CLR	R16
_LiquidPhotoAdj_Even:
  pInfo                --> R20
  pInfoEvent           --> R20
    08168 940E 6C2D CALL	_GetStoreState
    0816A 9180 00C1 LDS	R24,0xC1
(0249) }
(0250) unsigned char LiquidPhotoAdj_Even(INFO_EVENT * pInfoEvent){
(0251) 	unsigned char * pInfo;
(0252) 	switch(mainStep){
    0816C 7E8F      ANDI	R24,0xEF
    0816D 9380 00C1 STS	0xC1,R24
    0816F EA2F      LDI	R18,0xAF
    08170 E035      LDI	R19,5
    08171 E90F      LDI	R16,0x9F
    08172 E017      LDI	R17,7
    08173 940E A90D CALL	_uart_Printf
(0253) 		case 1:
(0254) 			if(pInfoEvent->event == INFO_LIQ_PHO_ADJ){
    08175 9180 00C1 LDS	R24,0xC1
    08177 6180      ORI	R24,0x10
(0255) 				pInfo = &(pInfoEvent->info[0]);
    08178 9380 00C1 STS	0xC1,R24
(0256) 				if(*(pInfo) == LiquidPhoNum){
    0817A C02A      RJMP	0x81A5
    0817B 9180 00C1 LDS	R24,0xC1
    0817D 7E8F      ANDI	R24,0xEF
    0817E 9380 00C1 STS	0xC1,R24
(0257) 					// 输出液路光耦调整结果
(0258) 					Uart0ReUnable;
    08180 EA2F      LDI	R18,0xAF
    08181 E035      LDI	R19,5
    08182 E003      LDI	R16,3
    08183 E017      LDI	R17,7
    08184 940E A90D CALL	_uart_Printf
(0259) 					uart_Printf("%s $%4d Num $%4d PWM $%4d Vol\r\n",strM4109, LiquidPhoNum, *(pInfo+1), *(pInfo+2));
    08186 9180 00C1 LDS	R24,0xC1
    08188 6180      ORI	R24,0x10
    08189 9380 00C1 STS	0xC1,R24
    0818B C019      RJMP	0x81A5
    0818C E081      LDI	R24,1
    0818D 9380 0533 STS	JumpMode,R24
    0818F 2700      CLR	R16
    08190 940E 6C2D CALL	_GetStoreState
    08192 E083      LDI	R24,3
    08193 9380 17D7 STS	WorkProcessStep,R24
    08195 9180 00C1 LDS	R24,0xC1
    08197 7E8F      ANDI	R24,0xEF
(0260) 					Uart0ReEnable;
    08198 9380 00C1 STS	0xC1,R24
    0819A EA2F      LDI	R18,0xAF
    0819B E035      LDI	R19,5
    0819C E90F      LDI	R16,0x9F
(0261) 					mainStep = 2;
    0819D E017      LDI	R17,7
    0819E 940E A90D CALL	_uart_Printf
(0262) 					return 1;
    081A0 9180 00C1 LDS	R24,0xC1
(0263) 					}
(0264) 				}
(0265) 			break;
(0266) 		default:
(0267) 			break;
(0268) 		}
(0269) 	return 0;
    081A2 6180      ORI	R24,0x10
    081A3 9380 00C1 STS	0xC1,R24
    081A5 9159      LD	R21,Y+
_LiquidPhotoAdjust:
    081A6 9149      LD	R20,Y+
    081A7 9508      RET
_StartWork:
    081A8 9722      SBIW	R28,2
(0270) }
(0271) unsigned char LiquidPhotoAdjust(void){
(0272) 	switch(mainStep){
    081A9 94F8      BCLR	7
    081AA 940E 61ED CALL	_DiluteProcDatInit
    081AC 940E 9E94 CALL	_RingQueueDatInit
    081AE 940E 9FFB CALL	_TestQueueDatInit
    081B0 940E A99E CALL	_UnloadQueueDatInit
    081B2 940E 2D56 CALL	_InitControlLayerData
(0273) 		case 0:
(0274) 			SetLiquidPhotoAdjust(LiquidPhoNum);
    081B4 940E 132C CALL	_InitCommandTransferData
    081B6 E001      LDI	R16,1
    081B7 940E 1699 CALL	_RegisterSlave
(0275) 			mainStep = 1;
    081B9 E002      LDI	R16,2
    081BA 940E 1699 CALL	_RegisterSlave
(0276) 			RegisterLiquidEvenProcess(LiquidPhotoAdj_Even);
    081BC E003      LDI	R16,3
    081BD 940E 1699 CALL	_RegisterSlave
(0277) 			break;
    081BF E004      LDI	R16,4
(0278) 		case 2:
(0279) 			Uart0ReUnable;
    081C0 940E 1699 CALL	_RegisterSlave
    081C2 E005      LDI	R16,5
    081C3 940E 1699 CALL	_RegisterSlave
(0280) 			uart_Printf("%s $%4d\r\n",strM4110, LiquidPhoNum);
    081C5 E008      LDI	R16,0x8
    081C6 940E 1699 CALL	_RegisterSlave
    081C8 E009      LDI	R16,0x9
    081C9 940E 1699 CALL	_RegisterSlave
    081CB E00A      LDI	R16,0xA
    081CC 940E 1699 CALL	_RegisterSlave
    081CE E00B      LDI	R16,0xB
    081CF 940E 1699 CALL	_RegisterSlave
(0281) 			Uart0ReEnable;
    081D1 E00C      LDI	R16,0xC
    081D2 940E 1699 CALL	_RegisterSlave
    081D4 E00D      LDI	R16,0xD
(0282) 			mainStep = 0;
    081D5 940E 1699 CALL	_RegisterSlave
    081D7 E00E      LDI	R16,0xE
(0283) 			return 1;
    081D8 940E 1699 CALL	_RegisterSlave
(0284) 			break;
(0285) 		default:
(0286) 			break;
(0287) 		}
(0288) 	return 0;
    081DA 940E 16A2 CALL	_StartCommandTransfer
    081DC 9478      BSET	7
    081DD 9180 00C1 LDS	R24,0xC1
(0289) }
(0290) 
(0291) static unsigned char CardStorePhoNum;
(0292) void SetCardStorePhotoAdjustNum(unsigned char n){
(0293) //	if(n>6)
(0294) //		n = 6;
(0295) 	if(n > 5)
_SetCardStorePhotoAdjustNum:
  n                    --> R16
    081DF 7E8F      ANDI	R24,0xEF
    081E0 9380 00C1 STS	0xC1,R24
(0296) 		n = 5;
    081E2 E18E      LDI	R24,0x1E
(0297) 	if(n == 0)
    081E3 E095      LDI	R25,5
    081E4 8399      STD	Y+1,R25
(0298) 		n = 1;
    081E5 8388      ST	Y,R24
(0299) 	CardStorePhoNum = n;
    081E6 E42D      LDI	R18,0x4D
    081E7 E035      LDI	R19,5
    081E8 ED0C      LDI	R16,0xDC
_CardStorePhotoAdj_Even:
  pInfo                --> R20
  pInfoEvent           --> R20
    081E9 E018      LDI	R17,0x8
    081EA 940E A90D CALL	_uart_Printf
    081EC E62C      LDI	R18,0x6C
(0300) }
(0301) unsigned char CardStorePhotoAdj_Even(INFO_EVENT * pInfoEvent){
(0302) 	unsigned char * pInfo;
(0303) 	switch(mainStep){
    081ED E035      LDI	R19,5
    081EE EE05      LDI	R16,0xE5
    081EF E018      LDI	R17,0x8
    081F0 940E A90D CALL	_uart_Printf
    081F2 E820      LDI	R18,0x80
    081F3 E035      LDI	R19,5
    081F4 EE05      LDI	R16,0xE5
(0304) 		case 1:
(0305) 			if(pInfoEvent->event == INFO_STORE_CAL){
    081F5 E018      LDI	R17,0x8
    081F6 940E A90D CALL	_uart_Printf
    081F8 9180 00C1 LDS	R24,0xC1
(0306) 				pInfo = &(pInfoEvent->info[0]);
    081FA 6180      ORI	R24,0x10
(0307) 		//		if(*(pInfo) == CardStorePhoNum){
(0308) 					// 输出液路光耦调整结果
(0309) 					Uart0ReUnable;
    081FB 9380 00C1 STS	0xC1,R24
    081FD 9622      ADIW	R28,2
    081FE 9508      RET
_MotorModelConfig:
    081FF 9723      SBIW	R28,3
(0310) 					uart_Printf("%s $%4d $%4d $%4d $%4d\r\n",strM4111, (*(pInfo)), *(pInfo+1), *(pInfo+2), *(pInfo+3));
    08200 E081      LDI	R24,1
    08201 838A      STD	Y+2,R24
    08202 E08A      LDI	R24,0xA
    08203 8388      ST	Y,R24
    08204 E728      LDI	R18,0x78
    08205 E001      LDI	R16,1
    08206 940E 6A9F CALL	_SetMotRunPam
    08208 E084      LDI	R24,4
    08209 838A      STD	Y+2,R24
    0820A E288      LDI	R24,0x28
    0820B 8388      ST	Y,R24
    0820C E322      LDI	R18,0x32
    0820D E002      LDI	R16,2
    0820E 940E 6A9F CALL	_SetMotRunPam
    08210 E083      LDI	R24,3
    08211 838A      STD	Y+2,R24
    08212 E08A      LDI	R24,0xA
    08213 8388      ST	Y,R24
    08214 EC28      LDI	R18,0xC8
    08215 E003      LDI	R16,3
    08216 940E 6A9F CALL	_SetMotRunPam
(0311) 					Uart0ReEnable;
    08218 E084      LDI	R24,4
    08219 838A      STD	Y+2,R24
    0821A E184      LDI	R24,0x14
    0821B 8388      ST	Y,R24
(0312) 					mainStep = 2;
    0821C EA20      LDI	R18,0xA0
    0821D E004      LDI	R16,4
    0821E 940E 6A9F CALL	_SetMotRunPam
(0313) 					return 1;
    08220 E084      LDI	R24,4
(0314) 		//			}
(0315) 				}
(0316) 			break;
(0317) 		default:
(0318) 			break;
(0319) 		}
(0320) 	return 0;
    08221 838A      STD	Y+2,R24
    08222 E184      LDI	R24,0x14
    08223 8388      ST	Y,R24
    08224 EA20      LDI	R18,0xA0
_CardStorePhotoAdjust:
    08225 E005      LDI	R16,5
    08226 940E 6A9F CALL	_SetMotRunPam
(0321) }
(0322) unsigned char CardStorePhotoAdjust(void){
(0323) 	switch(mainStep){
    08228 E08A      LDI	R24,0xA
    08229 838A      STD	Y+2,R24
    0822A 8388      ST	Y,R24
    0822B E220      LDI	R18,0x20
    0822C E008      LDI	R16,0x8
    0822D 940E 6A9F CALL	_SetMotRunPam
    0822F E084      LDI	R24,4
    08230 838A      STD	Y+2,R24
    08231 E184      LDI	R24,0x14
    08232 8388      ST	Y,R24
(0324) 		case 0:
(0325) 			SetStoreCAL(CardStorePhoNum);
    08233 EC28      LDI	R18,0xC8
    08234 E009      LDI	R16,0x9
    08235 940E 6A9F CALL	_SetMotRunPam
(0326) 			mainStep = 1;
    08237 E084      LDI	R24,4
    08238 838A      STD	Y+2,R24
    08239 E38C      LDI	R24,0x3C
(0327) 			RegisterCardStoreEvenProcess(CardStorePhotoAdj_Even);
    0823A 8388      ST	Y,R24
    0823B E820      LDI	R18,0x80
    0823C E00A      LDI	R16,0xA
    0823D 940E 6A9F CALL	_SetMotRunPam
(0328) 			break;
    0823F E084      LDI	R24,4
    08240 838A      STD	Y+2,R24
    08241 E38C      LDI	R24,0x3C
    08242 8388      ST	Y,R24
    08243 E820      LDI	R18,0x80
(0329) 		case 2:
(0330) 			Uart0ReUnable;
(0331) 			uart_Printf("%s $%4d\r\n",strM4112, CardStorePhoNum);
    08244 E00B      LDI	R16,0xB
    08245 940E 6A9F CALL	_SetMotRunPam
    08247 E086      LDI	R24,6
    08248 838A      STD	Y+2,R24
    08249 E38C      LDI	R24,0x3C
    0824A 8388      ST	Y,R24
    0824B E420      LDI	R18,0x40
    0824C E00C      LDI	R16,0xC
    0824D 940E 6A9F CALL	_SetMotRunPam
(0332) 			Uart0ReEnable;
    0824F 9623      ADIW	R28,3
    08250 9508      RET
_SetMaintianSubfunctionQuitFlag:
    08251 E081      LDI	R24,1
    08252 9380 17E0 STS	ControlModel+8,R24
(0333) 			mainStep = 0;
    08254 2700      CLR	R16
    08255 9508      RET
_SetNeedleOnMixPosFactor:
    08256 931A      ST	-Y,R17
(0334) 			return 1;
    08257 930A      ST	-Y,R16
    08258 9723      SBIW	R28,3
(0335) 			break;
(0336) 		default:
(0337) 			break;
(0338) 		}
(0339) 	return 0;
    08259 818B      LDD	R24,Y+3
    0825A 819C      LDD	R25,Y+4
    0825B 318E      CPI	R24,0x1E
    0825C E0E0      LDI	R30,0
    0825D 079E      CPC	R25,R30
_TurnPlateCheck:
    0825E F49C      BGE	0x8272
    0825F EE82      LDI	R24,0xE2
    08260 EF9F      LDI	R25,0xFF
(0340) }
(0341) unsigned char TurnPlateCheck(void){
(0342) 	// 转盘测试
(0343) 	if(WaitDelayTime(1))		return 0;
    08261 802B      LDD	R2,Y+3
    08262 803C      LDD	R3,Y+4
    08263 1582      CP	R24,R2
    08264 0593      CPC	R25,R3
    08265 F464      BGE	0x8272
    08266 E082      LDI	R24,2
    08267 E090      LDI	R25,0
(0344) 	if(waitMotor0){	if(GetMotState(MOT_TURN_PLATE)!=STA_SLAVE_FREE)	return 0;	waitMotor0 = 0;	}
    08268 8399      STD	Y+1,R25
    08269 8388      ST	Y,R24
    0826A 019E      MOVW	R18,R28
    0826B 5F2D      SUBI	R18,0xFD
    0826C 4F3F      SBCI	R19,0xFF
    0826D ED0C      LDI	R16,0xDC
    0826E E010      LDI	R17,0
    0826F 940E AF45 CALL	_EEPROMWriteBytes_extIO
    08271 C022      RJMP	0x8294
    08272 E081      LDI	R24,1
    08273 E090      LDI	R25,0
    08274 8399      STD	Y+1,R25
    08275 8388      ST	Y,R24
(0345) 
(0346) 	switch(mainStep){
    08276 019E      MOVW	R18,R28
    08277 5F2E      SUBI	R18,0xFE
    08278 4F3F      SBCI	R19,0xFF
    08279 ED0C      LDI	R16,0xDC
    0827A E010      LDI	R17,0
    0827B 940E AF2A CALL	_EEPROMReadBytes_extIO
    0827D 9180 00C1 LDS	R24,0xC1
    0827F 7E8F      ANDI	R24,0xEF
    08280 9380 00C1 STS	0xC1,R24
    08282 802A      LDD	R2,Y+2
    08283 2433      CLR	R3
    08284 FC27      SBRC	R2,7
    08285 9430      COM	R3
    08286 8239      STD	Y+1,R3
    08287 8228      ST	Y,R2
    08288 E125      LDI	R18,0x15
    08289 E136      LDI	R19,0x16
    0828A E50F      LDI	R16,0x5F
    0828B E019      LDI	R17,0x9
    0828C 940E A90D CALL	_uart_Printf
    0828E 9180 00C1 LDS	R24,0xC1
(0347) 		case 0:
(0348) 			SetMotRunPam(MOT_TURN_PLATE,120,10,CURRENT_TURN_PLATE);
    08290 6180      ORI	R24,0x10
    08291 9380 00C1 STS	0xC1,R24
    08293 C035      RJMP	0x82C9
    08294 E081      LDI	R24,1
    08295 E090      LDI	R25,0
    08296 8399      STD	Y+1,R25
(0349) 		//	MotRun(MOT_TURN_PLATE,8000);
(0350) 			MotInitCheck(MOT_TURN_PLATE);
    08297 8388      ST	Y,R24
    08298 019E      MOVW	R18,R28
    08299 5F2E      SUBI	R18,0xFE
(0351) 			waitMotor0 = 1;
    0829A 4F3F      SBCI	R19,0xFF
    0829B ED0C      LDI	R16,0xDC
    0829C E010      LDI	R17,0
(0352) 			mainStep = 1;
    0829D 940E AF2A CALL	_EEPROMReadBytes_extIO
(0353) 			break;
    0829F E18E      LDI	R24,0x1E
(0354) 		case 1:
(0355) 			SetDelayTime(1, 10);
    082A0 802A      LDD	R2,Y+2
    082A1 1582      CP	R24,R2
    082A2 F01C      BLT	0x82A6
    082A3 2D82      MOV	R24,R2
    082A4 3E82      CPI	R24,0xE2
(0356) 			mainStep = 2;
    082A5 F46C      BGE	0x82B3
    082A6 2422      CLR	R2
    082A7 822A      STD	Y+2,R2
(0357) 			subStep = 0;
    082A8 E081      LDI	R24,1
    082A9 E090      LDI	R25,0
    082AA 8399      STD	Y+1,R25
(0358) 			break;
    082AB 8388      ST	Y,R24
(0359) 		case 2:
(0360) 			subStep ++;
    082AC 019E      MOVW	R18,R28
    082AD 5F2E      SUBI	R18,0xFE
    082AE 4F3F      SBCI	R19,0xFF
    082AF ED0C      LDI	R16,0xDC
    082B0 E010      LDI	R17,0
(0361) 			if(subStep<30){
    082B1 940E AF45 CALL	_EEPROMWriteBytes_extIO
(0362) 				MotRunToSite(MOT_TURN_PLATE, subStep);
    082B3 9180 00C1 LDS	R24,0xC1
    082B5 7E8F      ANDI	R24,0xEF
    082B6 9380 00C1 STS	0xC1,R24
(0363) 				waitMotor0 = 1;
    082B8 802A      LDD	R2,Y+2
    082B9 2433      CLR	R3
(0364) 				mainStep = 3;
    082BA FC27      SBRC	R2,7
    082BB 9430      COM	R3
    082BC 8239      STD	Y+1,R3
(0365) 				}
    082BD 8228      ST	Y,R2
(0366) 			else{
(0367) 				waitMotor0 = 1;
    082BE E125      LDI	R18,0x15
    082BF E136      LDI	R19,0x16
    082C0 E50F      LDI	R16,0x5F
(0368) 				mainStep = 4;
    082C1 E019      LDI	R17,0x9
    082C2 940E A90D CALL	_uart_Printf
(0369) 				}
(0370) 			break;
    082C4 9180 00C1 LDS	R24,0xC1
(0371) 		case 3:
(0372) 			SetDelayTime(1, 5);
    082C6 6180      ORI	R24,0x10
    082C7 9380 00C1 STS	0xC1,R24
    082C9 9625      ADIW	R28,5
(0373) 			mainStep = 2;
    082CA 9508      RET
_GetNeedleOnMixCenterPos:
    082CB 934A      ST	-Y,R20
    082CC 935A      ST	-Y,R21
(0374) 			break;
    082CD 9723      SBIW	R28,3
(0375) 		case 4:
(0376) 			Uart0ReUnable;
    082CE E081      LDI	R24,1
    082CF E090      LDI	R25,0
    082D0 8399      STD	Y+1,R25
    082D1 8388      ST	Y,R24
    082D2 019E      MOVW	R18,R28
(0377) 			uart_Printf("%s\r\n",strM4120);
    082D3 5F2E      SUBI	R18,0xFE
    082D4 4F3F      SBCI	R19,0xFF
    082D5 ED0C      LDI	R16,0xDC
    082D6 E010      LDI	R17,0
    082D7 940E AF2A CALL	_EEPROMReadBytes_extIO
(0378) 			Uart0ReEnable;
    082D9 E18E      LDI	R24,0x1E
    082DA 802A      LDD	R2,Y+2
    082DB 1582      CP	R24,R2
    082DC F01C      BLT	0x82E0
    082DD 2D82      MOV	R24,R2
(0379) 			mainStep = 0;
    082DE 3E82      CPI	R24,0xE2
    082DF F46C      BGE	0x82ED
    082E0 2422      CLR	R2
(0380) 			return 1;
    082E1 822A      STD	Y+2,R2
    082E2 E081      LDI	R24,1
(0381) 			break;
(0382) 		default:
(0383) 			break;
(0384) 		}
(0385) 	return 0;
    082E3 E090      LDI	R25,0
    082E4 8399      STD	Y+1,R25
    082E5 8388      ST	Y,R24
    082E6 019E      MOVW	R18,R28
    082E7 5F2E      SUBI	R18,0xFE
_NeedleTurnCheck:
    082E8 4F3F      SBCI	R19,0xFF
    082E9 ED0C      LDI	R16,0xDC
    082EA E010      LDI	R17,0
(0386) }
(0387) 
(0388) unsigned char NeedleTurnCheck(void){
(0389) 	// 旋转臂测试
(0390) 	if(WaitDelayTime(1))		return 0;
    082EB 940E AF45 CALL	_EEPROMWriteBytes_extIO
    082ED 814A      LDD	R20,Y+2
    082EE 2755      CLR	R21
    082EF FD47      SBRC	R20,7
    082F0 9550      COM	R21
    082F1 5B4D      SUBI	R20,0xBD
(0391) 	if(waitMotor0){	if(GetMotState(MOT_SAMP_TRUN)!=STA_SLAVE_FREE)		return 0;	waitMotor0 = 0;	}
    082F2 4F5E      SBCI	R21,0xFE
    082F3 018A      MOVW	R16,R20
    082F4 9623      ADIW	R28,3
    082F5 9159      LD	R21,Y+
    082F6 9149      LD	R20,Y+
    082F7 9508      RET
_GetNeedleOnMixSidePos:
    082F8 934A      ST	-Y,R20
    082F9 935A      ST	-Y,R21
    082FA 9723      SBIW	R28,3
    082FB E081      LDI	R24,1
    082FC E090      LDI	R25,0
    082FD 8399      STD	Y+1,R25
    082FE 8388      ST	Y,R24
    082FF 019E      MOVW	R18,R28
(0392) 	if(waitMotor1){	if(GetMotState(MOT_SAMP_NEEDLE)!=STA_SLAVE_FREE)	return 0;	waitMotor1 = 0;	}
    08300 5F2E      SUBI	R18,0xFE
    08301 4F3F      SBCI	R19,0xFF
    08302 ED0C      LDI	R16,0xDC
    08303 E010      LDI	R17,0
    08304 940E AF2A CALL	_EEPROMReadBytes_extIO
    08306 E18E      LDI	R24,0x1E
    08307 802A      LDD	R2,Y+2
    08308 1582      CP	R24,R2
    08309 F01C      BLT	0x830D
    0830A 2D82      MOV	R24,R2
    0830B 3E82      CPI	R24,0xE2
    0830C F46C      BGE	0x831A
    0830D 2422      CLR	R2
    0830E 822A      STD	Y+2,R2
(0393) 
(0394) 	switch(mainStep){
    0830F E081      LDI	R24,1
    08310 E090      LDI	R25,0
    08311 8399      STD	Y+1,R25
    08312 8388      ST	Y,R24
    08313 019E      MOVW	R18,R28
    08314 5F2E      SUBI	R18,0xFE
    08315 4F3F      SBCI	R19,0xFF
    08316 ED0C      LDI	R16,0xDC
    08317 E010      LDI	R17,0
    08318 940E AF45 CALL	_EEPROMWriteBytes_extIO
    0831A 814A      LDD	R20,Y+2
    0831B 2755      CLR	R21
    0831C FD47      SBRC	R20,7
    0831D 9550      COM	R21
    0831E 5A41      SUBI	R20,0xA1
    0831F 4F5E      SBCI	R21,0xFE
    08320 018A      MOVW	R16,R20
    08321 9623      ADIW	R28,3
    08322 9159      LD	R21,Y+
    08323 9149      LD	R20,Y+
    08324 9508      RET
_SetDropHeightFactor:
    08325 931A      ST	-Y,R17
    08326 930A      ST	-Y,R16
    08327 9722      SBIW	R28,2
    08328 EC88      LDI	R24,0xC8
    08329 E090      LDI	R25,0
    0832A 802A      LDD	R2,Y+2
    0832B 803B      LDD	R3,Y+3
    0832C 1582      CP	R24,R2
    0832D 0593      CPC	R25,R3
    0832E F08C      BLT	0x8340
    0832F 01C1      MOVW	R24,R2
    08330 398C      CPI	R24,0x9C
    08331 EFEF      LDI	R30,0xFF
    08332 079E      CPC	R25,R30
    08333 F064      BLT	0x8340
    08334 E082      LDI	R24,2
    08335 E090      LDI	R25,0
    08336 8399      STD	Y+1,R25
    08337 8388      ST	Y,R24
    08338 019E      MOVW	R18,R28
    08339 5F2E      SUBI	R18,0xFE
    0833A 4F3F      SBCI	R19,0xFF
    0833B ED0D      LDI	R16,0xDD
    0833C E010      LDI	R17,0
    0833D 940E AF45 CALL	_EEPROMWriteBytes_extIO
(0395) 		case 0:
(0396) 			SetMotRunPam(MOT_SAMP_NEEDLE,240,10,CURRENT_SAMP_NEEDLE);
    0833F C021      RJMP	0x8361
    08340 E082      LDI	R24,2
    08341 E090      LDI	R25,0
    08342 8399      STD	Y+1,R25
    08343 8388      ST	Y,R24
    08344 ED2D      LDI	R18,0xDD
    08345 E137      LDI	R19,0x17
(0397) 			MotInitCheck(MOT_SAMP_NEEDLE);
    08346 ED0D      LDI	R16,0xDD
    08347 E010      LDI	R17,0
    08348 940E AF2A CALL	_EEPROMReadBytes_extIO
(0398) 			waitMotor1 = 1;
    0834A 9180 00C1 LDS	R24,0xC1
(0399) 			mainStep = 1;
    0834C 7E8F      ANDI	R24,0xEF
    0834D 9380 00C1 STS	0xC1,R24
(0400) 			break;
    0834F 9020 17DD LDS	R2,ControlModel+5
    08351 9030 17DE LDS	R3,ControlModel+6
    08353 8239      STD	Y+1,R3
    08354 8228      ST	Y,R2
    08355 E22E      LDI	R18,0x2E
    08356 E136      LDI	R19,0x16
(0401) 		case 1:
(0402) 			SetMotRunPam(MOT_SAMP_TRUN,120,40,CURRENT_SAMP_TRUN);
(0403) 			MotInitCheck(MOT_SAMP_TRUN);
    08357 E50F      LDI	R16,0x5F
    08358 E019      LDI	R17,0x9
    08359 940E A90D CALL	_uart_Printf
(0404) 			waitMotor0 = 1;
    0835B 9180 00C1 LDS	R24,0xC1
(0405) 			mainStep = 2;
    0835D 6180      ORI	R24,0x10
    0835E 9380 00C1 STS	0xC1,R24
(0406) 			break;
    08360 C03E      RJMP	0x839F
(0407) 		case 2:
(0408) 			SetDelayTime(1, 10);
    08361 E082      LDI	R24,2
    08362 E090      LDI	R25,0
    08363 8399      STD	Y+1,R25
    08364 8388      ST	Y,R24
    08365 ED2D      LDI	R18,0xDD
(0409) 			mainStep = 3;
    08366 E137      LDI	R19,0x17
    08367 ED0D      LDI	R16,0xDD
    08368 E010      LDI	R17,0
(0410) 			break;
    08369 940E AF2A CALL	_EEPROMReadBytes_extIO
(0411) 		case 3:
(0412) 			MotRunTo(MOT_SAMP_TRUN, _POS_NEEDLE_ON_MIXSIDE);
    0836B 9020 17DD LDS	R2,ControlModel+5
    0836D 9030 17DE LDS	R3,ControlModel+6
(0413) 			waitMotor0 = 1;
    0836F EC88      LDI	R24,0xC8
    08370 E090      LDI	R25,0
    08371 1582      CP	R24,R2
(0414) 			mainStep = 4;
    08372 0593      CPC	R25,R3
    08373 F02C      BLT	0x8379
    08374 01C1      MOVW	R24,R2
(0415) 		case 4:
(0416) 			SetDelayTime(1, 10);
    08375 398C      CPI	R24,0x9C
    08376 EFEF      LDI	R30,0xFF
    08377 079E      CPC	R25,R30
    08378 F484      BGE	0x8389
    08379 2422      CLR	R2
(0417) 			mainStep = 5;
    0837A 2433      CLR	R3
    0837B 9230 17DE STS	ControlModel+6,R3
(0418) 			break;
    0837D 9220 17DD STS	ControlModel+5,R2
(0419) 		case 5:
(0420) 			MotRunTo(MOT_SAMP_TRUN, _POS_SAMPTURN_SAMP);
    0837F E082      LDI	R24,2
    08380 E090      LDI	R25,0
    08381 8399      STD	Y+1,R25
    08382 8388      ST	Y,R24
(0421) 			waitMotor0 = 1;
    08383 ED2D      LDI	R18,0xDD
    08384 E137      LDI	R19,0x17
    08385 ED0D      LDI	R16,0xDD
(0422) 			mainStep = 6;
    08386 E010      LDI	R17,0
    08387 940E AF45 CALL	_EEPROMWriteBytes_extIO
(0423) 			break;
    08389 9180 00C1 LDS	R24,0xC1
(0424) 		case 6:
(0425) 			SetDelayTime(1, 10);
    0838B 7E8F      ANDI	R24,0xEF
    0838C 9380 00C1 STS	0xC1,R24
    0838E 9020 17DD LDS	R2,ControlModel+5
(0426) 			mainStep = 7;
    08390 9030 17DE LDS	R3,ControlModel+6
(0427) 			break;
    08392 8239      STD	Y+1,R3
(0428) 		case 7:
(0429) 			MotRunTo(MOT_SAMP_TRUN, 0);
    08393 8228      ST	Y,R2
    08394 E22E      LDI	R18,0x2E
    08395 E136      LDI	R19,0x16
    08396 E50F      LDI	R16,0x5F
    08397 E019      LDI	R17,0x9
(0430) 			waitMotor0 = 1;
    08398 940E A90D CALL	_uart_Printf
    0839A 9180 00C1 LDS	R24,0xC1
(0431) 			mainStep = 8;
    0839C 6180      ORI	R24,0x10
    0839D 9380 00C1 STS	0xC1,R24
(0432) 			break;
    0839F 9624      ADIW	R28,4
    083A0 9508      RET
_GetDropHeight:
    083A1 934A      ST	-Y,R20
    083A2 935A      ST	-Y,R21
    083A3 9724      SBIW	R28,4
(0433) 		case 8:
(0434) 			Uart0ReUnable;
(0435) 			uart_Printf("%s\r\n",strM4121);
    083A4 E082      LDI	R24,2
    083A5 E090      LDI	R25,0
    083A6 8399      STD	Y+1,R25
    083A7 8388      ST	Y,R24
    083A8 019E      MOVW	R18,R28
    083A9 5F2E      SUBI	R18,0xFE
(0436) 			Uart0ReEnable;
    083AA 4F3F      SBCI	R19,0xFF
    083AB ED0D      LDI	R16,0xDD
    083AC E010      LDI	R17,0
    083AD 940E AF2A CALL	_EEPROMReadBytes_extIO
(0437) 			mainStep = 0;
    083AF EC88      LDI	R24,0xC8
    083B0 E090      LDI	R25,0
    083B1 802A      LDD	R2,Y+2
(0438) 			return 1;
    083B2 803B      LDD	R3,Y+3
    083B3 1582      CP	R24,R2
(0439) 			break;
(0440) 		default:
(0441) 			break;
(0442) 		}
(0443) 	return 0;
    083B4 0593      CPC	R25,R3
    083B5 F02C      BLT	0x83BB
    083B6 01C1      MOVW	R24,R2
    083B7 398C      CPI	R24,0x9C
    083B8 EFEF      LDI	R30,0xFF
_NeedleUpdownCheck:
    083B9 079E      CPC	R25,R30
    083BA F52C      BGE	0x83E0
    083BB 2422      CLR	R2
(0444) }
(0445) 
(0446) unsigned char NeedleUpdownCheck(void){
(0447) 	// 取样针上下运行测试
(0448) 	if(WaitDelayTime(1))		return 0;
    083BC 2433      CLR	R3
    083BD 823B      STD	Y+3,R3
    083BE 822A      STD	Y+2,R2
    083BF E082      LDI	R24,2
    083C0 E090      LDI	R25,0
    083C1 8399      STD	Y+1,R25
    083C2 8388      ST	Y,R24
(0449) 	if(waitMotor0){	if(GetMotState(MOT_SAMP_TRUN)!=STA_SLAVE_FREE)		return 0;	waitMotor0 = 0;	}
    083C3 019E      MOVW	R18,R28
    083C4 5F2E      SUBI	R18,0xFE
    083C5 4F3F      SBCI	R19,0xFF
    083C6 ED0D      LDI	R16,0xDD
    083C7 E010      LDI	R17,0
    083C8 940E AF45 CALL	_EEPROMWriteBytes_extIO
    083CA 9180 00C1 LDS	R24,0xC1
    083CC 7E8F      ANDI	R24,0xEF
    083CD 9380 00C1 STS	0xC1,R24
    083CF 9020 17DD LDS	R2,ControlModel+5
(0450) 	if(waitMotor1){	if(GetMotState(MOT_SAMP_NEEDLE)!=STA_SLAVE_FREE)	return 0;	waitMotor1 = 0;	}
    083D1 9030 17DE LDS	R3,ControlModel+6
    083D3 8239      STD	Y+1,R3
    083D4 8228      ST	Y,R2
    083D5 ED29      LDI	R18,0xD9
    083D6 E135      LDI	R19,0x15
    083D7 E50F      LDI	R16,0x5F
    083D8 E019      LDI	R17,0x9
    083D9 940E A90D CALL	_uart_Printf
    083DB 9180 00C1 LDS	R24,0xC1
    083DD 6180      ORI	R24,0x10
    083DE 9380 00C1 STS	0xC1,R24
(0451) 
(0452) 	switch(mainStep){
    083E0 814A      LDD	R20,Y+2
    083E1 815B      LDD	R21,Y+3
    083E2 5844      SUBI	R20,0x84
    083E3 4F5E      SBCI	R21,0xFE
    083E4 018A      MOVW	R16,R20
    083E5 9624      ADIW	R28,4
    083E6 9159      LD	R21,Y+
    083E7 9149      LD	R20,Y+
    083E8 9508      RET
_SetMixHeight:
    083E9 931A      ST	-Y,R17
    083EA 930A      ST	-Y,R16
    083EB 9723      SBIW	R28,3
    083EC E684      LDI	R24,0x64
    083ED 802B      LDD	R2,Y+3
    083EE 1582      CP	R24,R2
    083EF F074      BLT	0x83FE
    083F0 2D82      MOV	R24,R2
    083F1 398C      CPI	R24,0x9C
    083F2 F05C      BLT	0x83FE
    083F3 E081      LDI	R24,1
    083F4 E090      LDI	R25,0
    083F5 8399      STD	Y+1,R25
    083F6 8388      ST	Y,R24
    083F7 019E      MOVW	R18,R28
    083F8 5F2D      SUBI	R18,0xFD
    083F9 4F3F      SBCI	R19,0xFF
    083FA ED0E      LDI	R16,0xDE
    083FB E010      LDI	R17,0
    083FC 940E AF45 CALL	_EEPROMWriteBytes_extIO
    083FE E081      LDI	R24,1
    083FF E090      LDI	R25,0
    08400 8399      STD	Y+1,R25
    08401 8388      ST	Y,R24
    08402 019E      MOVW	R18,R28
    08403 5F2E      SUBI	R18,0xFE
    08404 4F3F      SBCI	R19,0xFF
    08405 ED0E      LDI	R16,0xDE
    08406 E010      LDI	R17,0
    08407 940E AF2A CALL	_EEPROMReadBytes_extIO
    08409 E684      LDI	R24,0x64
    0840A 802A      LDD	R2,Y+2
    0840B 1582      CP	R24,R2
    0840C F01C      BLT	0x8410
    0840D 2D82      MOV	R24,R2
    0840E 398C      CPI	R24,0x9C
    0840F F46C      BGE	0x841D
    08410 2422      CLR	R2
    08411 822A      STD	Y+2,R2
    08412 E081      LDI	R24,1
    08413 E090      LDI	R25,0
    08414 8399      STD	Y+1,R25
(0453) 		case 0:
(0454) 			SetMotRunPam(MOT_SAMP_NEEDLE,240,10,CURRENT_SAMP_NEEDLE);
    08415 8388      ST	Y,R24
    08416 019E      MOVW	R18,R28
    08417 5F2E      SUBI	R18,0xFE
    08418 4F3F      SBCI	R19,0xFF
    08419 ED0E      LDI	R16,0xDE
    0841A E010      LDI	R17,0
    0841B 940E AF45 CALL	_EEPROMWriteBytes_extIO
(0455) 			MotInitCheck(MOT_SAMP_NEEDLE);
    0841D 810A      LDD	R16,Y+2
    0841E 9625      ADIW	R28,5
    0841F 9508      RET
(0456) 			waitMotor1 = 1;
_GetMixHeight:
    08420 934A      ST	-Y,R20
    08421 935A      ST	-Y,R21
    08422 9723      SBIW	R28,3
(0457) 			mainStep = 1;
    08423 E081      LDI	R24,1
    08424 E090      LDI	R25,0
(0458) 			break;
    08425 8399      STD	Y+1,R25
(0459) 		case 1:
(0460) 			SetMotRunPam(MOT_SAMP_TRUN,120,10,CURRENT_SAMP_TRUN);
    08426 8388      ST	Y,R24
    08427 019E      MOVW	R18,R28
    08428 5F2E      SUBI	R18,0xFE
    08429 4F3F      SBCI	R19,0xFF
    0842A ED0E      LDI	R16,0xDE
    0842B E010      LDI	R17,0
    0842C 940E AF2A CALL	_EEPROMReadBytes_extIO
(0461) 			MotInitCheck(MOT_SAMP_TRUN);
    0842E E684      LDI	R24,0x64
    0842F 802A      LDD	R2,Y+2
    08430 1582      CP	R24,R2
(0462) 			waitMotor0 = 1;
    08431 F01C      BLT	0x8435
    08432 2D82      MOV	R24,R2
    08433 398C      CPI	R24,0x9C
(0463) 			mainStep = 2;
    08434 F46C      BGE	0x8442
    08435 2422      CLR	R2
    08436 822A      STD	Y+2,R2
(0464) 			break;
    08437 E081      LDI	R24,1
(0465) 		case 2:
(0466) 			SetDelayTime(1, 10);
    08438 E090      LDI	R25,0
    08439 8399      STD	Y+1,R25
    0843A 8388      ST	Y,R24
    0843B 019E      MOVW	R18,R28
    0843C 5F2E      SUBI	R18,0xFE
(0467) 			mainStep = 3;
    0843D 4F3F      SBCI	R19,0xFF
    0843E ED0E      LDI	R16,0xDE
    0843F E010      LDI	R17,0
(0468) 			break;
    08440 940E AF45 CALL	_EEPROMWriteBytes_extIO
(0469) 		case 3:
(0470) 			MotRunTo(MOT_SAMP_TRUN, _POS_SAMPTURN_SAMP);
    08442 814A      LDD	R20,Y+2
    08443 2755      CLR	R21
    08444 FD47      SBRC	R20,7
    08445 9550      COM	R21
(0471) 			waitMotor0 = 1;
    08446 5740      SUBI	R20,0x70
    08447 4F5E      SBCI	R21,0xFE
    08448 018A      MOVW	R16,R20
(0472) 			mainStep = 4;
    08449 9623      ADIW	R28,3
    0844A 9159      LD	R21,Y+
    0844B 9149      LD	R20,Y+
(0473) 		case 4:
(0474) 			SetDelayTime(1, 10);
    0844C 9508      RET
_CardLoadStartAdjust:
    0844D 934A      ST	-Y,R20
    0844E 935A      ST	-Y,R21
    0844F 9723      SBIW	R28,3
    08450 9020 08ED LDS	R2,PacketState+237
(0475) 			mainStep = 5;
    08452 2022      TST	R2
    08453 F051      BEQ	0x845E
(0476) 			break;
    08454 E004      LDI	R16,4
(0477) 		case 5:
(0478) 			MotRunTo(MOT_SAMP_NEEDLE, _POS_SAMP_DOWN);
    08455 940E 6A0C CALL	_GetMotState
    08457 3001      CPI	R16,1
    08458 F011      BEQ	0x845B
    08459 2700      CLR	R16
(0479) 			waitMotor1 = 1;
    0845A C035      RJMP	0x8490
    0845B 2422      CLR	R2
    0845C 9220 08ED STS	PacketState+237,R2
(0480) 			mainStep = 6;
    0845E 9140 08EA LDS	R20,PacketState+234
(0481) 			break;
    08460 2755      CLR	R21
(0482) 		case 6:
(0483) 			SetDelayTime(1, 10);
    08461 3040      CPI	R20,0
    08462 0745      CPC	R20,R21
    08463 F029      BEQ	0x8469
    08464 3041      CPI	R20,1
    08465 E0E0      LDI	R30,0
(0484) 			mainStep = 7;
    08466 075E      CPC	R21,R30
    08467 F091      BEQ	0x847A
    08468 C026      RJMP	0x848F
(0485) 			break;
    08469 E084      LDI	R24,4
(0486) 		case 7:
(0487) 			MotRunTo(MOT_SAMP_NEEDLE, 0);
    0846A 838A      STD	Y+2,R24
    0846B E184      LDI	R24,0x14
    0846C 8388      ST	Y,R24
    0846D E420      LDI	R18,0x40
    0846E E004      LDI	R16,4
(0488) 			waitMotor1 = 1;
    0846F 940E 6A9F CALL	_SetMotRunPam
    08471 E004      LDI	R16,4
(0489) 			mainStep = 8;
    08472 940E 6AFA CALL	_MotInitCheck
    08474 E081      LDI	R24,1
(0490) 			break;
    08475 9380 08ED STS	PacketState+237,R24
(0491) 		case 8:
(0492) 			MotRunTo(MOT_SAMP_TRUN, 0);
    08477 9380 08EA STS	PacketState+234,R24
    08479 C015      RJMP	0x848F
    0847A 9180 00C1 LDS	R24,0xC1
(0493) 			waitMotor0 = 1;
    0847C 7E8F      ANDI	R24,0xEF
    0847D 9380 00C1 STS	0xC1,R24
(0494) 			mainStep = 9;
    0847F E426      LDI	R18,0x46
    08480 E136      LDI	R19,0x16
(0495) 			break;
    08481 E50A      LDI	R16,0x5A
(0496) 		case 9:
(0497) 			Uart0ReUnable;
    08482 E019      LDI	R17,0x9
    08483 940E A90D CALL	_uart_Printf
    08485 9180 00C1 LDS	R24,0xC1
(0498) 			uart_Printf("%s\r\n",strM4122);
    08487 6180      ORI	R24,0x10
    08488 9380 00C1 STS	0xC1,R24
    0848A 2422      CLR	R2
    0848B 9220 08EA STS	PacketState+234,R2
(0499) 			Uart0ReEnable;
    0848D E001      LDI	R16,1
    0848E C001      RJMP	0x8490
    0848F 2700      CLR	R16
    08490 9623      ADIW	R28,3
    08491 9159      LD	R21,Y+
(0500) 			mainStep = 0;
    08492 9149      LD	R20,Y+
    08493 9508      RET
_CardLoadEndAdjust:
    08494 934A      ST	-Y,R20
(0501) 			return 1;
    08495 935A      ST	-Y,R21
    08496 9723      SBIW	R28,3
(0502) 			break;
(0503) 		default:
(0504) 			break;
(0505) 		}
(0506) 	return 0;
    08497 9020 08ED LDS	R2,PacketState+237
    08499 2022      TST	R2
    0849A F051      BEQ	0x84A5
    0849B E004      LDI	R16,4
_CardStoreMoveCheck:
    0849C 940E 6A0C CALL	_GetMotState
    0849E 3001      CPI	R16,1
(0507) }
(0508) 
(0509) unsigned char CardStoreMoveCheck(void){
(0510) 	// 片仓小车运行测试
(0511) 	if(WaitDelayTime(1))		return 0;
    0849F F011      BEQ	0x84A2
    084A0 2700      CLR	R16
    084A1 C037      RJMP	0x84D9
    084A2 2422      CLR	R2
    084A3 9220 08ED STS	PacketState+237,R2
    084A5 9140 08EA LDS	R20,PacketState+234
(0512) 	if(waitMotor0){	if(GetMotState(MOT_STORE_CARD_MOVE)!=STA_SLAVE_FREE)		return 0;	waitMotor0 = 0;	}
    084A7 2755      CLR	R21
    084A8 3040      CPI	R20,0
    084A9 0745      CPC	R20,R21
    084AA F029      BEQ	0x84B0
    084AB 3041      CPI	R20,1
    084AC E0E0      LDI	R30,0
    084AD 075E      CPC	R21,R30
    084AE F0A1      BEQ	0x84C3
    084AF C028      RJMP	0x84D8
    084B0 E084      LDI	R24,4
    084B1 838A      STD	Y+2,R24
    084B2 E184      LDI	R24,0x14
    084B3 8388      ST	Y,R24
(0513) 
(0514) 	switch(mainStep){
    084B4 E420      LDI	R18,0x40
    084B5 E004      LDI	R16,4
    084B6 940E 6A9F CALL	_SetMotRunPam
    084B8 E420      LDI	R18,0x40
    084B9 E036      LDI	R19,6
    084BA E004      LDI	R16,4
    084BB 940E 6B1D CALL	_MotAdjustPosition
    084BD E081      LDI	R24,1
    084BE 9380 08ED STS	PacketState+237,R24
    084C0 9380 08EA STS	PacketState+234,R24
    084C2 C015      RJMP	0x84D8
    084C3 9180 00C1 LDS	R24,0xC1
    084C5 7E8F      ANDI	R24,0xEF
    084C6 9380 00C1 STS	0xC1,R24
    084C8 E625      LDI	R18,0x65
    084C9 E136      LDI	R19,0x16
    084CA E50A      LDI	R16,0x5A
    084CB E019      LDI	R17,0x9
    084CC 940E A90D CALL	_uart_Printf
    084CE 9180 00C1 LDS	R24,0xC1
(0515) 		case 0:
(0516) 			SetMotRunPam(MOT_STORE_CARD_MOVE,160,10,CURRENT_STORE_MOVE);
    084D0 6180      ORI	R24,0x10
    084D1 9380 00C1 STS	0xC1,R24
    084D3 2422      CLR	R2
    084D4 9220 08EA STS	PacketState+234,R2
(0517) 			MotInitCheck(MOT_STORE_CARD_MOVE);
    084D6 E001      LDI	R16,1
    084D7 C001      RJMP	0x84D9
    084D8 2700      CLR	R16
(0518) 			waitMotor0 = 1;
    084D9 9623      ADIW	R28,3
    084DA 9159      LD	R21,Y+
    084DB 9149      LD	R20,Y+
(0519) 			mainStep = 1;
    084DC 9508      RET
_CardUnloadStartAdjust:
    084DD 934A      ST	-Y,R20
(0520) 			break;
    084DE 935A      ST	-Y,R21
(0521) 		case 1:
(0522) 			SetDelayTime(1, 10);
    084DF 9723      SBIW	R28,3
    084E0 9020 08ED LDS	R2,PacketState+237
    084E2 2022      TST	R2
    084E3 F051      BEQ	0x84EE
(0523) 			mainStep = 2;
    084E4 E005      LDI	R16,5
    084E5 940E 6A0C CALL	_GetMotState
(0524) 			break;
    084E7 3001      CPI	R16,1
(0525) 		case 2:
(0526) 			MotRunTo(MOT_STORE_CARD_MOVE, 2550);
    084E8 F011      BEQ	0x84EB
    084E9 2700      CLR	R16
    084EA C035      RJMP	0x8520
    084EB 2422      CLR	R2
    084EC 9220 08ED STS	PacketState+237,R2
(0527) 			waitMotor0 = 1;
    084EE 9140 08EA LDS	R20,PacketState+234
(0528) 			mainStep = 3;
    084F0 2755      CLR	R21
    084F1 3040      CPI	R20,0
    084F2 0745      CPC	R20,R21
(0529) 		case 3:
(0530) 			SetDelayTime(1, 10);
    084F3 F029      BEQ	0x84F9
    084F4 3041      CPI	R20,1
    084F5 E0E0      LDI	R30,0
    084F6 075E      CPC	R21,R30
    084F7 F091      BEQ	0x850A
(0531) 			mainStep = 4;
    084F8 C026      RJMP	0x851F
    084F9 E084      LDI	R24,4
    084FA 838A      STD	Y+2,R24
(0532) 			break;
    084FB E184      LDI	R24,0x14
(0533) 		case 4:
(0534) 			MotRunTo(MOT_STORE_CARD_MOVE, 0);
    084FC 8388      ST	Y,R24
    084FD E420      LDI	R18,0x40
    084FE E005      LDI	R16,5
    084FF 940E 6A9F CALL	_SetMotRunPam
(0535) 			waitMotor0 = 1;
    08501 E005      LDI	R16,5
    08502 940E 6AFA CALL	_MotInitCheck
(0536) 			mainStep = 5;
    08504 E081      LDI	R24,1
    08505 9380 08ED STS	PacketState+237,R24
(0537) 			break;
    08507 9380 08EA STS	PacketState+234,R24
(0538) 		case 5:
(0539) 			Uart0ReUnable;
    08509 C015      RJMP	0x851F
    0850A 9180 00C1 LDS	R24,0xC1
    0850C 7E8F      ANDI	R24,0xEF
(0540) 			uart_Printf("%s\r\n",strM4123);
    0850D 9380 00C1 STS	0xC1,R24
    0850F E821      LDI	R18,0x81
    08510 E136      LDI	R19,0x16
    08511 E50A      LDI	R16,0x5A
    08512 E019      LDI	R17,0x9
(0541) 			Uart0ReEnable;
    08513 940E A90D CALL	_uart_Printf
    08515 9180 00C1 LDS	R24,0xC1
    08517 6180      ORI	R24,0x10
(0542) 			mainStep = 0;
    08518 9380 00C1 STS	0xC1,R24
    0851A 2422      CLR	R2
(0543) 			return 1;
    0851B 9220 08EA STS	PacketState+234,R2
(0544) 			break;
(0545) 		default:
(0546) 			break;
(0547) 		}
(0548) 	return 0;
    0851D E001      LDI	R16,1
    0851E C001      RJMP	0x8520
    0851F 2700      CLR	R16
    08520 9623      ADIW	R28,3
    08521 9159      LD	R21,Y+
_CardTakeHookCheck:
    08522 9149      LD	R20,Y+
    08523 9508      RET
_CardUnloadEndAdjust:
    08524 934A      ST	-Y,R20
(0549) }
(0550) 
(0551) unsigned char CardTakeHookCheck(void){
(0552) 	// 片仓取片钩子运行测试
(0553) 	if(WaitDelayTime(1))		return 0;
    08525 935A      ST	-Y,R21
    08526 9723      SBIW	R28,3
    08527 9020 08ED LDS	R2,PacketState+237
    08529 2022      TST	R2
    0852A F051      BEQ	0x8535
    0852B E005      LDI	R16,5
(0554) 	if(waitMotor0){	if(GetMotState(MOT_STORE_CARD_MOVE)!=STA_SLAVE_FREE)		return 0;	waitMotor0 = 0;	}
    0852C 940E 6A0C CALL	_GetMotState
    0852E 3001      CPI	R16,1
    0852F F011      BEQ	0x8532
    08530 2700      CLR	R16
    08531 C037      RJMP	0x8569
    08532 2422      CLR	R2
    08533 9220 08ED STS	PacketState+237,R2
    08535 9140 08EA LDS	R20,PacketState+234
    08537 2755      CLR	R21
    08538 3040      CPI	R20,0
    08539 0745      CPC	R20,R21
(0555) 
(0556) 	switch(mainStep){
    0853A F029      BEQ	0x8540
    0853B 3041      CPI	R20,1
    0853C E0E0      LDI	R30,0
    0853D 075E      CPC	R21,R30
    0853E F0A1      BEQ	0x8553
    0853F C028      RJMP	0x8568
    08540 E084      LDI	R24,4
    08541 838A      STD	Y+2,R24
    08542 E184      LDI	R24,0x14
    08543 8388      ST	Y,R24
    08544 E420      LDI	R18,0x40
    08545 E005      LDI	R16,5
    08546 940E 6A9F CALL	_SetMotRunPam
    08548 E420      LDI	R18,0x40
    08549 E036      LDI	R19,6
    0854A E005      LDI	R16,5
    0854B 940E 6B1D CALL	_MotAdjustPosition
    0854D E081      LDI	R24,1
    0854E 9380 08ED STS	PacketState+237,R24
    08550 9380 08EA STS	PacketState+234,R24
    08552 C015      RJMP	0x8568
    08553 9180 00C1 LDS	R24,0xC1
    08555 7E8F      ANDI	R24,0xEF
    08556 9380 00C1 STS	0xC1,R24
    08558 EA22      LDI	R18,0xA2
    08559 E136      LDI	R19,0x16
    0855A E50A      LDI	R16,0x5A
    0855B E019      LDI	R17,0x9
    0855C 940E A90D CALL	_uart_Printf
    0855E 9180 00C1 LDS	R24,0xC1
    08560 6180      ORI	R24,0x10
    08561 9380 00C1 STS	0xC1,R24
(0557) 		case 0:
(0558) 			SetMotRunPam(MOT_STORE_CARD_MOVE,160,10,CURRENT_STORE_MOVE);
    08563 2422      CLR	R2
    08564 9220 08EA STS	PacketState+234,R2
    08566 E001      LDI	R16,1
    08567 C001      RJMP	0x8569
    08568 2700      CLR	R16
    08569 9623      ADIW	R28,3
(0559) 			MotInitCheck(MOT_STORE_CARD_MOVE);
    0856A 9159      LD	R21,Y+
    0856B 9149      LD	R20,Y+
    0856C 9508      RET
(0560) 			waitMotor0 = 1;
_SetLiquidPhotoAdjustNum:
    0856D E082      LDI	R24,2
    0856E 1780      CP	R24,R16
    0856F F408      BCC	0x8571
(0561) 			mainStep = 1;
    08570 E002      LDI	R16,2
    08571 9300 17DC STS	ControlModel+4,R16
(0562) 			break;
    08573 9508      RET
_LiquidPhotoAdj_Even:
    08574 940E AE8D CALL	push_xgsetF000
    08576 01A8      MOVW	R20,R16
    08577 9726      SBIW	R28,6
(0563) 		case 1:
(0564) 			SetDelayTime(1, 5);
(0565) 			mainStep = 2;
    08578 9160 08EA LDS	R22,PacketState+234
    0857A 2777      CLR	R23
(0566) 			break;
    0857B 3061      CPI	R22,1
(0567) 		case 2:
(0568) 			MotRunTo(MOT_STORE_CARD_MOVE, CalCardStorePos(1));
    0857C E0E0      LDI	R30,0
    0857D 077E      CPC	R23,R30
    0857E F009      BEQ	0x8580
    0857F C02E      RJMP	0x85AE
    08580 01FA      MOVW	R30,R20
    08581 8181      LDD	R24,Z+1
    08582 308B      CPI	R24,0xB
    08583 F551      BNE	0x85AE
    08584 5F4E      SUBI	R20,0xFE
(0569) 			waitMotor0 = 1;
    08585 4F5F      SBCI	R21,0xFF
    08586 9020 17DC LDS	R2,ControlModel+4
(0570) 			mainStep = 3;
    08588 01FA      MOVW	R30,R20
    08589 8030      LD	R3,Z
    0858A 1432      CP	R3,R2
(0571) 		case 3:
(0572) 			SetDelayTime(1, 5);
    0858B F511      BNE	0x85AE
    0858C 9180 00C1 LDS	R24,0xC1
    0858E 7E8F      ANDI	R24,0xEF
    0858F 9380 00C1 STS	0xC1,R24
(0573) 			mainStep = 4;
    08591 8022      LDD	R2,Z+2
    08592 2433      CLR	R3
(0574) 			break;
    08593 823D      STD	Y+5,R3
(0575) 		case 4:
(0576) 			SetCardTrolleyState(1);	// 钩片抬起
    08594 822C      STD	Y+4,R2
    08595 8021      LDD	R2,Z+1
    08596 2433      CLR	R3
(0577) 			SetDelayTime(1, 20);
    08597 823B      STD	Y+3,R3
    08598 822A      STD	Y+2,R2
    08599 9020 17DC LDS	R2,ControlModel+4
    0859B 2433      CLR	R3
(0578) 			mainStep = 5;
    0859C 8239      STD	Y+1,R3
    0859D 8228      ST	Y,R2
    0859E EC20      LDI	R18,0xC0
(0579) 			break;
    0859F E136      LDI	R19,0x16
(0580) 		case 5:
(0581) 			SetCardTrolleyState(0);
    085A0 E30A      LDI	R16,0x3A
    085A1 E019      LDI	R17,0x9
    085A2 940E A90D CALL	_uart_Printf
(0582) 			SetDelayTime(1, 5);
    085A4 9180 00C1 LDS	R24,0xC1
    085A6 6180      ORI	R24,0x10
    085A7 9380 00C1 STS	0xC1,R24
(0583) 			mainStep = 6;
    085A9 E082      LDI	R24,2
    085AA 9380 08EA STS	PacketState+234,R24
(0584) 			break;
    085AC E001      LDI	R16,1
    085AD C001      RJMP	0x85AF
    085AE 2700      CLR	R16
    085AF 9626      ADIW	R28,6
    085B0 940C AE92 JMP	pop_xgsetF000
(0585) 		case 6:
(0586) 			MotRunTo(MOT_STORE_CARD_MOVE, 0);
(0587) 			waitMotor0 = 1;
_LiquidPhotoAdjust:
    085B2 934A      ST	-Y,R20
    085B3 935A      ST	-Y,R21
(0588) 			mainStep = 7;
    085B4 9722      SBIW	R28,2
    085B5 9140 08EA LDS	R20,PacketState+234
(0589) 			break;
    085B7 2755      CLR	R21
(0590) 		case 7:
(0591) 			Uart0ReUnable;
    085B8 3040      CPI	R20,0
    085B9 0745      CPC	R20,R21
    085BA F029      BEQ	0x85C0
    085BB 3042      CPI	R20,2
    085BC E0E0      LDI	R30,0
(0592) 			uart_Printf("%s\r\n",strM4124);
    085BD 075E      CPC	R21,R30
    085BE F069      BEQ	0x85CC
    085BF C026      RJMP	0x85E6
    085C0 9100 17DC LDS	R16,ControlModel+4
    085C2 940E 6BFB CALL	_SetLiquidPhotoAdjust
(0593) 			Uart0ReEnable;
    085C4 E081      LDI	R24,1
    085C5 9380 08EA STS	PacketState+234,R24
    085C7 EF06      LDI	R16,0xF6
(0594) 			mainStep = 0;
    085C8 E014      LDI	R17,4
    085C9 940E 2DE3 CALL	_RegisterLiquidEvenProcess
(0595) 			return 1;
    085CB C01A      RJMP	0x85E6
    085CC 9180 00C1 LDS	R24,0xC1
(0596) 			break;
(0597) 		default:
(0598) 			break;
(0599) 		}
(0600) 	return 0;
    085CE 7E8F      ANDI	R24,0xEF
    085CF 9380 00C1 STS	0xC1,R24
_CardLoadCheck:
    085D1 9020 17DC LDS	R2,ControlModel+4
    085D3 2433      CLR	R3
(0601) }
(0602) 
(0603) unsigned char CardLoadCheck(void){
(0604) 	// 卡片装载小车运行测试
(0605) 	if(WaitDelayTime(1))		return 0;
    085D4 8239      STD	Y+1,R3
    085D5 8228      ST	Y,R2
    085D6 ED2E      LDI	R18,0xDE
    085D7 E136      LDI	R19,0x16
    085D8 E50F      LDI	R16,0x5F
    085D9 E019      LDI	R17,0x9
    085DA 940E A90D CALL	_uart_Printf
(0606) 	if(waitMotor0){	if(GetMotState(MOT_CARD_LOAD)!=STA_SLAVE_FREE)		return 0;	waitMotor0 = 0;	}
    085DC 9180 00C1 LDS	R24,0xC1
    085DE 6180      ORI	R24,0x10
    085DF 9380 00C1 STS	0xC1,R24
    085E1 2422      CLR	R2
    085E2 9220 08EA STS	PacketState+234,R2
    085E4 E001      LDI	R16,1
    085E5 C001      RJMP	0x85E7
    085E6 2700      CLR	R16
    085E7 9622      ADIW	R28,2
    085E8 9159      LD	R21,Y+
(0607) 
(0608) 	switch(mainStep){
    085E9 9149      LD	R20,Y+
    085EA 9508      RET
_SetCardStorePhotoAdjustNum:
    085EB E085      LDI	R24,5
    085EC 1780      CP	R24,R16
    085ED F408      BCC	0x85EF
    085EE E005      LDI	R16,5
    085EF 2300      TST	R16
    085F0 F409      BNE	0x85F2
    085F1 E001      LDI	R16,1
    085F2 9300 17DB STS	ControlModel+3,R16
    085F4 9508      RET
_CardStorePhotoAdj_Even:
    085F5 940E AE8D CALL	push_xgsetF000
    085F7 01A8      MOVW	R20,R16
    085F8 9728      SBIW	R28,0x8
    085F9 9160 08EA LDS	R22,PacketState+234
    085FB 2777      CLR	R23
    085FC 3061      CPI	R22,1
    085FD E0E0      LDI	R30,0
    085FE 077E      CPC	R23,R30
    085FF F009      BEQ	0x8601
    08600 C02C      RJMP	0x862D
    08601 01FA      MOVW	R30,R20
    08602 8181      LDD	R24,Z+1
    08603 318A      CPI	R24,0x1A
    08604 F541      BNE	0x862D
(0609) 		case 0:
(0610) 			SetMotRunPam(MOT_CARD_LOAD,100,20,CURRENT_CARD_LOAD);
    08605 5F4E      SUBI	R20,0xFE
    08606 4F5F      SBCI	R21,0xFF
    08607 9180 00C1 LDS	R24,0xC1
    08609 7E8F      ANDI	R24,0xEF
    0860A 9380 00C1 STS	0xC1,R24
    0860C 01FA      MOVW	R30,R20
(0611) 			MotInitCheck(MOT_CARD_LOAD);
    0860D 8023      LDD	R2,Z+3
    0860E 2433      CLR	R3
    0860F 823F      STD	Y+7,R3
(0612) 			waitMotor0 = 1;
    08610 822E      STD	Y+6,R2
    08611 8022      LDD	R2,Z+2
    08612 2433      CLR	R3
(0613) 			mainStep = 1;
    08613 823D      STD	Y+5,R3
    08614 822C      STD	Y+4,R2
(0614) 			break;
    08615 8021      LDD	R2,Z+1
(0615) 		case 1:
(0616) 			SetDelayTime(1, 10);
    08616 2433      CLR	R3
    08617 823B      STD	Y+3,R3
    08618 822A      STD	Y+2,R2
    08619 8020      LD	R2,Z
    0861A 2433      CLR	R3
(0617) 			mainStep = 2;
    0861B 8239      STD	Y+1,R3
    0861C 8228      ST	Y,R2
    0861D EF2A      LDI	R18,0xFA
(0618) 			break;
    0861E E136      LDI	R19,0x16
(0619) 		case 2:
(0620) 			MotRunTo(MOT_CARD_LOAD,_POS_CARDLOAD_RING);
    0861F E201      LDI	R16,0x21
    08620 E019      LDI	R17,0x9
    08621 940E A90D CALL	_uart_Printf
    08623 9180 00C1 LDS	R24,0xC1
(0621) 			waitMotor0 = 1;
    08625 6180      ORI	R24,0x10
    08626 9380 00C1 STS	0xC1,R24
(0622) 			mainStep = 3;
    08628 E082      LDI	R24,2
    08629 9380 08EA STS	PacketState+234,R24
(0623) 		case 3:
(0624) 			SetDelayTime(1, 10);
    0862B E001      LDI	R16,1
    0862C C001      RJMP	0x862E
    0862D 2700      CLR	R16
    0862E 9628      ADIW	R28,0x8
(0625) 			mainStep = 4;
    0862F 940C AE92 JMP	pop_xgsetF000
_CardStorePhotoAdjust:
    08631 934A      ST	-Y,R20
(0626) 			break;
    08632 935A      ST	-Y,R21
(0627) 		case 4:
(0628) 			MotRunTo(MOT_CARD_LOAD, 0);
    08633 9722      SBIW	R28,2
    08634 9140 08EA LDS	R20,PacketState+234
    08636 2755      CLR	R21
    08637 3040      CPI	R20,0
(0629) 			waitMotor0 = 1;
    08638 0745      CPC	R20,R21
    08639 F029      BEQ	0x863F
    0863A 3042      CPI	R20,2
(0630) 			mainStep = 5;
    0863B E0E0      LDI	R30,0
    0863C 075E      CPC	R21,R30
    0863D F069      BEQ	0x864B
(0631) 			break;
    0863E C026      RJMP	0x8665
(0632) 		case 5:
(0633) 			Uart0ReUnable;
    0863F 9100 17DB LDS	R16,ControlModel+3
    08641 940E 6C43 CALL	_SetStoreCAL
    08643 E081      LDI	R24,1
(0634) 			uart_Printf("%s\r\n",strM4125);
    08644 9380 08EA STS	PacketState+234,R24
    08646 EF04      LDI	R16,0xF4
    08647 E014      LDI	R17,4
    08648 940E 2DEF CALL	_RegisterCardStoreEvenProcess
(0635) 			Uart0ReEnable;
    0864A C01A      RJMP	0x8665
    0864B 9180 00C1 LDS	R24,0xC1
    0864D 7E8F      ANDI	R24,0xEF
    0864E 9380 00C1 STS	0xC1,R24
(0636) 			mainStep = 0;
    08650 9020 17DB LDS	R2,ControlModel+3
(0637) 			return 1;
    08652 2433      CLR	R3
    08653 8239      STD	Y+1,R3
(0638) 			break;
(0639) 		default:
(0640) 			break;
(0641) 		}
(0642) 	return 0;
    08654 8228      ST	Y,R2
    08655 E12B      LDI	R18,0x1B
    08656 E137      LDI	R19,0x17
    08657 E50F      LDI	R16,0x5F
    08658 E019      LDI	R17,0x9
_CardUnloadCheck:
    08659 940E A90D CALL	_uart_Printf
    0865B 9180 00C1 LDS	R24,0xC1
(0643) }
(0644) 
(0645) unsigned char CardUnloadCheck(void){
(0646) 	// 卡片卸载小车运行测试
(0647) 	if(WaitDelayTime(1))		return 0;
    0865D 6180      ORI	R24,0x10
    0865E 9380 00C1 STS	0xC1,R24
    08660 2422      CLR	R2
    08661 9220 08EA STS	PacketState+234,R2
(0648) 	if(waitMotor0){	if(GetMotState(MOT_CARD_UNLOAD)!=STA_SLAVE_FREE)		return 0;	waitMotor0 = 0;	}
    08663 E001      LDI	R16,1
    08664 C001      RJMP	0x8666
    08665 2700      CLR	R16
    08666 9622      ADIW	R28,2
    08667 9159      LD	R21,Y+
    08668 9149      LD	R20,Y+
    08669 9508      RET
_TurnPlateCheck:
    0866A 934A      ST	-Y,R20
    0866B 935A      ST	-Y,R21
    0866C 9723      SBIW	R28,3
    0866D E001      LDI	R16,1
    0866E 940E 97C6 CALL	_WaitDelayTime
    08670 2300      TST	R16
(0649) 
(0650) 	switch(mainStep){
    08671 F011      BEQ	0x8674
    08672 2700      CLR	R16
    08673 C07C      RJMP	0x86F0
    08674 9020 08ED LDS	R2,PacketState+237
    08676 2022      TST	R2
    08677 F051      BEQ	0x8682
    08678 E001      LDI	R16,1
    08679 940E 6A0C CALL	_GetMotState
    0867B 3001      CPI	R16,1
    0867C F011      BEQ	0x867F
    0867D 2700      CLR	R16
    0867E C071      RJMP	0x86F0
    0867F 2422      CLR	R2
    08680 9220 08ED STS	PacketState+237,R2
    08682 9140 08EA LDS	R20,PacketState+234
    08684 2755      CLR	R21
    08685 3040      CPI	R20,0
    08686 0745      CPC	R20,R21
    08687 F099      BEQ	0x869B
    08688 3041      CPI	R20,1
    08689 E0E0      LDI	R30,0
    0868A 075E      CPC	R21,R30
    0868B F101      BEQ	0x86AC
    0868C 3042      CPI	R20,2
(0651) 		case 0:
(0652) 			SetMotRunPam(MOT_CARD_UNLOAD,100,20,CURRENT_CARD_UNLOAD);
    0868D E0E0      LDI	R30,0
    0868E 075E      CPC	R21,R30
    0868F F141      BEQ	0x86B8
    08690 3043      CPI	R20,3
    08691 E0E0      LDI	R30,0
    08692 075E      CPC	R21,R30
    08693 F409      BNE	0x8695
    08694 C03C      RJMP	0x86D1
(0653) 			MotInitCheck(MOT_CARD_UNLOAD);
    08695 3044      CPI	R20,4
    08696 E0E0      LDI	R30,0
    08697 075E      CPC	R21,R30
(0654) 			waitMotor0 = 1;
    08698 F409      BNE	0x869A
    08699 C040      RJMP	0x86DA
    0869A C054      RJMP	0x86EF
(0655) 			mainStep = 1;
    0869B E081      LDI	R24,1
    0869C 838A      STD	Y+2,R24
(0656) 			break;
    0869D E08A      LDI	R24,0xA
(0657) 		case 1:
(0658) 			SetDelayTime(1, 10);
    0869E 8388      ST	Y,R24
    0869F E728      LDI	R18,0x78
    086A0 E001      LDI	R16,1
    086A1 940E 6A9F CALL	_SetMotRunPam
(0659) 			mainStep = 2;
    086A3 E001      LDI	R16,1
    086A4 940E 6AFA CALL	_MotInitCheck
(0660) 			break;
    086A6 E081      LDI	R24,1
(0661) 		case 2:
(0662) 			MotRunTo(MOT_CARD_UNLOAD, _POS_UNLOAD_OUT);
    086A7 9380 08ED STS	PacketState+237,R24
    086A9 9380 08EA STS	PacketState+234,R24
    086AB C043      RJMP	0x86EF
(0663) 			waitMotor0 = 1;
    086AC E02A      LDI	R18,0xA
    086AD E030      LDI	R19,0
    086AE E001      LDI	R16,1
(0664) 			mainStep = 3;
    086AF 940E 97B7 CALL	_SetDelayTime
    086B1 E082      LDI	R24,2
(0665) 		case 3:
(0666) 			SetDelayTime(1, 10);
    086B2 9380 08EA STS	PacketState+234,R24
    086B4 2422      CLR	R2
    086B5 9220 08EC STS	PacketState+236,R2
(0667) 			mainStep = 4;
    086B7 C037      RJMP	0x86EF
    086B8 9180 08EC LDS	R24,PacketState+236
(0668) 			break;
    086BA 5F8F      SUBI	R24,0xFF
(0669) 		case 4:
(0670) 			MotRunTo(MOT_CARD_UNLOAD, 0);
    086BB 9380 08EC STS	PacketState+236,R24
    086BD 318E      CPI	R24,0x1E
    086BE F458      BCC	0x86CA
    086BF 2F28      MOV	R18,R24
(0671) 			waitMotor0 = 1;
    086C0 E001      LDI	R16,1
    086C1 940E 6A7F CALL	_MotRunToSite
(0672) 			mainStep = 5;
    086C3 E081      LDI	R24,1
    086C4 9380 08ED STS	PacketState+237,R24
(0673) 			break;
    086C6 E083      LDI	R24,3
(0674) 		case 5:
(0675) 			Uart0ReUnable;
    086C7 9380 08EA STS	PacketState+234,R24
    086C9 C025      RJMP	0x86EF
    086CA E081      LDI	R24,1
    086CB 9380 08ED STS	PacketState+237,R24
(0676) 			uart_Printf("%s\r\n",strM4126);
    086CD E084      LDI	R24,4
    086CE 9380 08EA STS	PacketState+234,R24
    086D0 C01E      RJMP	0x86EF
    086D1 E025      LDI	R18,5
(0677) 			Uart0ReEnable;
    086D2 E030      LDI	R19,0
    086D3 E001      LDI	R16,1
    086D4 940E 97B7 CALL	_SetDelayTime
    086D6 E082      LDI	R24,2
(0678) 			mainStep = 0;
    086D7 9380 08EA STS	PacketState+234,R24
    086D9 C015      RJMP	0x86EF
(0679) 			return 1;
    086DA 9180 00C1 LDS	R24,0xC1
(0680) 			break;
(0681) 		default:
(0682) 			break;
(0683) 		}
(0684) 	return 0;
    086DC 7E8F      ANDI	R24,0xEF
    086DD 9380 00C1 STS	0xC1,R24
    086DF EC27      LDI	R18,0xC7
    086E0 E137      LDI	R19,0x17
_DiluentPumpCheck:
    086E1 E50A      LDI	R16,0x5A
    086E2 E019      LDI	R17,0x9
    086E3 940E A90D CALL	_uart_Printf
(0685) }
(0686) 
(0687) unsigned char DiluentPumpCheck(void){
(0688) 	// 稀释液泵运行测试
(0689) 	if(WaitDelayTime(1))		return 0;
    086E5 9180 00C1 LDS	R24,0xC1
    086E7 6180      ORI	R24,0x10
    086E8 9380 00C1 STS	0xC1,R24
    086EA 2422      CLR	R2
(0690) 	if(waitMotor0){	if(GetMotState(MOT_DILUENT)!=STA_SLAVE_FREE)		return 0;	waitMotor0 = 0;	}
    086EB 9220 08EA STS	PacketState+234,R2
    086ED E001      LDI	R16,1
    086EE C001      RJMP	0x86F0
    086EF 2700      CLR	R16
    086F0 9623      ADIW	R28,3
    086F1 9159      LD	R21,Y+
    086F2 9149      LD	R20,Y+
    086F3 9508      RET
_NeedleTurnCheck:
    086F4 934A      ST	-Y,R20
    086F5 935A      ST	-Y,R21
    086F6 9723      SBIW	R28,3
    086F7 E001      LDI	R16,1
    086F8 940E 97C6 CALL	_WaitDelayTime
(0691) 	if(waitMotor1){	if(GetMotState(MOT_EFFLUENT)!=STA_SLAVE_FREE)		return 0;	waitMotor0 = 0;	}
    086FA 2300      TST	R16
    086FB F011      BEQ	0x86FE
    086FC 2700      CLR	R16
    086FD C0C3      RJMP	0x87C1
    086FE 9020 08ED LDS	R2,PacketState+237
    08700 2022      TST	R2
    08701 F051      BEQ	0x870C
    08702 E002      LDI	R16,2
    08703 940E 6A0C CALL	_GetMotState
    08705 3001      CPI	R16,1
    08706 F011      BEQ	0x8709
    08707 2700      CLR	R16
(0692) 
(0693) 	switch(mainStep){
    08708 C0B8      RJMP	0x87C1
    08709 2422      CLR	R2
    0870A 9220 08ED STS	PacketState+237,R2
    0870C 9020 08EE LDS	R2,PacketState+238
    0870E 2022      TST	R2
    0870F F059      BEQ	0x871B
    08710 E003      LDI	R16,3
    08711 940E 6A0C CALL	_GetMotState
    08713 2F40      MOV	R20,R16
    08714 3001      CPI	R16,1
    08715 F011      BEQ	0x8718
    08716 2700      CLR	R16
    08717 C0A9      RJMP	0x87C1
    08718 2422      CLR	R2
    08719 9220 08EE STS	PacketState+238,R2
    0871B 9140 08EA LDS	R20,PacketState+234
    0871D 2755      CLR	R21
    0871E 3040      CPI	R20,0
    0871F 0745      CPC	R20,R21
(0694) 		case 0:
(0695) 			SetMotRunPam(MOT_DILUENT, 100, 2, CURRENT_DILUENT);
    08720 F149      BEQ	0x874A
    08721 3041      CPI	R20,1
    08722 E0E0      LDI	R30,0
    08723 075E      CPC	R21,R30
    08724 F409      BNE	0x8726
    08725 C035      RJMP	0x875B
    08726 3042      CPI	R20,2
    08727 E0E0      LDI	R30,0
(0696) 			MotRun(MOT_DILUENT, 800);
    08728 075E      CPC	R21,R30
    08729 F409      BNE	0x872B
    0872A C042      RJMP	0x876D
    0872B 3043      CPI	R20,3
    0872C E0E0      LDI	R30,0
(0697) 			waitMotor0 = 1;
    0872D 075E      CPC	R21,R30
    0872E F409      BNE	0x8730
    0872F C046      RJMP	0x8776
(0698) 			mainStep = 1;
    08730 3044      CPI	R20,4
    08731 E0E0      LDI	R30,0
(0699) 		case 1:
(0700) 			SetDelayTime(1, 10);
    08732 075E      CPC	R21,R30
    08733 F409      BNE	0x8735
    08734 C04C      RJMP	0x8781
    08735 3045      CPI	R20,5
    08736 E0E0      LDI	R30,0
(0701) 			mainStep = 2;
    08737 075E      CPC	R21,R30
    08738 F409      BNE	0x873A
    08739 C050      RJMP	0x878A
(0702) 			break;
    0873A 3046      CPI	R20,6
(0703) 		case 2:
(0704) 			MotRun(MOT_DILUENT, 800);
    0873B E0E0      LDI	R30,0
    0873C 075E      CPC	R21,R30
    0873D F409      BNE	0x873F
    0873E C057      RJMP	0x8796
    0873F 3047      CPI	R20,7
(0705) 			waitMotor0 = 1;
    08740 E0E0      LDI	R30,0
    08741 075E      CPC	R21,R30
    08742 F409      BNE	0x8744
(0706) 			mainStep = 3;
    08743 C05B      RJMP	0x879F
    08744 3048      CPI	R20,0x8
    08745 E0E0      LDI	R30,0
(0707) 			break;
    08746 075E      CPC	R21,R30
(0708) 		case 3:
(0709) 			SetMotRunPam(MOT_EFFLUENT, 200, 2, CURRENT_EFFLUENT);
    08747 F409      BNE	0x8749
    08748 C062      RJMP	0x87AB
    08749 C076      RJMP	0x87C0
    0874A E083      LDI	R24,3
    0874B 838A      STD	Y+2,R24
    0874C E08A      LDI	R24,0xA
    0874D 8388      ST	Y,R24
    0874E EF20      LDI	R18,0xF0
(0710) 			//MotRun(MOT_EFFLUENT, 8000);
(0711) 			MotRun(MOT_EFFLUENT, 3000);
    0874F E003      LDI	R16,3
    08750 940E 6A9F CALL	_SetMotRunPam
    08752 E003      LDI	R16,3
    08753 940E 6AFA CALL	_MotInitCheck
(0712) 			waitMotor1 = 1;
    08755 E081      LDI	R24,1
    08756 9380 08EE STS	PacketState+238,R24
(0713) 			mainStep = 4;
    08758 9380 08EA STS	PacketState+234,R24
(0714) 			break;
    0875A C065      RJMP	0x87C0
(0715) 		case 4:
(0716) 			Uart0ReUnable;
    0875B E084      LDI	R24,4
    0875C 838A      STD	Y+2,R24
    0875D E288      LDI	R24,0x28
    0875E 8388      ST	Y,R24
    0875F E728      LDI	R18,0x78
(0717) 			uart_Printf("%s\r\n",strM4129);
    08760 E002      LDI	R16,2
    08761 940E 6A9F CALL	_SetMotRunPam
    08763 E002      LDI	R16,2
    08764 940E 6AFA CALL	_MotInitCheck
(0718) 			Uart0ReEnable;
    08766 E081      LDI	R24,1
    08767 9380 08ED STS	PacketState+237,R24
    08769 E082      LDI	R24,2
    0876A 9380 08EA STS	PacketState+234,R24
(0719) 			mainStep = 0;
    0876C C053      RJMP	0x87C0
    0876D E02A      LDI	R18,0xA
(0720) 			return 1;
    0876E E030      LDI	R19,0
    0876F E001      LDI	R16,1
(0721) 			break;
(0722) 		default:
(0723) 			break;
(0724) 		}
(0725) 	return 0;
    08770 940E 97B7 CALL	_SetDelayTime
    08772 E083      LDI	R24,3
    08773 9380 08EA STS	PacketState+234,R24
_LeanerPumpCheck:
    08775 C04A      RJMP	0x87C0
    08776 E52F      LDI	R18,0x5F
    08777 E031      LDI	R19,1
(0726) }
(0727) 
(0728) unsigned char LeanerPumpCheck(void){
(0729) 	// 清洗液泵运行测试
(0730) 	if(WaitDelayTime(1))		return 0;
    08778 E002      LDI	R16,2
    08779 940E 6A5B CALL	_MotRunTo
    0877B E081      LDI	R24,1
    0877C 9380 08ED STS	PacketState+237,R24
    0877E E084      LDI	R24,4
(0731) 	if(waitMotor0){	if(GetMotState(MOT_FLUID)!=STA_SLAVE_FREE)		return 0;	waitMotor0 = 0;	}
    0877F 9380 08EA STS	PacketState+234,R24
    08781 E02A      LDI	R18,0xA
    08782 E030      LDI	R19,0
    08783 E001      LDI	R16,1
    08784 940E 97B7 CALL	_SetDelayTime
    08786 E085      LDI	R24,5
    08787 9380 08EA STS	PacketState+234,R24
    08789 C036      RJMP	0x87C0
    0878A ED24      LDI	R18,0xD4
    0878B E033      LDI	R19,3
    0878C E002      LDI	R16,2
(0732) 	if(waitMotor1){	if(GetMotState(MOT_EFFLUENT)!=STA_SLAVE_FREE)		return 0;	waitMotor0 = 0;	}
    0878D 940E 6A5B CALL	_MotRunTo
    0878F E081      LDI	R24,1
    08790 9380 08ED STS	PacketState+237,R24
    08792 E086      LDI	R24,6
    08793 9380 08EA STS	PacketState+234,R24
    08795 C02A      RJMP	0x87C0
    08796 E02A      LDI	R18,0xA
    08797 E030      LDI	R19,0
    08798 E001      LDI	R16,1
    08799 940E 97B7 CALL	_SetDelayTime
    0879B E087      LDI	R24,7
(0733) 
(0734) 	switch(mainStep){
    0879C 9380 08EA STS	PacketState+234,R24
    0879E C021      RJMP	0x87C0
    0879F 2722      CLR	R18
    087A0 2733      CLR	R19
    087A1 E002      LDI	R16,2
    087A2 940E 6A5B CALL	_MotRunTo
    087A4 E081      LDI	R24,1
    087A5 9380 08ED STS	PacketState+237,R24
    087A7 E088      LDI	R24,0x8
    087A8 9380 08EA STS	PacketState+234,R24
    087AA C015      RJMP	0x87C0
    087AB 9180 00C1 LDS	R24,0xC1
    087AD 7E8F      ANDI	R24,0xEF
    087AE 9380 00C1 STS	0xC1,R24
    087B0 EE20      LDI	R18,0xE0
    087B1 E137      LDI	R19,0x17
    087B2 E50A      LDI	R16,0x5A
    087B3 E019      LDI	R17,0x9
(0735) 		case 0:
(0736) 			SetMotRunPam(MOT_FLUID, 80, 2, CURRENT_FLUID);
    087B4 940E A90D CALL	_uart_Printf
    087B6 9180 00C1 LDS	R24,0xC1
    087B8 6180      ORI	R24,0x10
    087B9 9380 00C1 STS	0xC1,R24
    087BB 2422      CLR	R2
(0737) 			MotRun(MOT_FLUID, 800);
    087BC 9220 08EA STS	PacketState+234,R2
    087BE E001      LDI	R16,1
    087BF C001      RJMP	0x87C1
    087C0 2700      CLR	R16
(0738) 			waitMotor0 = 1;
    087C1 9623      ADIW	R28,3
    087C2 9159      LD	R21,Y+
    087C3 9149      LD	R20,Y+
(0739) 			mainStep = 1;
    087C4 9508      RET
_NeedleUpdownCheck:
    087C5 934A      ST	-Y,R20
(0740) 		case 1:
(0741) 			SetDelayTime(1, 10);
    087C6 935A      ST	-Y,R21
    087C7 9723      SBIW	R28,3
    087C8 E001      LDI	R16,1
    087C9 940E 97C6 CALL	_WaitDelayTime
(0742) 			mainStep = 2;
    087CB 2300      TST	R16
    087CC F011      BEQ	0x87CF
    087CD 2700      CLR	R16
(0743) 			break;
    087CE C0D5      RJMP	0x88A4
(0744) 		case 2:
(0745) 			MotRun(MOT_FLUID, 800);
    087CF 9020 08ED LDS	R2,PacketState+237
    087D1 2022      TST	R2
    087D2 F051      BEQ	0x87DD
    087D3 E002      LDI	R16,2
(0746) 			waitMotor0 = 1;
    087D4 940E 6A0C CALL	_GetMotState
    087D6 3001      CPI	R16,1
(0747) 			mainStep = 3;
    087D7 F011      BEQ	0x87DA
    087D8 2700      CLR	R16
    087D9 C0CA      RJMP	0x88A4
(0748) 			break;
    087DA 2422      CLR	R2
(0749) 		case 3:
(0750) 			SetMotRunPam(MOT_EFFLUENT, 200, 2, CURRENT_EFFLUENT);
    087DB 9220 08ED STS	PacketState+237,R2
    087DD 9020 08EE LDS	R2,PacketState+238
    087DF 2022      TST	R2
    087E0 F059      BEQ	0x87EC
    087E1 E003      LDI	R16,3
    087E2 940E 6A0C CALL	_GetMotState
(0751) 			//MotRun(MOT_EFFLUENT, 2000);
(0752) 			MotRun(MOT_EFFLUENT, 3000);
    087E4 2F40      MOV	R20,R16
    087E5 3001      CPI	R16,1
    087E6 F011      BEQ	0x87E9
    087E7 2700      CLR	R16
(0753) 			waitMotor1 = 1;
    087E8 C0BB      RJMP	0x88A4
    087E9 2422      CLR	R2
    087EA 9220 08EE STS	PacketState+238,R2
(0754) 			mainStep = 4;
    087EC 9140 08EA LDS	R20,PacketState+234
(0755) 			break;
    087EE 2755      CLR	R21
(0756) 		case 4:
(0757) 			Uart0ReUnable;
    087EF 3040      CPI	R20,0
    087F0 0745      CPC	R20,R21
    087F1 F409      BNE	0x87F3
    087F2 C02E      RJMP	0x8821
    087F3 3041      CPI	R20,1
(0758) 			uart_Printf("%s\r\n",strM4130);
    087F4 E0E0      LDI	R30,0
    087F5 075E      CPC	R21,R30
    087F6 F409      BNE	0x87F8
    087F7 C03A      RJMP	0x8832
    087F8 3042      CPI	R20,2
    087F9 E0E0      LDI	R30,0
(0759) 			Uart0ReEnable;
    087FA 075E      CPC	R21,R30
    087FB F409      BNE	0x87FD
    087FC C047      RJMP	0x8844
    087FD 3043      CPI	R20,3
    087FE E0E0      LDI	R30,0
(0760) 			mainStep = 0;
    087FF 075E      CPC	R21,R30
    08800 F409      BNE	0x8802
    08801 C04B      RJMP	0x884D
(0761) 			return 1;
    08802 3044      CPI	R20,4
    08803 E0E0      LDI	R30,0
(0762) 			break;
(0763) 		default:
(0764) 			break;
(0765) 		}
(0766) 	return 0;
    08804 075E      CPC	R21,R30
    08805 F409      BNE	0x8807
    08806 C051      RJMP	0x8858
    08807 3045      CPI	R20,5
    08808 E0E0      LDI	R30,0
_EffluentPumpCheck:
    08809 075E      CPC	R21,R30
    0880A F409      BNE	0x880C
    0880B C055      RJMP	0x8861
(0767) }
(0768) 
(0769) unsigned char EffluentPumpCheck(void){
(0770) 	// 废液泵运行测试
(0771) 	if(WaitDelayTime(1))		return 0;
    0880C 3046      CPI	R20,6
    0880D E0E0      LDI	R30,0
    0880E 075E      CPC	R21,R30
    0880F F409      BNE	0x8811
    08810 C05C      RJMP	0x886D
    08811 3047      CPI	R20,7
    08812 E0E0      LDI	R30,0
(0772) 	if(waitMotor0){	if(GetMotState(MOT_EFFLUENT)!=STA_SLAVE_FREE)		return 0;	waitMotor0 = 0;	}
    08813 075E      CPC	R21,R30
    08814 F409      BNE	0x8816
    08815 C060      RJMP	0x8876
    08816 3048      CPI	R20,0x8
    08817 E0E0      LDI	R30,0
    08818 075E      CPC	R21,R30
    08819 F409      BNE	0x881B
    0881A C067      RJMP	0x8882
    0881B 3049      CPI	R20,0x9
    0881C E0E0      LDI	R30,0
    0881D 075E      CPC	R21,R30
    0881E F409      BNE	0x8820
    0881F C06E      RJMP	0x888E
    08820 C082      RJMP	0x88A3
(0773) 
(0774) 	switch(mainStep){
    08821 E083      LDI	R24,3
    08822 838A      STD	Y+2,R24
    08823 E08A      LDI	R24,0xA
    08824 8388      ST	Y,R24
    08825 EF20      LDI	R18,0xF0
    08826 E003      LDI	R16,3
    08827 940E 6A9F CALL	_SetMotRunPam
    08829 E003      LDI	R16,3
    0882A 940E 6AFA CALL	_MotInitCheck
    0882C E081      LDI	R24,1
    0882D 9380 08EE STS	PacketState+238,R24
    0882F 9380 08EA STS	PacketState+234,R24
    08831 C071      RJMP	0x88A3
    08832 E084      LDI	R24,4
    08833 838A      STD	Y+2,R24
(0775) 		case 0:
(0776) 			SetMotRunPam(MOT_EFFLUENT, 200, 2, CURRENT_EFFLUENT);
    08834 E08A      LDI	R24,0xA
    08835 8388      ST	Y,R24
    08836 E728      LDI	R18,0x78
    08837 E002      LDI	R16,2
    08838 940E 6A9F CALL	_SetMotRunPam
    0883A E002      LDI	R16,2
    0883B 940E 6AFA CALL	_MotInitCheck
(0777) 			MotRun(MOT_EFFLUENT, 800);
    0883D E081      LDI	R24,1
    0883E 9380 08ED STS	PacketState+237,R24
    08840 E082      LDI	R24,2
(0778) 			waitMotor0 = 1;
    08841 9380 08EA STS	PacketState+234,R24
    08843 C05F      RJMP	0x88A3
(0779) 			mainStep = 1;
    08844 E02A      LDI	R18,0xA
    08845 E030      LDI	R19,0
(0780) 		case 1:
(0781) 			SetDelayTime(1, 10);
    08846 E001      LDI	R16,1
    08847 940E 97B7 CALL	_SetDelayTime
    08849 E083      LDI	R24,3
    0884A 9380 08EA STS	PacketState+234,R24
(0782) 			mainStep = 2;
    0884C C056      RJMP	0x88A3
    0884D ED24      LDI	R18,0xD4
(0783) 			break;
    0884E E033      LDI	R19,3
(0784) 		case 2:
(0785) 			MotRun(MOT_EFFLUENT, 800);
    0884F E002      LDI	R16,2
    08850 940E 6A5B CALL	_MotRunTo
    08852 E081      LDI	R24,1
    08853 9380 08ED STS	PacketState+237,R24
(0786) 			waitMotor0 = 1;
    08855 E084      LDI	R24,4
    08856 9380 08EA STS	PacketState+234,R24
(0787) 			mainStep = 3;
    08858 E02A      LDI	R18,0xA
    08859 E030      LDI	R19,0
(0788) 			break;
    0885A E001      LDI	R16,1
(0789) 		case 3:
(0790) 			Uart0ReUnable;
    0885B 940E 97B7 CALL	_SetDelayTime
    0885D E085      LDI	R24,5
    0885E 9380 08EA STS	PacketState+234,R24
(0791) 			uart_Printf("%s\r\n",strM4131);
    08860 C042      RJMP	0x88A3
    08861 EA28      LDI	R18,0xA8
    08862 E037      LDI	R19,7
    08863 E003      LDI	R16,3
    08864 940E 6A5B CALL	_MotRunTo
(0792) 			Uart0ReEnable;
    08866 E081      LDI	R24,1
    08867 9380 08EE STS	PacketState+238,R24
    08869 E086      LDI	R24,6
    0886A 9380 08EA STS	PacketState+234,R24
(0793) 			mainStep = 0;
    0886C C036      RJMP	0x88A3
    0886D E02A      LDI	R18,0xA
(0794) 			return 1;
    0886E E030      LDI	R19,0
    0886F E001      LDI	R16,1
(0795) 			break;
(0796) 		default:
(0797) 			break;
(0798) 		}
(0799) 	return 0;
    08870 940E 97B7 CALL	_SetDelayTime
    08872 E087      LDI	R24,7
    08873 9380 08EA STS	PacketState+234,R24
_SamplingSyringCheck:
    08875 C02D      RJMP	0x88A3
    08876 2722      CLR	R18
    08877 2733      CLR	R19
(0800) }
(0801) /*
(0802) unsigned char SamplingSyringCheck(void){
(0803) 	// 取样注射泵运行测试
(0804) 	unsigned char i;
(0805) 	if(WaitDelayTime(1))		return 0;
(0806) 	if(waitMotor0){	if(GetMotState(MOT_SAMP_PUMP)!=STA_SLAVE_FREE)		return 0;	waitMotor0 = 0;	}
(0807) 
(0808) //	i = MaintainSubFunParam ;
(0809) //	if(i==0)
(0810) //		i = 1;
(0811) 	switch(mainStep){
(0812) 		case 0:
(0813) 			SetMotRunPam(MOT_SAMP_PUMP, 200, 10, CURRENT_SAMP_PUMP);
(0814) 			MotInitCheck(MOT_SAMP_PUMP);
(0815) 			waitMotor0 = 1;
(0816) 			mainStep = 1;
(0817) 			i = 1;
(0818) 			break;
(0819) 		case 1:
(0820) 			i--;
(0821) 			SetDelayTime(1, 10);
(0822) 			mainStep = 2;
(0823) 			break;
(0824) 		case 2:
(0825) 			MotRunTo(MOT_SAMP_PUMP, 4800);
(0826) 			waitMotor0 = 1;
(0827) 			mainStep = 3;
(0828) 		case 3:
(0829) 			SetDelayTime(1, 10);
(0830) 			mainStep = 4;
(0831) 			break;
(0832) 		case 4:
(0833) 			MotRunTo(MOT_SAMP_PUMP, 0);
(0834) 			waitMotor0 = 1;
(0835) 			if(i != 0)
(0836) 				mainStep = 1;
(0837) 			else
(0838) 				mainStep = 5;
(0839) 			break;
(0840) 		case 5:
(0841) 			uart_Printf("%s\r\n",strM4132);
(0842) 			mainStep = 0;
(0843) 			return 1;
(0844) 			break;
(0845) 		default:
(0846) 			break;
(0847) 		}
(0848) 	return 0;
(0849) }
(0850) */
(0851) //2016-5-17日 修改 如下：
(0852) unsigned char SamplingSyringCheck(void){
(0853) 	// 取样注射泵运行测试
(0854) 	if(WaitDelayTime(1))		return 0;
    08878 E003      LDI	R16,3
    08879 940E 6A5B CALL	_MotRunTo
    0887B E081      LDI	R24,1
    0887C 9380 08EE STS	PacketState+238,R24
    0887E E088      LDI	R24,0x8
(0855) 	if(waitMotor0){	if(GetMotState(MOT_SAMP_PUMP)!=STA_SLAVE_FREE)		return 0;	waitMotor0 = 0;	}
    0887F 9380 08EA STS	PacketState+234,R24
    08881 C021      RJMP	0x88A3
    08882 2722      CLR	R18
    08883 2733      CLR	R19
    08884 E002      LDI	R16,2
    08885 940E 6A5B CALL	_MotRunTo
    08887 E081      LDI	R24,1
    08888 9380 08ED STS	PacketState+237,R24
    0888A E089      LDI	R24,0x9
    0888B 9380 08EA STS	PacketState+234,R24
(0856) 
(0857) 	switch(mainStep){
    0888D C015      RJMP	0x88A3
    0888E 9180 00C1 LDS	R24,0xC1
    08890 7E8F      ANDI	R24,0xEF
    08891 9380 00C1 STS	0xC1,R24
    08893 EF2A      LDI	R18,0xFA
    08894 E137      LDI	R19,0x17
    08895 E50A      LDI	R16,0x5A
    08896 E019      LDI	R17,0x9
    08897 940E A90D CALL	_uart_Printf
    08899 9180 00C1 LDS	R24,0xC1
    0889B 6180      ORI	R24,0x10
    0889C 9380 00C1 STS	0xC1,R24
    0889E 2422      CLR	R2
    0889F 9220 08EA STS	PacketState+234,R2
    088A1 E001      LDI	R16,1
    088A2 C001      RJMP	0x88A4
    088A3 2700      CLR	R16
    088A4 9623      ADIW	R28,3
    088A5 9159      LD	R21,Y+
    088A6 9149      LD	R20,Y+
    088A7 9508      RET
_CardStoreMoveCheck:
    088A8 934A      ST	-Y,R20
(0858) 		case 0:
(0859) 			SetMotRunPam(MOT_SAMP_PUMP, 200, 10, CURRENT_SAMP_PUMP);
    088A9 935A      ST	-Y,R21
    088AA 9723      SBIW	R28,3
    088AB E001      LDI	R16,1
    088AC 940E 97C6 CALL	_WaitDelayTime
    088AE 2300      TST	R16
    088AF F011      BEQ	0x88B2
    088B0 2700      CLR	R16
(0860) 			MotInitCheck(MOT_SAMP_PUMP);
    088B1 C0B8      RJMP	_CardStorePhotoCheck_Even
    088B2 9020 08ED LDS	R2,PacketState+237
(0861) 			waitMotor0 = 1;
    088B4 2022      TST	R2
    088B5 F051      BEQ	0x88C0
    088B6 E008      LDI	R16,0x8
(0862) 			mainStep = 1;
    088B7 940E 6A0C CALL	_GetMotState
(0863) 			break;
    088B9 3001      CPI	R16,1
(0864) 		case 1:
(0865) 			SetDelayTime(1, 10);
    088BA F011      BEQ	0x88BD
    088BB 2700      CLR	R16
    088BC C0AD      RJMP	_CardStorePhotoCheck_Even
    088BD 2422      CLR	R2
    088BE 9220 08ED STS	PacketState+237,R2
(0866) 			mainStep = 2;
    088C0 9140 08EA LDS	R20,PacketState+234
(0867) 			break;
    088C2 2755      CLR	R21
(0868) 		case 2:
(0869) 			MotRunTo(MOT_SAMP_PUMP, 4800);
    088C3 3144      CPI	R20,0x14
    088C4 E0E0      LDI	R30,0
    088C5 075E      CPC	R21,R30
    088C6 F409      BNE	0x88C8
    088C7 C054      RJMP	0x891C
(0870) 			waitMotor0 = 1;
    088C8 E184      LDI	R24,0x14
    088C9 E090      LDI	R25,0
    088CA 1784      CP	R24,R20
(0871) 			mainStep = 3;
    088CB 0795      CPC	R25,R21
    088CC F0E4      BLT	0x88E9
    088CD 3040      CPI	R20,0
(0872) 			break;
    088CE 0745      CPC	R20,R21
(0873) 		case 3:
(0874) 			SetDelayTime(1, 10);
    088CF F121      BEQ	0x88F4
    088D0 3041      CPI	R20,1
    088D1 E0E0      LDI	R30,0
    088D2 075E      CPC	R21,R30
    088D3 F181      BEQ	0x8904
(0875) 			mainStep = 4;
    088D4 3042      CPI	R20,2
    088D5 E0E0      LDI	R30,0
    088D6 075E      CPC	R21,R30
(0876) 			break;
    088D7 F409      BNE	0x88D9
(0877) 		case 4:
(0878) 			MotRunTo(MOT_SAMP_PUMP, 0);
    088D8 C034      RJMP	0x890D
    088D9 3043      CPI	R20,3
    088DA E0E0      LDI	R30,0
    088DB 075E      CPC	R21,R30
    088DC F409      BNE	0x88DE
(0879) 			waitMotor0 = 1;
    088DD C049      RJMP	0x8927
    088DE 3044      CPI	R20,4
    088DF E0E0      LDI	R30,0
(0880) 			mainStep = 5;
    088E0 075E      CPC	R21,R30
    088E1 F409      BNE	0x88E3
    088E2 C04D      RJMP	0x8930
(0881) 			break;
    088E3 3045      CPI	R20,5
(0882) 		case 5:
(0883) 			Uart0ReUnable;
    088E4 E0E0      LDI	R30,0
    088E5 075E      CPC	R21,R30
    088E6 F409      BNE	0x88E8
    088E7 C06C      RJMP	0x8954
    088E8 C080      RJMP	0x8969
(0884) 			uart_Printf("%s\r\n",strM4132);
    088E9 3342      CPI	R20,0x32
    088EA E0E0      LDI	R30,0
    088EB 075E      CPC	R21,R30
    088EC F409      BNE	0x88EE
    088ED C04E      RJMP	0x893C
    088EE 3343      CPI	R20,0x33
(0885) 			Uart0ReEnable;
    088EF E0E0      LDI	R30,0
    088F0 075E      CPC	R21,R30
    088F1 F409      BNE	0x88F3
    088F2 C052      RJMP	0x8945
    088F3 C075      RJMP	0x8969
(0886) 			mainStep = 0;
    088F4 E08A      LDI	R24,0xA
    088F5 838A      STD	Y+2,R24
    088F6 8388      ST	Y,R24
(0887) 			return 1;
    088F7 EA20      LDI	R18,0xA0
    088F8 E008      LDI	R16,0x8
(0888) 			break;
(0889) 		default:
(0890) 			break;
(0891) 		}
(0892) 	return 0;
    088F9 940E 6A9F CALL	_SetMotRunPam
    088FB E008      LDI	R16,0x8
    088FC 940E 6AFA CALL	_MotInitCheck
_LiquidPhotoCheck_Even:
  pInfo                --> R20
  pInfoEvent           --> R20
    088FE E081      LDI	R24,1
    088FF 9380 08ED STS	PacketState+237,R24
    08901 9380 08EA STS	PacketState+234,R24
(0893) }
(0894) 
(0895) unsigned char LiquidPhotoCheck_Even(INFO_EVENT * pInfoEvent){
(0896) 	unsigned char * pInfo;
(0897) 	switch(mainStep){
    08903 C065      RJMP	0x8969
    08904 E025      LDI	R18,5
    08905 E030      LDI	R19,0
    08906 E001      LDI	R16,1
    08907 940E 97B7 CALL	_SetDelayTime
    08909 E082      LDI	R24,2
(0898) 		case 1:
(0899) 			if(pInfoEvent->event == INFO_LIQ_PHO_VAL){
    0890A 9380 08EA STS	PacketState+234,R24
    0890C C05C      RJMP	0x8969
    0890D 2722      CLR	R18
(0900) 				pInfo = &(pInfoEvent->info[0]);
    0890E E008      LDI	R16,0x8
    0890F 940E 2FEA CALL	_GetMotorMonitorState
(0901) 				// 输出液路光耦信息
(0902) 				Uart0ReUnable;
    08911 2F40      MOV	R20,R16
    08912 3001      CPI	R16,1
    08913 F421      BNE	0x8918
    08914 E184      LDI	R24,0x14
(0903) 				uart_Printf("%s $%4d $%4d $%4d $%4d\r\n",strM4133, *(pInfo), *(pInfo+1), *(pInfo+2), *(pInfo+3));
    08915 9380 08EA STS	PacketState+234,R24
    08917 C051      RJMP	0x8969
    08918 2422      CLR	R2
    08919 9220 08EA STS	PacketState+234,R2
    0891B C04D      RJMP	0x8969
    0891C EF26      LDI	R18,0xF6
    0891D E039      LDI	R19,0x9
    0891E E008      LDI	R16,0x8
    0891F 940E 6A5B CALL	_MotRunTo
    08921 E081      LDI	R24,1
    08922 9380 08ED STS	PacketState+237,R24
    08924 E083      LDI	R24,3
    08925 9380 08EA STS	PacketState+234,R24
    08927 E02A      LDI	R18,0xA
    08928 E030      LDI	R19,0
    08929 E001      LDI	R16,1
    0892A 940E 97B7 CALL	_SetDelayTime
(0904) 				Uart0ReEnable;
    0892C E084      LDI	R24,4
    0892D 9380 08EA STS	PacketState+234,R24
    0892F C039      RJMP	0x8969
    08930 2722      CLR	R18
(0905) 				mainStep = 2;
    08931 2733      CLR	R19
    08932 E008      LDI	R16,0x8
    08933 940E 6A5B CALL	_MotRunTo
(0906) 				return 1;
    08935 E081      LDI	R24,1
(0907) 				}
(0908) 			break;
(0909) 		default:
(0910) 			break;
(0911) 		}
(0912) 	return 0;
    08936 9380 08ED STS	PacketState+237,R24
    08938 E382      LDI	R24,0x32
    08939 9380 08EA STS	PacketState+234,R24
    0893B C02D      RJMP	0x8969
(0913) }
(0914) unsigned char LiquidPhotoCheck(void)
(0915) {
(0916) 	switch(mainStep){
    0893C E025      LDI	R18,5
    0893D E030      LDI	R19,0
    0893E E001      LDI	R16,1
    0893F 940E 97B7 CALL	_SetDelayTime
    08941 E383      LDI	R24,0x33
    08942 9380 08EA STS	PacketState+234,R24
    08944 C024      RJMP	0x8969
    08945 2722      CLR	R18
    08946 E008      LDI	R16,0x8
(0917) 		case 0:
(0918) 			GetLiquidPhotoInfo();
    08947 940E 2FEA CALL	_GetMotorMonitorState
(0919) 			mainStep = 1;
    08949 2F40      MOV	R20,R16
    0894A 3001      CPI	R16,1
    0894B F421      BNE	0x8950
(0920) 			RegisterLiquidEvenProcess(LiquidPhotoCheck_Even);
    0894C E085      LDI	R24,5
    0894D 9380 08EA STS	PacketState+234,R24
    0894F C019      RJMP	0x8969
(0921) 			break;
    08950 E084      LDI	R24,4
(0922) 		case 2:
(0923) 			Uart0ReUnable;
    08951 9380 08EA STS	PacketState+234,R24
    08953 C015      RJMP	0x8969
    08954 9180 00C1 LDS	R24,0xC1
(0924) 			uart_Printf("%s\r\n",strM4134);
    08956 7E8F      ANDI	R24,0xEF
    08957 9380 00C1 STS	0xC1,R24
    08959 E126      LDI	R18,0x16
    0895A E138      LDI	R19,0x18
    0895B E50A      LDI	R16,0x5A
(0925) 			Uart0ReEnable;
    0895C E019      LDI	R17,0x9
    0895D 940E A90D CALL	_uart_Printf
    0895F 9180 00C1 LDS	R24,0xC1
(0926) 			mainStep = 0;
    08961 6180      ORI	R24,0x10
    08962 9380 00C1 STS	0xC1,R24
(0927) 			return 1;
    08964 2422      CLR	R2
    08965 9220 08EA STS	PacketState+234,R2
(0928) 			break;
(0929) 		default:
(0930) 			break;
(0931) 		}
(0932) 	return 0;
    08967 E001      LDI	R16,1
    08968 C001      RJMP	_CardStorePhotoCheck_Even
    08969 2700      CLR	R16
_CardStorePhotoCheck_Even:
  pInfo                --> R20
  pInfoEvent           --> R20
    0896A 9623      ADIW	R28,3
    0896B 9159      LD	R21,Y+
    0896C 9149      LD	R20,Y+
    0896D 9508      RET
(0933) }
(0934) 
(0935) unsigned char CardStorePhotoCheck_Even(INFO_EVENT * pInfoEvent){
(0936) 	unsigned char * pInfo;
(0937) 	switch(mainStep){
_CardTakeHookCheck:
    0896E 940E AE83 CALL	push_xgset300C
    08970 9723      SBIW	R28,3
    08971 E001      LDI	R16,1
    08972 940E 97C6 CALL	_WaitDelayTime
    08974 2300      TST	R16
    08975 F011      BEQ	0x8978
(0938) 		case 1:
(0939) 			if(pInfoEvent->event == INFO_STORE_PHO_VOL){
    08976 2700      CLR	R16
    08977 C0A2      RJMP	0x8A1A
    08978 9020 08ED LDS	R2,PacketState+237
(0940) 				pInfo = &(pInfoEvent->info[0]);
    0897A 2022      TST	R2
    0897B F051      BEQ	0x8986
(0941) 			//	if(*(pInfo) == CardStorePhoNum){
(0942) 					// 输出液路光耦调整结果
(0943) 					Uart0ReUnable;
    0897C E008      LDI	R16,0x8
    0897D 940E 6A0C CALL	_GetMotState
    0897F 3001      CPI	R16,1
    08980 F011      BEQ	0x8983
(0944) 					uart_Printf("%s $%4d $%4d L $%4d H $%4d\r\n",strM4135, *(pInfo), *(pInfo+1), *(pInfo+2), *(pInfo+3));
    08981 2700      CLR	R16
    08982 C097      RJMP	0x8A1A
    08983 2422      CLR	R2
    08984 9220 08ED STS	PacketState+237,R2
    08986 9140 08EA LDS	R20,PacketState+234
    08988 2755      CLR	R21
    08989 3040      CPI	R20,0
    0898A 0745      CPC	R20,R21
    0898B F119      BEQ	0x89AF
    0898C 3041      CPI	R20,1
    0898D E0E0      LDI	R30,0
    0898E 075E      CPC	R21,R30
    0898F F179      BEQ	0x89BF
    08990 3042      CPI	R20,2
    08991 E0E0      LDI	R30,0
    08992 075E      CPC	R21,R30
    08993 F409      BNE	0x8995
    08994 C033      RJMP	0x89C8
    08995 3043      CPI	R20,3
    08996 E0E0      LDI	R30,0
    08997 075E      CPC	R21,R30
(0945) 					Uart0ReEnable;
    08998 F409      BNE	0x899A
    08999 C03D      RJMP	0x89D7
    0899A 3044      CPI	R20,4
    0899B E0E0      LDI	R30,0
    0899C 075E      CPC	R21,R30
(0946) 					mainStep = 2;
    0899D F409      BNE	0x899F
    0899E C041      RJMP	0x89E0
    0899F 3045      CPI	R20,5
(0947) 					return 1;
    089A0 E0E0      LDI	R30,0
    089A1 075E      CPC	R21,R30
(0948) 			//		}
(0949) 				}
(0950) 			break;
(0951) 		default:
(0952) 			break;
(0953) 		}
(0954) 	return 0;
    089A2 F409      BNE	0x89A4
    089A3 C048      RJMP	0x89EC
    089A4 3046      CPI	R20,6
    089A5 E0E0      LDI	R30,0
_CardStorePhotoCheck:
    089A6 075E      CPC	R21,R30
    089A7 F409      BNE	0x89A9
    089A8 C04F      RJMP	0x89F8
(0955) }
(0956) unsigned char CardStorePhotoCheck(void){
(0957) 	switch(mainStep){
    089A9 3047      CPI	R20,7
    089AA E0E0      LDI	R30,0
    089AB 075E      CPC	R21,R30
    089AC F409      BNE	0x89AE
    089AD C056      RJMP	0x8A04
    089AE C06A      RJMP	0x8A19
    089AF E08A      LDI	R24,0xA
    089B0 838A      STD	Y+2,R24
    089B1 8388      ST	Y,R24
    089B2 EA20      LDI	R18,0xA0
    089B3 E008      LDI	R16,0x8
(0958) 		case 0:
(0959) 			GetStorePhoVol(CardStorePhoNum);
    089B4 940E 6A9F CALL	_SetMotRunPam
    089B6 E008      LDI	R16,0x8
    089B7 940E 6AFA CALL	_MotInitCheck
(0960) 			mainStep = 1;
    089B9 E081      LDI	R24,1
    089BA 9380 08ED STS	PacketState+237,R24
(0961) 			RegisterCardStoreEvenProcess(CardStorePhotoCheck_Even);
    089BC 9380 08EA STS	PacketState+234,R24
    089BE C05A      RJMP	0x8A19
(0962) 			break;
    089BF E025      LDI	R18,5
(0963) 		case 2:
(0964) 			Uart0ReUnable;
    089C0 E030      LDI	R19,0
    089C1 E001      LDI	R16,1
    089C2 940E 97B7 CALL	_SetDelayTime
    089C4 E082      LDI	R24,2
(0965) 			uart_Printf("%s $%4d\r\n",strM4136, CardStorePhoNum);
    089C5 9380 08EA STS	PacketState+234,R24
    089C7 C051      RJMP	0x8A19
    089C8 E001      LDI	R16,1
    089C9 E010      LDI	R17,0
    089CA 940E 1872 CALL	_CalCardStorePos
    089CC 0158      MOVW	R10,R16
    089CD 0195      MOVW	R18,R10
    089CE E008      LDI	R16,0x8
    089CF 940E 6A5B CALL	_MotRunTo
(0966) 			Uart0ReEnable;
    089D1 E081      LDI	R24,1
    089D2 9380 08ED STS	PacketState+237,R24
    089D4 E083      LDI	R24,3
(0967) 			mainStep = 0;
    089D5 9380 08EA STS	PacketState+234,R24
    089D7 E025      LDI	R18,5
(0968) 			return 1;
    089D8 E030      LDI	R19,0
    089D9 E001      LDI	R16,1
(0969) 			break;
(0970) 		default:
(0971) 			break;
(0972) 		}
(0973) 	return 0;
    089DA 940E 97B7 CALL	_SetDelayTime
    089DC E084      LDI	R24,4
    089DD 9380 08EA STS	PacketState+234,R24
_NeedleOnMixSideCheck:
    089DF C039      RJMP	0x8A19
    089E0 E001      LDI	R16,1
    089E1 940E 18A0 CALL	_SetCardTrolleyState
(0974) }
(0975) 
(0976) unsigned char NeedleOnMixSideCheck(void){
(0977) 	// 旋转臂测试
(0978) 	if(WaitDelayTime(1))		return 0;
    089E3 E124      LDI	R18,0x14
    089E4 E030      LDI	R19,0
    089E5 E001      LDI	R16,1
    089E6 940E 97B7 CALL	_SetDelayTime
    089E8 E085      LDI	R24,5
(0979) 	if(waitMotor0){	if(GetMotState(MOT_SAMP_TRUN)!=STA_SLAVE_FREE)		return 0;	waitMotor0 = 0;	}
    089E9 9380 08EA STS	PacketState+234,R24
    089EB C02D      RJMP	0x8A19
    089EC 2700      CLR	R16
    089ED 940E 18A0 CALL	_SetCardTrolleyState
    089EF E025      LDI	R18,5
    089F0 E030      LDI	R19,0
    089F1 E001      LDI	R16,1
    089F2 940E 97B7 CALL	_SetDelayTime
    089F4 E086      LDI	R24,6
    089F5 9380 08EA STS	PacketState+234,R24
(0980) 	if(waitMotor1){	if(GetMotState(MOT_SAMP_NEEDLE)!=STA_SLAVE_FREE)	return 0;	waitMotor1 = 0;	}
    089F7 C021      RJMP	0x8A19
    089F8 2722      CLR	R18
    089F9 2733      CLR	R19
    089FA E008      LDI	R16,0x8
    089FB 940E 6A5B CALL	_MotRunTo
    089FD E081      LDI	R24,1
    089FE 9380 08ED STS	PacketState+237,R24
    08A00 E087      LDI	R24,7
    08A01 9380 08EA STS	PacketState+234,R24
    08A03 C015      RJMP	0x8A19
    08A04 9180 00C1 LDS	R24,0xC1
(0981) 
(0982) 	switch(mainStep){
    08A06 7E8F      ANDI	R24,0xEF
    08A07 9380 00C1 STS	0xC1,R24
    08A09 E323      LDI	R18,0x33
    08A0A E138      LDI	R19,0x18
    08A0B E50A      LDI	R16,0x5A
    08A0C E019      LDI	R17,0x9
    08A0D 940E A90D CALL	_uart_Printf
    08A0F 9180 00C1 LDS	R24,0xC1
    08A11 6180      ORI	R24,0x10
    08A12 9380 00C1 STS	0xC1,R24
    08A14 2422      CLR	R2
    08A15 9220 08EA STS	PacketState+234,R2
    08A17 E001      LDI	R16,1
    08A18 C001      RJMP	0x8A1A
    08A19 2700      CLR	R16
    08A1A 9623      ADIW	R28,3
    08A1B 940C AE88 JMP	pop_xgset300C
_CardLoadCheck:
    08A1D 934A      ST	-Y,R20
    08A1E 935A      ST	-Y,R21
    08A1F 9723      SBIW	R28,3
    08A20 E001      LDI	R16,1
    08A21 940E 97C6 CALL	_WaitDelayTime
    08A23 2300      TST	R16
    08A24 F011      BEQ	0x8A27
    08A25 2700      CLR	R16
    08A26 C0B8      RJMP	0x8ADF
    08A27 9020 08ED LDS	R2,PacketState+237
    08A29 2022      TST	R2
    08A2A F051      BEQ	0x8A35
    08A2B E004      LDI	R16,4
    08A2C 940E 6A0C CALL	_GetMotState
    08A2E 3001      CPI	R16,1
    08A2F F011      BEQ	0x8A32
    08A30 2700      CLR	R16
    08A31 C0AD      RJMP	0x8ADF
    08A32 2422      CLR	R2
    08A33 9220 08ED STS	PacketState+237,R2
    08A35 9140 08EA LDS	R20,PacketState+234
    08A37 2755      CLR	R21
    08A38 3144      CPI	R20,0x14
    08A39 E0E0      LDI	R30,0
    08A3A 075E      CPC	R21,R30
(0983) 		case 0:
(0984) 			SetMotRunPam(MOT_SAMP_NEEDLE,240,10,CURRENT_SAMP_NEEDLE);
    08A3B F409      BNE	0x8A3D
    08A3C C056      RJMP	0x8A93
    08A3D E184      LDI	R24,0x14
    08A3E E090      LDI	R25,0
    08A3F 1784      CP	R24,R20
    08A40 0795      CPC	R25,R21
    08A41 F0EC      BLT	0x8A5F
    08A42 3040      CPI	R20,0
(0985) 			MotInitCheck(MOT_SAMP_NEEDLE);
    08A43 0745      CPC	R20,R21
    08A44 F129      BEQ	0x8A6A
    08A45 3041      CPI	R20,1
(0986) 			waitMotor1 = 1;
    08A46 E0E0      LDI	R30,0
    08A47 075E      CPC	R21,R30
    08A48 F409      BNE	0x8A4A
(0987) 			mainStep = 1;
    08A49 C031      RJMP	0x8A7B
    08A4A 3042      CPI	R20,2
(0988) 			break;
    08A4B E0E0      LDI	R30,0
(0989) 		case 1:
(0990) 			SetMotRunPam(MOT_SAMP_TRUN,120,40,CURRENT_SAMP_TRUN);
    08A4C 075E      CPC	R21,R30
    08A4D F409      BNE	0x8A4F
    08A4E C035      RJMP	0x8A84
    08A4F 3043      CPI	R20,3
    08A50 E0E0      LDI	R30,0
    08A51 075E      CPC	R21,R30
    08A52 F409      BNE	0x8A54
    08A53 C04A      RJMP	0x8A9E
(0991) 			MotInitCheck(MOT_SAMP_TRUN);
    08A54 3044      CPI	R20,4
    08A55 E0E0      LDI	R30,0
    08A56 075E      CPC	R21,R30
(0992) 			waitMotor0 = 1;
    08A57 F409      BNE	0x8A59
    08A58 C04E      RJMP	0x8AA7
    08A59 3045      CPI	R20,5
(0993) 			mainStep = 2;
    08A5A E0E0      LDI	R30,0
    08A5B 075E      CPC	R21,R30
    08A5C F409      BNE	0x8A5E
(0994) 			break;
    08A5D C06B      RJMP	0x8AC9
(0995) 		case 2:
(0996) 			SetDelayTime(1, 5);
    08A5E C07F      RJMP	0x8ADE
    08A5F 3342      CPI	R20,0x32
    08A60 E0E0      LDI	R30,0
    08A61 075E      CPC	R21,R30
    08A62 F409      BNE	0x8A64
(0997) 			mainStep = 3;
    08A63 C04F      RJMP	0x8AB3
    08A64 3343      CPI	R20,0x33
    08A65 E0E0      LDI	R30,0
(0998) 			break;
    08A66 075E      CPC	R21,R30
(0999) 		case 3:
(1000) 			MotRunTo(MOT_SAMP_TRUN, GetNeedleOnMixSidePos());
    08A67 F409      BNE	0x8A69
    08A68 C052      RJMP	0x8ABB
    08A69 C074      RJMP	0x8ADE
    08A6A E084      LDI	R24,4
    08A6B 838A      STD	Y+2,R24
    08A6C E184      LDI	R24,0x14
    08A6D 8388      ST	Y,R24
(1001) 			waitMotor0 = 1;
    08A6E E624      LDI	R18,0x64
    08A6F E004      LDI	R16,4
    08A70 940E 6A9F CALL	_SetMotRunPam
(1002) 			mainStep = 4;
    08A72 E004      LDI	R16,4
    08A73 940E 6AFA CALL	_MotInitCheck
(1003) 		case 4:
(1004) 			SetDelayTime(1, 5);
    08A75 E081      LDI	R24,1
    08A76 9380 08ED STS	PacketState+237,R24
    08A78 9380 08EA STS	PacketState+234,R24
(1005) 			mainStep = 5;
    08A7A C063      RJMP	0x8ADE
    08A7B E025      LDI	R18,5
(1006) 			break;
    08A7C E030      LDI	R19,0
(1007) 		case 5:
(1008) 			MotRunTo(MOT_SAMP_NEEDLE, _POS_MIX_TOP);
    08A7D E001      LDI	R16,1
    08A7E 940E 97B7 CALL	_SetDelayTime
    08A80 E082      LDI	R24,2
    08A81 9380 08EA STS	PacketState+234,R24
(1009) 			waitMotor1 = 1;
    08A83 C05A      RJMP	0x8ADE
    08A84 2722      CLR	R18
(1010) 			mainStep = 6;
    08A85 E004      LDI	R16,4
    08A86 940E 2FEA CALL	_GetMotorMonitorState
(1011) 			break;
    08A88 2F40      MOV	R20,R16
(1012) 		case 6:
(1013) 			SetDelayTime(1, 30);
    08A89 3001      CPI	R16,1
    08A8A F421      BNE	0x8A8F
    08A8B E184      LDI	R24,0x14
    08A8C 9380 08EA STS	PacketState+234,R24
(1014) 			mainStep = 7;
    08A8E C04F      RJMP	0x8ADE
    08A8F 2422      CLR	R2
    08A90 9220 08EA STS	PacketState+234,R2
(1015) 			break;
    08A92 C04B      RJMP	0x8ADE
    08A93 E420      LDI	R18,0x40
    08A94 E036      LDI	R19,6
    08A95 E004      LDI	R16,4
    08A96 940E 6A5B CALL	_MotRunTo
(1016) 		case 7:
(1017) 			MotRunTo(MOT_SAMP_NEEDLE, 0);
(1018) 			waitMotor1 = 1;
    08A98 E081      LDI	R24,1
    08A99 9380 08ED STS	PacketState+237,R24
(1019) 			mainStep = 8;
    08A9B E083      LDI	R24,3
    08A9C 9380 08EA STS	PacketState+234,R24
(1020) 			break;
    08A9E E02A      LDI	R18,0xA
    08A9F E030      LDI	R19,0
    08AA0 E001      LDI	R16,1
    08AA1 940E 97B7 CALL	_SetDelayTime
(1021) 		case 8:
(1022) 			MotRunTo(MOT_SAMP_TRUN, 0);
(1023) 			waitMotor0 = 1;
    08AA3 E084      LDI	R24,4
    08AA4 9380 08EA STS	PacketState+234,R24
(1024) 			mainStep = 9;
    08AA6 C037      RJMP	0x8ADE
    08AA7 2722      CLR	R18
    08AA8 2733      CLR	R19
(1025) 			break;
    08AA9 E004      LDI	R16,4
(1026) 		case 9:
(1027) 			Uart0ReUnable;
    08AAA 940E 6A5B CALL	_MotRunTo
    08AAC E081      LDI	R24,1
    08AAD 9380 08ED STS	PacketState+237,R24
(1028) 			uart_Printf("%s\r\n",strM4137);
    08AAF E085      LDI	R24,5
    08AB0 9380 08EA STS	PacketState+234,R24
    08AB2 C02B      RJMP	0x8ADE
    08AB3 E025      LDI	R18,5
    08AB4 E030      LDI	R19,0
(1029) 			Uart0ReEnable;
    08AB5 E001      LDI	R16,1
    08AB6 940E 97B7 CALL	_SetDelayTime
    08AB8 E383      LDI	R24,0x33
    08AB9 9380 08EA STS	PacketState+234,R24
(1030) 			mainStep = 0;
    08ABB 2722      CLR	R18
    08ABC E004      LDI	R16,4
(1031) 			return 1;
    08ABD 940E 2FEA CALL	_GetMotorMonitorState
(1032) 			break;
(1033) 		default:
(1034) 			break;
(1035) 		}
(1036) 	return 0;
    08ABF 2F40      MOV	R20,R16
    08AC0 3001      CPI	R16,1
    08AC1 F421      BNE	0x8AC6
    08AC2 E085      LDI	R24,5
_DropHeightCheck:
    08AC3 9380 08EA STS	PacketState+234,R24
    08AC5 C003      RJMP	0x8AC9
(1037) }
(1038) unsigned char DropHeightCheck(void){
(1039) 	if(WaitDelayTime(1))		return 0;
    08AC6 E084      LDI	R24,4
    08AC7 9380 08EA STS	PacketState+234,R24
    08AC9 9180 00C1 LDS	R24,0xC1
    08ACB 7E8F      ANDI	R24,0xEF
    08ACC 9380 00C1 STS	0xC1,R24
(1040) 	if(waitMotor0){	if(GetMotState(MOT_SAMP_TRUN)!=STA_SLAVE_FREE)		return 0;	waitMotor0 = 0;	}
    08ACE E42F      LDI	R18,0x4F
    08ACF E138      LDI	R19,0x18
    08AD0 E50A      LDI	R16,0x5A
    08AD1 E019      LDI	R17,0x9
    08AD2 940E A90D CALL	_uart_Printf
    08AD4 9180 00C1 LDS	R24,0xC1
    08AD6 6180      ORI	R24,0x10
    08AD7 9380 00C1 STS	0xC1,R24
    08AD9 2422      CLR	R2
    08ADA 9220 08EA STS	PacketState+234,R2
(1041) 	if(waitMotor1){	if(GetMotState(MOT_SAMP_NEEDLE)!=STA_SLAVE_FREE)	return 0;	waitMotor1 = 0;	}
    08ADC E001      LDI	R16,1
    08ADD C001      RJMP	0x8ADF
    08ADE 2700      CLR	R16
    08ADF 9623      ADIW	R28,3
    08AE0 9159      LD	R21,Y+
    08AE1 9149      LD	R20,Y+
    08AE2 9508      RET
_CardUnloadCheck:
    08AE3 934A      ST	-Y,R20
    08AE4 935A      ST	-Y,R21
    08AE5 9723      SBIW	R28,3
    08AE6 E001      LDI	R16,1
    08AE7 940E 97C6 CALL	_WaitDelayTime
    08AE9 2300      TST	R16
(1042) 	if(waitMotor2){	if(GetMotState(MOT_CARD_LOAD)!=STA_SLAVE_FREE)	return 0;	waitMotor2 = 0;	}
    08AEA F011      BEQ	0x8AED
    08AEB 2700      CLR	R16
    08AEC C07A      RJMP	0x8B67
    08AED 9020 08ED LDS	R2,PacketState+237
    08AEF 2022      TST	R2
    08AF0 F051      BEQ	0x8AFB
    08AF1 E005      LDI	R16,5
    08AF2 940E 6A0C CALL	_GetMotState
    08AF4 3001      CPI	R16,1
    08AF5 F011      BEQ	0x8AF8
    08AF6 2700      CLR	R16
    08AF7 C06F      RJMP	0x8B67
    08AF8 2422      CLR	R2
(1043) 
(1044) 	switch(mainStep){
    08AF9 9220 08ED STS	PacketState+237,R2
    08AFB 9140 08EA LDS	R20,PacketState+234
    08AFD 2755      CLR	R21
    08AFE 3040      CPI	R20,0
    08AFF 0745      CPC	R20,R21
    08B00 F0B1      BEQ	0x8B17
    08B01 3041      CPI	R20,1
    08B02 E0E0      LDI	R30,0
    08B03 075E      CPC	R21,R30
    08B04 F119      BEQ	0x8B28
    08B05 3042      CPI	R20,2
    08B06 E0E0      LDI	R30,0
    08B07 075E      CPC	R21,R30
    08B08 F141      BEQ	0x8B31
    08B09 3043      CPI	R20,3
    08B0A E0E0      LDI	R30,0
    08B0B 075E      CPC	R21,R30
    08B0C F179      BEQ	0x8B3C
    08B0D 3044      CPI	R20,4
    08B0E E0E0      LDI	R30,0
    08B0F 075E      CPC	R21,R30
    08B10 F1A1      BEQ	0x8B45
    08B11 3045      CPI	R20,5
    08B12 E0E0      LDI	R30,0
    08B13 075E      CPC	R21,R30
    08B14 F409      BNE	0x8B16
    08B15 C03B      RJMP	0x8B51
    08B16 C04F      RJMP	0x8B66
    08B17 E084      LDI	R24,4
    08B18 838A      STD	Y+2,R24
    08B19 E184      LDI	R24,0x14
    08B1A 8388      ST	Y,R24
    08B1B E624      LDI	R18,0x64
    08B1C E005      LDI	R16,5
    08B1D 940E 6A9F CALL	_SetMotRunPam
    08B1F E005      LDI	R16,5
    08B20 940E 6AFA CALL	_MotInitCheck
    08B22 E081      LDI	R24,1
    08B23 9380 08ED STS	PacketState+237,R24
    08B25 9380 08EA STS	PacketState+234,R24
    08B27 C03E      RJMP	0x8B66
    08B28 E02A      LDI	R18,0xA
    08B29 E030      LDI	R19,0
    08B2A E001      LDI	R16,1
    08B2B 940E 97B7 CALL	_SetDelayTime
    08B2D E082      LDI	R24,2
(1045) 		case 0:
(1046) 			SetMotRunPam(MOT_SAMP_NEEDLE,240,10,CURRENT_SAMP_NEEDLE);
    08B2E 9380 08EA STS	PacketState+234,R24
    08B30 C035      RJMP	0x8B66
    08B31 E420      LDI	R18,0x40
    08B32 E036      LDI	R19,6
    08B33 E005      LDI	R16,5
    08B34 940E 6A5B CALL	_MotRunTo
(1047) 			MotInitCheck(MOT_SAMP_NEEDLE);
    08B36 E081      LDI	R24,1
    08B37 9380 08ED STS	PacketState+237,R24
(1048) 			waitMotor1 = 1;
    08B39 E083      LDI	R24,3
    08B3A 9380 08EA STS	PacketState+234,R24
(1049) 			mainStep = 1;
    08B3C E02A      LDI	R18,0xA
    08B3D E030      LDI	R19,0
(1050) 			break;
    08B3E E001      LDI	R16,1
(1051) 		case 1:
(1052) 			SetMotRunPam(MOT_SAMP_TRUN,120,40,CURRENT_SAMP_TRUN);
    08B3F 940E 97B7 CALL	_SetDelayTime
    08B41 E084      LDI	R24,4
    08B42 9380 08EA STS	PacketState+234,R24
    08B44 C021      RJMP	0x8B66
    08B45 2722      CLR	R18
    08B46 2733      CLR	R19
(1053) 			MotInitCheck(MOT_SAMP_TRUN);
    08B47 E005      LDI	R16,5
    08B48 940E 6A5B CALL	_MotRunTo
(1054) 			SetMotRunPam(MOT_CARD_LOAD,140,10,CURRENT_CARD_LOAD);
    08B4A E081      LDI	R24,1
    08B4B 9380 08ED STS	PacketState+237,R24
    08B4D E085      LDI	R24,5
    08B4E 9380 08EA STS	PacketState+234,R24
    08B50 C015      RJMP	0x8B66
    08B51 9180 00C1 LDS	R24,0xC1
(1055) 			MotInitCheck(MOT_CARD_LOAD);
    08B53 7E8F      ANDI	R24,0xEF
    08B54 9380 00C1 STS	0xC1,R24
(1056) 			waitMotor0 = 1;
    08B56 E627      LDI	R18,0x67
    08B57 E138      LDI	R19,0x18
(1057) 			mainStep = 2;
    08B58 E50A      LDI	R16,0x5A
    08B59 E019      LDI	R17,0x9
    08B5A 940E A90D CALL	_uart_Printf
(1058) 			break;
    08B5C 9180 00C1 LDS	R24,0xC1
    08B5E 6180      ORI	R24,0x10
    08B5F 9380 00C1 STS	0xC1,R24
(1059) 		case 2:
(1060) 			SetDelayTime(1, 5);
(1061) 			mainStep = 3;
    08B61 2422      CLR	R2
    08B62 9220 08EA STS	PacketState+234,R2
(1062) 			break;
    08B64 E001      LDI	R16,1
(1063) 		case 3:
(1064) 			MotRunTo(MOT_CARD_LOAD, _POS_CARDLOAD_DROP);
    08B65 C001      RJMP	0x8B67
    08B66 2700      CLR	R16
    08B67 9623      ADIW	R28,3
    08B68 9159      LD	R21,Y+
    08B69 9149      LD	R20,Y+
(1065) 			waitMotor2 = 1;
    08B6A 9508      RET
_DiluentPumpCheck:
    08B6B 934A      ST	-Y,R20
    08B6C 935A      ST	-Y,R21
(1066) 			mainStep = 4;
    08B6D 9723      SBIW	R28,3
    08B6E E001      LDI	R16,1
    08B6F 940E 97C6 CALL	_WaitDelayTime
(1067) 			break;
    08B71 2300      TST	R16
    08B72 F011      BEQ	0x8B75
    08B73 2700      CLR	R16
    08B74 C086      RJMP	0x8BFB
    08B75 9020 08ED LDS	R2,PacketState+237
(1068) 		case 4:
(1069) 			SetDelayTime(1, 5);
(1070) 			mainStep = 5;
    08B77 2022      TST	R2
    08B78 F051      BEQ	0x8B83
(1071) 			break;
    08B79 E009      LDI	R16,0x9
(1072) 		case 5:
(1073) 			MotRunTo(MOT_SAMP_NEEDLE, GetDropHeight());
    08B7A 940E 6A0C CALL	_GetMotState
    08B7C 3001      CPI	R16,1
    08B7D F011      BEQ	0x8B80
    08B7E 2700      CLR	R16
    08B7F C07B      RJMP	0x8BFB
    08B80 2422      CLR	R2
(1074) 			waitMotor1 = 1;
    08B81 9220 08ED STS	PacketState+237,R2
    08B83 9020 08EE LDS	R2,PacketState+238
(1075) 			mainStep = 6;
    08B85 2022      TST	R2
    08B86 F059      BEQ	0x8B92
(1076) 			break;
    08B87 E00B      LDI	R16,0xB
(1077) 		case 6:
(1078) 			SetDelayTime(1, 30);
    08B88 940E 6A0C CALL	_GetMotState
    08B8A 2F40      MOV	R20,R16
    08B8B 3001      CPI	R16,1
    08B8C F011      BEQ	0x8B8F
(1079) 			mainStep = 7;
    08B8D 2700      CLR	R16
    08B8E C06C      RJMP	0x8BFB
    08B8F 2422      CLR	R2
(1080) 			break;
    08B90 9220 08ED STS	PacketState+237,R2
(1081) 		case 7:
(1082) 			MotRunTo(MOT_SAMP_NEEDLE, 0);
    08B92 9140 08EA LDS	R20,PacketState+234
    08B94 2755      CLR	R21
    08B95 3040      CPI	R20,0
(1083) 			waitMotor1 = 1;
    08B96 0745      CPC	R20,R21
    08B97 F091      BEQ	0x8BAA
    08B98 3041      CPI	R20,1
(1084) 			mainStep = 8;
    08B99 E0E0      LDI	R30,0
    08B9A 075E      CPC	R21,R30
    08B9B F101      BEQ	0x8BBC
(1085) 			break;
    08B9C 3042      CPI	R20,2
(1086) 		case 8:
(1087) 			MotRunTo(MOT_CARD_LOAD, 0);
    08B9D E0E0      LDI	R30,0
    08B9E 075E      CPC	R21,R30
    08B9F F129      BEQ	0x8BC5
    08BA0 3043      CPI	R20,3
    08BA1 E0E0      LDI	R30,0
(1088) 			waitMotor2 = 1;
    08BA2 075E      CPC	R21,R30
    08BA3 F169      BEQ	0x8BD1
    08BA4 3044      CPI	R20,4
(1089) 			mainStep = 9;
    08BA5 E0E0      LDI	R30,0
    08BA6 075E      CPC	R21,R30
    08BA7 F409      BNE	0x8BA9
(1090) 			break;
    08BA8 C03C      RJMP	0x8BE5
(1091) 		case 9:
(1092) 			Uart0ReUnable;
    08BA9 C050      RJMP	0x8BFA
    08BAA E084      LDI	R24,4
    08BAB 838A      STD	Y+2,R24
    08BAC E082      LDI	R24,2
    08BAD 8388      ST	Y,R24
(1093) 			uart_Printf("%s\r\n",strM4138);
    08BAE E624      LDI	R18,0x64
    08BAF E009      LDI	R16,0x9
    08BB0 940E 6A9F CALL	_SetMotRunPam
    08BB2 E220      LDI	R18,0x20
    08BB3 E033      LDI	R19,3
(1094) 			Uart0ReEnable;
    08BB4 E009      LDI	R16,0x9
    08BB5 940E 6A2C CALL	_MotRun
    08BB7 E081      LDI	R24,1
    08BB8 9380 08ED STS	PacketState+237,R24
(1095) 			mainStep = 0;
    08BBA 9380 08EA STS	PacketState+234,R24
(1096) 			return 1;
    08BBC E02A      LDI	R18,0xA
    08BBD E030      LDI	R19,0
(1097) 			break;
(1098) 		default:
(1099) 			break;
(1100) 		}
(1101) 	return 0;
    08BBE E001      LDI	R16,1
    08BBF 940E 97B7 CALL	_SetDelayTime
    08BC1 E082      LDI	R24,2
_MixHeightCheck:
    08BC2 9380 08EA STS	PacketState+234,R24
    08BC4 C035      RJMP	0x8BFA
(1102) 
(1103) }
(1104) 
(1105) 
(1106) unsigned char MixHeightCheck(void)
(1107) {
(1108) 	if(WaitDelayTime(1))		return 0;
    08BC5 E220      LDI	R18,0x20
    08BC6 E033      LDI	R19,3
    08BC7 E009      LDI	R16,0x9
    08BC8 940E 6A2C CALL	_MotRun
    08BCA E081      LDI	R24,1
    08BCB 9380 08ED STS	PacketState+237,R24
(1109) 	if(waitMotor0){	if(GetMotState(MOT_SAMP_TRUN)!=STA_SLAVE_FREE)		return 0;	waitMotor0 = 0;	}
    08BCD E083      LDI	R24,3
    08BCE 9380 08EA STS	PacketState+234,R24
    08BD0 C029      RJMP	0x8BFA
    08BD1 E084      LDI	R24,4
    08BD2 838A      STD	Y+2,R24
    08BD3 E082      LDI	R24,2
    08BD4 8388      ST	Y,R24
    08BD5 EC28      LDI	R18,0xC8
    08BD6 E00B      LDI	R16,0xB
    08BD7 940E 6A9F CALL	_SetMotRunPam
    08BD9 EB28      LDI	R18,0xB8
(1110) 	if(waitMotor1){	if(GetMotState(MOT_SAMP_NEEDLE)!=STA_SLAVE_FREE)	return 0;	waitMotor1 = 0;	}
    08BDA E03B      LDI	R19,0xB
    08BDB E00B      LDI	R16,0xB
    08BDC 940E 6A2C CALL	_MotRun
    08BDE E081      LDI	R24,1
    08BDF 9380 08EE STS	PacketState+238,R24
    08BE1 E084      LDI	R24,4
    08BE2 9380 08EA STS	PacketState+234,R24
    08BE4 C015      RJMP	0x8BFA
    08BE5 9180 00C1 LDS	R24,0xC1
    08BE7 7E8F      ANDI	R24,0xEF
    08BE8 9380 00C1 STS	0xC1,R24
(1111) 	if(waitMotor2){	if(GetMotState(MOT_CARD_LOAD)!=STA_SLAVE_FREE)	return 0;	waitMotor2 = 0;	}
    08BEA EB27      LDI	R18,0xB7
    08BEB E138      LDI	R19,0x18
    08BEC E50A      LDI	R16,0x5A
    08BED E019      LDI	R17,0x9
    08BEE 940E A90D CALL	_uart_Printf
    08BF0 9180 00C1 LDS	R24,0xC1
    08BF2 6180      ORI	R24,0x10
    08BF3 9380 00C1 STS	0xC1,R24
    08BF5 2422      CLR	R2
    08BF6 9220 08EA STS	PacketState+234,R2
(1112) 
(1113) 	switch(mainStep){
    08BF8 E001      LDI	R16,1
    08BF9 C001      RJMP	0x8BFB
    08BFA 2700      CLR	R16
    08BFB 9623      ADIW	R28,3
    08BFC 9159      LD	R21,Y+
    08BFD 9149      LD	R20,Y+
    08BFE 9508      RET
_LeanerPumpCheck:
    08BFF 934A      ST	-Y,R20
    08C00 935A      ST	-Y,R21
    08C01 9723      SBIW	R28,3
    08C02 E001      LDI	R16,1
    08C03 940E 97C6 CALL	_WaitDelayTime
    08C05 2300      TST	R16
    08C06 F011      BEQ	0x8C09
    08C07 2700      CLR	R16
    08C08 C086      RJMP	0x8C8F
    08C09 9020 08ED LDS	R2,PacketState+237
    08C0B 2022      TST	R2
    08C0C F051      BEQ	0x8C17
    08C0D E00A      LDI	R16,0xA
    08C0E 940E 6A0C CALL	_GetMotState
    08C10 3001      CPI	R16,1
    08C11 F011      BEQ	0x8C14
    08C12 2700      CLR	R16
    08C13 C07B      RJMP	0x8C8F
    08C14 2422      CLR	R2
    08C15 9220 08ED STS	PacketState+237,R2
    08C17 9020 08EE LDS	R2,PacketState+238
    08C19 2022      TST	R2
    08C1A F059      BEQ	0x8C26
    08C1B E00B      LDI	R16,0xB
    08C1C 940E 6A0C CALL	_GetMotState
    08C1E 2F40      MOV	R20,R16
    08C1F 3001      CPI	R16,1
    08C20 F011      BEQ	0x8C23
    08C21 2700      CLR	R16
    08C22 C06C      RJMP	0x8C8F
    08C23 2422      CLR	R2
    08C24 9220 08ED STS	PacketState+237,R2
    08C26 9140 08EA LDS	R20,PacketState+234
    08C28 2755      CLR	R21
    08C29 3040      CPI	R20,0
    08C2A 0745      CPC	R20,R21
    08C2B F091      BEQ	0x8C3E
    08C2C 3041      CPI	R20,1
(1114) 		case 0:
(1115) 			SetMotRunPam(MOT_SAMP_NEEDLE,240,10,CURRENT_SAMP_NEEDLE);
    08C2D E0E0      LDI	R30,0
    08C2E 075E      CPC	R21,R30
    08C2F F101      BEQ	0x8C50
    08C30 3042      CPI	R20,2
    08C31 E0E0      LDI	R30,0
    08C32 075E      CPC	R21,R30
    08C33 F129      BEQ	0x8C59
    08C34 3043      CPI	R20,3
(1116) 			MotInitCheck(MOT_SAMP_NEEDLE);
    08C35 E0E0      LDI	R30,0
    08C36 075E      CPC	R21,R30
    08C37 F169      BEQ	0x8C65
(1117) 			waitMotor1 = 1;
    08C38 3044      CPI	R20,4
    08C39 E0E0      LDI	R30,0
    08C3A 075E      CPC	R21,R30
(1118) 			mainStep = 1;
    08C3B F409      BNE	0x8C3D
    08C3C C03C      RJMP	0x8C79
(1119) 			break;
    08C3D C050      RJMP	0x8C8E
(1120) 		case 1:
(1121) 			SetMotRunPam(MOT_SAMP_TRUN,120,40,CURRENT_SAMP_TRUN);
    08C3E E084      LDI	R24,4
    08C3F 838A      STD	Y+2,R24
    08C40 E082      LDI	R24,2
    08C41 8388      ST	Y,R24
    08C42 E520      LDI	R18,0x50
    08C43 E00A      LDI	R16,0xA
    08C44 940E 6A9F CALL	_SetMotRunPam
(1122) 			MotInitCheck(MOT_SAMP_TRUN);
    08C46 E220      LDI	R18,0x20
    08C47 E033      LDI	R19,3
    08C48 E00A      LDI	R16,0xA
(1123) 			SetMotRunPam(MOT_CARD_LOAD,140,10,CURRENT_CARD_LOAD);
    08C49 940E 6A2C CALL	_MotRun
    08C4B E081      LDI	R24,1
    08C4C 9380 08ED STS	PacketState+237,R24
    08C4E 9380 08EA STS	PacketState+234,R24
    08C50 E02A      LDI	R18,0xA
(1124) 			MotInitCheck(MOT_CARD_LOAD);
    08C51 E030      LDI	R19,0
    08C52 E001      LDI	R16,1
    08C53 940E 97B7 CALL	_SetDelayTime
(1125) 			waitMotor0 = 1;
    08C55 E082      LDI	R24,2
    08C56 9380 08EA STS	PacketState+234,R24
(1126) 			mainStep = 2;
    08C58 C035      RJMP	0x8C8E
    08C59 E220      LDI	R18,0x20
(1127) 			break;
    08C5A E033      LDI	R19,3
(1128) 		case 2:
(1129) 			SetDelayTime(1, 5);
    08C5B E00A      LDI	R16,0xA
    08C5C 940E 6A2C CALL	_MotRun
    08C5E E081      LDI	R24,1
    08C5F 9380 08ED STS	PacketState+237,R24
(1130) 			mainStep = 3;
    08C61 E083      LDI	R24,3
    08C62 9380 08EA STS	PacketState+234,R24
(1131) 			break;
    08C64 C029      RJMP	0x8C8E
    08C65 E084      LDI	R24,4
    08C66 838A      STD	Y+2,R24
    08C67 E082      LDI	R24,2
    08C68 8388      ST	Y,R24
(1132) 		case 3:
(1133) 			MotRunTo(MOT_CARD_LOAD, _POS_CARDLOAD_MIX);
(1134) 			waitMotor2 = 1;
    08C69 EC28      LDI	R18,0xC8
    08C6A E00B      LDI	R16,0xB
    08C6B 940E 6A9F CALL	_SetMotRunPam
(1135) 			mainStep = 4;
    08C6D EB28      LDI	R18,0xB8
    08C6E E03B      LDI	R19,0xB
(1136) 			break;
    08C6F E00B      LDI	R16,0xB
(1137) 		case 4:
(1138) 			SetDelayTime(1, 5);
    08C70 940E 6A2C CALL	_MotRun
    08C72 E081      LDI	R24,1
    08C73 9380 08EE STS	PacketState+238,R24
(1139) 			mainStep = 5;
    08C75 E084      LDI	R24,4
    08C76 9380 08EA STS	PacketState+234,R24
(1140) 			break;
    08C78 C015      RJMP	0x8C8E
(1141) 		case 5:
(1142) 			MotRunTo(MOT_SAMP_NEEDLE, GetMixHeight());
    08C79 9180 00C1 LDS	R24,0xC1
    08C7B 7E8F      ANDI	R24,0xEF
    08C7C 9380 00C1 STS	0xC1,R24
    08C7E ED22      LDI	R18,0xD2
    08C7F E138      LDI	R19,0x18
(1143) 			waitMotor1 = 1;
    08C80 E50A      LDI	R16,0x5A
    08C81 E019      LDI	R17,0x9
    08C82 940E A90D CALL	_uart_Printf
(1144) 			mainStep = 6;
    08C84 9180 00C1 LDS	R24,0xC1
(1145) 			break;
    08C86 6180      ORI	R24,0x10
(1146) 		case 6:
(1147) 			SetDelayTime(1, 30);
    08C87 9380 00C1 STS	0xC1,R24
    08C89 2422      CLR	R2
    08C8A 9220 08EA STS	PacketState+234,R2
(1148) 			mainStep = 7;
    08C8C E001      LDI	R16,1
    08C8D C001      RJMP	0x8C8F
    08C8E 2700      CLR	R16
(1149) 			break;
    08C8F 9623      ADIW	R28,3
(1150) 		case 7:
(1151) 			MotRunTo(MOT_SAMP_NEEDLE, 0);
    08C90 9159      LD	R21,Y+
    08C91 9149      LD	R20,Y+
    08C92 9508      RET
_EffluentPumpCheck:
    08C93 934A      ST	-Y,R20
    08C94 935A      ST	-Y,R21
(1152) 			waitMotor1 = 1;
    08C95 9723      SBIW	R28,3
    08C96 E001      LDI	R16,1
    08C97 940E 97C6 CALL	_WaitDelayTime
(1153) 			mainStep = 8;
    08C99 2300      TST	R16
    08C9A F011      BEQ	0x8C9D
(1154) 			break;
    08C9B 2700      CLR	R16
(1155) 		case 8:
(1156) 			MotRunTo(MOT_CARD_LOAD, 0);
    08C9C C05E      RJMP	0x8CFB
    08C9D 9020 08ED LDS	R2,PacketState+237
    08C9F 2022      TST	R2
    08CA0 F051      BEQ	0x8CAB
(1157) 			waitMotor2 = 1;
    08CA1 E00B      LDI	R16,0xB
    08CA2 940E 6A0C CALL	_GetMotState
(1158) 			mainStep = 9;
    08CA4 3001      CPI	R16,1
    08CA5 F011      BEQ	0x8CA8
    08CA6 2700      CLR	R16
(1159) 			break;
    08CA7 C053      RJMP	0x8CFB
(1160) 		case 9:
(1161) 			Uart0ReUnable;
    08CA8 2422      CLR	R2
    08CA9 9220 08ED STS	PacketState+237,R2
    08CAB 9140 08EA LDS	R20,PacketState+234
(1162) 			uart_Printf("%s\r\n",strM4119);
    08CAD 2755      CLR	R21
    08CAE 3040      CPI	R20,0
    08CAF 0745      CPC	R20,R21
    08CB0 F069      BEQ	0x8CBE
    08CB1 3041      CPI	R20,1
    08CB2 E0E0      LDI	R30,0
(1163) 			Uart0ReEnable;
    08CB3 075E      CPC	R21,R30
    08CB4 F0D9      BEQ	0x8CD0
    08CB5 3042      CPI	R20,2
    08CB6 E0E0      LDI	R30,0
    08CB7 075E      CPC	R21,R30
(1164) 			mainStep = 0;
    08CB8 F101      BEQ	0x8CD9
    08CB9 3043      CPI	R20,3
    08CBA E0E0      LDI	R30,0
(1165) 			return 1;
    08CBB 075E      CPC	R21,R30
    08CBC F141      BEQ	0x8CE5
(1166) 			break;
(1167) 		default:
(1168) 			break;
(1169) 		}
(1170) 	return 0;
    08CBD C03C      RJMP	0x8CFA
    08CBE E084      LDI	R24,4
    08CBF 838A      STD	Y+2,R24
    08CC0 E082      LDI	R24,2
_SetDiluentQuantifyVolume:
  n                    --> R20
    08CC1 8388      ST	Y,R24
    08CC2 EC28      LDI	R18,0xC8
(1171) 
(1172) }
(1173) 
(1174) 
(1175) static unsigned int DiluentQuantifyVolume = 10*100;
(1176) void SetDiluentQuantifyVolume(unsigned char n){
(1177) 	if(n > 50)
    08CC3 E00B      LDI	R16,0xB
    08CC4 940E 6A9F CALL	_SetMotRunPam
(1178) 		n = 50;
    08CC6 E220      LDI	R18,0x20
(1179) 	if(n == 0)
    08CC7 E033      LDI	R19,3
    08CC8 E00B      LDI	R16,0xB
(1180) 		n = 1;
    08CC9 940E 6A2C CALL	_MotRun
(1181) 	DiluentQuantifyVolume = n * 100;
    08CCB E081      LDI	R24,1
    08CCC 9380 08ED STS	PacketState+237,R24
    08CCE 9380 08EA STS	PacketState+234,R24
    08CD0 E02A      LDI	R18,0xA
    08CD1 E030      LDI	R19,0
    08CD2 E001      LDI	R16,1
_DiluentQuantifyTest:
    08CD3 940E 97B7 CALL	_SetDelayTime
    08CD5 E082      LDI	R24,2
(1182) }
(1183) 
(1184) unsigned int QuantifyTestCnt = 0;
(1185) 
(1186) unsigned char DiluentQuantifyTest(void){
(1187) 	// 稀释液泵定量测试
(1188) 	
(1189) 	if(WaitDelayTime(1))		return 0;
    08CD6 9380 08EA STS	PacketState+234,R24
    08CD8 C021      RJMP	0x8CFA
    08CD9 E220      LDI	R18,0x20
    08CDA E033      LDI	R19,3
    08CDB E00B      LDI	R16,0xB
    08CDC 940E 6A2C CALL	_MotRun
(1190) 	if(waitMotor0){	if(GetMotState(MOT_DILUENT)!=STA_SLAVE_FREE)		return 0;	waitMotor0 = 0;	}
    08CDE E081      LDI	R24,1
    08CDF 9380 08ED STS	PacketState+237,R24
    08CE1 E083      LDI	R24,3
    08CE2 9380 08EA STS	PacketState+234,R24
    08CE4 C015      RJMP	0x8CFA
    08CE5 9180 00C1 LDS	R24,0xC1
    08CE7 7E8F      ANDI	R24,0xEF
    08CE8 9380 00C1 STS	0xC1,R24
    08CEA EE2C      LDI	R18,0xEC
(1191) 	if(waitMotor1){	if(GetMotState(MOT_EFFLUENT)!=STA_SLAVE_FREE)		return 0;	waitMotor1 = 0;	}
    08CEB E138      LDI	R19,0x18
    08CEC E50A      LDI	R16,0x5A
    08CED E019      LDI	R17,0x9
    08CEE 940E A90D CALL	_uart_Printf
    08CF0 9180 00C1 LDS	R24,0xC1
    08CF2 6180      ORI	R24,0x10
    08CF3 9380 00C1 STS	0xC1,R24
    08CF5 2422      CLR	R2
    08CF6 9220 08EA STS	PacketState+234,R2
    08CF8 E001      LDI	R16,1
    08CF9 C001      RJMP	0x8CFB
(1192) 
(1193) 	if(waitStartKey){
    08CFA 2700      CLR	R16
    08CFB 9623      ADIW	R28,3
    08CFC 9159      LD	R21,Y+
    08CFD 9149      LD	R20,Y+
(1194) 		if(quitFlag == 1){
    08CFE 9508      RET
_SamplingSyringCheck:
    08CFF 934A      ST	-Y,R20
    08D00 935A      ST	-Y,R21
    08D01 9723      SBIW	R28,3
(1195) 			mainStep = 0;
    08D02 E001      LDI	R16,1
    08D03 940E 97C6 CALL	_WaitDelayTime
(1196) 			waitStartKey = 0;
    08D05 2300      TST	R16
    08D06 F011      BEQ	0x8D09
(1197) 			quitFlag = 0;
    08D07 2700      CLR	R16
    08D08 C07B      RJMP	0x8D84
(1198) 			Uart0ReUnable;
    08D09 9020 08ED LDS	R2,PacketState+237
    08D0B 2022      TST	R2
    08D0C F051      BEQ	0x8D17
    08D0D E00C      LDI	R16,0xC
(1199) 			uart_Printf("%s\r\n",strM4151);
    08D0E 940E 6A0C CALL	_GetMotState
    08D10 3001      CPI	R16,1
    08D11 F011      BEQ	0x8D14
    08D12 2700      CLR	R16
    08D13 C070      RJMP	0x8D84
(1200) 			Uart0ReEnable;
    08D14 2422      CLR	R2
    08D15 9220 08ED STS	PacketState+237,R2
    08D17 9140 08EA LDS	R20,PacketState+234
(1201) 			return 1;		// 结束退出
    08D19 2755      CLR	R21
    08D1A 3040      CPI	R20,0
(1202) 			}
(1203) 		if(WaitStartKey()==0)
    08D1B 0745      CPC	R20,R21
    08D1C F0B1      BEQ	0x8D33
    08D1D 3041      CPI	R20,1
    08D1E E0E0      LDI	R30,0
    08D1F 075E      CPC	R21,R30
(1204) 			return 0;
    08D20 F119      BEQ	0x8D44
    08D21 3042      CPI	R20,2
(1205) 		waitStartKey = 0;	
    08D22 E0E0      LDI	R30,0
    08D23 075E      CPC	R21,R30
    08D24 F141      BEQ	0x8D4D
(1206) 		}
(1207) 	
(1208) 	switch(mainStep){
    08D25 3043      CPI	R20,3
    08D26 E0E0      LDI	R30,0
    08D27 075E      CPC	R21,R30
    08D28 F181      BEQ	0x8D59
    08D29 3044      CPI	R20,4
    08D2A E0E0      LDI	R30,0
    08D2B 075E      CPC	R21,R30
    08D2C F1A9      BEQ	0x8D62
    08D2D 3045      CPI	R20,5
    08D2E E0E0      LDI	R30,0
    08D2F 075E      CPC	R21,R30
    08D30 F409      BNE	0x8D32
    08D31 C03C      RJMP	0x8D6E
    08D32 C050      RJMP	0x8D83
    08D33 E086      LDI	R24,6
    08D34 838A      STD	Y+2,R24
    08D35 E08A      LDI	R24,0xA
    08D36 8388      ST	Y,R24
    08D37 EC28      LDI	R18,0xC8
    08D38 E00C      LDI	R16,0xC
    08D39 940E 6A9F CALL	_SetMotRunPam
    08D3B E00C      LDI	R16,0xC
    08D3C 940E 6AFA CALL	_MotInitCheck
    08D3E E081      LDI	R24,1
(1209) 		case 0:
(1210) 			quitFlag = 0;
    08D3F 9380 08ED STS	PacketState+237,R24
    08D41 9380 08EA STS	PacketState+234,R24
(1211) 			SetEValve(EV_ALL, EV_CLOSE);
    08D43 C03F      RJMP	0x8D83
    08D44 E02A      LDI	R18,0xA
    08D45 E030      LDI	R19,0
(1212) 			_EffluentMotRun(150,200);
    08D46 E001      LDI	R16,1
    08D47 940E 97B7 CALL	_SetDelayTime
    08D49 E082      LDI	R24,2
    08D4A 9380 08EA STS	PacketState+234,R24
(1213) #if 	(DILUTE_TUBE == 14)
(1214) 							_DiluentMotRun(40+5, 64);		// 注入40个单位溶液
(1215) #elif	(DILUTE_TUBE == 16)
(1216) 							_DiluentMotRun(12+2, 64);		// 注入12+2个单位溶液
    08D4C C036      RJMP	0x8D83
    08D4D EC20      LDI	R18,0xC0
    08D4E E132      LDI	R19,0x12
    08D4F E00C      LDI	R16,0xC
    08D50 940E 6A5B CALL	_MotRunTo
(1217) #endif
(1218) 			SetDelayTime(1, 30);
    08D52 E081      LDI	R24,1
    08D53 9380 08ED STS	PacketState+237,R24
    08D55 E083      LDI	R24,3
    08D56 9380 08EA STS	PacketState+234,R24
(1219) 			mainStep = 1;
    08D58 C02A      RJMP	0x8D83
    08D59 E02A      LDI	R18,0xA
(1220) 			break;
    08D5A E030      LDI	R19,0
(1221) 		case 1:
(1222) 			MotStop(MOT_DILUENT);
    08D5B E001      LDI	R16,1
    08D5C 940E 97B7 CALL	_SetDelayTime
(1223) 			MotStop(MOT_EFFLUENT);
    08D5E E084      LDI	R24,4
    08D5F 9380 08EA STS	PacketState+234,R24
(1224) 			QuantifyTestCnt = 0;
    08D61 C021      RJMP	0x8D83
    08D62 2722      CLR	R18
    08D63 2733      CLR	R19
    08D64 E00C      LDI	R16,0xC
    08D65 940E 6A5B CALL	_MotRunTo
(1225) 			mainStep = 2;
    08D67 E081      LDI	R24,1
    08D68 9380 08ED STS	PacketState+237,R24
(1226) 			Uart0ReUnable;
    08D6A E085      LDI	R24,5
    08D6B 9380 08EA STS	PacketState+234,R24
    08D6D C015      RJMP	0x8D83
    08D6E 9180 00C1 LDS	R24,0xC1
(1227) 			uart_Printf("%s\r\n",strM4150);
    08D70 7E8F      ANDI	R24,0xEF
    08D71 9380 00C1 STS	0xC1,R24
    08D73 E028      LDI	R18,0x8
    08D74 E139      LDI	R19,0x19
(1228) 			Uart0ReEnable;
    08D75 E50A      LDI	R16,0x5A
    08D76 E019      LDI	R17,0x9
    08D77 940E A90D CALL	_uart_Printf
    08D79 9180 00C1 LDS	R24,0xC1
(1229) 			break;
    08D7B 6180      ORI	R24,0x10
    08D7C 9380 00C1 STS	0xC1,R24
(1230) 		case 2:
(1231) 			waitStartKey = 1;
(1232) 			mainStep = 3;
    08D7E 2422      CLR	R2
    08D7F 9220 08EA STS	PacketState+234,R2
(1233) 			break;
    08D81 E001      LDI	R16,1
(1234) 		case 3:
(1235) 			QuantifyTestCnt ++;
    08D82 C001      RJMP	0x8D84
    08D83 2700      CLR	R16
    08D84 9623      ADIW	R28,3
    08D85 9159      LD	R21,Y+
    08D86 9149      LD	R20,Y+
    08D87 9508      RET
_LiquidPhotoCheck_Even:
    08D88 940E AE8D CALL	push_xgsetF000
    08D8A 01A8      MOVW	R20,R16
(1236) 			MotRun(MOT_DILUENT, DiluentQuantifyVolume);
    08D8B 9728      SBIW	R28,0x8
    08D8C 9160 08EA LDS	R22,PacketState+234
    08D8E 2777      CLR	R23
    08D8F 3061      CPI	R22,1
    08D90 E0E0      LDI	R30,0
    08D91 077E      CPC	R23,R30
(1237) 			waitMotor0 = 1;
    08D92 F009      BEQ	0x8D94
    08D93 C02C      RJMP	_SetLeanerQuantifyVolume
    08D94 01FA      MOVW	R30,R20
(1238) 			mainStep = 4;
    08D95 8181      LDD	R24,Z+1
    08D96 308A      CPI	R24,0xA
    08D97 F541      BNE	0x8DC0
(1239) 			break;
    08D98 5F4E      SUBI	R20,0xFE
(1240) 		case 4:
(1241) 			Uart0ReUnable;
    08D99 4F5F      SBCI	R21,0xFF
    08D9A 9180 00C1 LDS	R24,0xC1
    08D9C 7E8F      ANDI	R24,0xEF
    08D9D 9380 00C1 STS	0xC1,R24
(1242) 			uart_Printf("%s $%4d\r\n",strM4154, QuantifyTestCnt);
    08D9F 01FA      MOVW	R30,R20
    08DA0 8023      LDD	R2,Z+3
    08DA1 2433      CLR	R3
    08DA2 823F      STD	Y+7,R3
    08DA3 822E      STD	Y+6,R2
    08DA4 8022      LDD	R2,Z+2
    08DA5 2433      CLR	R3
    08DA6 823D      STD	Y+5,R3
    08DA7 822C      STD	Y+4,R2
    08DA8 8021      LDD	R2,Z+1
    08DA9 2433      CLR	R3
(1243) 			Uart0ReEnable;
    08DAA 823B      STD	Y+3,R3
    08DAB 822A      STD	Y+2,R2
    08DAC 8020      LD	R2,Z
    08DAD 2433      CLR	R3
    08DAE 8239      STD	Y+1,R3
(1244) 			MotRun(MOT_EFFLUENT, DiluentQuantifyVolume);
    08DAF 8228      ST	Y,R2
    08DB0 E226      LDI	R18,0x26
    08DB1 E139      LDI	R19,0x19
    08DB2 E201      LDI	R16,0x21
    08DB3 E019      LDI	R17,0x9
    08DB4 940E A90D CALL	_uart_Printf
(1245) 			waitMotor1 = 1;
    08DB6 9180 00C1 LDS	R24,0xC1
    08DB8 6180      ORI	R24,0x10
(1246) 			mainStep = 2;
    08DB9 9380 00C1 STS	0xC1,R24
    08DBB E082      LDI	R24,2
(1247) 			break;
(1248) 		default:
(1249) 			break;
(1250) 		}
(1251) 	return 0;
    08DBC 9380 08EA STS	PacketState+234,R24
    08DBE E001      LDI	R16,1
    08DBF C001      RJMP	0x8DC1
_SetLeanerQuantifyVolume:
  n                    --> R20
    08DC0 2700      CLR	R16
    08DC1 9628      ADIW	R28,0x8
(1252) }
(1253) 
(1254) static unsigned int LeanerQuantifyVolume = 10*100;
(1255) 
(1256) void SetLeanerQuantifyVolume(unsigned char n){
(1257) 	if(n > 15)
    08DC2 940C AE92 JMP	pop_xgsetF000
_LiquidPhotoCheck:
    08DC4 934A      ST	-Y,R20
(1258) 		n = 15;
    08DC5 935A      ST	-Y,R21
(1259) 	if(n == 0)
    08DC6 9140 08EA LDS	R20,PacketState+234
(1260) 		n = 1;
    08DC8 2755      CLR	R21
(1261) 	LeanerQuantifyVolume = n * 100;
    08DC9 3040      CPI	R20,0
    08DCA 0745      CPC	R20,R21
    08DCB F029      BEQ	0x8DD1
    08DCC 3042      CPI	R20,2
    08DCD E0E0      LDI	R30,0
    08DCE 075E      CPC	R21,R30
    08DCF F059      BEQ	0x8DDB
    08DD0 C01F      RJMP	0x8DF0
    08DD1 940E 6C0D CALL	_GetLiquidPhotoInfo
    08DD3 E081      LDI	R24,1
    08DD4 9380 08EA STS	PacketState+234,R24
(1262) }
(1263) 
(1264) unsigned char LeanerQuantifyTest(void){
(1265) 	// 稀释液泵定量测试
(1266) 	
(1267) 	if(WaitDelayTime(1))		return 0;
    08DD6 EF02      LDI	R16,0xF2
    08DD7 E014      LDI	R17,4
    08DD8 940E 2DE3 CALL	_RegisterLiquidEvenProcess
    08DDA C015      RJMP	0x8DF0
    08DDB 9180 00C1 LDS	R24,0xC1
(1268) 	if(waitMotor0){	if(GetMotState(MOT_FLUID)!=STA_SLAVE_FREE)		return 0;	waitMotor0 = 0;	}
    08DDD 7E8F      ANDI	R24,0xEF
    08DDE 9380 00C1 STS	0xC1,R24
    08DE0 E32E      LDI	R18,0x3E
    08DE1 E139      LDI	R19,0x19
    08DE2 E50A      LDI	R16,0x5A
    08DE3 E019      LDI	R17,0x9
    08DE4 940E A90D CALL	_uart_Printf
    08DE6 9180 00C1 LDS	R24,0xC1
    08DE8 6180      ORI	R24,0x10
    08DE9 9380 00C1 STS	0xC1,R24
(1269) 	if(waitMotor1){	if(GetMotState(MOT_EFFLUENT)!=STA_SLAVE_FREE)		return 0;	waitMotor1 = 0;	}
    08DEB 2422      CLR	R2
    08DEC 9220 08EA STS	PacketState+234,R2
    08DEE E001      LDI	R16,1
    08DEF C001      RJMP	0x8DF1
    08DF0 2700      CLR	R16
    08DF1 9159      LD	R21,Y+
    08DF2 9149      LD	R20,Y+
    08DF3 9508      RET
_CardStorePhotoCheck_Even:
    08DF4 940E AE8D CALL	push_xgsetF000
    08DF6 01A8      MOVW	R20,R16
    08DF7 9728      SBIW	R28,0x8
    08DF8 9160 08EA LDS	R22,PacketState+234
(1270) 
(1271) 	if(waitStartKey){
    08DFA 2777      CLR	R23
    08DFB 3061      CPI	R22,1
    08DFC E0E0      LDI	R30,0
(1272) 		if(quitFlag == 1){
    08DFD 077E      CPC	R23,R30
    08DFE F009      BEQ	0x8E00
    08DFF C02C      RJMP	0x8E2C
    08E00 01FA      MOVW	R30,R20
(1273) 			mainStep = 0;
    08E01 8181      LDD	R24,Z+1
    08E02 318C      CPI	R24,0x1C
    08E03 F541      BNE	0x8E2C
(1274) 			waitStartKey = 0;
    08E04 5F4E      SUBI	R20,0xFE
    08E05 4F5F      SBCI	R21,0xFF
(1275) 			quitFlag = 0;
    08E06 9180 00C1 LDS	R24,0xC1
(1276) 			Uart0ReUnable;
    08E08 7E8F      ANDI	R24,0xEF
    08E09 9380 00C1 STS	0xC1,R24
    08E0B 01FA      MOVW	R30,R20
    08E0C 8023      LDD	R2,Z+3
(1277) 			uart_Printf("%s\r\n",strM4153);
    08E0D 2433      CLR	R3
    08E0E 823F      STD	Y+7,R3
    08E0F 822E      STD	Y+6,R2
    08E10 8022      LDD	R2,Z+2
    08E11 2433      CLR	R3
    08E12 823D      STD	Y+5,R3
(1278) 			Uart0ReEnable;
    08E13 822C      STD	Y+4,R2
    08E14 8021      LDD	R2,Z+1
    08E15 2433      CLR	R3
    08E16 823B      STD	Y+3,R3
    08E17 822A      STD	Y+2,R2
(1279) 			return 1;		// 结束退出
    08E18 8020      LD	R2,Z
    08E19 2433      CLR	R3
(1280) 			}
(1281) 		if(WaitStartKey()==0)
    08E1A 8239      STD	Y+1,R3
    08E1B 8228      ST	Y,R2
    08E1C E529      LDI	R18,0x59
    08E1D E139      LDI	R19,0x19
    08E1E E004      LDI	R16,4
(1282) 			return 0;
    08E1F E019      LDI	R17,0x9
    08E20 940E A90D CALL	_uart_Printf
(1283) 		waitStartKey = 0;	
    08E22 9180 00C1 LDS	R24,0xC1
(1284) 		}
(1285) 	
(1286) 	switch(mainStep){
    08E24 6180      ORI	R24,0x10
    08E25 9380 00C1 STS	0xC1,R24
    08E27 E082      LDI	R24,2
    08E28 9380 08EA STS	PacketState+234,R24
    08E2A E001      LDI	R16,1
    08E2B C001      RJMP	0x8E2D
    08E2C 2700      CLR	R16
    08E2D 9628      ADIW	R28,0x8
    08E2E 940C AE92 JMP	pop_xgsetF000
_CardStorePhotoCheck:
    08E30 934A      ST	-Y,R20
    08E31 935A      ST	-Y,R21
    08E32 9722      SBIW	R28,2
    08E33 9140 08EA LDS	R20,PacketState+234
    08E35 2755      CLR	R21
    08E36 3040      CPI	R20,0
    08E37 0745      CPC	R20,R21
    08E38 F029      BEQ	0x8E3E
    08E39 3042      CPI	R20,2
    08E3A E0E0      LDI	R30,0
    08E3B 075E      CPC	R21,R30
    08E3C F069      BEQ	0x8E4A
    08E3D C026      RJMP	0x8E64
    08E3E 9100 17DB LDS	R16,ControlModel+3
(1287) 		case 0:
(1288) 			quitFlag = 0;
    08E40 940E 6C54 CALL	_GetStorePhoVol
(1289) 			SetEValve(EV_ALL, EV_CLOSE);
    08E42 E081      LDI	R24,1
    08E43 9380 08EA STS	PacketState+234,R24
    08E45 EF00      LDI	R16,0xF0
(1290) 			SetMotRunPam(MOT_EFFLUENT, 240, 2, CURRENT_EFFLUENT);
    08E46 E014      LDI	R17,4
    08E47 940E 2DEF CALL	_RegisterCardStoreEvenProcess
    08E49 C01A      RJMP	0x8E64
    08E4A 9180 00C1 LDS	R24,0xC1
    08E4C 7E8F      ANDI	R24,0xEF
    08E4D 9380 00C1 STS	0xC1,R24
(1291) 			MotRun(MOT_EFFLUENT, 150*100);
    08E4F 9020 17DB LDS	R2,ControlModel+3
    08E51 2433      CLR	R3
    08E52 8239      STD	Y+1,R3
(1292) 			SetMotRunPam(MOT_FLUID, 60, 2, CURRENT_FLUID);
    08E53 8228      ST	Y,R2
    08E54 E724      LDI	R18,0x74
    08E55 E139      LDI	R19,0x19
    08E56 E50F      LDI	R16,0x5F
    08E57 E019      LDI	R17,0x9
    08E58 940E A90D CALL	_uart_Printf
    08E5A 9180 00C1 LDS	R24,0xC1
(1293) 			MotRun(MOT_FLUID, 70*100);			// 开启稀释液泵
    08E5C 6180      ORI	R24,0x10
    08E5D 9380 00C1 STS	0xC1,R24
    08E5F 2422      CLR	R2
(1294) 			SetDelayTime(1, 30);
    08E60 9220 08EA STS	PacketState+234,R2
    08E62 E001      LDI	R16,1
    08E63 C001      RJMP	0x8E65
    08E64 2700      CLR	R16
(1295) 			mainStep = 1;
    08E65 9622      ADIW	R28,2
    08E66 9159      LD	R21,Y+
    08E67 9149      LD	R20,Y+
(1296) 			break;
    08E68 9508      RET
(1297) 		case 1:
(1298) 			MotStop(MOT_FLUID);
_NeedleOnMixSideCheck:
    08E69 940E AE83 CALL	push_xgset300C
    08E6B 9723      SBIW	R28,3
(1299) 			MotStop(MOT_EFFLUENT);
    08E6C E001      LDI	R16,1
    08E6D 940E 97C6 CALL	_WaitDelayTime
(1300) 			QuantifyTestCnt = 0; 
    08E6F 2300      TST	R16
    08E70 F011      BEQ	0x8E73
    08E71 2700      CLR	R16
    08E72 C0D7      RJMP	0x8F4A
    08E73 9020 08ED LDS	R2,PacketState+237
(1301) 			mainStep = 2;
    08E75 2022      TST	R2
    08E76 F051      BEQ	0x8E81
    08E77 E002      LDI	R16,2
(1302) 			Uart0ReUnable;
    08E78 940E 6A0C CALL	_GetMotState
    08E7A 3001      CPI	R16,1
    08E7B F011      BEQ	0x8E7E
    08E7C 2700      CLR	R16
(1303) 			uart_Printf("%s\r\n",strM4152);
    08E7D C0CC      RJMP	0x8F4A
    08E7E 2422      CLR	R2
    08E7F 9220 08ED STS	PacketState+237,R2
    08E81 9020 08EE LDS	R2,PacketState+238
(1304) 			Uart0ReEnable;
    08E83 2022      TST	R2
    08E84 F059      BEQ	0x8E90
    08E85 E003      LDI	R16,3
    08E86 940E 6A0C CALL	_GetMotState
(1305) 			break;
    08E88 2F40      MOV	R20,R16
(1306) 		case 2:
(1307) 			waitStartKey = 1;
    08E89 3001      CPI	R16,1
    08E8A F011      BEQ	0x8E8D
    08E8B 2700      CLR	R16
(1308) 			mainStep = 3;
    08E8C C0BD      RJMP	0x8F4A
    08E8D 2422      CLR	R2
    08E8E 9220 08EE STS	PacketState+238,R2
(1309) 			break;
    08E90 9140 08EA LDS	R20,PacketState+234
    08E92 2755      CLR	R21
    08E93 3040      CPI	R20,0
    08E94 0745      CPC	R20,R21
    08E95 F409      BNE	0x8E97
    08E96 C02E      RJMP	0x8EC5
    08E97 3041      CPI	R20,1
    08E98 E0E0      LDI	R30,0
(1310) 		case 3:
(1311) 			QuantifyTestCnt ++;
(1312) 			MotRun(MOT_FLUID, LeanerQuantifyVolume);
    08E99 075E      CPC	R21,R30
    08E9A F409      BNE	0x8E9C
    08E9B C03A      RJMP	0x8ED6
    08E9C 3042      CPI	R20,2
    08E9D E0E0      LDI	R30,0
    08E9E 075E      CPC	R21,R30
    08E9F F409      BNE	0x8EA1
(1313) 			waitMotor0 = 1;
    08EA0 C047      RJMP	0x8EE8
    08EA1 3043      CPI	R20,3
    08EA2 E0E0      LDI	R30,0
(1314) 			mainStep = 4;
    08EA3 075E      CPC	R21,R30
    08EA4 F409      BNE	0x8EA6
    08EA5 C04B      RJMP	0x8EF1
(1315) 			break;
    08EA6 3044      CPI	R20,4
(1316) 		case 4:
(1317) 			Uart0ReUnable;
    08EA7 E0E0      LDI	R30,0
    08EA8 075E      CPC	R21,R30
    08EA9 F409      BNE	0x8EAB
    08EAA C053      RJMP	0x8EFE
    08EAB 3045      CPI	R20,5
(1318) 			uart_Printf("%s $%4d\r\n",strM4154, QuantifyTestCnt);
    08EAC E0E0      LDI	R30,0
    08EAD 075E      CPC	R21,R30
    08EAE F409      BNE	0x8EB0
    08EAF C057      RJMP	0x8F07
    08EB0 3046      CPI	R20,6
    08EB1 E0E0      LDI	R30,0
    08EB2 075E      CPC	R21,R30
    08EB3 F409      BNE	0x8EB5
    08EB4 C05E      RJMP	0x8F13
    08EB5 3047      CPI	R20,7
    08EB6 E0E0      LDI	R30,0
    08EB7 075E      CPC	R21,R30
(1319) 			Uart0ReEnable;
    08EB8 F409      BNE	0x8EBA
    08EB9 C062      RJMP	0x8F1C
    08EBA 3048      CPI	R20,0x8
    08EBB E0E0      LDI	R30,0
    08EBC 075E      CPC	R21,R30
(1320) 			MotRun(MOT_EFFLUENT, LeanerQuantifyVolume);
    08EBD F409      BNE	0x8EBF
    08EBE C069      RJMP	0x8F28
    08EBF 3049      CPI	R20,0x9
    08EC0 E0E0      LDI	R30,0
    08EC1 075E      CPC	R21,R30
    08EC2 F409      BNE	0x8EC4
    08EC3 C070      RJMP	0x8F34
(1321) 			waitMotor1 = 1;
    08EC4 C084      RJMP	0x8F49
    08EC5 E083      LDI	R24,3
    08EC6 838A      STD	Y+2,R24
(1322) 			mainStep = 2;
    08EC7 E08A      LDI	R24,0xA
    08EC8 8388      ST	Y,R24
    08EC9 EF20      LDI	R18,0xF0
(1323) 			break;
(1324) 		default:
(1325) 			break;
(1326) 		}
(1327) 	return 0;
    08ECA E003      LDI	R16,3
    08ECB 940E 6A9F CALL	_SetMotRunPam
    08ECD E003      LDI	R16,3
(1328) }
(1329) 
(1330) static unsigned int SampQuantifyVolume = 40;
(1331) void SetSampQuantifyVolume(unsigned char n){
(1332) 	if(n > 120)
_SetSampQuantifyVolume:
  n                    --> R16
    08ECE 940E 6AFA CALL	_MotInitCheck
    08ED0 E081      LDI	R24,1
(1333) 		n = 120;
    08ED1 9380 08EE STS	PacketState+238,R24
(1334) 	if(n <5)
    08ED3 9380 08EA STS	PacketState+234,R24
(1335) 		n = 5;
    08ED5 C073      RJMP	0x8F49
    08ED6 E084      LDI	R24,4
    08ED7 838A      STD	Y+2,R24
    08ED8 E288      LDI	R24,0x28
    08ED9 8388      ST	Y,R24
    08EDA E728      LDI	R18,0x78
    08EDB E002      LDI	R16,2
    08EDC 940E 6A9F CALL	_SetMotRunPam
    08EDE E002      LDI	R16,2
    08EDF 940E 6AFA CALL	_MotInitCheck
    08EE1 E081      LDI	R24,1
    08EE2 9380 08ED STS	PacketState+237,R24
(1336) 	SampQuantifyVolume = n * 4;
(1337) }
(1338) 
(1339) unsigned char SampQuantifyTest(void){
(1340) 	static unsigned int liqDetBaseAdc;
(1341) 	unsigned int i;
(1342) 	// 取样泵定量测试
(1343) 	if(WaitDelayTime(1))		return 0;
    08EE4 E082      LDI	R24,2
    08EE5 9380 08EA STS	PacketState+234,R24
    08EE7 C061      RJMP	0x8F49
    08EE8 E025      LDI	R18,5
    08EE9 E030      LDI	R19,0
(1344) 	if(waitMotor0){	if(GetMotState(MOT_SAMP_PUMP)!=STA_SLAVE_FREE)		return 0;	waitMotor0 = 0;	}
    08EEA E001      LDI	R16,1
    08EEB 940E 97B7 CALL	_SetDelayTime
    08EED E083      LDI	R24,3
    08EEE 9380 08EA STS	PacketState+234,R24
    08EF0 C058      RJMP	0x8F49
    08EF1 940E 82F8 CALL	_GetNeedleOnMixSidePos
    08EF3 0158      MOVW	R10,R16
    08EF4 0195      MOVW	R18,R10
    08EF5 E002      LDI	R16,2
    08EF6 940E 6A5B CALL	_MotRunTo
(1345) 	if(waitMotor1){	if(GetMotState(MOT_SAMP_TRUN)!=STA_SLAVE_FREE)		return 0;	waitMotor1 = 0;	}
    08EF8 E081      LDI	R24,1
    08EF9 9380 08ED STS	PacketState+237,R24
    08EFB E084      LDI	R24,4
    08EFC 9380 08EA STS	PacketState+234,R24
    08EFE E025      LDI	R18,5
    08EFF E030      LDI	R19,0
    08F00 E001      LDI	R16,1
    08F01 940E 97B7 CALL	_SetDelayTime
    08F03 E085      LDI	R24,5
    08F04 9380 08EA STS	PacketState+234,R24
    08F06 C042      RJMP	0x8F49
(1346) 	if(waitMotor2){	if(GetMotState(MOT_SAMP_NEEDLE)!=STA_SLAVE_FREE)	return 0;	waitMotor2 = 0;	}
    08F07 E628      LDI	R18,0x68
    08F08 E031      LDI	R19,1
    08F09 E003      LDI	R16,3
    08F0A 940E 6A5B CALL	_MotRunTo
    08F0C E081      LDI	R24,1
    08F0D 9380 08EE STS	PacketState+238,R24
    08F0F E086      LDI	R24,6
    08F10 9380 08EA STS	PacketState+234,R24
    08F12 C036      RJMP	0x8F49
    08F13 E12E      LDI	R18,0x1E
    08F14 E030      LDI	R19,0
    08F15 E001      LDI	R16,1
(1347) 	if(waitMotor3){	if(GetMotState(MOT_FLUID)!=STA_SLAVE_FREE)			return 0;	waitMotor3 = 0;	}
    08F16 940E 97B7 CALL	_SetDelayTime
    08F18 E087      LDI	R24,7
    08F19 9380 08EA STS	PacketState+234,R24
    08F1B C02D      RJMP	0x8F49
    08F1C 2722      CLR	R18
    08F1D 2733      CLR	R19
    08F1E E003      LDI	R16,3
    08F1F 940E 6A5B CALL	_MotRunTo
    08F21 E081      LDI	R24,1
    08F22 9380 08EE STS	PacketState+238,R24
    08F24 E088      LDI	R24,0x8
(1348) 	if(waitMotor4){	if(GetMotState(MOT_EFFLUENT)!=STA_SLAVE_FREE)		return 0;	waitMotor4 = 0;	}
    08F25 9380 08EA STS	PacketState+234,R24
    08F27 C021      RJMP	0x8F49
    08F28 2722      CLR	R18
    08F29 2733      CLR	R19
    08F2A E002      LDI	R16,2
    08F2B 940E 6A5B CALL	_MotRunTo
    08F2D E081      LDI	R24,1
    08F2E 9380 08ED STS	PacketState+237,R24
    08F30 E089      LDI	R24,0x9
    08F31 9380 08EA STS	PacketState+234,R24
    08F33 C015      RJMP	0x8F49
(1349) 
(1350) 	if(waitStartKey){
    08F34 9180 00C1 LDS	R24,0xC1
    08F36 7E8F      ANDI	R24,0xEF
    08F37 9380 00C1 STS	0xC1,R24
(1351) 		if(quitFlag == 1){
    08F39 E922      LDI	R18,0x92
    08F3A E139      LDI	R19,0x19
    08F3B E50A      LDI	R16,0x5A
(1352) 			mainStep = 3;
    08F3C E019      LDI	R17,0x9
    08F3D 940E A90D CALL	_uart_Printf
(1353) 			workStep = 0;
    08F3F 9180 00C1 LDS	R24,0xC1
    08F41 6180      ORI	R24,0x10
(1354) 			waitStartKey = 0;
    08F42 9380 00C1 STS	0xC1,R24
(1355) 	//		quitFlag = 0;
(1356) 	//		uart_Printf("*4151 DiluentQuantifyTestQuit\r\n");
(1357) 	//		return 1;		// 结束退出
(1358) 			}
(1359) 		if(WaitStartKey()==0)
    08F44 2422      CLR	R2
    08F45 9220 08EA STS	PacketState+234,R2
    08F47 E001      LDI	R16,1
    08F48 C001      RJMP	0x8F4A
(1360) 			return 0;
    08F49 2700      CLR	R16
    08F4A 9623      ADIW	R28,3
(1361) 		waitStartKey = 0;	
    08F4B 940C AE88 JMP	pop_xgset300C
_DropHeightCheck:
    08F4D 940E AE83 CALL	push_xgset300C
(1362) 		}
(1363) 	
(1364) 	switch(mainStep){
    08F4F 9723      SBIW	R28,3
    08F50 E001      LDI	R16,1
    08F51 940E 97C6 CALL	_WaitDelayTime
    08F53 2300      TST	R16
    08F54 F011      BEQ	0x8F57
    08F55 2700      CLR	R16
    08F56 C0F2      RJMP	0x9049
    08F57 9020 08ED LDS	R2,PacketState+237
    08F59 2022      TST	R2
    08F5A F051      BEQ	0x8F65
    08F5B E002      LDI	R16,2
    08F5C 940E 6A0C CALL	_GetMotState
    08F5E 3001      CPI	R16,1
    08F5F F011      BEQ	0x8F62
    08F60 2700      CLR	R16
    08F61 C0E7      RJMP	0x9049
    08F62 2422      CLR	R2
    08F63 9220 08ED STS	PacketState+237,R2
(1365) 		case 0:		// 准备工作
(1366) 			switch(workStep){
    08F65 9020 08EE LDS	R2,PacketState+238
    08F67 2022      TST	R2
    08F68 F059      BEQ	0x8F74
    08F69 E003      LDI	R16,3
    08F6A 940E 6A0C CALL	_GetMotState
    08F6C 2F40      MOV	R20,R16
    08F6D 3001      CPI	R16,1
    08F6E F011      BEQ	0x8F71
    08F6F 2700      CLR	R16
    08F70 C0D8      RJMP	0x9049
    08F71 2422      CLR	R2
    08F72 9220 08EE STS	PacketState+238,R2
    08F74 9020 08EF LDS	R2,PacketState+239
    08F76 2022      TST	R2
    08F77 F059      BEQ	0x8F83
    08F78 E004      LDI	R16,4
    08F79 940E 6A0C CALL	_GetMotState
    08F7B 2F40      MOV	R20,R16
    08F7C 3001      CPI	R16,1
    08F7D F011      BEQ	0x8F80
    08F7E 2700      CLR	R16
    08F7F C0C9      RJMP	0x9049
    08F80 2422      CLR	R2
    08F81 9220 08EF STS	PacketState+239,R2
    08F83 9140 08EA LDS	R20,PacketState+234
    08F85 2755      CLR	R21
    08F86 3040      CPI	R20,0
    08F87 0745      CPC	R20,R21
    08F88 F409      BNE	0x8F8A
    08F89 C02E      RJMP	0x8FB8
    08F8A 3041      CPI	R20,1
    08F8B E0E0      LDI	R30,0
    08F8C 075E      CPC	R21,R30
    08F8D F409      BNE	0x8F8F
(1367) 				case 0:
(1368) 					quitFlag = 0;
    08F8E C03A      RJMP	0x8FC9
    08F8F 3042      CPI	R20,2
    08F90 E0E0      LDI	R30,0
(1369) 					SetEValve(EV_ALL, EV_CLOSE);
    08F91 075E      CPC	R21,R30
    08F92 F409      BNE	0x8F94
    08F93 C052      RJMP	0x8FE6
    08F94 3043      CPI	R20,3
(1370) 					SetMotRunPam(MOT_SAMP_NEEDLE, 240, 20, CURRENT_SAMP_NEEDLE);
    08F95 E0E0      LDI	R30,0
    08F96 075E      CPC	R21,R30
    08F97 F409      BNE	0x8F99
    08F98 C056      RJMP	0x8FEF
    08F99 3044      CPI	R20,4
    08F9A E0E0      LDI	R30,0
    08F9B 075E      CPC	R21,R30
    08F9C F409      BNE	0x8F9E
(1371) 					MotInitCheck(MOT_SAMP_NEEDLE);
    08F9D C05D      RJMP	0x8FFB
    08F9E 3045      CPI	R20,5
    08F9F E0E0      LDI	R30,0
(1372) 					waitMotor2 = 1;
    08FA0 075E      CPC	R21,R30
    08FA1 F409      BNE	0x8FA3
    08FA2 C061      RJMP	0x9004
(1373) 					workStep = 1;
    08FA3 3046      CPI	R20,6
    08FA4 E0E0      LDI	R30,0
(1374) 					break;
    08FA5 075E      CPC	R21,R30
(1375) 				case 1:
(1376) 					SetMotRunPam(MOT_SAMP_TRUN, 32, 20, CURRENT_SAMP_TRUN);
    08FA6 F409      BNE	0x8FA8
    08FA7 C06A      RJMP	0x9012
    08FA8 3047      CPI	R20,7
    08FA9 E0E0      LDI	R30,0
    08FAA 075E      CPC	R21,R30
    08FAB F409      BNE	0x8FAD
    08FAC C06E      RJMP	0x901B
    08FAD 3048      CPI	R20,0x8
(1377) 					MotInitCheck(MOT_SAMP_TRUN);
    08FAE E0E0      LDI	R30,0
    08FAF 075E      CPC	R21,R30
    08FB0 F409      BNE	0x8FB2
(1378) 					waitMotor1 = 1;
    08FB1 C075      RJMP	0x9027
    08FB2 3049      CPI	R20,0x9
    08FB3 E0E0      LDI	R30,0
(1379) 					workStep = 2;
    08FB4 075E      CPC	R21,R30
    08FB5 F409      BNE	0x8FB7
    08FB6 C07C      RJMP	0x9033
(1380) 					break;
    08FB7 C090      RJMP	0x9048
(1381) 				case 2:
(1382) 					MotRunTo(MOT_SAMP_TRUN,_POS_NEEDLE_ON_MIXCENTRE);
    08FB8 E083      LDI	R24,3
    08FB9 838A      STD	Y+2,R24
    08FBA E08A      LDI	R24,0xA
    08FBB 8388      ST	Y,R24
    08FBC EF20      LDI	R18,0xF0
(1383) 					waitMotor1 = 1;
    08FBD E003      LDI	R16,3
    08FBE 940E 6A9F CALL	_SetMotRunPam
(1384) 					workStep = 3;
    08FC0 E003      LDI	R16,3
    08FC1 940E 6AFA CALL	_MotInitCheck
(1385) 					break;
    08FC3 E081      LDI	R24,1
(1386) 				case 3:	// 
(1387) 					MotRunTo(MOT_SAMP_NEEDLE, 1000);
    08FC4 9380 08EE STS	PacketState+238,R24
    08FC6 9380 08EA STS	PacketState+234,R24
    08FC8 C07F      RJMP	0x9048
(1388) 					waitMotor2 = 1;
    08FC9 E084      LDI	R24,4
    08FCA 838A      STD	Y+2,R24
    08FCB E288      LDI	R24,0x28
(1389) 					workStep = 4;
    08FCC 8388      ST	Y,R24
    08FCD E728      LDI	R18,0x78
    08FCE E002      LDI	R16,2
(1390) 					timeOut = 0;
    08FCF 940E 6A9F CALL	_SetMotRunPam
    08FD1 E002      LDI	R16,2
(1391) 					break;
    08FD2 940E 6AFA CALL	_MotInitCheck
(1392) 				case 4:	// 灌注取样针管路
(1393) 					SetEValve(EV4, EV_OPEN);
    08FD4 E084      LDI	R24,4
    08FD5 838A      STD	Y+2,R24
    08FD6 E08A      LDI	R24,0xA
(1394) 					SetMotRunPam(MOT_FLUID, 40, 2, CURRENT_FLUID);
    08FD7 8388      ST	Y,R24
    08FD8 E82C      LDI	R18,0x8C
    08FD9 E004      LDI	R16,4
    08FDA 940E 6A9F CALL	_SetMotRunPam
    08FDC E004      LDI	R16,4
    08FDD 940E 6AFA CALL	_MotInitCheck
(1395) 					MotRun(MOT_FLUID, 5000);
    08FDF E081      LDI	R24,1
    08FE0 9380 08ED STS	PacketState+237,R24
    08FE2 E082      LDI	R24,2
    08FE3 9380 08EA STS	PacketState+234,R24
(1396) 					SetMotRunPam(MOT_EFFLUENT, 60, 2, CURRENT_EFFLUENT);
    08FE5 C062      RJMP	0x9048
    08FE6 E025      LDI	R18,5
    08FE7 E030      LDI	R19,0
    08FE8 E001      LDI	R16,1
    08FE9 940E 97B7 CALL	_SetDelayTime
    08FEB E083      LDI	R24,3
(1397) 					MotRun(MOT_EFFLUENT, 9000);
    08FEC 9380 08EA STS	PacketState+234,R24
    08FEE C059      RJMP	0x9048
    08FEF E42A      LDI	R18,0x4A
    08FF0 E030      LDI	R19,0
(1398) 					waitMotor3 = 1;
    08FF1 E004      LDI	R16,4
    08FF2 940E 6A5B CALL	_MotRunTo
(1399) 					waitMotor4 = 1;
    08FF4 E081      LDI	R24,1
    08FF5 9380 08EF STS	PacketState+239,R24
(1400) 					workStep = 5;
    08FF7 E084      LDI	R24,4
    08FF8 9380 08EA STS	PacketState+234,R24
(1401) 					break;
    08FFA C04D      RJMP	0x9048
    08FFB E025      LDI	R18,5
    08FFC E030      LDI	R19,0
    08FFD E001      LDI	R16,1
(1402) 				case 5:
(1403) 				//	MotStop(MOT_EFFLUENT);
(1404) 					SetEValve(EV_ALL, EV_CLOSE);
(1405) 					workStep = 6;
    08FFE 940E 97B7 CALL	_SetDelayTime
    09000 E085      LDI	R24,5
(1406) 					break;
    09001 9380 08EA STS	PacketState+234,R24
(1407) 				case 6:	// 向混匀池注入稀释液，直到取样针高度位置
(1408) 					liqDetBaseAdc = getLiqDetADC(NeedleChannel);
    09003 C044      RJMP	0x9048
    09004 940E 83A1 CALL	_GetDropHeight
    09006 0158      MOVW	R10,R16
    09007 0195      MOVW	R18,R10
    09008 E003      LDI	R16,3
    09009 940E 6A5B CALL	_MotRunTo
(1409) 					if(liqDetBaseAdc > 500)
    0900B E081      LDI	R24,1
    0900C 9380 08EE STS	PacketState+238,R24
    0900E E086      LDI	R24,6
    0900F 9380 08EA STS	PacketState+234,R24
(1410) 					{
(1411) 						Uart0ReUnable;
    09011 C036      RJMP	0x9048
    09012 E12E      LDI	R18,0x1E
    09013 E030      LDI	R19,0
    09014 E001      LDI	R16,1
(1412) 						uart_Printf("%s $%d\r\n",strM2150, liqDetBaseAdc);
    09015 940E 97B7 CALL	_SetDelayTime
    09017 E087      LDI	R24,7
    09018 9380 08EA STS	PacketState+234,R24
    0901A C02D      RJMP	0x9048
    0901B 2722      CLR	R18
    0901C 2733      CLR	R19
(1413) 						Uart0ReEnable;
    0901D E003      LDI	R16,3
    0901E 940E 6A5B CALL	_MotRunTo
    09020 E081      LDI	R24,1
    09021 9380 08EE STS	PacketState+238,R24
(1414) 					}
    09023 E088      LDI	R24,0x8
    09024 9380 08EA STS	PacketState+234,R24
    09026 C021      RJMP	0x9048
    09027 2722      CLR	R18
(1415) 					else
(1416) 					{
(1417) 						Uart0ReUnable;
(1418) 						uart_Printf("%s $%d\r\n",strE2950, liqDetBaseAdc);
    09028 2733      CLR	R19
    09029 E004      LDI	R16,4
    0902A 940E 6A5B CALL	_MotRunTo
    0902C E081      LDI	R24,1
    0902D 9380 08EF STS	PacketState+239,R24
    0902F E089      LDI	R24,0x9
    09030 9380 08EA STS	PacketState+234,R24
    09032 C015      RJMP	0x9048
    09033 9180 00C1 LDS	R24,0xC1
(1419) 						Uart0ReEnable;
    09035 7E8F      ANDI	R24,0xEF
    09036 9380 00C1 STS	0xC1,R24
    09038 EB20      LDI	R18,0xB0
(1420) 						// 退出处理
(1421) 						mainStep = 3;
    09039 E139      LDI	R19,0x19
    0903A E50A      LDI	R16,0x5A
    0903B E019      LDI	R17,0x9
(1422) 						workStep = 0;
    0903C 940E A90D CALL	_uart_Printf
    0903E 9180 00C1 LDS	R24,0xC1
(1423) 						break;
    09040 6180      ORI	R24,0x10
    09041 9380 00C1 STS	0xC1,R24
    09043 2422      CLR	R2
    09044 9220 08EA STS	PacketState+234,R2
    09046 E001      LDI	R16,1
    09047 C001      RJMP	0x9049
(1424) 					}
(1425) 					SetMotRunPam(MOT_DILUENT, 64, 2, CURRENT_DILUENT);
(1426) 					MotRun(MOT_DILUENT, 80*100);			// 开启稀释液泵
    09048 2700      CLR	R16
    09049 9623      ADIW	R28,3
    0904A 940C AE88 JMP	pop_xgset300C
_MixHeightCheck:
    0904C 940E AE83 CALL	push_xgset300C
(1427) 					workStep = 7;
    0904E 9723      SBIW	R28,3
    0904F E001      LDI	R16,1
(1428) 					break;
    09050 940E 97C6 CALL	_WaitDelayTime
(1429) 				case 7:
(1430) 					if(GetMotState(MOT_DILUENT)==STA_SLAVE_FREE){
    09052 2300      TST	R16
    09053 F011      BEQ	0x9056
    09054 2700      CLR	R16
    09055 C0F2      RJMP	0x9148
    09056 9020 08ED LDS	R2,PacketState+237
(1431) 						timeOut ++;
    09058 2022      TST	R2
    09059 F051      BEQ	0x9064
    0905A E002      LDI	R16,2
    0905B 940E 6A0C CALL	_GetMotState
(1432) 						if(timeOut<3){
    0905D 3001      CPI	R16,1
(1433) 							workStep = 6;
    0905E F011      BEQ	0x9061
    0905F 2700      CLR	R16
    09060 C0E7      RJMP	0x9148
(1434) 							}
    09061 2422      CLR	R2
(1435) 						else{
(1436) 							// 退出处理
(1437) 							mainStep = 3;
    09062 9220 08ED STS	PacketState+237,R2
    09064 9020 08EE LDS	R2,PacketState+238
(1438) 							workStep = 0;
    09066 2022      TST	R2
    09067 F059      BEQ	0x9073
(1439) 							Uart0ReUnable;
    09068 E003      LDI	R16,3
    09069 940E 6A0C CALL	_GetMotState
    0906B 2F40      MOV	R20,R16
    0906C 3001      CPI	R16,1
(1440) //							uart_Printf("%s\r\n",strE2910);
(1441) 							uart_Printf("%s\r\n",strE3904);
    0906D F011      BEQ	0x9070
    0906E 2700      CLR	R16
    0906F C0D8      RJMP	0x9148
    09070 2422      CLR	R2
    09071 9220 08EE STS	PacketState+238,R2
(1442) 							Uart0ReEnable;
    09073 9020 08EF LDS	R2,PacketState+239
    09075 2022      TST	R2
    09076 F059      BEQ	0x9082
    09077 E004      LDI	R16,4
(1443) 							break;
    09078 940E 6A0C CALL	_GetMotState
(1444) 							}
(1445) 						}
(1446) 					i = getLiqDetADC(NeedleChannel);
    0907A 2F40      MOV	R20,R16
    0907B 3001      CPI	R16,1
    0907C F011      BEQ	0x907F
(1447) 					if(i<liqDetBaseAdc){
    0907D 2700      CLR	R16
    0907E C0C9      RJMP	0x9148
    0907F 2422      CLR	R2
    09080 9220 08EF STS	PacketState+239,R2
    09082 9140 08EA LDS	R20,PacketState+234
    09084 2755      CLR	R21
(1448) 						i = liqDetBaseAdc - i;
    09085 3040      CPI	R20,0
    09086 0745      CPC	R20,R21
    09087 F409      BNE	0x9089
(1449) 						if(i>200){
    09088 C02E      RJMP	0x90B7
    09089 3041      CPI	R20,1
    0908A E0E0      LDI	R30,0
    0908B 075E      CPC	R21,R30
    0908C F409      BNE	0x908E
    0908D C03A      RJMP	0x90C8
(1450) 							MotStop(MOT_DILUENT);
    0908E 3042      CPI	R20,2
    0908F E0E0      LDI	R30,0
    09090 075E      CPC	R21,R30
(1451) 							MotRun(MOT_SAMP_NEEDLE, 40);
    09091 F409      BNE	0x9093
    09092 C052      RJMP	0x90E5
    09093 3043      CPI	R20,3
    09094 E0E0      LDI	R30,0
    09095 075E      CPC	R21,R30
(1452) 							SetMotRunPam(MOT_SAMP_PUMP, 32, 2, CURRENT_SAMP_PUMP);
    09096 F409      BNE	0x9098
    09097 C056      RJMP	0x90EE
    09098 3044      CPI	R20,4
    09099 E0E0      LDI	R30,0
    0909A 075E      CPC	R21,R30
    0909B F409      BNE	0x909D
    0909C C05D      RJMP	0x90FA
    0909D 3045      CPI	R20,5
(1453) 							MotInitCheck(MOT_SAMP_PUMP);
    0909E E0E0      LDI	R30,0
    0909F 075E      CPC	R21,R30
    090A0 F409      BNE	0x90A2
(1454) 							waitMotor0 = 1;
    090A1 C061      RJMP	0x9103
    090A2 3046      CPI	R20,6
    090A3 E0E0      LDI	R30,0
(1455) 							waitMotor2 = 1;
    090A4 075E      CPC	R21,R30
    090A5 F409      BNE	0x90A7
(1456) 							workStep = 0;
    090A6 C06A      RJMP	0x9111
    090A7 3047      CPI	R20,7
    090A8 E0E0      LDI	R30,0
(1457) 							mainStep = 1;
    090A9 075E      CPC	R21,R30
    090AA F409      BNE	0x90AC
(1458) 							}
(1459) 						}
(1460) 					break;
(1461) 				default:
(1462) 					break;
(1463) 				}
(1464) 			break;
    090AB C06E      RJMP	0x911A
(1465) 		case 1:		// 吸取液体
(1466) 			switch(workStep){
    090AC 3048      CPI	R20,0x8
    090AD E0E0      LDI	R30,0
    090AE 075E      CPC	R21,R30
    090AF F409      BNE	0x90B1
    090B0 C075      RJMP	0x9126
    090B1 3049      CPI	R20,0x9
    090B2 E0E0      LDI	R30,0
    090B3 075E      CPC	R21,R30
    090B4 F409      BNE	0x90B6
    090B5 C07C      RJMP	0x9132
    090B6 C090      RJMP	0x9147
    090B7 E083      LDI	R24,3
    090B8 838A      STD	Y+2,R24
    090B9 E08A      LDI	R24,0xA
    090BA 8388      ST	Y,R24
    090BB EF20      LDI	R18,0xF0
    090BC E003      LDI	R16,3
    090BD 940E 6A9F CALL	_SetMotRunPam
    090BF E003      LDI	R16,3
    090C0 940E 6AFA CALL	_MotInitCheck
    090C2 E081      LDI	R24,1
    090C3 9380 08EE STS	PacketState+238,R24
    090C5 9380 08EA STS	PacketState+234,R24
    090C7 C07F      RJMP	0x9147
    090C8 E084      LDI	R24,4
(1467) 				case 0:
(1468) 					waitStartKey = 1;
    090C9 838A      STD	Y+2,R24
    090CA E288      LDI	R24,0x28
    090CB 8388      ST	Y,R24
(1469) 					workStep = 1;
    090CC E728      LDI	R18,0x78
    090CD E002      LDI	R16,2
(1470) 					break;
    090CE 940E 6A9F CALL	_SetMotRunPam
(1471) 				case 1:
(1472) 					MotRun(MOT_SAMP_PUMP,SampQuantifyVolume + 15);
    090D0 E002      LDI	R16,2
    090D1 940E 6AFA CALL	_MotInitCheck
    090D3 E084      LDI	R24,4
    090D4 838A      STD	Y+2,R24
    090D5 E08A      LDI	R24,0xA
    090D6 8388      ST	Y,R24
    090D7 E82C      LDI	R18,0x8C
(1473) 					waitMotor0 = 1;
    090D8 E004      LDI	R16,4
    090D9 940E 6A9F CALL	_SetMotRunPam
(1474) 					workStep = 2;
    090DB E004      LDI	R16,4
    090DC 940E 6AFA CALL	_MotInitCheck
(1475) 					break;
    090DE E081      LDI	R24,1
(1476) 				case 2:
(1477) 					MotRun(MOT_SAMP_PUMP,-5);
    090DF 9380 08ED STS	PacketState+237,R24
    090E1 E082      LDI	R24,2
    090E2 9380 08EA STS	PacketState+234,R24
(1478) 					waitMotor0 = 1;
    090E4 C062      RJMP	0x9147
    090E5 E025      LDI	R18,5
    090E6 E030      LDI	R19,0
(1479) 					workStep = 3;
    090E7 E001      LDI	R16,1
    090E8 940E 97B7 CALL	_SetDelayTime
(1480) 					break;
    090EA E083      LDI	R24,3
(1481) 				case 3:
(1482) 					SetMotRunPam(MOT_SAMP_NEEDLE, 240, 20, CURRENT_SAMP_NEEDLE);
    090EB 9380 08EA STS	PacketState+234,R24
    090ED C059      RJMP	0x9147
    090EE E82D      LDI	R18,0x8D
    090EF E030      LDI	R19,0
    090F0 E004      LDI	R16,4
    090F1 940E 6A5B CALL	_MotRunTo
(1483) 					MotRunTo(MOT_SAMP_NEEDLE, 0);
    090F3 E081      LDI	R24,1
    090F4 9380 08EF STS	PacketState+239,R24
    090F6 E084      LDI	R24,4
    090F7 9380 08EA STS	PacketState+234,R24
(1484) 					waitMotor2 = 1;
    090F9 C04D      RJMP	0x9147
    090FA E025      LDI	R18,5
(1485) 					workStep = 4;
    090FB E030      LDI	R19,0
    090FC E001      LDI	R16,1
    090FD 940E 97B7 CALL	_SetDelayTime
(1486) 					break;
    090FF E085      LDI	R24,5
    09100 9380 08EA STS	PacketState+234,R24
    09102 C044      RJMP	0x9147
    09103 940E 8420 CALL	_GetMixHeight
(1487) 				case 4:
(1488) 					MotRunTo(MOT_SAMP_TRUN, _POS_SAMPTURN_SAMP);
(1489) 					waitMotor1 = 1;
    09105 0158      MOVW	R10,R16
    09106 0195      MOVW	R18,R10
(1490) 					workStep = 5;
    09107 E003      LDI	R16,3
    09108 940E 6A5B CALL	_MotRunTo
(1491) 					break;
    0910A E081      LDI	R24,1
(1492) 				case 5:
(1493) 					MotRunTo(MOT_SAMP_NEEDLE, 3600);
    0910B 9380 08EE STS	PacketState+238,R24
    0910D E086      LDI	R24,6
    0910E 9380 08EA STS	PacketState+234,R24
(1494) 					waitMotor2 = 1;
    09110 C036      RJMP	0x9147
    09111 E12E      LDI	R18,0x1E
    09112 E030      LDI	R19,0
(1495) 					workStep = 0;
    09113 E001      LDI	R16,1
    09114 940E 97B7 CALL	_SetDelayTime
(1496) 					mainStep = 2;
    09116 E087      LDI	R24,7
    09117 9380 08EA STS	PacketState+234,R24
(1497) 					break;
(1498) 				}
(1499) 			break;
    09119 C02D      RJMP	0x9147
(1500) 		case 2:
(1501) 			switch(workStep){
    0911A 2722      CLR	R18
    0911B 2733      CLR	R19
    0911C E003      LDI	R16,3
    0911D 940E 6A5B CALL	_MotRunTo
    0911F E081      LDI	R24,1
    09120 9380 08EE STS	PacketState+238,R24
    09122 E088      LDI	R24,0x8
    09123 9380 08EA STS	PacketState+234,R24
    09125 C021      RJMP	0x9147
    09126 2722      CLR	R18
    09127 2733      CLR	R19
    09128 E004      LDI	R16,4
    09129 940E 6A5B CALL	_MotRunTo
    0912B E081      LDI	R24,1
    0912C 9380 08EF STS	PacketState+239,R24
    0912E E089      LDI	R24,0x9
    0912F 9380 08EA STS	PacketState+234,R24
    09131 C015      RJMP	0x9147
    09132 9180 00C1 LDS	R24,0xC1
    09134 7E8F      ANDI	R24,0xEF
    09135 9380 00C1 STS	0xC1,R24
    09137 EA2E      LDI	R18,0xAE
    09138 E137      LDI	R19,0x17
    09139 E50A      LDI	R16,0x5A
    0913A E019      LDI	R17,0x9
    0913B 940E A90D CALL	_uart_Printf
    0913D 9180 00C1 LDS	R24,0xC1
    0913F 6180      ORI	R24,0x10
    09140 9380 00C1 STS	0xC1,R24
    09142 2422      CLR	R2
    09143 9220 08EA STS	PacketState+234,R2
    09145 E001      LDI	R16,1
    09146 C001      RJMP	0x9148
    09147 2700      CLR	R16
(1502) 				case 0:
(1503) 					waitStartKey = 1;
    09148 9623      ADIW	R28,3
    09149 940C AE88 JMP	pop_xgset300C
(1504) 					workStep = 1;
_SetDiluentQuantifyVolume:
    0914B 934A      ST	-Y,R20
    0914C 2F40      MOV	R20,R16
(1505) 					break;
    0914D E382      LDI	R24,0x32
(1506) 				case 1:
(1507) 					MotRun(MOT_SAMP_PUMP,-SampQuantifyVolume);
    0914E 1784      CP	R24,R20
    0914F F408      BCC	0x9151
    09150 E342      LDI	R20,0x32
    09151 2344      TST	R20
    09152 F409      BNE	0x9154
    09153 E041      LDI	R20,1
    09154 E604      LDI	R16,0x64
    09155 2F14      MOV	R17,R20
    09156 0301      MULSU	R16,R17
    09157 9210 08F4 STS	PacketState+244,R1
(1508) 					waitMotor0 = 1;
    09159 9200 08F3 STS	PacketState+243,R0
    0915B 9149      LD	R20,Y+
(1509) 					workStep = 2;
    0915C 9508      RET
_DiluentQuantifyTest:
    0915D 940E AE83 CALL	push_xgset300C
(1510) 					break;
    0915F 9722      SBIW	R28,2
(1511) 				case 2:
(1512) 					SetDelayTime(1, 5);
    09160 E001      LDI	R16,1
    09161 940E 97C6 CALL	_WaitDelayTime
    09163 2300      TST	R16
    09164 F011      BEQ	0x9167
(1513) 					workStep = 3;
    09165 2700      CLR	R16
    09166 C0E0      RJMP	0x9247
    09167 9020 08ED LDS	R2,PacketState+237
(1514) 					break;
    09169 2022      TST	R2
    0916A F051      BEQ	0x9175
    0916B E009      LDI	R16,0x9
    0916C 940E 6A0C CALL	_GetMotState
(1515) 				case 3:
(1516) 					MotRunTo(MOT_SAMP_NEEDLE, 0);
(1517) 					waitMotor2 = 1;
    0916E 3001      CPI	R16,1
    0916F F011      BEQ	0x9172
    09170 2700      CLR	R16
(1518) 					workStep = 4;
    09171 C0D5      RJMP	0x9247
    09172 2422      CLR	R2
    09173 9220 08ED STS	PacketState+237,R2
(1519) 					break;
    09175 9020 08EE LDS	R2,PacketState+238
    09177 2022      TST	R2
    09178 F059      BEQ	0x9184
    09179 E00B      LDI	R16,0xB
(1520) 				case 4:
(1521) 					MotRunTo(MOT_SAMP_TRUN, 0);
(1522) 					waitMotor1 = 1;
    0917A 940E 6A0C CALL	_GetMotState
    0917C 2F40      MOV	R20,R16
(1523) 					workStep = 5;
    0917D 3001      CPI	R16,1
    0917E F011      BEQ	0x9181
    0917F 2700      CLR	R16
(1524) 					break;
    09180 C0C6      RJMP	0x9247
(1525) 				case 5:
(1526) 					MotRunTo(MOT_SAMP_TRUN, _POS_NEEDLE_ON_MIXCENTRE);
    09181 2422      CLR	R2
    09182 9220 08EE STS	PacketState+238,R2
    09184 9020 08F2 LDS	R2,PacketState+242
(1527) 					waitMotor1 = 1;
    09186 2022      TST	R2
    09187 F139      BEQ	0x91AF
    09188 9180 17E0 LDS	R24,ControlModel+8
(1528) 					workStep = 6;
    0918A 3081      CPI	R24,1
    0918B F4C9      BNE	0x91A5
(1529) 					break;
    0918C 2422      CLR	R2
(1530) 				case 6:
(1531) 					MotRunTo(MOT_SAMP_NEEDLE, 800);
    0918D 9220 08EA STS	PacketState+234,R2
    0918F 9220 08F2 STS	PacketState+242,R2
    09191 9220 17E0 STS	ControlModel+8,R2
(1532) 					waitMotor2 = 1;
    09193 9180 00C1 LDS	R24,0xC1
(1533) 					workStep = 7;
    09195 7E8F      ANDI	R24,0xEF
    09196 9380 00C1 STS	0xC1,R24
(1534) 					break;
    09198 EE29      LDI	R18,0xE9
(1535) 				case 7:
(1536) 					liqDetBaseAdc = getLiqDetADC(NeedleChannel);
    09199 E139      LDI	R19,0x19
    0919A E50A      LDI	R16,0x5A
    0919B E019      LDI	R17,0x9
    0919C 940E A90D CALL	_uart_Printf
    0919E 9180 00C1 LDS	R24,0xC1
    091A0 6180      ORI	R24,0x10
(1537) 					if(liqDetBaseAdc > 500){
    091A1 9380 00C1 STS	0xC1,R24
    091A3 E001      LDI	R16,1
    091A4 C0A2      RJMP	0x9247
    091A5 940E 370B CALL	_WaitStartKey
(1538) 						Uart0ReUnable;
    091A7 2EA0      MOV	R10,R16
    091A8 2300      TST	R16
    091A9 F411      BNE	0x91AC
    091AA 2700      CLR	R16
    091AB C09B      RJMP	0x9247
(1539) 						uart_Printf("%s $%d\r\n",strM2150, liqDetBaseAdc);
    091AC 2422      CLR	R2
    091AD 9220 08F2 STS	PacketState+242,R2
    091AF 9140 08EA LDS	R20,PacketState+234
    091B1 2755      CLR	R21
    091B2 3040      CPI	R20,0
    091B3 0745      CPC	R20,R21
(1540) 						Uart0ReEnable;
    091B4 F0A1      BEQ	0x91C9
    091B5 3041      CPI	R20,1
    091B6 E0E0      LDI	R30,0
    091B7 075E      CPC	R21,R30
    091B8 F161      BEQ	0x91E5
(1541) 						}
    091B9 3042      CPI	R20,2
(1542) 					else{
(1543) 						Uart0ReUnable;
    091BA E0E0      LDI	R30,0
    091BB 075E      CPC	R21,R30
    091BC F409      BNE	0x91BE
    091BD C047      RJMP	0x9205
    091BE 3043      CPI	R20,3
(1544) 						uart_Printf("%s $%d\r\n",strE2950, liqDetBaseAdc);
    091BF E0E0      LDI	R30,0
    091C0 075E      CPC	R21,R30
    091C1 F409      BNE	0x91C3
    091C2 C049      RJMP	0x920C
    091C3 3044      CPI	R20,4
    091C4 E0E0      LDI	R30,0
    091C5 075E      CPC	R21,R30
    091C6 F409      BNE	0x91C8
    091C7 C05B      RJMP	0x9223
    091C8 C07D      RJMP	0x9246
    091C9 2422      CLR	R2
    091CA 9220 17E0 STS	ControlModel+8,R2
(1545) 						Uart0ReEnable;
    091CC 2722      CLR	R18
    091CD 2700      CLR	R16
    091CE 940E 6B81 CALL	_SetEValve
(1546) 						// 退出处理
(1547) 						mainStep = 3;
    091D0 EC28      LDI	R18,0xC8
    091D1 E030      LDI	R19,0
    091D2 E906      LDI	R16,0x96
(1548) 						workStep = 0;
    091D3 E010      LDI	R17,0
    091D4 940E 6289 CALL	__EffluentMotRun
(1549) 						break;
    091D6 E420      LDI	R18,0x40
(1550) 						}
(1551) 					SetMotRunPam(MOT_SAMP_NEEDLE, 64, 2, CURRENT_SAMP_NEEDLE);
    091D7 E030      LDI	R19,0
    091D8 E00E      LDI	R16,0xE
    091D9 E010      LDI	R17,0
    091DA 940E 62A2 CALL	__DiluentMotRun
    091DC E12E      LDI	R18,0x1E
    091DD E030      LDI	R19,0
    091DE E001      LDI	R16,1
(1552) 					MotRun(MOT_SAMP_NEEDLE, 800);			// 开启稀释液泵
    091DF 940E 97B7 CALL	_SetDelayTime
    091E1 E081      LDI	R24,1
    091E2 9380 08EA STS	PacketState+234,R24
(1553) 					workStep = 8;
    091E4 C061      RJMP	0x9246
    091E5 E009      LDI	R16,0x9
    091E6 940E 6A13 CALL	_MotStop
(1554) 					break;
    091E8 E00B      LDI	R16,0xB
    091E9 940E 6A13 CALL	_MotStop
    091EB 2422      CLR	R2
    091EC 2433      CLR	R3
    091ED 9230 08F6 STS	QuantifyTestCnt+1,R3
(1555) 				case 8:
(1556) 					if(GetMotState(MOT_SAMP_NEEDLE)==STA_SLAVE_FREE){
(1557) 						Uart0ReUnable;
    091EF 9220 08F5 STS	QuantifyTestCnt,R2
    091F1 E082      LDI	R24,2
    091F2 9380 08EA STS	PacketState+234,R24
(1558) 					//	uart_Printf("%s\r\n",strE2910);
(1559) 						uart_Printf("%s\r\n",strE3904);
    091F4 9180 00C1 LDS	R24,0xC1
    091F6 7E8F      ANDI	R24,0xEF
    091F7 9380 00C1 STS	0xC1,R24
(1560) 						Uart0ReEnable;
    091F9 EC2A      LDI	R18,0xCA
    091FA E139      LDI	R19,0x19
    091FB E50A      LDI	R16,0x5A
    091FC E019      LDI	R17,0x9
    091FD 940E A90D CALL	_uart_Printf
(1561) 						// 退出处理
(1562) 						mainStep = 3;
    091FF 9180 00C1 LDS	R24,0xC1
(1563) 						workStep = 0;
    09201 6180      ORI	R24,0x10
    09202 9380 00C1 STS	0xC1,R24
(1564) 						break;
    09204 C041      RJMP	0x9246
(1565) 						}
(1566) 					i = getLiqDetADC(NeedleChannel);
    09205 E081      LDI	R24,1
    09206 9380 08F2 STS	PacketState+242,R24
    09208 E083      LDI	R24,3
    09209 9380 08EA STS	PacketState+234,R24
(1567) 					if(i<liqDetBaseAdc){
    0920B C03A      RJMP	0x9246
    0920C 9180 08F5 LDS	R24,QuantifyTestCnt
    0920E 9190 08F6 LDS	R25,QuantifyTestCnt+1
    09210 9601      ADIW	R24,1
    09211 9390 08F6 STS	QuantifyTestCnt+1,R25
(1568) 						i = liqDetBaseAdc - i;
    09213 9380 08F5 STS	QuantifyTestCnt,R24
(1569) 						if(i>200){
    09215 9120 08F3 LDS	R18,PacketState+243
    09217 9130 08F4 LDS	R19,PacketState+244
    09219 E009      LDI	R16,0x9
    0921A 940E 6A2C CALL	_MotRun
(1570) 							MotStop(MOT_SAMP_NEEDLE);
    0921C E081      LDI	R24,1
    0921D 9380 08ED STS	PacketState+237,R24
(1571) 							MotRun(MOT_SAMP_NEEDLE, 40);
    0921F E084      LDI	R24,4
    09220 9380 08EA STS	PacketState+234,R24
    09222 C023      RJMP	0x9246
(1572) 							SetMotRunPam(MOT_SAMP_PUMP, 32, 2, CURRENT_SAMP_PUMP);
    09223 9180 00C1 LDS	R24,0xC1
    09225 7E8F      ANDI	R24,0xEF
    09226 9380 00C1 STS	0xC1,R24
    09228 9020 08F5 LDS	R2,QuantifyTestCnt
    0922A 9030 08F6 LDS	R3,QuantifyTestCnt+1
(1573) 							MotInitCheck(MOT_SAMP_PUMP);
    0922C 8239      STD	Y+1,R3
    0922D 8228      ST	Y,R2
(1574) 							waitMotor0 = 1;
    0922E E422      LDI	R18,0x42
    0922F E13A      LDI	R19,0x1A
    09230 E50F      LDI	R16,0x5F
(1575) 							waitMotor2 = 1;
    09231 E019      LDI	R17,0x9
    09232 940E A90D CALL	_uart_Printf
(1576) 							workStep = 0;
    09234 9180 00C1 LDS	R24,0xC1
(1577) 							mainStep = 1;
    09236 6180      ORI	R24,0x10
    09237 9380 00C1 STS	0xC1,R24
(1578) 							}
(1579) 						}
(1580) 					break;
(1581) 				}
(1582) 			break;
    09239 9120 08F3 LDS	R18,PacketState+243
    0923B 9130 08F4 LDS	R19,PacketState+244
    0923D E00B      LDI	R16,0xB
    0923E 940E 6A2C CALL	_MotRun
    09240 E081      LDI	R24,1
    09241 9380 08EE STS	PacketState+238,R24
    09243 E082      LDI	R24,2
    09244 9380 08EA STS	PacketState+234,R24
    09246 2700      CLR	R16
    09247 9622      ADIW	R28,2
(1583) 		case 3:		// 退出
(1584) 			switch(workStep){
(1585) 				case 0:
(1586) 					SetMotRunPam(MOT_SAMP_NEEDLE, 240, 20, CURRENT_SAMP_NEEDLE);
    09248 940C AE88 JMP	pop_xgset300C
_SetLeanerQuantifyVolume:
    0924A 934A      ST	-Y,R20
    0924B 2F40      MOV	R20,R16
    0924C E08F      LDI	R24,0xF
    0924D 1784      CP	R24,R20
    0924E F408      BCC	0x9250
    0924F E04F      LDI	R20,0xF
(1587) 					MotRunTo(MOT_SAMP_NEEDLE, 0);
    09250 2344      TST	R20
    09251 F409      BNE	0x9253
    09252 E041      LDI	R20,1
    09253 E604      LDI	R16,0x64
    09254 2F14      MOV	R17,R20
(1588) 					SetMotRunPam(MOT_EFFLUENT, 240, 2, CURRENT_EFFLUENT);
    09255 0301      MULSU	R16,R17
    09256 9210 08F8 STS	QuantifyTestCnt+3,R1
    09258 9200 08F7 STS	QuantifyTestCnt+2,R0
    0925A 9149      LD	R20,Y+
    0925B 9508      RET
_LeanerQuantifyTest:
    0925C 940E AE83 CALL	push_xgset300C
(1589) 					MotRun(MOT_EFFLUENT, 1500);
    0925E 9723      SBIW	R28,3
    0925F E001      LDI	R16,1
    09260 940E 97C6 CALL	_WaitDelayTime
(1590) 					waitMotor2 = 1;
    09262 2300      TST	R16
    09263 F011      BEQ	0x9266
    09264 2700      CLR	R16
(1591) 					workStep = 1;
    09265 C0EF      RJMP	0x9355
    09266 9020 08ED LDS	R2,PacketState+237
(1592) 					break;
    09268 2022      TST	R2
    09269 F051      BEQ	0x9274
    0926A E00A      LDI	R16,0xA
    0926B 940E 6A0C CALL	_GetMotState
    0926D 3001      CPI	R16,1
    0926E F011      BEQ	0x9271
    0926F 2700      CLR	R16
(1593) 				case 1:
(1594) 					SetMotRunPam(MOT_SAMP_TRUN, 32, 20, CURRENT_SAMP_TRUN);
(1595) 					MotRunTo(MOT_SAMP_TRUN,0);
    09270 C0E4      RJMP	0x9355
    09271 2422      CLR	R2
    09272 9220 08ED STS	PacketState+237,R2
    09274 9020 08EE LDS	R2,PacketState+238
(1596) 					waitMotor1 = 1;
    09276 2022      TST	R2
    09277 F059      BEQ	0x9283
(1597) 					workStep = 2;
    09278 E00B      LDI	R16,0xB
    09279 940E 6A0C CALL	_GetMotState
(1598) 					break;
    0927B 2F40      MOV	R20,R16
(1599) 				case 2:
(1600) 					mainStep = 0;
    0927C 3001      CPI	R16,1
    0927D F011      BEQ	0x9280
    0927E 2700      CLR	R16
(1601) 					workStep = 0;
    0927F C0D5      RJMP	0x9355
    09280 2422      CLR	R2
(1602) 					waitStartKey = 0;
    09281 9220 08EE STS	PacketState+238,R2
(1603) 					quitFlag = 0;
    09283 9020 08F2 LDS	R2,PacketState+242
(1604) 					Uart0ReUnable;
    09285 2022      TST	R2
    09286 F139      BEQ	0x92AE
    09287 9180 17E0 LDS	R24,ControlModel+8
    09289 3081      CPI	R24,1
(1605) 					uart_Printf("%s\r\n",strM4151);
    0928A F4C9      BNE	0x92A4
    0928B 2422      CLR	R2
    0928C 9220 08EA STS	PacketState+234,R2
    0928E 9220 08F2 STS	PacketState+242,R2
(1606) 					Uart0ReEnable;
    09290 9220 17E0 STS	ControlModel+8,R2
    09292 9180 00C1 LDS	R24,0xC1
    09294 7E8F      ANDI	R24,0xEF
(1607) 					return 1;
    09295 9380 00C1 STS	0xC1,R24
(1608) 					break;
(1609) 				}
(1610) 			break;
(1611) 		default:
(1612) 			break;
(1613) 		}
(1614) 	return 0;
    09297 E225      LDI	R18,0x25
    09298 E13A      LDI	R19,0x1A
    09299 E50A      LDI	R16,0x5A
    0929A E019      LDI	R17,0x9
FILE: D:\Work\主控软件\2032A2~1\physicalLayer.c
(0001) #include <iom1280v.h>
(0002) #include <macros.h>
(0003) #include "B1404_LIB.h"
(0004) #include "LibCommon.h"
(0005) #include "Common.h"
(0006) 
(0007) 
(0008) extern unsigned char ControlModel;			// 0:正常， 1:超级终端调试
(0009) 
(0010) 
(0011) //void uartDataInit(void);
(0012) //void uart0DataReceive(unsigned char dat);
(0013) 
(0014) UARTBUF_TXD		uart0TxdBuf;	// 发送数据缓冲区
(0015) UARTBUF_RXD 	uart0RxdBuf;
(0016) unsigned char 	uartBufProtect = 0;
(0017) 
(0018) unsigned char checkFlag = 0;
(0019) 
(0020) void port_init(void)
(0021) {
(0022) 	PORTA = 0x00;
_port_init:
    0929B 940E A90D CALL	_uart_Printf
(0023) 	DDRA  = 0x00;
    0929D 9180 00C1 LDS	R24,0xC1
(0024) 	PORTB = 0x80;
    0929F 6180      ORI	R24,0x10
(0025) 	DDRB  = 0x00;
    092A0 9380 00C1 STS	0xC1,R24
(0026) 	PORTC = 0x00; //m103 output only
    092A2 E001      LDI	R16,1
(0027) 	DDRC  = 0x00;
(0028) 	PORTD = 0xFF;
    092A3 C0B1      RJMP	0x9355
    092A4 940E 370B CALL	_WaitStartKey
(0029) 	//DDRD  = 0x00;
(0030) 	DDRD  = 0x80;
    092A6 2EA0      MOV	R10,R16
(0031) 	PORTE = 0x33;
    092A7 2300      TST	R16
    092A8 F411      BNE	0x92AB
(0032) 	DDRE  = 0x32;
    092A9 2700      CLR	R16
    092AA C0AA      RJMP	0x9355
(0033) 	PORTF = 0x00;
    092AB 2422      CLR	R2
(0034) 	DDRF  = 0x03;
    092AC 9220 08F2 STS	PacketState+242,R2
(0035) 	PORTG = 0x00;
    092AE 9140 08EA LDS	R20,PacketState+234
(0036) 	DDRG  = 0x00;
    092B0 2755      CLR	R21
    092B1 3040      CPI	R20,0
(0037) 	PORTH = 0x03;
(0038) 	DDRH  = 0x0c;
    092B2 0745      CPC	R20,R21
    092B3 F0A9      BEQ	0x92C9
    092B4 3041      CPI	R20,1
(0039) 	PORTJ = 0x03;
    092B5 E0E0      LDI	R30,0
    092B6 075E      CPC	R21,R30
    092B7 F409      BNE	0x92B9
(0040) 	DDRJ  = 0x0c;
    092B8 C03A      RJMP	0x92F3
    092B9 3042      CPI	R20,2
    092BA E0E0      LDI	R30,0
(0041) 	PORTK = 0x0f;
    092BB 075E      CPC	R21,R30
    092BC F409      BNE	0x92BE
    092BD C055      RJMP	0x9313
(0042) 	DDRK  = 0x00;
    092BE 3043      CPI	R20,3
    092BF E0E0      LDI	R30,0
(0043) 	PORTL = 0x00;
    092C0 075E      CPC	R21,R30
    092C1 F409      BNE	0x92C3
(0044) 	DDRL  = 0x00;
    092C2 C057      RJMP	0x931A
    092C3 3044      CPI	R20,4
    092C4 E0E0      LDI	R30,0
(0045) }
(0046) 
(0047) //TIMER0 initialize - prescale:64
(0048) // WGM: Normal
(0049) // desired value: 8KHz
(0050) // actual value: 8.229KHz (2.8%)
(0051) void timer0_init(void){
(0052) 	TCCR0B = 0x00; //stop
_timer0_init:
    092C5 075E      CPC	R21,R30
    092C6 F409      BNE	0x92C8
(0053) 	TCNT0 = 0x8d;//0xc7;//0xE4; //set count
    092C7 C069      RJMP	0x9331
    092C8 C08B      RJMP	0x9354
(0054) 	OCR0A  = 0xc6;//0x39;//0x1C;
    092C9 2422      CLR	R2
    092CA 9220 17E0 STS	ControlModel+8,R2
(0055) 	TCCR0A = 0x40; //start timer
    092CC 2722      CLR	R18
(0056) 	TCCR0B = 0x03; //start timer
    092CD 2700      CLR	R16
    092CE 940E 6B81 CALL	_SetEValve
_timer0_ovf_isr:
    092D0 E084      LDI	R24,4
    092D1 838A      STD	Y+2,R24
    092D2 E082      LDI	R24,2
    092D3 8388      ST	Y,R24
    092D4 EF20      LDI	R18,0xF0
    092D5 E00B      LDI	R16,0xB
    092D6 940E 6A9F CALL	_SetMotRunPam
    092D8 E928      LDI	R18,0x98
    092D9 E33A      LDI	R19,0x3A
    092DA E00B      LDI	R16,0xB
    092DB 940E 6A2C CALL	_MotRun
    092DD E084      LDI	R24,4
    092DE 838A      STD	Y+2,R24
    092DF E082      LDI	R24,2
    092E0 8388      ST	Y,R24
    092E1 E32C      LDI	R18,0x3C
    092E2 E00A      LDI	R16,0xA
    092E3 940E 6A9F CALL	_SetMotRunPam
    092E5 E528      LDI	R18,0x58
(0057) }
(0058) 
(0059) 
(0060) #pragma interrupt_handler timer0_ovf_isr:iv_TIM0_OVF
(0061) void timer0_ovf_isr(void)
(0062) {
(0063) 	// OCR0A  = 0x04;
(0064) 	SendCommandData();
    092E6 E13B      LDI	R19,0x1B
    092E7 E00A      LDI	R16,0xA
(0065) 	uart0Transfer();		// 串口0数据自动发送
    092E8 940E 6A2C CALL	_MotRun
(0066) 	SendInfoEvent();
    092EA E12E      LDI	R18,0x1E
(0067) 	
(0068) //	CardTrolleyTurnProcess();
(0069) 	
(0070) 	Beep();
    092EB E030      LDI	R19,0
    092EC E001      LDI	R16,1
(0071) 	// 0xb4 3k, 0x8d 2k, 0x67 1k5, 0x1a 1k
(0072) 	TCNT0 = 0x8d;//0xc7;//0x01; //reload counter value
    092ED 940E 97B7 CALL	_SetDelayTime
    092EF E081      LDI	R24,1
    092F0 9380 08EA STS	PacketState+234,R24
    092F2 C061      RJMP	0x9354
    092F3 E00A      LDI	R16,0xA
    092F4 940E 6A13 CALL	_MotStop
    092F6 E00B      LDI	R16,0xB
    092F7 940E 6A13 CALL	_MotStop
    092F9 2422      CLR	R2
    092FA 2433      CLR	R3
    092FB 9230 08F6 STS	QuantifyTestCnt+1,R3
    092FD 9220 08F5 STS	QuantifyTestCnt,R2
    092FF E082      LDI	R24,2
    09300 9380 08EA STS	PacketState+234,R24
    09302 9180 00C1 LDS	R24,0xC1
    09304 7E8F      ANDI	R24,0xEF
    09305 9380 00C1 STS	0xC1,R24
(0073) }
(0074) 
(0075) //TIMER1 initialize - prescale:256
(0076) // WGM: 0) Normal, TOP=0xFFFF
(0077) // desired value: 100mSec
(0078) // actual value: 99.983mSec (0.0%)
(0079) void timer1_init(void){
(0080) 	TCCR1B = 0x00; //stop
    09307 E027      LDI	R18,7
    09308 E13A      LDI	R19,0x1A
(0081) 	TCNT1H = 0xE9; //setup
    09309 E50A      LDI	R16,0x5A
    0930A E019      LDI	R17,0x9
    0930B 940E A90D CALL	_uart_Printf
(0082) 	TCNT1L = 0x81;
    0930D 9180 00C1 LDS	R24,0xC1
(0083) 	OCR1AH = 0x16;
    0930F 6180      ORI	R24,0x10
    09310 9380 00C1 STS	0xC1,R24
(0084) 	OCR1AL = 0x7F;
    09312 C041      RJMP	0x9354
    09313 E081      LDI	R24,1
    09314 9380 08F2 STS	PacketState+242,R24
(0085) 	OCR1BH = 0x16;
    09316 E083      LDI	R24,3
    09317 9380 08EA STS	PacketState+234,R24
(0086) 	OCR1BL = 0x7F;
    09319 C03A      RJMP	0x9354
    0931A 9180 08F5 LDS	R24,QuantifyTestCnt
(0087) 	OCR1CH = 0x00;
    0931C 9190 08F6 LDS	R25,QuantifyTestCnt+1
(0088) 	OCR1CL = 0x00;
    0931E 9601      ADIW	R24,1
(0089) 	ICR1H  = 0x16;
    0931F 9390 08F6 STS	QuantifyTestCnt+1,R25
    09321 9380 08F5 STS	QuantifyTestCnt,R24
(0090) 	ICR1L  = 0x7F;
    09323 9120 08F7 LDS	R18,QuantifyTestCnt+2
(0091) 	TCCR1A = 0x00;
    09325 9130 08F8 LDS	R19,QuantifyTestCnt+3
(0092) 	TCCR1C = 0x00;
    09327 E00A      LDI	R16,0xA
    09328 940E 6A2C CALL	_MotRun
(0093) 	TCCR1B = 0x04; //start Timer
    0932A E081      LDI	R24,1
    0932B 9380 08ED STS	PacketState+237,R24
(0094) }
(0095) 
(0096) unsigned int DelayCount[16];
(0097) void SetDelayTime(unsigned char num, unsigned int t){
(0098) 	// 100mS
(0099) 	if(num>15)
_SetDelayTime:
  t                    --> R18
  num                  --> R16
    0932D E084      LDI	R24,4
    0932E 9380 08EA STS	PacketState+234,R24
(0100) 		return;
    09330 C023      RJMP	0x9354
(0101) 	DelayCount[num] = t;
    09331 9180 00C1 LDS	R24,0xC1
    09333 7E8F      ANDI	R24,0xEF
    09334 9380 00C1 STS	0xC1,R24
    09336 9020 08F5 LDS	R2,QuantifyTestCnt
    09338 9030 08F6 LDS	R3,QuantifyTestCnt+1
    0933A 8239      STD	Y+1,R3
    0933B 8228      ST	Y,R2
(0102) }
(0103) unsigned char WaitDelayTime(unsigned char num){
(0104) 	if(num>15)
_WaitDelayTime:
  num                  --> R16
    0933C E422      LDI	R18,0x42
    0933D E13A      LDI	R19,0x1A
    0933E E50F      LDI	R16,0x5F
(0105) 		return 0;
    0933F E019      LDI	R17,0x9
    09340 940E A90D CALL	_uart_Printf
(0106) 	if(DelayCount[num] == 0)
    09342 9180 00C1 LDS	R24,0xC1
    09344 6180      ORI	R24,0x10
    09345 9380 00C1 STS	0xC1,R24
    09347 9120 08F7 LDS	R18,QuantifyTestCnt+2
    09349 9130 08F8 LDS	R19,QuantifyTestCnt+3
    0934B E00B      LDI	R16,0xB
    0934C 940E 6A2C CALL	_MotRun
    0934E E081      LDI	R24,1
(0107) 		return 0;
    0934F 9380 08EE STS	PacketState+238,R24
(0108) 	else
(0109) 		return 1;
    09351 E082      LDI	R24,2
    09352 9380 08EA STS	PacketState+234,R24
    09354 2700      CLR	R16
    09355 9623      ADIW	R28,3
    09356 940C AE88 JMP	pop_xgset300C
_SetSampQuantifyVolume:
    09358 E788      LDI	R24,0x78
    09359 1780      CP	R24,R16
    0935A F408      BCC	0x935C
    0935B E708      LDI	R16,0x78
    0935C 3005      CPI	R16,5
    0935D F408      BCC	0x935F
    0935E E005      LDI	R16,5
    0935F 2E20      MOV	R2,R16
    09360 2433      CLR	R3
    09361 0C22      LSL	R2
    09362 1C33      ROL	R3
    09363 0C22      LSL	R2
    09364 1C33      ROL	R3
    09365 9230 08FA STS	QuantifyTestCnt+5,R3
    09367 9220 08F9 STS	QuantifyTestCnt+4,R2
    09369 9508      RET
(0110) }
(0111) extern unsigned long SecondCount;
(0112) #pragma interrupt_handler timer1_ovf_isr:iv_TIM1_OVF
(0113) void timer1_ovf_isr(void){
(0114) 	unsigned char n;
(0115) 	static unsigned char i,j;
(0116) 	//TIMER1 has overflowed
(0117) 	TCNT1H = 0xE9; //reload counter high value
_SampQuantifyTest:
    0936A 940E AEA5 CALL	push_xgset303C
    0936C 9723      SBIW	R28,3
(0118) 	TCNT1L = 0x81; //reload counter low value
    0936D E001      LDI	R16,1
    0936E 940E 97C6 CALL	_WaitDelayTime
(0119) 
(0120) 	for(n=0; n<16; n++){		// 为每个延时计数计时
    09370 2300      TST	R16
    09371 F011      BEQ	0x9374
(0121) 		if(DelayCount[n] != 0)
    09372 2700      CLR	R16
    09373 C3AE      RJMP	0x9722
    09374 9020 08ED LDS	R2,PacketState+237
    09376 2022      TST	R2
    09377 F051      BEQ	0x9382
    09378 E00C      LDI	R16,0xC
    09379 940E 6A0C CALL	_GetMotState
    0937B 3001      CPI	R16,1
    0937C F011      BEQ	0x937F
    0937D 2700      CLR	R16
    0937E C3A3      RJMP	0x9722
    0937F 2422      CLR	R2
(0122) 			DelayCount[n] --;	// 计数值减到零时停止
    09380 9220 08ED STS	PacketState+237,R2
    09382 9020 08EE LDS	R2,PacketState+238
    09384 2022      TST	R2
    09385 F059      BEQ	0x9391
    09386 E002      LDI	R16,2
    09387 940E 6A0C CALL	_GetMotState
    09389 2F40      MOV	R20,R16
    0938A 3001      CPI	R16,1
    0938B F011      BEQ	0x938E
    0938C 2700      CLR	R16
    0938D C394      RJMP	0x9722
    0938E 2422      CLR	R2
(0123) 		}
(0124) //	CardTrolleyTurnProcess();
(0125) 	i++;
    0938F 9220 08EE STS	PacketState+238,R2
    09391 9020 08EF LDS	R2,PacketState+239
    09393 2022      TST	R2
(0126) 	j++;
    09394 F059      BEQ	0x93A0
    09395 E003      LDI	R16,3
    09396 940E 6A0C CALL	_GetMotState
    09398 2F40      MOV	R20,R16
(0127) 	if(i>9)
    09399 3001      CPI	R16,1
    0939A F011      BEQ	0x939D
    0939B 2700      CLR	R16
    0939C C385      RJMP	0x9722
    0939D 2422      CLR	R2
(0128) 	{
(0129) 		SecondCount ++;
    0939E 9220 08EF STS	PacketState+239,R2
    093A0 9020 08F0 LDS	R2,PacketState+240
    093A2 2022      TST	R2
    093A3 F059      BEQ	0x93AF
    093A4 E00A      LDI	R16,0xA
    093A5 940E 6A0C CALL	_GetMotState
    093A7 2F40      MOV	R20,R16
    093A8 3001      CPI	R16,1
    093A9 F011      BEQ	0x93AC
    093AA 2700      CLR	R16
    093AB C376      RJMP	0x9722
    093AC 2422      CLR	R2
    093AD 9220 08F0 STS	PacketState+240,R2
    093AF 9020 08F1 LDS	R2,PacketState+241
    093B1 2022      TST	R2
    093B2 F059      BEQ	0x93BE
    093B3 E00B      LDI	R16,0xB
    093B4 940E 6A0C CALL	_GetMotState
(0130) 		i = 0;
    093B6 2F40      MOV	R20,R16
    093B7 3001      CPI	R16,1
    093B8 F011      BEQ	0x93BB
(0131) 		// 废片仓功能开启
(0132) 		if(GetwasteCardState() == 0)	
    093B9 2700      CLR	R16
    093BA C367      RJMP	0x9722
    093BB 2422      CLR	R2
    093BC 9220 08F1 STS	PacketState+241,R2
(0133) 			TrashCanMonitor();
    093BE 9020 08F2 LDS	R2,PacketState+242
(0134) 	}
(0135) 	if(j > 4)
    093C0 2022      TST	R2
    093C1 F0B1      BEQ	0x93D8
    093C2 9180 17E0 LDS	R24,ControlModel+8
(0136) 	{
(0137) 		j = 0;
    093C4 3081      CPI	R24,1
    093C5 F441      BNE	0x93CE
    093C6 E083      LDI	R24,3
(0138) 		PORTD ^= (1 << 7);
    093C7 9380 08EA STS	PacketState+234,R24
    093C9 2422      CLR	R2
    093CA 9220 08EB STS	PacketState+235,R2
    093CC 9220 08F2 STS	PacketState+242,R2
(0139) 	}
    093CE 940E 370B CALL	_WaitStartKey
    093D0 2EA0      MOV	R10,R16
    093D1 2300      TST	R16
    093D2 F411      BNE	0x93D5
    093D3 2700      CLR	R16
    093D4 C34D      RJMP	0x9722
    093D5 2422      CLR	R2
    093D6 9220 08F2 STS	PacketState+242,R2
    093D8 9140 08EA LDS	R20,PacketState+234
    093DA 2755      CLR	R21
    093DB 3040      CPI	R20,0
    093DC 0745      CPC	R20,R21
    093DD F081      BEQ	0x93EE
    093DE 3041      CPI	R20,1
    093DF E0E0      LDI	R30,0
    093E0 075E      CPC	R21,R30
    093E1 F409      BNE	0x93E3
    093E2 C153      RJMP	0x9536
    093E3 3042      CPI	R20,2
    093E4 E0E0      LDI	R30,0
    093E5 075E      CPC	R21,R30
(0140) }
(0141) //TIMER4 initialize - prescale:1
(0142) // WGM: 7) PWM 10bit fast, TOP=0x03FF
(0143) // desired value: 10KHz
(0144) // actual value: 14.400KHz (30.6%)
(0145) void timer4_init(void)
(0146) {
(0147)  TCCR4B = 0x00; //stop
_timer4_init:
    093E6 F409      BNE	0x93E8
    093E7 C1BC      RJMP	0x95A4
    093E8 3043      CPI	R20,3
(0148)  TCNT4H = 0xFC; //setup
    093E9 E0E0      LDI	R30,0
    093EA 075E      CPC	R21,R30
    093EB F409      BNE	0x93ED
(0149)  TCNT4L = 0x01;
    093EC C2D6      RJMP	0x96C3
    093ED C333      RJMP	0x9721
    093EE 9140 08EB LDS	R20,PacketState+235
(0150)  OCR4AH = 0x03;
    093F0 2755      CLR	R21
    093F1 3040      CPI	R20,0
(0151)  OCR4AL = 0xFF;
    093F2 0745      CPC	R20,R21
    093F3 F121      BEQ	0x9418
    093F4 3041      CPI	R20,1
(0152)  OCR4BH = 0x03;
    093F5 E0E0      LDI	R30,0
    093F6 075E      CPC	R21,R30
    093F7 F409      BNE	0x93F9
(0153)  OCR4BL = 0xFF;
    093F8 C037      RJMP	0x9430
    093F9 3042      CPI	R20,2
    093FA E0E0      LDI	R30,0
(0154)  OCR4CH = 0x03;
    093FB 075E      CPC	R21,R30
    093FC F409      BNE	0x93FE
    093FD C044      RJMP	0x9442
(0155)  OCR4CL = 0xFF;
    093FE 3043      CPI	R20,3
    093FF E0E0      LDI	R30,0
    09400 075E      CPC	R21,R30
(0156)  ICR4H  = 0x03;
    09401 F409      BNE	0x9403
    09402 C04B      RJMP	0x944E
    09403 3044      CPI	R20,4
(0157)  ICR4L  = 0xFF;
    09404 E0E0      LDI	R30,0
    09405 075E      CPC	R21,R30
    09406 F409      BNE	0x9408
(0158)  TCCR4A = 0x2B; //0x2B;	//0x3F;
    09407 C055      RJMP	0x945D
    09408 3045      CPI	R20,5
    09409 E0E0      LDI	R30,0
(0159)  TCCR4C = 0x00;
    0940A 075E      CPC	R21,R30
    0940B F409      BNE	0x940D
(0160)  TCCR4B = 0x09; //start Timer
    0940C C077      RJMP	0x9484
    0940D 3046      CPI	R20,6
    0940E E0E0      LDI	R30,0
    0940F 075E      CPC	R21,R30
(0161) }
(0162) 
(0163) //TIMER5 initialize - prescale:1
(0164) // WGM: 7) PWM 10bit fast, TOP=0x03FF
(0165) // desired value: 10KHz
(0166) // actual value: 14.400KHz (30.6%)
(0167) void timer5_init(void)
(0168) {
(0169)  TCCR5B = 0x00; //stop
_timer5_init:
    09410 F409      BNE	0x9412
    09411 C07A      RJMP	0x948C
    09412 3047      CPI	R20,7
(0170)  TCNT5H = 0xFC; //setup
    09413 E0E0      LDI	R30,0
    09414 075E      CPC	R21,R30
    09415 F409      BNE	0x9417
(0171)  TCNT5L = 0x01;
    09416 C0C4      RJMP	0x94DB
    09417 C309      RJMP	0x9721
    09418 2422      CLR	R2
(0172)  OCR5AH = 0x03;
    09419 9220 17E0 STS	ControlModel+8,R2
    0941B 2722      CLR	R18
(0173)  OCR5AL = 0xFF;
    0941C 2700      CLR	R16
    0941D 940E 6B81 CALL	_SetEValve
(0174)  OCR5BH = 0x03;
    0941F E083      LDI	R24,3
    09420 838A      STD	Y+2,R24
    09421 E184      LDI	R24,0x14
(0175)  OCR5BL = 0xFF;
    09422 8388      ST	Y,R24
    09423 EF20      LDI	R18,0xF0
    09424 E003      LDI	R16,3
(0176)  OCR5CH = 0x03;
    09425 940E 6A9F CALL	_SetMotRunPam
    09427 E003      LDI	R16,3
(0177)  OCR5CL = 0xFF;
    09428 940E 6AFA CALL	_MotInitCheck
    0942A E081      LDI	R24,1
(0178)  ICR5H  = 0x03;
    0942B 9380 08EF STS	PacketState+239,R24
    0942D 9380 08EB STS	PacketState+235,R24
(0179)  ICR5L  = 0xFF;
    0942F C2F1      RJMP	0x9721
    09430 E084      LDI	R24,4
(0180)  TCCR5A = 0x2B; //0x2B;	//0x3F;
    09431 838A      STD	Y+2,R24
    09432 E184      LDI	R24,0x14
    09433 8388      ST	Y,R24
(0181)  TCCR5C = 0x00;
    09434 E220      LDI	R18,0x20
    09435 E002      LDI	R16,2
(0182)  TCCR5B = 0x09; //start Timer
    09436 940E 6A9F CALL	_SetMotRunPam
    09438 E002      LDI	R16,2
    09439 940E 6AFA CALL	_MotInitCheck
(0183) }
(0184) 
(0185) //UART0 initialize
(0186) // desired baud rate: 115200
(0187) // actual: baud rate:115200 (0.0%) 
(0188) // char size: 8 bit
(0189) // parity: Disabled
(0190) void uart0_init(void){
(0191) 	UCSR0B = 0x00; //disable while setting baud rate
    0943B E081      LDI	R24,1
    0943C 9380 08EE STS	PacketState+238,R24
(0192) 	UCSR0A = 0x00;
    0943E E082      LDI	R24,2
(0193) 	UCSR0C = 0x06;
    0943F 9380 08EB STS	PacketState+235,R24
    09441 C2DF      RJMP	0x9721
(0194) 	//UBRR0L = 0x07; //set baud rate lo
(0195) 	UBRR0L = 0X0F;
    09442 E423      LDI	R18,0x43
    09443 E031      LDI	R19,1
    09444 E002      LDI	R16,2
(0196) 	UBRR0H = 0x00; //set baud rate hi
    09445 940E 6A5B CALL	_MotRunTo
(0197) 	UCSR0B = 0x98;//0xD8;
    09447 E081      LDI	R24,1
    09448 9380 08EE STS	PacketState+238,R24
    0944A E083      LDI	R24,3
_HexToBin:
  n                    --> R20
  c                    --> R16
    0944B 9380 08EB STS	PacketState+235,R24
(0198) }
(0199) 
(0200) unsigned char HexToBin(unsigned char c){
(0201) 	unsigned char n=0;
    0944D C2D3      RJMP	0x9721
(0202) 	if(c>='0' && c<='9')
    0944E EE28      LDI	R18,0xE8
    0944F E033      LDI	R19,3
    09450 E003      LDI	R16,3
    09451 940E 6A5B CALL	_MotRunTo
(0203) 		n = c-0x30;
    09453 E081      LDI	R24,1
    09454 9380 08EF STS	PacketState+239,R24
(0204) 	if(c>='a' && c<='f')
    09456 E084      LDI	R24,4
    09457 9380 08EB STS	PacketState+235,R24
    09459 2422      CLR	R2
(0205) 		n = c-'a' + 10;
    0945A 9220 17DF STS	ControlModel+7,R2
    0945C C2C4      RJMP	0x9721
(0206) 	if(c>='A' && c<='F')
    0945D E021      LDI	R18,1
    0945E E004      LDI	R16,4
    0945F 940E 6B81 CALL	_SetEValve
    09461 E084      LDI	R24,4
(0207) 		n = c-'A' + 10;
    09462 838A      STD	Y+2,R24
    09463 E082      LDI	R24,2
    09464 8388      ST	Y,R24
(0208) 	return n;
    09465 E228      LDI	R18,0x28
    09466 E00A      LDI	R16,0xA
    09467 940E 6A9F CALL	_SetMotRunPam
_uart0_rx_isr:
  dat                  --> R10
    09469 E828      LDI	R18,0x88
    0946A E133      LDI	R19,0x13
    0946B E00A      LDI	R16,0xA
    0946C 940E 6A2C CALL	_MotRun
    0946E E084      LDI	R24,4
    0946F 838A      STD	Y+2,R24
    09470 E082      LDI	R24,2
    09471 8388      ST	Y,R24
    09472 E32C      LDI	R18,0x3C
    09473 E00B      LDI	R16,0xB
    09474 940E 6A9F CALL	_SetMotRunPam
    09476 E228      LDI	R18,0x28
    09477 E233      LDI	R19,0x23
    09478 E00B      LDI	R16,0xB
    09479 940E 6A2C CALL	_MotRun
    0947B E081      LDI	R24,1
    0947C 9380 08F0 STS	PacketState+240,R24
    0947E 9380 08F1 STS	PacketState+241,R24
(0209) 	
(0210) }
(0211) //unsigned char CmdBuf[30];
(0212) //unsigned char CmdLen=0;
(0213) //unsigned char rxBuf[60];
(0214) //unsigned char rxPnt=0;
(0215) #pragma interrupt_handler uart0_rx_isr:iv_USART0_RXC
(0216) void uart0_rx_isr(void){
(0217)  //uart has received a character in UDR
(0218) 	unsigned char dat;
(0219) 	dat = UDR0;
    09480 E085      LDI	R24,5
    09481 9380 08EB STS	PacketState+235,R24
(0220) 	uart0DataReceive(dat);
    09483 C29D      RJMP	0x9721
    09484 2722      CLR	R18
    09485 2700      CLR	R16
    09486 940E 6B81 CALL	_SetEValve
    09488 E086      LDI	R24,6
    09489 9380 08EB STS	PacketState+235,R24
    0948B C295      RJMP	0x9721
    0948C 2700      CLR	R16
    0948D 940E 9A52 CALL	_getLiqDetADC
    0948F 0158      MOVW	R10,R16
    09490 92B0 17DA STS	ControlModel+2,R11
    09492 92A0 17D9 STS	ControlModel+1,R10
    09494 EF84      LDI	R24,0xF4
    09495 E091      LDI	R25,1
    09496 0115      MOVW	R2,R10
    09497 1780      CP	R24,R16
    09498 0791      CPC	R25,R17
    09499 F498      BCC	0x94AD
    0949A 9180 00C1 LDS	R24,0xC1
(0221) }
(0222) 
(0223) #pragma interrupt_handler uart0_tx_isr:iv_USART0_TXC
(0224) void uart0_tx_isr(void){
_uart0_tx_isr:
    0949C 7E8F      ANDI	R24,0xEF
(0225) 	//character has been transmitted
(0226) 
(0227) }
(0228) 
(0229) //UART1 initialize
(0230) // desired baud rate:9600
(0231) // actual baud rate:9600 (0.0%)
(0232) // char size: 8 bit
(0233) // parity: Disabled
(0234) void uart1_init(void){
(0235) 	UCSR1B = 0x00; //disable while setting baud rate
_uart1_init:
    0949D 9380 00C1 STS	0xC1,R24
    0949F 8239      STD	Y+1,R3
(0236) 	UCSR1A = 0x00;
    094A0 8228      ST	Y,R2
    094A1 E12C      LDI	R18,0x1C
(0237) 	UCSR1C = 0x06;
    094A2 E03B      LDI	R19,0xB
    094A3 EF0B      LDI	R16,0xFB
    094A4 E018      LDI	R17,0x8
(0238) 	UBRR1L = 0x5F; //set baud rate lo
    094A5 940E A90D CALL	_uart_Printf
    094A7 9180 00C1 LDS	R24,0xC1
(0239) 	UBRR1H = 0x00; //set baud rate hi
    094A9 6180      ORI	R24,0x10
(0240) 	UCSR1B = 0x98;
    094AA 9380 00C1 STS	0xC1,R24
    094AC C01D      RJMP	0x94CA
    094AD 9180 00C1 LDS	R24,0xC1
(0241) }
(0242) 
(0243) #pragma interrupt_handler uart1_rx_isr:iv_USART1_RXC
(0244) void uart1_rx_isr(void){
_uart2_init:
    094AF 7E8F      ANDI	R24,0xEF
    094B0 9380 00C1 STS	0xC1,R24
(0245)  //uart has received a character in UDR
(0246) 	
(0247) }
(0248) 
(0249) //UART2 initialize
(0250) // desired baud rate:115200
(0251) // actual baud rate:115200 (0.0%)
(0252) // char size: 9 bit
(0253) // parity: Disabled
(0254) void uart2_init(void){
(0255) 	UCSR2B = 0x00; //disable while setting baud rate
(0256) 	UCSR2A = 0x00;
    094B2 9020 17D9 LDS	R2,ControlModel+1
(0257) 	UCSR2C = 0x06;
    094B4 9030 17DA LDS	R3,ControlModel+2
    094B6 8239      STD	Y+1,R3
(0258) 	UBRR2L = 0x07; //set baud rate lo	115200
    094B7 8228      ST	Y,R2
    094B8 E124      LDI	R18,0x14
    094B9 E03C      LDI	R19,0xC
(0259) 	UBRR2H = 0x00; //set baud rate hi
    094BA EF0B      LDI	R16,0xFB
    094BB E018      LDI	R17,0x8
(0260) 	UCSR2B = 0xDC;//0xDC;
    094BC 940E A90D CALL	_uart_Printf
    094BE 9180 00C1 LDS	R24,0xC1
(0261) }
(0262) 
(0263) unsigned char _Uart2DetectorSelfFlag = 0;	// 数据发送标记, 用于在线侦测发送数据
(0264) unsigned char _Uart2DetectorSelfData;		// 接收在线侦测到的数据
(0265) unsigned char _Uart2CurrentSendData;		// 当前发送的数据
(0266) unsigned char _Uart2DataSendResult = 0;
(0267) /*void SetUart2DetectorSelf(void){
(0268) 	_Uart2DetectorSelfFlag = 1;
(0269) }
(0270) unsigned char GetUart2DetectorSelfData(void){
(0271) 	return _Uart2DetectorSelfData;
(0272) }*/
(0273) unsigned char GetUart2DataSendResult(void){
(0274) 	return _Uart2DataSendResult;
_GetUart2DataSendResult:
    094C0 6180      ORI	R24,0x10
    094C1 9380 00C1 STS	0xC1,R24
_uart2_rx_isr:
  dat                  --> R10
    094C3 E083      LDI	R24,3
    094C4 9380 08EA STS	PacketState+234,R24
    094C6 2422      CLR	R2
    094C7 9220 08EB STS	PacketState+235,R2
    094C9 C257      RJMP	0x9721
    094CA E084      LDI	R24,4
    094CB 838A      STD	Y+2,R24
    094CC E082      LDI	R24,2
    094CD 8388      ST	Y,R24
    094CE E420      LDI	R18,0x40
    094CF E009      LDI	R16,0x9
    094D0 940E 6A9F CALL	_SetMotRunPam
    094D2 E420      LDI	R18,0x40
    094D3 E13F      LDI	R19,0x1F
    094D4 E009      LDI	R16,0x9
    094D5 940E 6A2C CALL	_MotRun
    094D7 E087      LDI	R24,7
    094D8 9380 08EB STS	PacketState+235,R24
(0275) }
(0276) 
(0277) #pragma interrupt_handler uart2_rx_isr:iv_USART2_RXC
(0278) void uart2_rx_isr(void)
(0279) {
(0280) 	//uart has received a character in UDR
(0281) 	unsigned char dat;
(0282) 	dat = UDR2;
    094DA C246      RJMP	0x9721
    094DB E009      LDI	R16,0x9
(0283) 	if(_Uart2DetectorSelfFlag)
    094DC 940E 6A0C CALL	_GetMotState
    094DE 2F40      MOV	R20,R16
    094DF 3001      CPI	R16,1
(0284) 	{
(0285) 		_Uart2DetectorSelfData = dat;
    094E0 F511      BNE	0x9503
    094E1 9180 17DF LDS	R24,ControlModel+7
(0286) 		_Uart2DetectorSelfFlag = 0;
    094E3 5F8F      SUBI	R24,0xFF
    094E4 9380 17DF STS	ControlModel+7,R24
(0287) 		if(_Uart2DetectorSelfData == _Uart2CurrentSendData)
    094E6 3083      CPI	R24,3
    094E7 F420      BCC	0x94EC
    094E8 E086      LDI	R24,6
(0288) 			_Uart2DataSendResult = 0;
    094E9 9380 08EB STS	PacketState+235,R24
    094EB C017      RJMP	0x9503
    094EC E083      LDI	R24,3
(0289) 		else
(0290) 			_Uart2DataSendResult = 1;
    094ED 9380 08EA STS	PacketState+234,R24
    094EF 2422      CLR	R2
(0291) 	}
    094F0 9220 08EB STS	PacketState+235,R2
(0292) 	else
(0293) 		ReceiveSlaveInfo(dat);
    094F2 9180 00C1 LDS	R24,0xC1
    094F4 7E8F      ANDI	R24,0xEF
    094F5 9380 00C1 STS	0xC1,R24
    094F7 E825      LDI	R18,0x85
    094F8 E134      LDI	R19,0x14
    094F9 E50A      LDI	R16,0x5A
    094FA E019      LDI	R17,0x9
    094FB 940E A90D CALL	_uart_Printf
    094FD 9180 00C1 LDS	R24,0xC1
    094FF 6180      ORI	R24,0x10
    09500 9380 00C1 STS	0xC1,R24
    09502 C21E      RJMP	0x9721
    09503 2700      CLR	R16
    09504 940E 9A52 CALL	_getLiqDetADC
    09506 0158      MOVW	R10,R16
    09507 9020 17D9 LDS	R2,ControlModel+1
    09509 9030 17DA LDS	R3,ControlModel+2
    0950B 1502      CP	R16,R2
_uart2_tx_isr:
    0950C 0513      CPC	R17,R3
    0950D F008      BCS	0x950F
    0950E C212      RJMP	0x9721
(0294) }
(0295) 
(0296) #pragma interrupt_handler uart2_tx_isr:iv_USART2_TXC
(0297) void uart2_tx_isr(void){
(0298) 	//character has been transmitted
(0299) 	PORTH = 0x03;
    0950F 1A20      SUB	R2,R16
    09510 0A31      SBC	R3,R17
    09511 0151      MOVW	R10,R2
(0300) 	PORTH = 0x03;
    09512 EC88      LDI	R24,0xC8
    09513 E090      LDI	R25,0
    09514 1582      CP	R24,R2
    09515 0593      CPC	R25,R3
    09516 F008      BCS	0x9518
    09517 C209      RJMP	0x9721
(0301) //	BeepNum = 2;
(0302) }
(0303) void Uart2SendAdd(unsigned char add)
(0304) {
(0305) 	PORTH = 0x0b;	//0x0f;
_Uart2SendAdd:
  add                  --> R16
    09518 E009      LDI	R16,0x9
    09519 940E 6A13 CALL	_MotStop
(0306) 	_Uart2DetectorSelfFlag = 1;
    0951B E228      LDI	R18,0x28
    0951C E030      LDI	R19,0
    0951D E003      LDI	R16,3
(0307) 	while(!(UCSR2A & 0x20));
    0951E 940E 6A2C CALL	_MotRun
    09520 E086      LDI	R24,6
    09521 838A      STD	Y+2,R24
(0308) 	UCSR2B |= 0x01;
    09522 E082      LDI	R24,2
    09523 8388      ST	Y,R24
    09524 E220      LDI	R18,0x20
    09525 E00C      LDI	R16,0xC
    09526 940E 6A9F CALL	_SetMotRunPam
(0309) 	UDR2 = add;
    09528 E00C      LDI	R16,0xC
(0310) 	_Uart2CurrentSendData = add;
    09529 940E 6AFA CALL	_MotInitCheck
    0952B E081      LDI	R24,1
(0311) }
(0312) void Uart2SendDat(unsigned char dat)
(0313) {
(0314) 	PORTH = 0x0b;	//0x0f;
_Uart2SendDat:
  dat                  --> R16
    0952C 9380 08ED STS	PacketState+237,R24
    0952E 9380 08EF STS	PacketState+239,R24
(0315) 	_Uart2DetectorSelfFlag = 1;
    09530 2422      CLR	R2
    09531 9220 08EB STS	PacketState+235,R2
(0316) 	while(!(UCSR2A & 0x20));
    09533 9380 08EA STS	PacketState+234,R24
    09535 C1EB      RJMP	0x9721
(0317) 	UCSR2B &= 0xFE;
    09536 9140 08EB LDS	R20,PacketState+235
    09538 2755      CLR	R21
    09539 3040      CPI	R20,0
    0953A 0745      CPC	R20,R21
(0318) 	UDR2 = dat;
    0953B F0B9      BEQ	0x9553
    0953C 3041      CPI	R20,1
(0319) 	_Uart2CurrentSendData = dat;
    0953D E0E0      LDI	R30,0
    0953E 075E      CPC	R21,R30
    0953F F0C9      BEQ	0x9559
(0320) }
(0321) 
(0322) //UART3 initialize
(0323) // desired baud rate:115200
(0324) // actual baud rate:115200 (0.0%)
(0325) // char size: 9 bit
(0326) // parity: Disabled
(0327) void uart3_init(void){
(0328) 	UCSR3B = 0x00; //disable while setting baud rate
_uart3_init:
    09540 3042      CPI	R20,2
    09541 E0E0      LDI	R30,0
    09542 075E      CPC	R21,R30
(0329) 	UCSR3A = 0x00;
    09543 F129      BEQ	0x9569
    09544 3043      CPI	R20,3
(0330) 	UCSR3C = 0x06;
    09545 E0E0      LDI	R30,0
    09546 075E      CPC	R21,R30
    09547 F169      BEQ	0x9575
(0331) 	UBRR3L = 0x07; //set baud rate lo
    09548 3044      CPI	R20,4
    09549 E0E0      LDI	R30,0
    0954A 075E      CPC	R21,R30
(0332) //	UBRR3L = 0x0f; //set baud rate lo
(0333) 	UBRR3H = 0x00; //set baud rate hi
    0954B F409      BNE	0x954D
    0954C C03C      RJMP	0x9589
(0334) 	UCSR3B = 0xDC;//0xDC;
    0954D 3045      CPI	R20,5
    0954E E0E0      LDI	R30,0
    0954F 075E      CPC	R21,R30
    09550 F409      BNE	0x9552
_uart3_rx_isr:
  dat                  --> R16
    09551 C043      RJMP	0x9595
    09552 C1CE      RJMP	0x9721
    09553 E081      LDI	R24,1
    09554 9380 08F2 STS	PacketState+242,R24
(0335) }
(0336) 
(0337) #pragma interrupt_handler uart3_rx_isr:iv_USART3_RXC
(0338) void uart3_rx_isr(void){
(0339) 	//uart has received a character in UDR
(0340) 	unsigned char dat;
(0341) 	while(!(UCSR3A & 0x80));
    09556 9380 08EB STS	PacketState+235,R24
    09558 C1C8      RJMP	0x9721
(0342) 	dat = UDR3;
    09559 9120 08F9 LDS	R18,QuantifyTestCnt+4
(0343) 	while(!(UCSR0A & 0x20));
    0955B 9130 08FA LDS	R19,QuantifyTestCnt+5
    0955D 5F21      SUBI	R18,0xF1
    0955E 4F3F      SBCI	R19,0xFF
(0344) 	UDR0 = dat;
    0955F E00C      LDI	R16,0xC
    09560 940E 6A2C CALL	_MotRun
    09562 E081      LDI	R24,1
    09563 9380 08ED STS	PacketState+237,R24
    09565 E082      LDI	R24,2
_uart3_tx_isr:
    09566 9380 08EB STS	PacketState+235,R24
    09568 C1B8      RJMP	0x9721
(0345) //	dat = dat;
(0346) 	//BeepNum = 2;
(0347) }
(0348) 
(0349) #pragma interrupt_handler uart3_tx_isr:iv_USART3_TXC
(0350) void uart3_tx_isr(void){
(0351) 	//character has been transmitted
(0352) 	PORTJ = 0x03;
    09569 EF2B      LDI	R18,0xFB
    0956A EF3F      LDI	R19,0xFF
    0956B E00C      LDI	R16,0xC
(0353) 	PORTJ = 0x03;
    0956C 940E 6A2C CALL	_MotRun
    0956E E081      LDI	R24,1
    0956F 9380 08ED STS	PacketState+237,R24
    09571 E083      LDI	R24,3
(0354) }
(0355) void Uart3SendAdd(unsigned char add){
(0356) 	PORTJ = 0x0f;
_Uart3SendAdd:
  add                  --> R16
    09572 9380 08EB STS	PacketState+235,R24
    09574 C1AC      RJMP	0x9721
(0357) 	while(!(UCSR2A & 0x20));
    09575 E083      LDI	R24,3
    09576 838A      STD	Y+2,R24
    09577 E184      LDI	R24,0x14
    09578 8388      ST	Y,R24
(0358) 	UCSR3B |= 0x01;
    09579 EF20      LDI	R18,0xF0
    0957A E003      LDI	R16,3
    0957B 940E 6A9F CALL	_SetMotRunPam
    0957D 2722      CLR	R18
(0359) 	UDR3 = add;
    0957E 2733      CLR	R19
    0957F E003      LDI	R16,3
    09580 940E 6A5B CALL	_MotRunTo
(0360) }
(0361) void Uart3SendDat(unsigned char dat){
(0362) 	PORTJ = 0x0f;
    09582 E081      LDI	R24,1
    09583 9380 08EF STS	PacketState+239,R24
(0363) 	while(!(UCSR3A & 0x20));
    09585 E084      LDI	R24,4
    09586 9380 08EB STS	PacketState+235,R24
(0364) 	UCSR3B &= 0xFE;
    09588 C198      RJMP	0x9721
    09589 ED24      LDI	R18,0xD4
    0958A E033      LDI	R19,3
    0958B E002      LDI	R16,2
    0958C 940E 6A5B CALL	_MotRunTo
(0365) 	UDR3 = dat;
    0958E E081      LDI	R24,1
    0958F 9380 08EE STS	PacketState+238,R24
(0366) }
(0367) 
(0368) #pragma interrupt_handler pcint2_isr:iv_PCINT2
(0369) void pcint2_isr(void){
_adc_init:
    09591 E085      LDI	R24,5
    09592 9380 08EB STS	PacketState+235,R24
(0370) 	//pin change interrupt 2
(0371) }
(0372) 
(0373) //ADC initialize
(0374) // Conversion time: 112uS
(0375) void adc_init(void){
(0376) 	ADCSRA = 0x00; //disable adc
(0377) 	ADMUX = 0x42;  //select adc input 2
    09594 C18C      RJMP	0x9721
    09595 E120      LDI	R18,0x10
    09596 E03E      LDI	R19,0xE
(0378) 	ACSR  = 0x80;
    09597 E003      LDI	R16,3
    09598 940E 6A5B CALL	_MotRunTo
(0379) 	ADCSRB = 0x00;
    0959A E081      LDI	R24,1
(0380) 	ADCSRA = 0xEF;
    0959B 9380 08EF STS	PacketState+239,R24
    0959D 2422      CLR	R2
    0959E 9220 08EB STS	PacketState+235,R2
    095A0 E082      LDI	R24,2
(0381) }
(0382) 
(0383) void SetNextADChannel(unsigned char num)
(0384) {
(0385) 	switch(num)
    095A1 9380 08EA STS	PacketState+234,R24
    095A3 C17D      RJMP	0x9721
    095A4 9140 08EB LDS	R20,PacketState+235
    095A6 2755      CLR	R21
    095A7 3040      CPI	R20,0
    095A8 0745      CPC	R20,R21
    095A9 F141      BEQ	0x95D2
    095AA 3041      CPI	R20,1
    095AB E0E0      LDI	R30,0
    095AC 075E      CPC	R21,R30
    095AD F151      BEQ	0x95D8
    095AE 3042      CPI	R20,2
(0386) 	{
(0387) 		case NeedleChannel:	ADCSRB = 0X08;ADMUX = 0X42;break;	 // Next ADC 10
    095AF E0E0      LDI	R30,0
    095B0 075E      CPC	R21,R30
    095B1 F409      BNE	0x95B3
    095B2 C037      RJMP	0x95EA
    095B3 3043      CPI	R20,3
    095B4 E0E0      LDI	R30,0
    095B5 075E      CPC	R21,R30
(0388) 		case LoadChannel:	ADCSRB = 0X08;ADMUX = 0X43;break;	 // Next ADC 11
    095B6 F409      BNE	0x95B8
    095B7 C03B      RJMP	0x95F3
    095B8 3044      CPI	R20,4
    095B9 E0E0      LDI	R30,0
    095BA 075E      CPC	R21,R30
    095BB F409      BNE	0x95BD
    095BC C042      RJMP	0x95FF
(0389) 		case UnloadChannel: ADCSRB = 0X00;ADMUX = 0X42;break;	 // Next ADC 02
    095BD 3045      CPI	R20,5
    095BE E0E0      LDI	R30,0
    095BF 075E      CPC	R21,R30
    095C0 F409      BNE	0x95C2
    095C1 C049      RJMP	0x960B
    095C2 3046      CPI	R20,6
(0390) 	//	case NeedleChannel:	ADCSRB = 0X08;ADMUX = 0X43;break;	 // ADC 2
(0391) 	//	case LoadChannel:	ADCSRB = 0X00;ADMUX = 0X42;break;	 // ADC 11
(0392) 	//	case UnloadChannel: ADCSRB = 0X08;ADMUX = 0X42;break;	 // ADC 10 
(0393) 		default:break;
    095C3 E0E0      LDI	R30,0
    095C4 075E      CPC	R21,R30
    095C5 F409      BNE	0x95C7
(0394) 	}
(0395) }
(0396) 
(0397) unsigned int AdcResult[3];		// 0 NeedleChannel,1 LoadChannel, 2 UnloadChannel 
(0398) #define _ADC_DIFF_BUF_LEN 20
(0399) signed int _Adc_DiffBuf[_ADC_DIFF_BUF_LEN];
(0400) signed int _Adc_Wave = 0;
(0401) unsigned char _Adc_DiffBufPnt=0;
(0402) 
(0403) unsigned int getLiqDetADC(unsigned char num)
(0404) {
(0405) 	return AdcResult[num];
_getLiqDetADC:
  num                  --> R16
    095C6 C050      RJMP	0x9617
    095C7 3047      CPI	R20,7
    095C8 E0E0      LDI	R30,0
    095C9 075E      CPC	R21,R30
    095CA F409      BNE	0x95CC
    095CB C057      RJMP	0x9623
    095CC 3048      CPI	R20,0x8
    095CD E0E0      LDI	R30,0
    095CE 075E      CPC	R21,R30
    095CF F409      BNE	0x95D1
    095D0 C0A1      RJMP	0x9672
(0406) }
(0407) unsigned char CheckLiqDetBase(void)
(0408) {
(0409) 	if(AdcResult[NeedleChannel] > 1015)	// 液体探测电极未连接
_CheckLiqDetBase:
    095D1 C14F      RJMP	0x9721
    095D2 E081      LDI	R24,1
    095D3 9380 08F2 STS	PacketState+242,R24
    095D5 9380 08EB STS	PacketState+235,R24
    095D7 C149      RJMP	0x9721
    095D8 9120 08F9 LDS	R18,QuantifyTestCnt+4
(0410) 	{		
(0411) 		SetBeepWarning();
    095DA 9130 08FA LDS	R19,QuantifyTestCnt+5
(0412) 		Uart0ReUnable;
    095DC 9520      COM	R18
    095DD 9530      COM	R19
    095DE 5F2F      SUBI	R18,0xFF
    095DF 4F3F      SBCI	R19,0xFF
    095E0 E00C      LDI	R16,0xC
(0413) 		uart_Printf("!2901 $%d\r\n", AdcResult[NeedleChannel]);		// 液体探测电极未连接, 请检查液体探测电极连接是否完好
    095E1 940E 6A2C CALL	_MotRun
    095E3 E081      LDI	R24,1
    095E4 9380 08ED STS	PacketState+237,R24
    095E6 E082      LDI	R24,2
    095E7 9380 08EB STS	PacketState+235,R24
(0414) 		Uart0ReEnable;
    095E9 C137      RJMP	0x9721
    095EA E025      LDI	R18,5
    095EB E030      LDI	R19,0
    095EC E001      LDI	R16,1
    095ED 940E 97B7 CALL	_SetDelayTime
(0415) 		return 2;
    095EF E083      LDI	R24,3
(0416) 	}
(0417) 	else if(AdcResult[NeedleChannel] < 400) // 液体探测电极附带影响大
    095F0 9380 08EB STS	PacketState+235,R24
    095F2 C12E      RJMP	0x9721
    095F3 2722      CLR	R18
    095F4 2733      CLR	R19
    095F5 E003      LDI	R16,3
    095F6 940E 6A5B CALL	_MotRunTo
(0418) 	{
(0419) 		SetBeepWarning();
    095F8 E081      LDI	R24,1
    095F9 9380 08EF STS	PacketState+239,R24
(0420) 		Uart0ReUnable;
    095FB E084      LDI	R24,4
    095FC 9380 08EB STS	PacketState+235,R24
    095FE C122      RJMP	0x9721
(0421) 		uart_Printf("!2902 $%d\r\n", AdcResult[NeedleChannel]);	// 液体探测电极受影响，请检查取样针接头处以及清洗头处是否有污染物
    095FF 2722      CLR	R18
    09600 2733      CLR	R19
    09601 E002      LDI	R16,2
    09602 940E 6A5B CALL	_MotRunTo
    09604 E081      LDI	R24,1
    09605 9380 08EE STS	PacketState+238,R24
(0422) 		Uart0ReEnable;
    09607 E085      LDI	R24,5
    09608 9380 08EB STS	PacketState+235,R24
    0960A C116      RJMP	0x9721
    0960B E423      LDI	R18,0x43
(0423) 		return 1;
    0960C E031      LDI	R19,1
    0960D E002      LDI	R16,2
(0424) 	}
(0425) 	
(0426) 	return 0;
    0960E 940E 6A5B CALL	_MotRunTo
(0427) }
(0428) signed int GetLiqDetDiff(void){
(0429) 	return _Adc_Wave;
_GetLiqDetDiff:
    09610 E081      LDI	R24,1
    09611 9380 08EE STS	PacketState+238,R24
    09613 E086      LDI	R24,6
    09614 9380 08EB STS	PacketState+235,R24
    09616 C10A      RJMP	0x9721
    09617 E220      LDI	R18,0x20
(0430) }
(0431) unsigned char GetLiqDetResult(signed int ref){
(0432) 	if(ref>0){
    09618 E033      LDI	R19,3
    09619 E003      LDI	R16,3
    0961A 940E 6A5B CALL	_MotRunTo
    0961C E081      LDI	R24,1
(0433) 		if(_Adc_Wave > ref){
    0961D 9380 08EF STS	PacketState+239,R24
    0961F E087      LDI	R24,7
    09620 9380 08EB STS	PacketState+235,R24
    09622 C0FE      RJMP	0x9721
    09623 2700      CLR	R16
(0434) 			Uart0ReUnable;
    09624 940E 9A52 CALL	_getLiqDetADC
    09626 0168      MOVW	R12,R16
    09627 92D0 17DA STS	ControlModel+2,R13
(0435) 			uart_Printf("// Liquid detect: %d\r\n", _Adc_Wave);
    09629 92C0 17D9 STS	ControlModel+1,R12
    0962B EF84      LDI	R24,0xF4
    0962C E091      LDI	R25,1
    0962D 0116      MOVW	R2,R12
(0436) 			Uart0ReEnable;
    0962E 1780      CP	R24,R16
    0962F 0791      CPC	R25,R17
    09630 F498      BCC	0x9644
    09631 9180 00C1 LDS	R24,0xC1
(0437) 			return 1;
    09633 7E8F      ANDI	R24,0xEF
    09634 9380 00C1 STS	0xC1,R24
(0438) 			}
(0439) 		}
(0440) 	else{
(0441) 		if(_Adc_Wave < ref){
    09636 8239      STD	Y+1,R3
    09637 8228      ST	Y,R2
    09638 E12C      LDI	R18,0x1C
    09639 E03B      LDI	R19,0xB
    0963A EF0B      LDI	R16,0xFB
    0963B E018      LDI	R17,0x8
(0442) 			Uart0ReUnable;
    0963C 940E A90D CALL	_uart_Printf
    0963E 9180 00C1 LDS	R24,0xC1
    09640 6180      ORI	R24,0x10
(0443) 			uart_Printf("// Liquid detect: %d\r\n", _Adc_Wave);
    09641 9380 00C1 STS	0xC1,R24
    09643 C01D      RJMP	0x9661
    09644 9180 00C1 LDS	R24,0xC1
(0444) 			Uart0ReEnable;
    09646 7E8F      ANDI	R24,0xEF
    09647 9380 00C1 STS	0xC1,R24
    09649 9020 17D9 LDS	R2,ControlModel+1
(0445) 			return 1;
    0964B 9030 17DA LDS	R3,ControlModel+2
(0446) 			}
(0447) 		}
(0448) 	return 0;
    0964D 8239      STD	Y+1,R3
    0964E 8228      ST	Y,R2
    0964F E124      LDI	R18,0x14
    09650 E03C      LDI	R19,0xC
_adc_isr:
  tmp                  --> R10
    09651 EF0B      LDI	R16,0xFB
    09652 E018      LDI	R17,0x8
    09653 940E A90D CALL	_uart_Printf
    09655 9180 00C1 LDS	R24,0xC1
    09657 6180      ORI	R24,0x10
    09658 9380 00C1 STS	0xC1,R24
    0965A E083      LDI	R24,3
    0965B 9380 08EA STS	PacketState+234,R24
    0965D 2422      CLR	R2
    0965E 9220 08EB STS	PacketState+235,R2
    09660 C0C0      RJMP	0x9721
    09661 E083      LDI	R24,3
    09662 838A      STD	Y+2,R24
    09663 E082      LDI	R24,2
    09664 8388      ST	Y,R24
    09665 E420      LDI	R18,0x40
    09666 E003      LDI	R16,3
    09667 940E 6A9F CALL	_SetMotRunPam
(0449) }
(0450) 
(0451) #pragma interrupt_handler adc_isr:iv_ADC
(0452) void adc_isr(void)
(0453) {
(0454) 	unsigned int tmp;
(0455) 	static signed int adc_change = 0;	
(0456) 	tmp = ADCL;            //Read 8 low bits first (important)
    09669 E220      LDI	R18,0x20
    0966A E033      LDI	R19,3
    0966B E003      LDI	R16,3
(0457) 	tmp  += ((unsigned int)ADCH << 8); //read 2 high bits and shift into top byte
    0966C 940E 6A2C CALL	_MotRun
    0966E E088      LDI	R24,0x8
    0966F 9380 08EB STS	PacketState+235,R24
    09671 C0AF      RJMP	0x9721
    09672 E003      LDI	R16,3
(0458) 	if(tmp > AdcResult[adc_change])
    09673 940E 6A0C CALL	_GetMotState
    09675 2F40      MOV	R20,R16
    09676 3001      CPI	R16,1
    09677 F4B9      BNE	0x968F
    09678 9180 00C1 LDS	R24,0xC1
    0967A 7E8F      ANDI	R24,0xEF
    0967B 9380 00C1 STS	0xC1,R24
    0967D E825      LDI	R18,0x85
    0967E E134      LDI	R19,0x14
    0967F E50A      LDI	R16,0x5A
    09680 E019      LDI	R17,0x9
    09681 940E A90D CALL	_uart_Printf
(0459) 	{
(0460) 		AdcResult[adc_change] ++;
    09683 9180 00C1 LDS	R24,0xC1
    09685 6180      ORI	R24,0x10
    09686 9380 00C1 STS	0xC1,R24
    09688 E083      LDI	R24,3
    09689 9380 08EA STS	PacketState+234,R24
    0968B 2422      CLR	R2
    0968C 9220 08EB STS	PacketState+235,R2
    0968E C092      RJMP	0x9721
    0968F 2700      CLR	R16
(0461) 	}
    09690 940E 9A52 CALL	_getLiqDetADC
(0462) 	else if(tmp < AdcResult[adc_change])
    09692 0168      MOVW	R12,R16
    09693 0156      MOVW	R10,R12
    09694 9020 17D9 LDS	R2,ControlModel+1
    09696 9030 17DA LDS	R3,ControlModel+2
    09698 1502      CP	R16,R2
    09699 0513      CPC	R17,R3
    0969A F008      BCS	0x969C
    0969B C085      RJMP	0x9721
    0969C 1A20      SUB	R2,R16
    0969D 0A31      SBC	R3,R17
    0969E 0151      MOVW	R10,R2
    0969F EC88      LDI	R24,0xC8
(0463) 	{
(0464) 		AdcResult[adc_change] --;
    096A0 E090      LDI	R25,0
    096A1 1582      CP	R24,R2
    096A2 0593      CPC	R25,R3
    096A3 F008      BCS	0x96A5
    096A4 C07C      RJMP	0x9721
    096A5 E003      LDI	R16,3
    096A6 940E 6A13 CALL	_MotStop
    096A8 E228      LDI	R18,0x28
    096A9 E030      LDI	R19,0
    096AA E003      LDI	R16,3
    096AB 940E 6A2C CALL	_MotRun
    096AD E086      LDI	R24,6
(0465) 	}
(0466) 	adc_change++;
    096AE 838A      STD	Y+2,R24
    096AF E082      LDI	R24,2
    096B0 8388      ST	Y,R24
    096B1 E220      LDI	R18,0x20
    096B2 E00C      LDI	R16,0xC
    096B3 940E 6A9F CALL	_SetMotRunPam
    096B5 E00C      LDI	R16,0xC
    096B6 940E 6AFA CALL	_MotInitCheck
(0467) 	if(adc_change > 2)
    096B8 E081      LDI	R24,1
    096B9 9380 08ED STS	PacketState+237,R24
    096BB 9380 08EF STS	PacketState+239,R24
    096BD 2422      CLR	R2
    096BE 9220 08EB STS	PacketState+235,R2
(0468) 		adc_change = 0;
    096C0 9380 08EA STS	PacketState+234,R24
    096C2 C05E      RJMP	0x9721
    096C3 9140 08EB LDS	R20,PacketState+235
    096C5 2755      CLR	R21
(0469) 	SetNextADChannel(adc_change);
    096C6 3040      CPI	R20,0
    096C7 0745      CPC	R20,R21
    096C8 F049      BEQ	0x96D2
    096C9 3041      CPI	R20,1
    096CA E0E0      LDI	R30,0
    096CB 075E      CPC	R21,R30
    096CC F129      BEQ	0x96F2
    096CD 3042      CPI	R20,2
    096CE E0E0      LDI	R30,0
    096CF 075E      CPC	R21,R30
    096D0 F1A9      BEQ	0x9706
    096D1 C04F      RJMP	0x9721
    096D2 E083      LDI	R24,3
    096D3 838A      STD	Y+2,R24
    096D4 E184      LDI	R24,0x14
    096D5 8388      ST	Y,R24
    096D6 EF20      LDI	R18,0xF0
    096D7 E003      LDI	R16,3
    096D8 940E 6A9F CALL	_SetMotRunPam
    096DA 2722      CLR	R18
    096DB 2733      CLR	R19
    096DC E003      LDI	R16,3
    096DD 940E 6A5B CALL	_MotRunTo
    096DF E084      LDI	R24,4
    096E0 838A      STD	Y+2,R24
    096E1 E082      LDI	R24,2
    096E2 8388      ST	Y,R24
    096E3 EF20      LDI	R18,0xF0
(0470) }
(0471) 
(0472) //call this routine to initialize all peripherals
(0473) void init_devices(void){
(0474) 	//stop errant interrupts until set up
(0475) 	CLI(); //disable all interrupts
_init_devices:
    096E4 E00B      LDI	R16,0xB
(0476) //	XMCRA = 0x98; //external memory
(0477) //	XMCRB = 0x00; //external memory
(0478) 	uartDataInit();
    096E5 940E 6A9F CALL	_SetMotRunPam
(0479) 	port_init();
    096E7 ED2C      LDI	R18,0xDC
(0480) 	timer0_init();
(0481) 	timer1_init();
    096E8 E035      LDI	R19,5
(0482) 	timer4_init();
    096E9 E00B      LDI	R16,0xB
(0483) 	timer5_init();
    096EA 940E 6A2C CALL	_MotRun
(0484) 	uart0_init();
    096EC E081      LDI	R24,1
(0485) //	uart1_init();
(0486) 	uart2_init();
(0487) //	uart3_init();
(0488) 	adc_init();
    096ED 9380 08EF STS	PacketState+239,R24
(0489) 	TWI_Init();
    096EF 9380 08EB STS	PacketState+235,R24
(0490) 
(0491) 	MCUCR  = 0x00;
    096F1 C02F      RJMP	0x9721
(0492) 	EICRA  = 0x00; //pin change int edge 0:3
    096F2 E084      LDI	R24,4
    096F3 838A      STD	Y+2,R24
(0493) 	EICRB  = 0x00; //pin change int edge 4:7
    096F4 E184      LDI	R24,0x14
    096F5 8388      ST	Y,R24
(0494) 	// PCICR  = 0x04; //pin change int enable
(0495) 	PCMSK0 = 0x00; //pin change mask
    096F6 E220      LDI	R18,0x20
    096F7 E002      LDI	R16,2
(0496) 	PCMSK1 = 0x00; //pin change mask
    096F8 940E 6A9F CALL	_SetMotRunPam
(0497) 	PCMSK2 = 0x00; //pin change mask
    096FA 2722      CLR	R18
    096FB 2733      CLR	R19
(0498) 	EIMSK  = 0x00;
    096FC E002      LDI	R16,2
(0499) 	TIMSK0 = 0x01; //timer0 interrupt sources
    096FD 940E 6A5B CALL	_MotRunTo
    096FF E081      LDI	R24,1
(0500) 	TIMSK1 = 0x01; //timer1 interrupt sources
    09700 9380 08EE STS	PacketState+238,R24
(0501) 	TIMSK2 = 0x00; //timer2 interrupt sources
    09702 E082      LDI	R24,2
    09703 9380 08EB STS	PacketState+235,R24
(0502) 	TIMSK3 = 0x00; //timer3 interrupt sources
    09705 C01B      RJMP	0x9721
(0503) 	TIMSK4 = 0x00; //timer4 interrupt sources
    09706 2422      CLR	R2
    09707 9220 08EA STS	PacketState+234,R2
(0504) 	TIMSK5 = 0x00; //timer5 interrupt sources
    09709 9220 08EB STS	PacketState+235,R2
(0505) 	PRR0   = 0x00;
    0970B 9220 08F2 STS	PacketState+242,R2
(0506) 	PRR1   = 0x00;
    0970D 9220 17E0 STS	ControlModel+8,R2
(0507)  
(0508) 	SEI(); //re-enable interrupts
    0970F 9180 00C1 LDS	R24,0xC1
(0509) 	//all peripherals are now initialized
(0510) }
(0511) 
(0512) ///////////////// Uart1 buffer /////////////////////
(0513) void uartDataInit(void){
(0514) 	unsigned int i;
(0515) 	unsigned char *p0, *p1;
(0516) 
(0517) 	p0 = (unsigned char *)(&uart0RxdBuf);
    09711 7E8F      ANDI	R24,0xEF
(0518) 	for(i=0; i<sizeof(UARTBUF_RXD); i++){
    09712 9380 00C1 STS	0xC1,R24
    09714 EE29      LDI	R18,0xE9
(0519) 		*(p0++) = 0;
    09715 E139      LDI	R19,0x19
    09716 E50A      LDI	R16,0x5A
    09717 E019      LDI	R17,0x9
    09718 940E A90D CALL	_uart_Printf
    0971A 9180 00C1 LDS	R24,0xC1
    0971C 6180      ORI	R24,0x10
    0971D 9380 00C1 STS	0xC1,R24
(0520) 		}
(0521) 	p0 = (unsigned char *)(&uart0TxdBuf);
    0971F E001      LDI	R16,1
    09720 C001      RJMP	0x9722
(0522) 	for(i=0; i<sizeof(UARTBUF_TXD); i++){
    09721 2700      CLR	R16
    09722 9623      ADIW	R28,3
    09723 940C AEAC JMP	pop_xgset303C
(0523) 		*(p0++) = 0;
_port_init:
    09725 2422      CLR	R2
    09726 B822      OUT	0x02,R2
    09727 B821      OUT	0x01,R2
    09728 E880      LDI	R24,0x80
    09729 B985      OUT	0x05,R24
    0972A B824      OUT	0x04,R2
    0972B B828      OUT	0x08,R2
    0972C B827      OUT	0x07,R2
    0972D EF8F      LDI	R24,0xFF
(0524) 		}
(0525) 	uart0TxdBuf.remanentLen = UARTBUF_TXD_LEN-1;
    0972E B98B      OUT	0x0B,R24
    0972F E880      LDI	R24,0x80
    09730 B98A      OUT	0x0A,R24
    09731 E383      LDI	R24,0x33
    09732 B98E      OUT	0x0E,R24
    09733 E382      LDI	R24,0x32
    09734 B98D      OUT	0x0D,R24
_uart0DataReceive:
  i                    --> Y,+1
  dat                  --> R20
    09735 BA21      OUT	0x11,R2
    09736 E083      LDI	R24,3
    09737 BB80      OUT	0x10,R24
(0526) }
(0527) 
(0528) // 0x15(NAK),	0x06(ACK),	0x02(STX),	0x03(ETX)
(0529) static unsigned char PacketState=0;
(0530) //static unsigned char UartReceiveBuf[60];	// 从主机接收串口接收缓存
(0531) unsigned char UartReceiveBuf[60];
(0532) static unsigned char PRecBuf;
(0533) static unsigned char WaitAnswer;
(0534) void CommandExplain(unsigned char c);
(0535) 
(0536) void uart0DataReceive(unsigned char dat)
(0537) {
(0538) 	unsigned char i;
(0539) 	static unsigned char checkSum,	checkLB, checkHB;	// 校验和
(0540) 	switch(PacketState)
    09738 BA24      OUT	0x14,R2
    09739 BA23      OUT	0x13,R2
    0973A 9380 0102 STS	0x102,R24
    0973C E08C      LDI	R24,0xC
    0973D 9380 0101 STS	0x101,R24
    0973F E083      LDI	R24,3
    09740 9380 0105 STS	0x105,R24
    09742 E08C      LDI	R24,0xC
    09743 9380 0104 STS	0x104,R24
    09745 E08F      LDI	R24,0xF
    09746 9380 0108 STS	0x108,R24
    09748 9220 0107 STS	0x107,R2
    0974A 9220 010B STS	0x10B,R2
    0974C 9220 010A STS	0x10A,R2
    0974E 9508      RET
_timer0_init:
    0974F 2422      CLR	R2
    09750 BC25      OUT	0x25,R2
    09751 E88D      LDI	R24,0x8D
    09752 BD86      OUT	0x26,R24
    09753 EC86      LDI	R24,0xC6
    09754 BD87      OUT	0x27,R24
    09755 E480      LDI	R24,0x40
    09756 BD84      OUT	0x24,R24
    09757 E083      LDI	R24,3
    09758 BD85      OUT	0x25,R24
    09759 9508      RET
_timer0_ovf_isr:
    0975A 920A      ST	-Y,R0
    0975B 921A      ST	-Y,R1
    0975C 922A      ST	-Y,R2
    0975D 923A      ST	-Y,R3
    0975E 924A      ST	-Y,R4
    0975F 925A      ST	-Y,R5
    09760 926A      ST	-Y,R6
    09761 927A      ST	-Y,R7
(0541) 	{
(0542) 		case 0:
(0543) 			if(WaitAnswer)
    09762 928A      ST	-Y,R8
    09763 929A      ST	-Y,R9
    09764 930A      ST	-Y,R16
    09765 931A      ST	-Y,R17
(0544) 			{
(0545) 				if(dat == ACK)
    09766 932A      ST	-Y,R18
    09767 933A      ST	-Y,R19
(0546) 				{
(0547) 					WaitAnswer = 0;
    09768 938A      ST	-Y,R24
    09769 939A      ST	-Y,R25
    0976A 93AA      ST	-Y,R26
(0548) 					PacketState = 13;
    0976B 93BA      ST	-Y,R27
    0976C 93EA      ST	-Y,R30
    0976D 93FA      ST	-Y,R31
(0549) 				}
    0976E B60F      IN	R0,0x3F
(0550) 				else
(0551) 				{	
(0552) 					uart0SendChar(0x0F);	// 等待ACK过程中,接收到非ACK命令
    0976F 920A      ST	-Y,R0
    09770 940E 1471 CALL	_SendCommandData
(0553) 					WaitAnswer = 0;
    09772 D54C      RCALL	_uart0Transfer
    09773 940E 1775 CALL	_SendInfoEvent
(0554) 				}
(0555) 				break;
    09775 940E 3773 CALL	_Beep
(0556) 			}
(0557) 			else
(0558) 			{
(0559) 				if(dat == STX)
(0560) 				{
(0561) 					PacketState = 2;
    09777 E88D      LDI	R24,0x8D
    09778 BD86      OUT	0x26,R24
    09779 9009      LD	R0,Y+
(0562) 					checkSum = 0;
    0977A BE0F      OUT	0x3F,R0
    0977B 91F9      LD	R31,Y+
    0977C 91E9      LD	R30,Y+
(0563) 					PRecBuf = 0;
    0977D 91B9      LD	R27,Y+
    0977E 91A9      LD	R26,Y+
(0564) 					UartReceiveBuf[PRecBuf] = STX;
    0977F 9199      LD	R25,Y+
    09780 9189      LD	R24,Y+
    09781 9139      LD	R19,Y+
    09782 9129      LD	R18,Y+
    09783 9119      LD	R17,Y+
    09784 9109      LD	R16,Y+
    09785 9099      LD	R9,Y+
    09786 9089      LD	R8,Y+
(0565) 					CommandExplain(0x0d);	// 结束当前命令	
    09787 9079      LD	R7,Y+
    09788 9069      LD	R6,Y+
    09789 9059      LD	R5,Y+
(0566) 					break;
    0978A 9049      LD	R4,Y+
(0567) 				}
(0568) 				if(dat < 128)
    0978B 9039      LD	R3,Y+
    0978C 9029      LD	R2,Y+
    0978D 9019      LD	R1,Y+
(0569) 					CommandExplain(dat);	// 命令解析
    0978E 9009      LD	R0,Y+
    0978F 9518      RETI
_timer1_init:
    09790 2422      CLR	R2
(0570) 			}
(0571) 			break;
    09791 9220 0081 STS	0x81,R2
(0572) 		case 1:
(0573) 			if(dat == STX)
    09793 EE89      LDI	R24,0xE9
    09794 9380 0085 STS	0x85,R24
(0574) 			{
(0575) 				PacketState = 2;
    09796 E881      LDI	R24,0x81
    09797 9380 0084 STS	0x84,R24
(0576) 				checkSum = 0;
    09799 E186      LDI	R24,0x16
    0979A 9380 0089 STS	0x89,R24
(0577) 				PRecBuf = 0;
    0979C E78F      LDI	R24,0x7F
(0578) 				UartReceiveBuf[PRecBuf] = STX;
    0979D 9380 0088 STS	0x88,R24
    0979F E186      LDI	R24,0x16
    097A0 9380 008B STS	0x8B,R24
    097A2 E78F      LDI	R24,0x7F
    097A3 9380 008A STS	0x8A,R24
(0579) 				CommandExplain(0x0d);	// 结束当前命令	
    097A5 9220 008D STS	0x8D,R2
    097A7 9220 008C STS	0x8C,R2
(0580) 			}
(0581) 			break;
    097A9 E186      LDI	R24,0x16
    097AA 9380 0087 STS	0x87,R24
(0582) 		case 2:			// 本机接收数据包状态
(0583) 			if(dat == ETX)
(0584) 			{
(0585) 				PRecBuf ++;
    097AC E78F      LDI	R24,0x7F
    097AD 9380 0086 STS	0x86,R24
    097AF 9220 0080 STS	0x80,R2
(0586) 				UartReceiveBuf[PRecBuf] = ETX;
    097B1 9220 0082 STS	0x82,R2
    097B3 E084      LDI	R24,4
    097B4 9380 0081 STS	0x81,R24
    097B6 9508      RET
_SetDelayTime:
    097B7 E08F      LDI	R24,0xF
    097B8 1780      CP	R24,R16
(0587) 				PacketState = 10;
    097B9 F408      BCC	0x97BB
    097BA C00A      RJMP	0x97C5
    097BB E586      LDI	R24,0x56
(0588) 			}
    097BC E198      LDI	R25,0x18
(0589) 			else if(dat == STX)		// 重新开始接收
    097BD 2FE0      MOV	R30,R16
    097BE 27FF      CLR	R31
(0590) 			{
(0591) 				checkSum = 0;
    097BF 0FEE      LSL	R30
    097C0 1FFF      ROL	R31
    097C1 0FE8      ADD	R30,R24
(0592) 				PRecBuf = 0;
    097C2 1FF9      ADC	R31,R25
    097C3 8331      STD	Z+1,R19
(0593) 				UartReceiveBuf[PRecBuf] = STX;
    097C4 8320      ST	Z,R18
    097C5 9508      RET
_WaitDelayTime:
    097C6 E08F      LDI	R24,0xF
    097C7 1780      CP	R24,R16
    097C8 F410      BCC	0x97CB
    097C9 2700      CLR	R16
    097CA C011      RJMP	0x97DC
    097CB E586      LDI	R24,0x56
(0594) 				CommandExplain(0x0d);	// 结束当前命令	
    097CC E198      LDI	R25,0x18
    097CD 2FE0      MOV	R30,R16
    097CE 27FF      CLR	R31
(0595) 				break;
    097CF 0FEE      LSL	R30
(0596) 			}
(0597) 			else 				// 接收数据
(0598) 			{
(0599) 				PRecBuf ++;
    097D0 1FFF      ROL	R31
    097D1 0FE8      ADD	R30,R24
    097D2 1FF9      ADC	R31,R25
    097D3 8020      LD	R2,Z
    097D4 8031      LDD	R3,Z+1
(0600) 				UartReceiveBuf[PRecBuf] = dat;
    097D5 2022      TST	R2
    097D6 F421      BNE	0x97DB
    097D7 2033      TST	R3
    097D8 F411      BNE	0x97DB
    097D9 2700      CLR	R16
    097DA C001      RJMP	0x97DC
    097DB E001      LDI	R16,1
    097DC 9508      RET
(0601) 				checkSum += dat;
_timer1_ovf_isr:
    097DD 920A      ST	-Y,R0
    097DE 921A      ST	-Y,R1
    097DF 922A      ST	-Y,R2
    097E0 923A      ST	-Y,R3
    097E1 924A      ST	-Y,R4
(0602) 			}
(0603) 			break;
    097E2 925A      ST	-Y,R5
(0604) 		case 10:	// 接收第一字节校验
(0605) 			PRecBuf ++;
    097E3 926A      ST	-Y,R6
    097E4 927A      ST	-Y,R7
    097E5 928A      ST	-Y,R8
    097E6 929A      ST	-Y,R9
    097E7 930A      ST	-Y,R16
(0606) 			UartReceiveBuf[PRecBuf] = dat;
    097E8 931A      ST	-Y,R17
    097E9 932A      ST	-Y,R18
    097EA 933A      ST	-Y,R19
    097EB 938A      ST	-Y,R24
    097EC 939A      ST	-Y,R25
    097ED 93AA      ST	-Y,R26
    097EE 93BA      ST	-Y,R27
    097EF 93EA      ST	-Y,R30
(0607) 			checkLB = dat - 'A';
    097F0 93FA      ST	-Y,R31
    097F1 B60F      IN	R0,0x3F
    097F2 920A      ST	-Y,R0
    097F3 940E AE83 CALL	push_xgset300C
(0608) 			PacketState = 11;
    097F5 EE89      LDI	R24,0xE9
    097F6 9380 0085 STS	0x85,R24
(0609) 			break;
    097F8 E881      LDI	R24,0x81
    097F9 9380 0084 STS	0x84,R24
    097FB 2744      CLR	R20
(0610) 		case 11:	// 接收第二字节校验
(0611) 			checkHB = dat - 'A';
(0612) 			checkHB <<= 4;
    097FC C01B      RJMP	0x9818
    097FD E586      LDI	R24,0x56
    097FE E198      LDI	R25,0x18
    097FF 2FE4      MOV	R30,R20
(0613) 			PRecBuf ++;
    09800 27FF      CLR	R31
    09801 0FEE      LSL	R30
    09802 1FFF      ROL	R31
    09803 0FE8      ADD	R30,R24
    09804 1FF9      ADC	R31,R25
(0614) 			UartReceiveBuf[PRecBuf] = dat;
    09805 8020      LD	R2,Z
    09806 8031      LDD	R3,Z+1
    09807 2022      TST	R2
    09808 F411      BNE	0x980B
    09809 2033      TST	R3
    0980A F061      BEQ	0x9817
    0980B 2E24      MOV	R2,R20
    0980C 2433      CLR	R3
(0615) 			UartReceiveBuf[PRecBuf + 1] = 0;
    0980D 0C22      LSL	R2
    0980E 1C33      ROL	R3
    0980F 0E28      ADD	R2,R24
    09810 1E39      ADC	R3,R25
    09811 01F1      MOVW	R30,R2
    09812 8180      LD	R24,Z
    09813 8191      LDD	R25,Z+1
    09814 9701      SBIW	R24,1
    09815 8391      STD	Z+1,R25
(0616) 			if(checkSum == checkLB + checkHB)
    09816 8380      ST	Z,R24
    09817 9543      INC	R20
    09818 3140      CPI	R20,0x10
    09819 F318      BCS	0x97FD
    0981A 9180 17E1 LDS	R24,ControlModel+9
    0981C 5F8F      SUBI	R24,0xFF
    0981D 9380 17E1 STS	ControlModel+9,R24
(0617) 			{
(0618) 				uart0SendChar(ACK);
    0981F 9180 17E2 LDS	R24,ControlModel+10
(0619) 				PacketState = 12;
    09821 5F8F      SUBI	R24,0xFF
    09822 9380 17E2 STS	ControlModel+10,R24
(0620) 				PRecBuf = 0;
    09824 E089      LDI	R24,0x9
    09825 9020 17E1 LDS	R2,ControlModel+9
(0621) 			}
    09827 1582      CP	R24,R2
(0622) 			else
(0623) 			{
(0624) 				PacketState = 14; //PacketState = 1;
    09828 F508      BCC	0x984A
    09829 E081      LDI	R24,1
    0982A E090      LDI	R25,0
(0625) 				PRecBuf = 0;
    0982B E0A0      LDI	R26,0
    0982C E0B0      LDI	R27,0
    0982D 9040 0529 LDS	R4,SecondCount+2
(0626) 			}
(0627) 			break;
    0982F 9050 052A LDS	R5,SecondCount+3
(0628) 		case 12:	// 处理接收到的数据，放到数据发送定时处理函数中处理
(0629) 		case 13:
(0630) 		case 14:
(0631) 			uart0SendChar(0X0E);
(0632) 			break;
(0633) 		default:
(0634) 			break;
    09831 9020 0527 LDS	R2,SecondCount
_uart0Transfer:
  c                    --> R20
  pEnd                 --> R10
  pTop                 --> R22
    09833 9030 0528 LDS	R3,SecondCount+1
(0635) 	}
(0636) }
(0637) 
(0638) void uart0Transfer(void)
(0639) {
(0640) // 串口0发送1字节数据
(0641) 	//static unsigned int  pTextStart;	// 数据包起始指针
(0642) 	//static unsigned int  pTransfer;	// 数据发送指针
(0643) 	//static unsigned char checkSum,	checkLB, checkHB;	// 校验和
(0644) 	//static unsigned char reTransferCnt;	// 重发计数
(0645) 	unsigned int pTop, pEnd;
(0646) 	unsigned char c;
(0647) 	static unsigned int timeOut;
(0648) 	if(uartBufProtect )		// 发送缓存保护
    09835 0E28      ADD	R2,R24
    09836 1E39      ADC	R3,R25
    09837 1E4A      ADC	R4,R26
    09838 1E5B      ADC	R5,R27
(0649) 		return;
    09839 9230 0528 STS	SecondCount+1,R3
(0650) 	switch(PacketState){
    0983B 9220 0527 STS	SecondCount,R2
    0983D 9250 052A STS	SecondCount+3,R5
    0983F 9240 0529 STS	SecondCount+2,R4
    09841 2422      CLR	R2
    09842 9220 17E1 STS	ControlModel+9,R2
    09844 940E A99B CALL	_GetwasteCardState
    09846 2300      TST	R16
    09847 F411      BNE	0x984A
    09848 940E ACDA CALL	_TrashCanMonitor
    0984A E084      LDI	R24,4
    0984B 9020 17E2 LDS	R2,ControlModel+10
    0984D 1582      CP	R24,R2
    0984E F450      BCC	0x9859
    0984F 2422      CLR	R2
    09850 9220 17E2 STS	ControlModel+10,R2
    09852 E880      LDI	R24,0x80
    09853 E090      LDI	R25,0
    09854 B02B      IN	R2,0x0B
    09855 2433      CLR	R3
    09856 2628      EOR	R2,R24
    09857 2639      EOR	R3,R25
    09858 B82B      OUT	0x0B,R2
    09859 940E AE88 CALL	pop_xgset300C
(0651) 		case 0:		// 普通模式
(0652) 			pTop = uart0TxdBuf.pHead;
    0985B 9009      LD	R0,Y+
    0985C BE0F      OUT	0x3F,R0
    0985D 91F9      LD	R31,Y+
(0653) 			pEnd = uart0TxdBuf.pEnd;
    0985E 91E9      LD	R30,Y+
    0985F 91B9      LD	R27,Y+
    09860 91A9      LD	R26,Y+
    09861 9199      LD	R25,Y+
(0654) 			if(pTop != pEnd)
    09862 9189      LD	R24,Y+
    09863 9139      LD	R19,Y+
    09864 9129      LD	R18,Y+
(0655) 			{
(0656) 				if(UCSR0A & 0x20 )
    09865 9119      LD	R17,Y+
    09866 9109      LD	R16,Y+
    09867 9099      LD	R9,Y+
    09868 9089      LD	R8,Y+
(0657) 				{
(0658) 					c = uart0TxdBuf.buffer[pTop];
    09869 9079      LD	R7,Y+
    0986A 9069      LD	R6,Y+
    0986B 9059      LD	R5,Y+
    0986C 9049      LD	R4,Y+
    0986D 9039      LD	R3,Y+
    0986E 9029      LD	R2,Y+
(0659) 					//if((c != STX) && (c!= ETX))		
(0660) 						UDR0 = c;
    0986F 9019      LD	R1,Y+
    09870 9009      LD	R0,Y+
(0661) 					pTop ++;
    09871 9518      RETI
_timer4_init:
    09872 2422      CLR	R2
(0662) 					if(pTop == UARTBUF_TXD_LEN)
    09873 9220 00A1 STS	0xA1,R2
    09875 EF8C      LDI	R24,0xFC
    09876 9380 00A5 STS	0xA5,R24
(0663) 						pTop = 0;
    09878 E081      LDI	R24,1
(0664) 					uart0TxdBuf.pHead = pTop;
    09879 9380 00A4 STS	0xA4,R24
    0987B E083      LDI	R24,3
    0987C 9380 00A9 STS	0xA9,R24
(0665) 				}
(0666) 			}
(0667) 			
(0668) 			// ACK 超时等待
(0669) 			if(WaitAnswer == 1)
    0987E EF8F      LDI	R24,0xFF
    0987F 9380 00A8 STS	0xA8,R24
(0670) 			{
(0671) 				timeOut++;
    09881 E083      LDI	R24,3
    09882 9380 00AB STS	0xAB,R24
    09884 EF8F      LDI	R24,0xFF
    09885 9380 00AA STS	0xAA,R24
    09887 E083      LDI	R24,3
    09888 9380 00AD STS	0xAD,R24
(0672) 				//if(timeOut > 800)	// 0.5 * 800  -> 400ms
(0673) 				//if(timeOut > 2000)	
(0674) 				if(timeOut > 6000)	
    0988A EF8F      LDI	R24,0xFF
    0988B 9380 00AC STS	0xAC,R24
    0988D E083      LDI	R24,3
    0988E 9380 00A7 STS	0xA7,R24
    09890 EF8F      LDI	R24,0xFF
    09891 9380 00A6 STS	0xA6,R24
    09893 E28B      LDI	R24,0x2B
(0675) 				{
(0676) 					timeOut = 0;
    09894 9380 00A0 STS	0xA0,R24
    09896 9220 00A2 STS	0xA2,R2
    09898 E089      LDI	R24,0x9
    09899 9380 00A1 STS	0xA1,R24
(0677) 					WaitAnswer = 0;
    0989B 9508      RET
(0678) 					Uart0ReUnable;
_timer5_init:
    0989C 2422      CLR	R2
    0989D 9220 0121 STS	0x121,R2
    0989F EF8C      LDI	R24,0xFC
    098A0 9380 0125 STS	0x125,R24
(0679) 					uart_Printf("*3344 WaitAckOutOfTime\r\n");	
    098A2 E081      LDI	R24,1
    098A3 9380 0124 STS	0x124,R24
(0680) 					Uart0ReEnable;
    098A5 E083      LDI	R24,3
    098A6 9380 0129 STS	0x129,R24
    098A8 EF8F      LDI	R24,0xFF
    098A9 9380 0128 STS	0x128,R24
(0681) 				}
(0682) 			}
    098AB E083      LDI	R24,3
    098AC 9380 012B STS	0x12B,R24
    098AE EF8F      LDI	R24,0xFF
    098AF 9380 012A STS	0x12A,R24
(0683) 			else
(0684) 			{
(0685) 				timeOut = 0;
(0686) 			}
(0687) 			break;	
    098B1 E083      LDI	R24,3
(0688) 		case 1:		// 空闲,数据包未开始
(0689) 			pTop = uart0TxdBuf.pHead;
    098B2 9380 012D STS	0x12D,R24
    098B4 EF8F      LDI	R24,0xFF
    098B5 9380 012C STS	0x12C,R24
(0690) 			pEnd = uart0TxdBuf.pEnd;
    098B7 E083      LDI	R24,3
    098B8 9380 0127 STS	0x127,R24
(0691) 			if(pTop != pEnd)
    098BA EF8F      LDI	R24,0xFF
    098BB 9380 0126 STS	0x126,R24
    098BD E28B      LDI	R24,0x2B
(0692) 			{
(0693) 				if(UCSR0A & 0x20)
    098BE 9380 0120 STS	0x120,R24
    098C0 9220 0122 STS	0x122,R2
(0694) 				{
(0695) 					c = uart0TxdBuf.buffer[pTop];
    098C2 E089      LDI	R24,0x9
    098C3 9380 0121 STS	0x121,R24
    098C5 9508      RET
_uart0_init:
    098C6 2422      CLR	R2
    098C7 9220 00C1 STS	0xC1,R2
(0696) 					UDR0 = c;
    098C9 9220 00C0 STS	0xC0,R2
(0697) 					pTop ++;
    098CB E086      LDI	R24,6
(0698) 					if(pTop == UARTBUF_TXD_LEN)
    098CC 9380 00C2 STS	0xC2,R24
    098CE E08F      LDI	R24,0xF
    098CF 9380 00C4 STS	0xC4,R24
(0699) 						pTop = 0;
    098D1 9220 00C5 STS	0xC5,R2
(0700) 					uart0TxdBuf.pHead = pTop;
    098D3 E988      LDI	R24,0x98
    098D4 9380 00C1 STS	0xC1,R24
(0701) 					if(c == 0x0d)	// 数据包结束
    098D6 9508      RET
_HexToBin:
    098D7 934A      ST	-Y,R20
    098D8 935A      ST	-Y,R21
(0702) 					{
(0703) 						PacketState = 0;
    098D9 2744      CLR	R20
    098DA 3300      CPI	R16,0x30
    098DB F028      BCS	0x98E1
(0704) 						break;
    098DC E389      LDI	R24,0x39
(0705) 					}
(0706) 				}
(0707) 			}
(0708) 			break;
(0709) 		case 12:
(0710) 			if(UartReceiveBuf[PRecBuf] != 0)
    098DD 1780      CP	R24,R16
    098DE F010      BCS	0x98E1
    098DF 2F40      MOV	R20,R16
    098E0 5340      SUBI	R20,0x30
    098E1 3601      CPI	R16,0x61
    098E2 F030      BCS	0x98E9
    098E3 E686      LDI	R24,0x66
    098E4 1780      CP	R24,R16
    098E5 F018      BCS	0x98E9
    098E6 2F40      MOV	R20,R16
(0711) 			{
(0712) 				uart0SendChar(UartReceiveBuf[PRecBuf]);
    098E7 5641      SUBI	R20,0x61
    098E8 5F46      SUBI	R20,0xF6
    098E9 3401      CPI	R16,0x41
    098EA F030      BCS	0x98F1
    098EB E486      LDI	R24,0x46
    098EC 1780      CP	R24,R16
    098ED F018      BCS	0x98F1
(0713) 				PRecBuf++;
    098EE 2F40      MOV	R20,R16
    098EF 5441      SUBI	R20,0x41
    098F0 5F46      SUBI	R20,0xF6
    098F1 2F04      MOV	R16,R20
    098F2 9159      LD	R21,Y+
(0714) 			}
    098F3 9149      LD	R20,Y+
(0715) 			else
(0716) 			{
(0717) 				uart0SendChar('\r');
    098F4 9508      RET
_uart0_rx_isr:
    098F5 920A      ST	-Y,R0
(0718) 				uart0SendChar('\n');
    098F6 921A      ST	-Y,R1
    098F7 922A      ST	-Y,R2
(0719) 				PRecBuf = 0;
    098F8 923A      ST	-Y,R3
    098F9 924A      ST	-Y,R4
    098FA 925A      ST	-Y,R5
(0720) 				WaitAnswer = 1;
    098FB 926A      ST	-Y,R6
    098FC 927A      ST	-Y,R7
    098FD 928A      ST	-Y,R8
(0721) 				PacketState = 0;
    098FE 929A      ST	-Y,R9
    098FF 930A      ST	-Y,R16
(0722) 				
(0723) 			}
(0724) 			break;
    09900 931A      ST	-Y,R17
(0725) 		case 13:
(0726) 			if(UartReceiveBuf[PRecBuf] != 0)
    09901 932A      ST	-Y,R18
    09902 933A      ST	-Y,R19
    09903 938A      ST	-Y,R24
    09904 939A      ST	-Y,R25
    09905 93AA      ST	-Y,R26
    09906 93BA      ST	-Y,R27
    09907 93EA      ST	-Y,R30
    09908 93FA      ST	-Y,R31
    09909 B60F      IN	R0,0x3F
    0990A 920A      ST	-Y,R0
(0727) 			{
(0728) 				checkFlag = 1;
    0990B 92AA      ST	-Y,R10
    0990C 90A0 00C6 LDS	R10,0xC6
(0729) 				CommandExplain(UartReceiveBuf[PRecBuf]);	// 命令解析
    0990E 2D0A      MOV	R16,R10
    0990F D2B1      RCALL	_uart0DataReceive
    09910 90A9      LD	R10,Y+
    09911 9009      LD	R0,Y+
    09912 BE0F      OUT	0x3F,R0
    09913 91F9      LD	R31,Y+
    09914 91E9      LD	R30,Y+
    09915 91B9      LD	R27,Y+
    09916 91A9      LD	R26,Y+
    09917 9199      LD	R25,Y+
(0730) 				PRecBuf ++;
    09918 9189      LD	R24,Y+
    09919 9139      LD	R19,Y+
    0991A 9129      LD	R18,Y+
    0991B 9119      LD	R17,Y+
    0991C 9109      LD	R16,Y+
(0731) 			}
    0991D 9099      LD	R9,Y+
(0732) 			else
(0733) 			{
(0734) 				checkFlag = 0;
    0991E 9089      LD	R8,Y+
    0991F 9079      LD	R7,Y+
    09920 9069      LD	R6,Y+
(0735) 				PRecBuf = 0;
    09921 9059      LD	R5,Y+
    09922 9049      LD	R4,Y+
(0736) 				PacketState = 0;
    09923 9039      LD	R3,Y+
    09924 9029      LD	R2,Y+
(0737) 			}
(0738) 			break;
    09925 9019      LD	R1,Y+
(0739) 		case 14:
(0740) 			if(UartReceiveBuf[PRecBuf] != 0)
    09926 9009      LD	R0,Y+
    09927 9518      RETI
_uart0_tx_isr:
    09928 9518      RETI
_uart1_init:
    09929 2422      CLR	R2
    0992A 9220 00C9 STS	0xC9,R2
    0992C 9220 00C8 STS	0xC8,R2
    0992E E086      LDI	R24,6
    0992F 9380 00CA STS	0xCA,R24
(0741) 			{
(0742) 				uart0SendChar(UartReceiveBuf[PRecBuf]);
    09931 E58F      LDI	R24,0x5F
    09932 9380 00CC STS	0xCC,R24
    09934 9220 00CD STS	0xCD,R2
    09936 E988      LDI	R24,0x98
(0743) 				PRecBuf++;
    09937 9380 00C9 STS	0xC9,R24
    09939 9508      RET
_uart1_rx_isr:
    0993A 9518      RETI
_uart2_init:
    0993B 2422      CLR	R2
(0744) 			}
    0993C 9220 00D1 STS	0xD1,R2
(0745) 			else
(0746) 			{
(0747) 				uart0SendChar('\r');
    0993E 9220 00D0 STS	0xD0,R2
(0748) 				uart0SendChar('\n');
    09940 E086      LDI	R24,6
(0749) 				uart0SendChar(NAK);
    09941 9380 00D2 STS	0xD2,R24
(0750) 				PRecBuf = 0;
    09943 E087      LDI	R24,7
    09944 9380 00D4 STS	0xD4,R24
(0751) 				PacketState = 0;
    09946 9220 00D5 STS	0xD5,R2
(0752) 			}
(0753) 			break;
(0754) 		default:
(0755) 			break;
    09948 ED8C      LDI	R24,0xDC
    09949 9380 00D1 STS	0xD1,R24
    0994B 9508      RET
(0756) 		}
(0757) }
(0758) 
(0759) unsigned char uart0SendData(unsigned char * data, unsigned short len)
(0760) {
(0761) 	// 指定长度数据写入缓冲区
(0762) 	unsigned short i;
(0763) 	unsigned int pTop, pEnd, p;
(0764) 	uartBufProtect = 1;
_GetUart2DataSendResult:
    0994C 9100 096C LDS	R16,_Uart2DataSendResult
    0994E 9508      RET
(0765) 	pTop = uart0TxdBuf.pHead;
_uart2_rx_isr:
    0994F 920A      ST	-Y,R0
    09950 921A      ST	-Y,R1
    09951 922A      ST	-Y,R2
    09952 923A      ST	-Y,R3
(0766) 	pEnd = uart0TxdBuf.pEnd;
    09953 924A      ST	-Y,R4
    09954 925A      ST	-Y,R5
    09955 926A      ST	-Y,R6
    09956 927A      ST	-Y,R7
(0767) 	for(i=0; i<len; i++)
    09957 928A      ST	-Y,R8
    09958 929A      ST	-Y,R9
    09959 930A      ST	-Y,R16
(0768) 	{
(0769) 		p = pEnd;
    0995A 931A      ST	-Y,R17
(0770) 		pEnd ++;
    0995B 932A      ST	-Y,R18
    0995C 933A      ST	-Y,R19
(0771) 		if(pEnd == UARTBUF_TXD_LEN)
    0995D 938A      ST	-Y,R24
    0995E 939A      ST	-Y,R25
    0995F 93AA      ST	-Y,R26
    09960 93BA      ST	-Y,R27
(0772) 			pEnd = 0;
    09961 93EA      ST	-Y,R30
    09962 93FA      ST	-Y,R31
(0773) 		if(pEnd != pTop)
    09963 B60F      IN	R0,0x3F
    09964 920A      ST	-Y,R0
    09965 92AA      ST	-Y,R10
(0774) 			uart0TxdBuf.buffer[p] = (* (data+i));
    09966 90A0 00D6 LDS	R10,0xD6
    09968 9020 096B LDS	R2,_Uart2DetectorSelfFlag
    0996A 2022      TST	R2
    0996B F089      BEQ	0x997D
    0996C 92A0 1855 STS	_Uart2DetectorSelfData,R10
    0996E 2422      CLR	R2
    0996F 9220 096B STS	_Uart2DetectorSelfFlag,R2
(0775) 		else
(0776) 		{
(0777) 			pEnd = p;
    09971 9020 1854 LDS	R2,_Uart2CurrentSendData
(0778) 			break;
    09973 14A2      CP	R10,R2
    09974 F421      BNE	0x9979
    09975 2422      CLR	R2
    09976 9220 096C STS	_Uart2DataSendResult,R2
(0779) 		}
(0780) 	}
(0781) 	uart0TxdBuf.pEnd = pEnd;
    09978 C007      RJMP	0x9980
    09979 E081      LDI	R24,1
    0997A 9380 096C STS	_Uart2DataSendResult,R24
(0782) 	uartBufProtect = 0;
    0997C C003      RJMP	0x9980
    0997D 2D0A      MOV	R16,R10
    0997E 940E 1525 CALL	_ReceiveSlaveInfo
(0783) 	return 1;
    09980 90A9      LD	R10,Y+
    09981 9009      LD	R0,Y+
_uart0SendChar:
  p                    --> R10
  pTop                 --> R12
  pEnd                 --> R20
  c                    --> R16
    09982 BE0F      OUT	0x3F,R0
    09983 91F9      LD	R31,Y+
(0784) }
(0785) 
(0786) unsigned char uart0SendChar(unsigned char c){
(0787) 	// 1字符数据写入缓冲区
(0788) 	unsigned int pTop, pEnd, p;
(0789) 	if(c){
    09984 91E9      LD	R30,Y+
    09985 91B9      LD	R27,Y+
(0790) 		pTop = uart0TxdBuf.pHead;
    09986 91A9      LD	R26,Y+
    09987 9199      LD	R25,Y+
    09988 9189      LD	R24,Y+
    09989 9139      LD	R19,Y+
(0791) 		pEnd = uart0TxdBuf.pEnd;
    0998A 9129      LD	R18,Y+
    0998B 9119      LD	R17,Y+
    0998C 9109      LD	R16,Y+
    0998D 9099      LD	R9,Y+
(0792) 		p = pEnd;
    0998E 9089      LD	R8,Y+
(0793) 		pEnd ++;
    0998F 9079      LD	R7,Y+
    09990 9069      LD	R6,Y+
(0794) 		if(pEnd == UARTBUF_TXD_LEN)
    09991 9059      LD	R5,Y+
    09992 9049      LD	R4,Y+
    09993 9039      LD	R3,Y+
    09994 9029      LD	R2,Y+
(0795) 			pEnd = 0;
    09995 9019      LD	R1,Y+
    09996 9009      LD	R0,Y+
(0796) 		if(pEnd != pTop)
    09997 9518      RETI
_uart2_tx_isr:
    09998 938A      ST	-Y,R24
    09999 B78F      IN	R24,0x3F
(0797) 			uart0TxdBuf.buffer[p] = c;
    0999A 938A      ST	-Y,R24
    0999B E083      LDI	R24,3
    0999C 9380 0102 STS	0x102,R24
    0999E 9380 0102 STS	0x102,R24
    099A0 9189      LD	R24,Y+
(0798) 		else
(0799) 			return 1;
    099A1 BF8F      OUT	0x3F,R24
    099A2 9189      LD	R24,Y+
(0800) 		uart0TxdBuf.pEnd = pEnd;
    099A3 9518      RETI
_Uart2SendAdd:
    099A4 E08B      LDI	R24,0xB
    099A5 9380 0102 STS	0x102,R24
(0801) 	
(0802) 		uartBufProtect = 0;
    099A7 E081      LDI	R24,1
    099A8 9380 096B STS	_Uart2DetectorSelfFlag,R24
(0803) 		return 0;
    099AA 9020 00D0 LDS	R2,0xD0
(0804) 		}
(0805) 	return 1;
    099AC FE25      SBRS	R2,5
    099AD CFFC      RJMP	0x99AA
    099AE 9180 00D1 LDS	R24,0xD1
    099B0 6081      ORI	R24,1
(0806) }
(0807) 
(0808) unsigned char uart0SendString(_CONST  char * pS)
(0809) {
(0810) 	unsigned short i;
(0811) 	unsigned int pTop, pEnd, p;
(0812) 	// 字符串数据写入缓冲区
(0813) 	uartBufProtect = 1;
    099B1 9380 00D1 STS	0xD1,R24
    099B3 9300 00D6 STS	0xD6,R16
(0814) 	pTop = uart0TxdBuf.pHead;
    099B5 9300 1854 STS	_Uart2CurrentSendData,R16
    099B7 9508      RET
(0815) 	pEnd = uart0TxdBuf.pEnd;
_Uart2SendDat:
    099B8 E08B      LDI	R24,0xB
    099B9 9380 0102 STS	0x102,R24
    099BB E081      LDI	R24,1
    099BC 9380 096B STS	_Uart2DetectorSelfFlag,R24
(0816) 	while(*pS){
(0817) 		p = pEnd;
    099BE 9020 00D0 LDS	R2,0xD0
(0818) 		pEnd ++;
(0819) 		if(pEnd == UARTBUF_TXD_LEN){
    099C0 FE25      SBRS	R2,5
    099C1 CFFC      RJMP	0x99BE
    099C2 9180 00D1 LDS	R24,0xD1
(0820) 			pEnd = 0;
    099C4 7F8E      ANDI	R24,0xFE
    099C5 9380 00D1 STS	0xD1,R24
(0821) 			}
(0822) 		if(pEnd != pTop){
    099C7 9300 00D6 STS	0xD6,R16
(0823) 			uart0TxdBuf.buffer[p] = (* (pS));
    099C9 9300 1854 STS	_Uart2CurrentSendData,R16
    099CB 9508      RET
_uart3_init:
    099CC 2422      CLR	R2
    099CD 9220 0131 STS	0x131,R2
    099CF 9220 0130 STS	0x130,R2
    099D1 E086      LDI	R24,6
    099D2 9380 0132 STS	0x132,R24
    099D4 E087      LDI	R24,7
    099D5 9380 0134 STS	0x134,R24
(0824) 			pS ++;
    099D7 9220 0135 STS	0x135,R2
(0825) 			}
    099D9 ED8C      LDI	R24,0xDC
(0826) 		else{
(0827) 			pEnd = p;
(0828) 			break;
    099DA 9380 0131 STS	0x131,R24
    099DC 9508      RET
_uart3_rx_isr:
    099DD 922A      ST	-Y,R2
    099DE 930A      ST	-Y,R16
(0829) 			}
(0830) 		}
(0831) 	uart0TxdBuf.pEnd = pEnd;
    099DF B62F      IN	R2,0x3F
    099E0 922A      ST	-Y,R2
    099E1 9020 0130 LDS	R2,0x130
(0832) 	uartBufProtect = 0;
    099E3 FE27      SBRS	R2,7
    099E4 CFFC      RJMP	0x99E1
    099E5 9100 0136 LDS	R16,0x136
(0833) 	return 1;
    099E7 9020 00C0 LDS	R2,0xC0
(0834) }
(0835) 
(0836) unsigned char uart0GetChar(void){
(0837) 	unsigned char c;
(0838) 	unsigned char pHead, pEnd;
(0839) 	pHead = uart0RxdBuf.pHead;
_uart0GetChar:
  c                    --> R16
  pEnd                 --> R16
  pHead                --> R18
    099E9 FE25      SBRS	R2,5
    099EA CFFC      RJMP	0x99E7
(0840) 	pEnd  = uart0RxdBuf.pEnd;
    099EB 9300 00C6 STS	0xC6,R16
(0841) 	if(pEnd == pHead){
    099ED 9029      LD	R2,Y+
    099EE BE2F      OUT	0x3F,R2
(0842) 		return 0;
    099EF 9109      LD	R16,Y+
    099F0 9029      LD	R2,Y+
(0843) 		}
(0844) 	else{
(0845) //		UCSR0B &= 0x7f;		// 禁止接收中断
(0846) 		c = uart0RxdBuf.buf[pHead];
    099F1 9518      RETI
_uart3_tx_isr:
    099F2 938A      ST	-Y,R24
    099F3 B78F      IN	R24,0x3F
    099F4 938A      ST	-Y,R24
    099F5 E083      LDI	R24,3
    099F6 9380 0105 STS	0x105,R24
(0847) 		uart0RxdBuf.buf[pHead] = 0;
    099F8 9380 0105 STS	0x105,R24
    099FA 9189      LD	R24,Y+
    099FB BF8F      OUT	0x3F,R24
    099FC 9189      LD	R24,Y+
    099FD 9518      RETI
(0848) 		uart0RxdBuf.pHead ++;
_Uart3SendAdd:
    099FE E08F      LDI	R24,0xF
    099FF 9380 0105 STS	0x105,R24
    09A01 9020 00D0 LDS	R2,0xD0
(0849) 		if(uart0RxdBuf.pHead == UARTBUF_RXD_LEN)
    09A03 FE25      SBRS	R2,5
    09A04 CFFC      RJMP	0x9A01
(0850) 			uart0RxdBuf.pHead = 0;
    09A05 9180 0131 LDS	R24,0x131
(0851) 		}
(0852) //	UCSR0B |= 0x80;		// 开启接收中断
(0853) 	return c;
    09A07 6081      ORI	R24,1
FILE: D:\Work\主控软件\2032A2~1\ringQueueProcess.c
(0001) #include <iom1280v.h>
(0002) #include "B1404_LIB.h"
(0003) #include "Common.h"
(0004) 
(0005) 
(0006) // 转盘队列处理
(0007) 
(0008) unsigned char TurnPlateUsedLock;		// 转盘使用锁
(0009) 
(0010) RING_QUEUE	RingQueue;
(0011) extern unsigned long SecondCount;	// 秒时钟计数
(0012) 
(0013) void RingQueueDatInit(void){
(0014) 	unsigned int i;
(0015) 	unsigned char *pChar;
(0016) 
(0017) 	pChar = (unsigned char *)&(RingQueue);
_RingQueueDatInit:
  pChar                --> R18
  i                    --> R16
    09A08 9380 0131 STS	0x131,R24
(0018) 	for(i=0; i<sizeof(RING_QUEUE); i++){
    09A0A 9300 0136 STS	0x136,R16
    09A0C 9508      RET
(0019) 		*pChar++ = 0;
_Uart3SendDat:
    09A0D E08F      LDI	R24,0xF
    09A0E 9380 0105 STS	0x105,R24
    09A10 9020 0130 LDS	R2,0x130
    09A12 FE25      SBRS	R2,5
    09A13 CFFC      RJMP	0x9A10
    09A14 9180 0131 LDS	R24,0x131
    09A16 7F8E      ANDI	R24,0xFE
(0020) 		}
(0021) 	TurnPlateUsedLock = 0;
    09A17 9380 0131 STS	0x131,R24
    09A19 9300 0136 STS	0x136,R16
_RingQueueInsertCalculate:
  i                    --> R22
  ringNum              --> R20
    09A1B 9508      RET
_pcint2_isr:
    09A1C 9518      RETI
_adc_init:
    09A1D 2422      CLR	R2
(0022) }
(0023) 
(0024) unsigned char RingQueueInsertCalculate(void){
(0025) 	// 查找出转盘下一个插入位置，返回查找到的位置编号
(0026) 	unsigned char i, ringNum;
(0027) 	ringNum = RingQueue.prevNum;		
    09A1E 9220 007A STS	0x7A,R2
(0028) 	i = RING_QUEUE_NUM;
    09A20 E482      LDI	R24,0x42
    09A21 9380 007C STS	0x7C,R24
(0029) 	while(i--){
(0030) 		// 从转盘上次插入干片位置开始遍历查找空位置
(0031) 		ringNum ++;
    09A23 E880      LDI	R24,0x80
    09A24 BF80      OUT	0x30,R24
(0032) 		if(ringNum == RING_QUEUE_NUM)
(0033) 			ringNum = 0;
    09A25 9220 007B STS	0x7B,R2
(0034) 		if(RingQueue.flag[ringNum] == 0)	// 找到转盘空位置
    09A27 EE8F      LDI	R24,0xEF
    09A28 9380 007A STS	0x7A,R24
    09A2A 9508      RET
_SetNextADChannel:
    09A2B 934A      ST	-Y,R20
    09A2C 935A      ST	-Y,R21
    09A2D 2F40      MOV	R20,R16
    09A2E 2755      CLR	R21
(0035) 			break;
    09A2F 3040      CPI	R20,0
    09A30 0745      CPC	R20,R21
    09A31 F049      BEQ	0x9A3B
    09A32 3041      CPI	R20,1
    09A33 E0E0      LDI	R30,0
    09A34 075E      CPC	R21,R30
(0036) 		}
(0037) 	if(i == 255)   // 0-1 = 255
    09A35 F061      BEQ	0x9A42
    09A36 3042      CPI	R20,2
(0038) 	{
(0039) 		Uart0ReUnable;
    09A37 E0E0      LDI	R30,0
    09A38 075E      CPC	R21,R30
    09A39 F079      BEQ	0x9A49
    09A3A C014      RJMP	0x9A4F
    09A3B E088      LDI	R24,0x8
(0040) 		uart_Printf("%s $%d\r\n",strE3935,RingQueue.prevNum); 
    09A3C 9380 007B STS	0x7B,R24
    09A3E E482      LDI	R24,0x42
    09A3F 9380 007C STS	0x7C,R24
    09A41 C00D      RJMP	0x9A4F
    09A42 E088      LDI	R24,0x8
    09A43 9380 007B STS	0x7B,R24
    09A45 E483      LDI	R24,0x43
    09A46 9380 007C STS	0x7C,R24
(0041) 		Uart0ReEnable;
    09A48 C006      RJMP	0x9A4F
    09A49 2422      CLR	R2
    09A4A 9220 007B STS	0x7B,R2
(0042) 		return 0xff;			// 未找到空位置，查找失败
    09A4C E482      LDI	R24,0x42
    09A4D 9380 007C STS	0x7C,R24
(0043) 	}
(0044) 	RingQueue.prevNum = ringNum;
    09A4F 9159      LD	R21,Y+
(0045) 	return ringNum;
    09A50 9149      LD	R20,Y+
    09A51 9508      RET
_getLiqDetADC:
    09A52 E48E      LDI	R24,0x4E
    09A53 E198      LDI	R25,0x18
    09A54 2FE0      MOV	R30,R16
_RingQueueInsert:
  newSamp              --> R10
  ringNum              --> R12
    09A55 27FF      CLR	R31
    09A56 0FEE      LSL	R30
    09A57 1FFF      ROL	R31
    09A58 0FE8      ADD	R30,R24
    09A59 1FF9      ADC	R31,R25
(0046) }
(0047) 
(0048) /*
(0049) unsigned char RingQueueInsertCalculate(void)
(0050) {
(0051) 	// 查找出转盘下一个插入位置，返回查找到的位置编号
(0052) 	unsigned char ringNum;
(0053) 	ringNum = RingQueue.prevNum;
(0054) 	ringNum++;
(0055) 	if(ringNum >= RING_QUEUE_NUM)
(0056) 		ringNum = 0;
(0057) 	RingQueue.prevNum = ringNum;
(0058) 	return ringNum;
(0059) }
(0060) */
(0061) 
(0062) void RingQueueInsert(unsigned char ringNum,SAMP_INFO * newSamp){
(0063) 	// 转盘队列插入新测试，只将标本信息放入转盘，等待干片装入转盘后再设置新插入位置有效标识
(0064) 	//RingQueue.flag[ringNum] = 1;		// 设置使用标记
(0065) 	MemCopy(newSamp, &(RingQueue.sampInfo[ringNum]), sizeof(SAMP_INFO));		// 存入测试信息
    09A5A 8100      LD	R16,Z
    09A5B 8111      LDD	R17,Z+1
    09A5C 9508      RET
_CheckLiqDetBase:
    09A5D EF87      LDI	R24,0xF7
    09A5E E093      LDI	R25,3
    09A5F 9020 184E LDS	R2,AdcResult
    09A61 9030 184F LDS	R3,AdcResult+1
    09A63 1582      CP	R24,R2
    09A64 0593      CPC	R25,R3
    09A65 F4B0      BCC	0x9A7C
    09A66 940E 372D CALL	_SetBeepWarning
    09A68 9180 00C1 LDS	R24,0xC1
(0066) }
(0067) 
(0068) void RingQueueDelete(unsigned char ringNum){
(0069) 	RingQueue.flag[ringNum] = 0;
_RingQueueDelete:
  ringNum              --> R16
    09A6A 7E8F      ANDI	R24,0xEF
    09A6B 9380 00C1 STS	0xC1,R24
    09A6D 9120 184E LDS	R18,AdcResult
    09A6F 9130 184F LDS	R19,AdcResult+1
    09A71 EA0F      LDI	R16,0xAF
    09A72 E019      LDI	R17,0x9
(0070) }
(0071) 
(0072) void SetRingQueueUnitUsed(unsigned char ringNum){
(0073) 	RingQueue.flag[ringNum] = 1;
_SetRingQueueUnitUsed:
  ringNum              --> R16
    09A73 940E A90D CALL	_uart_Printf
    09A75 9180 00C1 LDS	R24,0xC1
    09A77 6180      ORI	R24,0x10
    09A78 9380 00C1 STS	0xC1,R24
    09A7A E002      LDI	R16,2
    09A7B C01F      RJMP	0x9A9B
FILE: D:\Work\主控软件\2032A2~1\testQueueProcess.c
(0001) 
(0002) 
(0003) #include <iom1280v.h>
(0004) #include "B1404_LIB.h"
(0005) #include "Common.h"
(0006) #include "eeprom.h"
(0007) 
(0008) unsigned char insertflag[30];	// 插入转盘标志  255 插入  200 下片 0 空闲
(0009) 
(0010) TEST_QUEUE TestQueueA;
(0011) TEST_QUEUE TestQueueB;
(0012) extern RING_QUEUE	RingQueue;
(0013) extern unsigned long SecondCount;	// 秒时钟计数
(0014) extern unsigned char TurnPlateUsedLock;		// 转盘使用锁
(0015) static unsigned char LampAState;
(0016) static unsigned char LampBState;
(0017) static unsigned char ReadColseAnswer;
(0018) extern unsigned char CardNoneUseful;
(0019) 
(0020) void TestALampOpen(void){
(0021) 	DDRH |= 0x70;	
_TestALampOpen:
    09A7C 9180 184E LDS	R24,AdcResult
    09A7E 9190 184F LDS	R25,AdcResult+1
    09A80 3980      CPI	R24,0x90
(0022) 	PORTH &= 0xcf;
    09A81 E0E1      LDI	R30,1
    09A82 079E      CPC	R25,R30
    09A83 F4B0      BCC	0x9A9A
    09A84 940E 372D CALL	_SetBeepWarning
(0023) 	PORTH |= 0x40;
    09A86 9180 00C1 LDS	R24,0xC1
    09A88 7E8F      ANDI	R24,0xEF
    09A89 9380 00C1 STS	0xC1,R24
(0024) 	LampAState = 1;
    09A8B 9120 184E LDS	R18,AdcResult
    09A8D 9130 184F LDS	R19,AdcResult+1
(0025) }
(0026) void TestALampClose(void){
(0027) 	DDRH &= 0x8f;	
_TestALampClose:
    09A8F EA03      LDI	R16,0xA3
    09A90 E019      LDI	R17,0x9
    09A91 940E A90D CALL	_uart_Printf
    09A93 9180 00C1 LDS	R24,0xC1
(0028) 	PORTH &= 0x8f;
    09A95 6180      ORI	R24,0x10
    09A96 9380 00C1 STS	0xC1,R24
    09A98 E001      LDI	R16,1
(0029) 	LampAState = 0;
    09A99 C001      RJMP	0x9A9B
    09A9A 2700      CLR	R16
    09A9B 9508      RET
_GetLiqDetDiff:
    09A9C 9100 096D LDS	R16,_Adc_Wave
(0030) }
(0031) void TestBLampOpen(void){
(0032) 	DDRL |= 0x70;	
    09A9E 9110 096E LDS	R17,_Adc_Wave+1
    09AA0 9508      RET
_GetLiqDetResult:
    09AA1 92AA      ST	-Y,R10
(0033) 	PORTL &= 0xcf;
    09AA2 92BA      ST	-Y,R11
    09AA3 0158      MOVW	R10,R16
    09AA4 2422      CLR	R2
    09AA5 2433      CLR	R3
    09AA6 142A      CP	R2,R10
(0034) 	PORTL |= 0x40;
    09AA7 043B      CPC	R3,R11
    09AA8 F4C4      BGE	0x9AC1
    09AA9 9020 096D LDS	R2,_Adc_Wave
    09AAB 9030 096E LDS	R3,_Adc_Wave+1
(0035) 	LampBState = 1;
    09AAD 14A2      CP	R10,R2
    09AAE 04B3      CPC	R11,R3
    09AAF F54C      BGE	0x9AD9
(0036) }
(0037) void TestBLampClose(void){
(0038) 	DDRL &= 0x8f;
_TestBLampClose:
    09AB0 9180 00C1 LDS	R24,0xC1
    09AB2 7E8F      ANDI	R24,0xEF
    09AB3 9380 00C1 STS	0xC1,R24
(0039) 	PORTL &= 0x8f;
    09AB5 0191      MOVW	R18,R2
    09AB6 E80C      LDI	R16,0x8C
    09AB7 E019      LDI	R17,0x9
    09AB8 940E A90D CALL	_uart_Printf
(0040) 	LampBState = 0;
    09ABA 9180 00C1 LDS	R24,0xC1
    09ABC 6180      ORI	R24,0x10
    09ABD 9380 00C1 STS	0xC1,R24
    09ABF E001      LDI	R16,1
    09AC0 C019      RJMP	0x9ADA
    09AC1 9020 096D LDS	R2,_Adc_Wave
(0041) }
(0042) 
(0043) void ReSetTestLampPWM(unsigned char n){
(0044) 	// 读取光源设置值并设置
(0045) 	unsigned int lampPWM;
(0046) 	if(n<4){
    09AC3 9030 096E LDS	R3,_Adc_Wave+1
(0047) 		EEPROM_READ(EEP_ADD_LAMPSET+n*2,   lampPWM);
    09AC5 142A      CP	R2,R10
    09AC6 043B      CPC	R3,R11
    09AC7 F48C      BGE	0x9AD9
    09AC8 9180 00C1 LDS	R24,0xC1
    09ACA 7E8F      ANDI	R24,0xEF
    09ACB 9380 00C1 STS	0xC1,R24
    09ACD 0191      MOVW	R18,R2
    09ACE E80C      LDI	R16,0x8C
    09ACF E019      LDI	R17,0x9
    09AD0 940E A90D CALL	_uart_Printf
    09AD2 9180 00C1 LDS	R24,0xC1
(0048) 	//	lampPWM = lampPWM + 512;
(0049) 		switch(n){
    09AD4 6180      ORI	R24,0x10
    09AD5 9380 00C1 STS	0xC1,R24
    09AD7 E001      LDI	R16,1
    09AD8 C001      RJMP	0x9ADA
    09AD9 2700      CLR	R16
    09ADA 90B9      LD	R11,Y+
    09ADB 90A9      LD	R10,Y+
    09ADC 9508      RET
_adc_isr:
    09ADD 920A      ST	-Y,R0
    09ADE 921A      ST	-Y,R1
    09ADF 922A      ST	-Y,R2
    09AE0 923A      ST	-Y,R3
    09AE1 924A      ST	-Y,R4
    09AE2 925A      ST	-Y,R5
    09AE3 926A      ST	-Y,R6
    09AE4 927A      ST	-Y,R7
(0050) 			case 0:		OCR4BH = lampPWM>>8;	OCR4BL = (unsigned char)lampPWM;	break;
    09AE5 928A      ST	-Y,R8
    09AE6 929A      ST	-Y,R9
    09AE7 930A      ST	-Y,R16
    09AE8 931A      ST	-Y,R17
    09AE9 932A      ST	-Y,R18
    09AEA 933A      ST	-Y,R19
    09AEB 938A      ST	-Y,R24
    09AEC 939A      ST	-Y,R25
    09AED 93AA      ST	-Y,R26
    09AEE 93BA      ST	-Y,R27
    09AEF 93EA      ST	-Y,R30
(0051) 			case 1:		OCR4CH = lampPWM>>8;	OCR4CL = (unsigned char)lampPWM;	break;
    09AF0 93FA      ST	-Y,R31
    09AF1 B60F      IN	R0,0x3F
    09AF2 920A      ST	-Y,R0
    09AF3 92AA      ST	-Y,R10
    09AF4 92BA      ST	-Y,R11
    09AF5 90A0 0078 LDS	R10,0x78
    09AF7 24BB      CLR	R11
    09AF8 9020 0079 LDS	R2,0x79
    09AFA 2433      CLR	R3
(0052) 			case 2:		OCR5BH = lampPWM>>8;	OCR5BL = (unsigned char)lampPWM;	break;
    09AFB 2C32      MOV	R3,R2
    09AFC 2422      CLR	R2
    09AFD 0CA2      ADD	R10,R2
    09AFE 1CB3      ADC	R11,R3
    09AFF E48E      LDI	R24,0x4E
    09B00 E198      LDI	R25,0x18
    09B01 91E0 0970 LDS	R30,_Adc_DiffBufPnt+1
    09B03 91F0 0971 LDS	R31,_Adc_DiffBufPnt+2
    09B05 0FEE      LSL	R30
(0053) 			case 3:		OCR5CH = lampPWM>>8;	OCR5CL = (unsigned char)lampPWM;	break;
    09B06 1FFF      ROL	R31
    09B07 0FE8      ADD	R30,R24
    09B08 1FF9      ADC	R31,R25
    09B09 8020      LD	R2,Z
    09B0A 8031      LDD	R3,Z+1
    09B0B 142A      CP	R2,R10
    09B0C 043B      CPC	R3,R11
    09B0D F478      BCC	0x9B1D
    09B0E 9020 0970 LDS	R2,_Adc_DiffBufPnt+1
(0054) 			default:	break;
(0055) 			}
(0056) 		}
    09B10 9030 0971 LDS	R3,_Adc_DiffBufPnt+2
    09B12 0C22      LSL	R2
    09B13 1C33      ROL	R3
_ReadTestLampPWM:
  lampPWM              --> Y,+2
  n                    --> R20
    09B14 0E28      ADD	R2,R24
    09B15 1E39      ADC	R3,R25
    09B16 01F1      MOVW	R30,R2
(0057) }
(0058) unsigned int ReadTestLampPWM(unsigned char n){
(0059) 	unsigned int lampPWM;
(0060) 	if(n<4){
    09B17 8180      LD	R24,Z
    09B18 8191      LDD	R25,Z+1
(0061) 		EEPROM_READ(EEP_ADD_LAMPSET+n*2,   lampPWM);
    09B19 9601      ADIW	R24,1
    09B1A 8391      STD	Z+1,R25
    09B1B 8380      ST	Z,R24
    09B1C C01D      RJMP	0x9B3A
    09B1D E48E      LDI	R24,0x4E
    09B1E E198      LDI	R25,0x18
    09B1F 91E0 0970 LDS	R30,_Adc_DiffBufPnt+1
    09B21 91F0 0971 LDS	R31,_Adc_DiffBufPnt+2
    09B23 0FEE      LSL	R30
    09B24 1FFF      ROL	R31
    09B25 0FE8      ADD	R30,R24
    09B26 1FF9      ADC	R31,R25
    09B27 8020      LD	R2,Z
(0062) 		return lampPWM;
    09B28 8031      LDD	R3,Z+1
    09B29 14A2      CP	R10,R2
    09B2A 04B3      CPC	R11,R3
(0063) 		}
(0064) 	return 0;
    09B2B F470      BCC	0x9B3A
    09B2C 9020 0970 LDS	R2,_Adc_DiffBufPnt+1
    09B2E 9030 0971 LDS	R3,_Adc_DiffBufPnt+2
_AdjustTestLamp:
  i                    --> Y,+3
  lampPWM              --> Y,+2
  adj                  --> R22
  n                    --> R20
    09B30 0C22      LSL	R2
    09B31 1C33      ROL	R3
    09B32 0E28      ADD	R2,R24
    09B33 1E39      ADC	R3,R25
    09B34 01F1      MOVW	R30,R2
(0065) }
(0066) 
(0067) // 调整光源值,上位机输入正或者负的调整量,完毕向上位机返回调整完后的结果
(0068) unsigned int AdjustTestLamp(unsigned char n, unsigned int adj){
(0069) 	// 光源序号和调整量
(0070) 	// 返回调整后的结果
(0071) 	unsigned int lampPWM;
(0072) 	signed int i;
(0073) 	
(0074) 	if(n<4){
    09B35 8180      LD	R24,Z
    09B36 8191      LDD	R25,Z+1
(0075) 		if(adj == 0)
    09B37 9701      SBIW	R24,1
    09B38 8391      STD	Z+1,R25
    09B39 8380      ST	Z,R24
(0076) 			adj = 1;
    09B3A 9180 0970 LDS	R24,_Adc_DiffBufPnt+1
(0077) 		if(adj > 1020)
    09B3C 9190 0971 LDS	R25,_Adc_DiffBufPnt+2
    09B3E 9601      ADIW	R24,1
    09B3F 9390 0971 STS	_Adc_DiffBufPnt+2,R25
(0078) 			adj = 1020;
    09B41 9380 0970 STS	_Adc_DiffBufPnt+1,R24
(0079) 		lampPWM = adj;
    09B43 E082      LDI	R24,2
    09B44 E090      LDI	R25,0
(0080) 		EEPROM_WRITE(EEP_ADD_LAMPSET+n*2,   lampPWM);
    09B45 9020 0970 LDS	R2,_Adc_DiffBufPnt+1
    09B47 9030 0971 LDS	R3,_Adc_DiffBufPnt+2
    09B49 1582      CP	R24,R2
    09B4A 0593      CPC	R25,R3
    09B4B F434      BGE	0x9B52
    09B4C 2422      CLR	R2
    09B4D 2433      CLR	R3
    09B4E 9230 0971 STS	_Adc_DiffBufPnt+2,R3
    09B50 9220 0970 STS	_Adc_DiffBufPnt+1,R2
    09B52 9100 0970 LDS	R16,_Adc_DiffBufPnt+1
(0081) 		ReSetTestLampPWM(n);
    09B54 9110 0971 LDS	R17,_Adc_DiffBufPnt+2
(0082) 		}
(0083) 	return lampPWM;
    09B56 DED4      RCALL	_SetNextADChannel
    09B57 90B9      LD	R11,Y+
    09B58 90A9      LD	R10,Y+
    09B59 9009      LD	R0,Y+
    09B5A BE0F      OUT	0x3F,R0
(0084) }
(0085) 
(0086) unsigned char SetReadCloseAnswer(void)
(0087) {
(0088) 	ReadColseAnswer = 1;
_SetReadCloseAnswer:
    09B5B 91F9      LD	R31,Y+
    09B5C 91E9      LD	R30,Y+
    09B5D 91B9      LD	R27,Y+
(0089) 	Uart0ReUnable;
    09B5E 91A9      LD	R26,Y+
    09B5F 9199      LD	R25,Y+
    09B60 9189      LD	R24,Y+
    09B61 9139      LD	R19,Y+
    09B62 9129      LD	R18,Y+
(0090) 	uart_Printf("%s\r\n",strM3159);
    09B63 9119      LD	R17,Y+
    09B64 9109      LD	R16,Y+
    09B65 9099      LD	R9,Y+
    09B66 9089      LD	R8,Y+
    09B67 9079      LD	R7,Y+
    09B68 9069      LD	R6,Y+
(0091) 	Uart0ReEnable;
    09B69 9059      LD	R5,Y+
    09B6A 9049      LD	R4,Y+
    09B6B 9039      LD	R3,Y+
    09B6C 9029      LD	R2,Y+
    09B6D 9019      LD	R1,Y+
    09B6E 9009      LD	R0,Y+
_TestQueueDatInit:
  pChar                --> R22
  i                    --> R20
    09B6F 9518      RETI
_init_devices:
    09B70 94F8      BCLR	7
(0092) }
(0093) 
(0094) void TestQueueDatInit(void){
(0095) 	unsigned int i;
(0096) 	unsigned char *pChar;
(0097) 
(0098) 	pChar = (unsigned char *)&(TestQueueA);
    09B71 D02A      RCALL	_uartDataInit
    09B72 DBB2      RCALL	_port_init
(0099) 	for(i=0; i<sizeof(TEST_QUEUE); i++){
    09B73 DBDB      RCALL	_timer0_init
    09B74 DC1B      RCALL	_timer1_init
    09B75 DCFC      RCALL	_timer4_init
(0100) 		*pChar++ = 0;
    09B76 DD25      RCALL	_timer5_init
    09B77 DD4E      RCALL	_uart0_init
    09B78 DDC2      RCALL	_uart2_init
    09B79 DEA3      RCALL	_adc_init
    09B7A 940E 6DE5 CALL	_TWI_Init
    09B7C 2422      CLR	R2
    09B7D BE25      OUT	0x35,R2
    09B7E 9220 0069 STS	0x69,R2
(0101) 		}
(0102) 	pChar = (unsigned char *)&(TestQueueB);
    09B80 9220 006A STS	0x6A,R2
(0103) 	for(i=0; i<sizeof(TEST_QUEUE); i++){
    09B82 9220 006B STS	0x6B,R2
    09B84 9220 006C STS	0x6C,R2
(0104) 		*pChar++ = 0;
    09B86 9220 006D STS	0x6D,R2
    09B88 BA2D      OUT	0x1D,R2
    09B89 E081      LDI	R24,1
    09B8A 9380 006E STS	0x6E,R24
    09B8C 9380 006F STS	0x6F,R24
    09B8E 9220 0070 STS	0x70,R2
(0105) 		}
(0106) 	for(i=0; i<TEST_QUEUE_NUM; i++){
    09B90 9220 0071 STS	0x71,R2
(0107) 		TestQueueA.ringNum[i] = 0xff;
    09B92 9220 0072 STS	0x72,R2
    09B94 9220 0073 STS	0x73,R2
    09B96 9220 0064 STS	0x64,R2
    09B98 9220 0065 STS	0x65,R2
(0108) 		TestQueueB.ringNum[i] = 0xff;
    09B9A 9478      BSET	7
    09B9B 9508      RET
_uartDataInit:
    09B9C E726      LDI	R18,0x76
    09B9D E138      LDI	R19,0x18
    09B9E 2700      CLR	R16
    09B9F 2711      CLR	R17
    09BA0 C006      RJMP	0x9BA7
    09BA1 2422      CLR	R2
    09BA2 01F9      MOVW	R30,R18
    09BA3 9221      ST	Z+,R2
    09BA4 019F      MOVW	R18,R30
    09BA5 5F0F      SUBI	R16,0xFF
(0109) 		}
(0110) 	ReSetTestLampPWM(0);
    09BA6 4F1F      SBCI	R17,0xFF
    09BA7 3003      CPI	R16,3
(0111) 	ReSetTestLampPWM(1);
    09BA8 E0E0      LDI	R30,0
    09BA9 071E      CPC	R17,R30
(0112) 	ReSetTestLampPWM(2);
    09BAA F3B0      BCS	0x9BA1
    09BAB E729      LDI	R18,0x79
(0113) 	ReSetTestLampPWM(3);
    09BAC E138      LDI	R19,0x18
    09BAD 2700      CLR	R16
    09BAE 2711      CLR	R17
    09BAF C006      RJMP	0x9BB6
_TestQueueInsertCalculate:
  time                 --> Y,+0
  i                    --> R10
  testTime             --> Y,+10
  pTestQueue           --> R16
    09BB0 2422      CLR	R2
    09BB1 01F9      MOVW	R30,R18
    09BB2 9221      ST	Z+,R2
    09BB3 019F      MOVW	R18,R30
    09BB4 5F0F      SUBI	R16,0xFF
(0114) }
(0115) 
(0116) unsigned char TestQueueInsertCalculate(TEST_QUEUE * pTestQueue, signed long testTime){
(0117) 	unsigned char i;
(0118) 	signed long time;
(0119) 	for(i=0; i<TEST_QUEUE_NUM; i++){		// 按顺序遍历队列，以测试时间为条件找出合适的位置插入队列
    09BB5 4F1F      SBCI	R17,0xFF
    09BB6 3F0A      CPI	R16,0xFA
(0120) 		time = pTestQueue->testTime[i];
    09BB7 E0E1      LDI	R30,1
    09BB8 071E      CPC	R17,R30
    09BB9 F3B0      BCS	0x9BB0
    09BBA EF83      LDI	R24,0xF3
    09BBB E091      LDI	R25,1
    09BBC 9390 1A72 STS	uart0TxdBuf+505,R25
    09BBE 9380 1A71 STS	uart0TxdBuf+504,R24
    09BC0 9508      RET
_uart0DataReceive:
    09BC1 940E AE8D CALL	push_xgsetF000
    09BC3 2F40      MOV	R20,R16
    09BC4 9160 0972 LDS	R22,_Adc_DiffBufPnt+3
    09BC6 2777      CLR	R23
    09BC7 3060      CPI	R22,0
    09BC8 0767      CPC	R22,R23
(0121) 		if(time == 0){
    09BC9 F121      BEQ	0x9BEE
    09BCA 3061      CPI	R22,1
    09BCB E0E0      LDI	R30,0
    09BCC 077E      CPC	R23,R30
    09BCD F409      BNE	0x9BCF
    09BCE C04F      RJMP	0x9C1E
    09BCF 3062      CPI	R22,2
    09BD0 E0E0      LDI	R30,0
    09BD1 077E      CPC	R23,R30
    09BD2 F409      BNE	0x9BD4
(0122) 			// 在队尾，插入队尾
(0123) 			return i;	// 返回插入位置
    09BD3 C061      RJMP	0x9C35
    09BD4 306A      CPI	R22,0xA
(0124) 			}
(0125) 		else{	// 在队列中间，和当前队列元素的时间做比较
(0126) 			time += TEST_CYCLE_TIME;
    09BD5 E0E0      LDI	R30,0
    09BD6 077E      CPC	R23,R30
    09BD7 F409      BNE	0x9BD9
    09BD8 C096      RJMP	0x9C6F
    09BD9 306B      CPI	R22,0xB
    09BDA E0E0      LDI	R30,0
    09BDB 077E      CPC	R23,R30
    09BDC F409      BNE	0x9BDE
    09BDD C0A6      RJMP	0x9C84
    09BDE 306C      CPI	R22,0xC
    09BDF E0E0      LDI	R30,0
    09BE0 077E      CPC	R23,R30
    09BE1 F409      BNE	0x9BE3
    09BE2 C0D8      RJMP	0x9CBB
    09BE3 306D      CPI	R22,0xD
    09BE4 E0E0      LDI	R30,0
(0127) 			if(testTime>time){	// 插入的时间在当前元素时间之后，继续比较下个队列元素
    09BE5 077E      CPC	R23,R30
    09BE6 F409      BNE	0x9BE8
    09BE7 C0D3      RJMP	0x9CBB
    09BE8 306E      CPI	R22,0xE
    09BE9 E0E0      LDI	R30,0
    09BEA 077E      CPC	R23,R30
    09BEB F409      BNE	0x9BED
    09BEC C0CE      RJMP	0x9CBB
    09BED C0CF      RJMP	0x9CBD
    09BEE 9020 17E8 LDS	R2,ControlModel+16
    09BF0 2022      TST	R2
    09BF1 F079      BEQ	0x9C01
(0128) 				continue;		// 继续判断下一个
    09BF2 3046      CPI	R20,6
(0129) 				}
(0130) 			else if(testTime<=(time-TEST_CYCLE_TIME)){	// 插入的时间在当前元素时间前
    09BF3 F439      BNE	0x9BFB
    09BF4 2422      CLR	R2
    09BF5 9220 17E8 STS	ControlModel+16,R2
    09BF7 E08D      LDI	R24,0xD
    09BF8 9380 0972 STS	_Adc_DiffBufPnt+3,R24
    09BFA C0C2      RJMP	0x9CBD
    09BFB E00F      LDI	R16,0xF
    09BFC D211      RCALL	_uart0SendChar
    09BFD 2422      CLR	R2
    09BFE 9220 17E8 STS	ControlModel+16,R2
    09C00 C0BC      RJMP	0x9CBD
    09C01 3042      CPI	R20,2
    09C02 F4A1      BNE	0x9C17
    09C03 E082      LDI	R24,2
    09C04 9380 0972 STS	_Adc_DiffBufPnt+3,R24
    09C06 2422      CLR	R2
    09C07 9220 17E3 STS	ControlModel+11,R2
(0131) 				// 插入队中间
(0132) 				return i;	// 返回插入位置
    09C09 9220 17E9 STS	ControlModel+17,R2
(0133) 				}
(0134) 			else{
(0135) 				// 和当前元素时间有冲突，不能插入
(0136) 				return 0xff;
    09C0B EE8A      LDI	R24,0xEA
    09C0C E197      LDI	R25,0x17
    09C0D 2DE2      MOV	R30,R2
    09C0E 27FF      CLR	R31
    09C0F 0FE8      ADD	R30,R24
    09C10 1FF9      ADC	R31,R25
(0137) 				}
(0138) 			}
(0139) 		}
(0140) 	return 0xff;
    09C11 E082      LDI	R24,2
    09C12 8380      ST	Z,R24
    09C13 E00D      LDI	R16,0xD
    09C14 940E 2D35 CALL	_CommandExplain
    09C16 C0A6      RJMP	0x9CBD
_TestQueueInsert:
  i                    --> R20
  testTime             --> Y,+4
  ringNum              --> R10
  idx                  --> R18
  pTestQueue           --> R16
    09C17 3840      CPI	R20,0x80
    09C18 F008      BCS	0x9C1A
    09C19 C0A3      RJMP	0x9CBD
(0141) }
(0142) 
(0143) void TestQueueInsert(TEST_QUEUE * pTestQueue, unsigned char idx, unsigned char ringNum, signed long testTime){
(0144) 	// 测试队列插入新任务
(0145) 	// pTestQueue:测试队列，idx:插入位置，ringNum:转盘上的编号，testTime:测试时间
(0146) 	unsigned char i;
(0147) 	i = TEST_QUEUE_NUM-1;
    09C1A 2F04      MOV	R16,R20
    09C1B 940E 2D35 CALL	_CommandExplain
(0148) 	while(i--){
(0149) 		if(i != idx){
    09C1D C09F      RJMP	0x9CBD
(0150) 			pTestQueue->testTime[i] = pTestQueue->testTime[i-1];
    09C1E 3042      CPI	R20,2
    09C1F F009      BEQ	0x9C21
    09C20 C09C      RJMP	0x9CBD
    09C21 E082      LDI	R24,2
    09C22 9380 0972 STS	_Adc_DiffBufPnt+3,R24
    09C24 2422      CLR	R2
    09C25 9220 17E3 STS	ControlModel+11,R2
    09C27 9220 17E9 STS	ControlModel+17,R2
    09C29 EE8A      LDI	R24,0xEA
    09C2A E197      LDI	R25,0x17
    09C2B 2DE2      MOV	R30,R2
    09C2C 27FF      CLR	R31
    09C2D 0FE8      ADD	R30,R24
    09C2E 1FF9      ADC	R31,R25
    09C2F E082      LDI	R24,2
    09C30 8380      ST	Z,R24
    09C31 E00D      LDI	R16,0xD
    09C32 940E 2D35 CALL	_CommandExplain
    09C34 C088      RJMP	0x9CBD
    09C35 3043      CPI	R20,3
    09C36 F491      BNE	0x9C49
    09C37 9180 17E9 LDS	R24,ControlModel+17
(0151) 			pTestQueue->ringNum[i] = pTestQueue->ringNum[i-1];
    09C39 5F8F      SUBI	R24,0xFF
    09C3A 9380 17E9 STS	ControlModel+17,R24
    09C3C EE8A      LDI	R24,0xEA
    09C3D E197      LDI	R25,0x17
    09C3E 91E0 17E9 LDS	R30,ControlModel+17
    09C40 27FF      CLR	R31
    09C41 0FE8      ADD	R30,R24
    09C42 1FF9      ADC	R31,R25
    09C43 E083      LDI	R24,3
(0152) 			}
    09C44 8380      ST	Z,R24
(0153) 		else{
(0154) 			pTestQueue->testTime[i] = testTime;
    09C45 E08A      LDI	R24,0xA
    09C46 9380 0972 STS	_Adc_DiffBufPnt+3,R24
    09C48 C074      RJMP	0x9CBD
    09C49 3042      CPI	R20,2
    09C4A F489      BNE	0x9C5C
    09C4B 2422      CLR	R2
    09C4C 9220 17E3 STS	ControlModel+11,R2
    09C4E 9220 17E9 STS	ControlModel+17,R2
    09C50 EE8A      LDI	R24,0xEA
    09C51 E197      LDI	R25,0x17
    09C52 2DE2      MOV	R30,R2
    09C53 27FF      CLR	R31
    09C54 0FE8      ADD	R30,R24
    09C55 1FF9      ADC	R31,R25
    09C56 E082      LDI	R24,2
(0155) 			pTestQueue->ringNum[i] = ringNum;
    09C57 8380      ST	Z,R24
    09C58 E00D      LDI	R16,0xD
    09C59 940E 2D35 CALL	_CommandExplain
    09C5B C061      RJMP	0x9CBD
(0156) 			return;
    09C5C 9180 17E9 LDS	R24,ControlModel+17
    09C5E 5F8F      SUBI	R24,0xFF
    09C5F 9380 17E9 STS	ControlModel+17,R24
    09C61 EE8A      LDI	R24,0xEA
    09C62 E197      LDI	R25,0x17
    09C63 91E0 17E9 LDS	R30,ControlModel+17
    09C65 27FF      CLR	R31
_TestQueueForward:
  i                    --> R20
  pTestQueue           --> R16
    09C66 0FE8      ADD	R30,R24
(0157) 			}
(0158) 		}
(0159) }
(0160) void TestQueueForward(TEST_QUEUE * pTestQueue){
(0161) 	// 测试队列前进一步，当队头测试完毕后，队头元素删除队列前进一步
(0162) 	unsigned char i;
(0163) 	for(i=0; i<TEST_QUEUE_NUM; i++){
    09C67 1FF9      ADC	R31,R25
    09C68 8340      ST	Z,R20
(0164) 		if(i != (TEST_QUEUE_NUM-1)){
    09C69 9020 17E3 LDS	R2,ControlModel+11
(0165) 			// 每个元素往前移动一个，队头元素被后面覆盖
(0166) 			pTestQueue->testTime[i] = pTestQueue->testTime[i+1];
    09C6B 0E24      ADD	R2,R20
    09C6C 9220 17E3 STS	ControlModel+11,R2
    09C6E C04E      RJMP	0x9CBD
    09C6F 9180 17E9 LDS	R24,ControlModel+17
    09C71 5F8F      SUBI	R24,0xFF
    09C72 9380 17E9 STS	ControlModel+17,R24
    09C74 EE8A      LDI	R24,0xEA
    09C75 E197      LDI	R25,0x17
    09C76 91E0 17E9 LDS	R30,ControlModel+17
    09C78 27FF      CLR	R31
    09C79 0FE8      ADD	R30,R24
    09C7A 1FF9      ADC	R31,R25
    09C7B 8340      ST	Z,R20
    09C7C 2F84      MOV	R24,R20
    09C7D 5481      SUBI	R24,0x41
    09C7E 9380 17E4 STS	ControlModel+12,R24
    09C80 E08B      LDI	R24,0xB
    09C81 9380 0972 STS	_Adc_DiffBufPnt+3,R24
    09C83 C039      RJMP	0x9CBD
    09C84 2F84      MOV	R24,R20
    09C85 5481      SUBI	R24,0x41
(0167) 			pTestQueue->ringNum[i] = pTestQueue->ringNum[i+1];
    09C86 9380 17E5 STS	ControlModel+13,R24
    09C88 708F      ANDI	R24,0xF
    09C89 9582      SWAP	R24
    09C8A 9380 17E5 STS	ControlModel+13,R24
    09C8C 9180 17E9 LDS	R24,ControlModel+17
(0168) 			}
    09C8E 5F8F      SUBI	R24,0xFF
    09C8F 9380 17E9 STS	ControlModel+17,R24
    09C91 EE8A      LDI	R24,0xEA
    09C92 E197      LDI	R25,0x17
    09C93 91E0 17E9 LDS	R30,ControlModel+17
    09C95 27FF      CLR	R31
    09C96 0FE8      ADD	R30,R24
    09C97 1FF9      ADC	R31,R25
    09C98 8340      ST	Z,R20
    09C99 EE8B      LDI	R24,0xEB
    09C9A E197      LDI	R25,0x17
    09C9B 91E0 17E9 LDS	R30,ControlModel+17
(0169) 		else{
(0170) 			// 队尾填充零
(0171) 			pTestQueue->testTime[i] = 0;
(0172) 			pTestQueue->ringNum[i] = 0xff;
    09C9D 27FF      CLR	R31
    09C9E 0FE8      ADD	R30,R24
    09C9F 1FF9      ADC	R31,R25
    09CA0 2422      CLR	R2
    09CA1 8220      ST	Z,R2
    09CA2 9020 17E5 LDS	R2,ControlModel+13
    09CA4 9030 17E4 LDS	R3,ControlModel+12
    09CA6 0C32      ADD	R3,R2
    09CA7 9020 17E3 LDS	R2,ControlModel+11
_InsertNewTest:
  pTestQueue           --> R20
  inst1                --> R22
  inst0                --> R12
  testTime1            --> Y,+10
  testTime0            --> Y,+6
  ringNum              --> R10
  sampInfo             --> R20
    09CA9 1423      CP	R2,R3
    09CAA F449      BNE	0x9CB4
    09CAB E006      LDI	R16,6
    09CAC D161      RCALL	_uart0SendChar
    09CAD E08C      LDI	R24,0xC
(0173) 			}
(0174) 		}
(0175) }
(0176) 
(0177) unsigned char InsertNewTest(SAMP_INFO * sampInfo, unsigned char ringNum){
(0178) 	// 新的测试插入测试队列，稀释完准备滴样时调用本函数，直到插入成功
(0179) 	// 插入成功返回0，失败返回0xff
(0180) 	unsigned char inst0, inst1;
(0181) 	signed long testTime0, testTime1;
(0182) 	TEST_QUEUE * pTestQueue;
(0183) 
(0184) 	// 计算测试时间
(0185) 	testTime0 = sampInfo->testTime0;	// 第一测试时间，如果值为零表示没有此测试
    09CAE 9380 0972 STS	_Adc_DiffBufPnt+3,R24
    09CB0 2422      CLR	R2
    09CB1 9220 17E9 STS	ControlModel+17,R2
    09CB3 C009      RJMP	0x9CBD
    09CB4 E08E      LDI	R24,0xE
    09CB5 9380 0972 STS	_Adc_DiffBufPnt+3,R24
    09CB7 2422      CLR	R2
(0186) 	if(testTime0 != 0)
    09CB8 9220 17E9 STS	ControlModel+17,R2
    09CBA C002      RJMP	0x9CBD
    09CBB E00E      LDI	R16,0xE
    09CBC D151      RCALL	_uart0SendChar
    09CBD 940C AE92 JMP	pop_xgsetF000
_uart0Transfer:
    09CBF 940E AE97 CALL	push_xgsetF00C
    09CC1 9020 0969 LDS	R2,uartBufProtect
(0187) 		testTime0 += SecondCount;
    09CC3 2022      TST	R2
    09CC4 F009      BEQ	0x9CC6
    09CC5 C10E      RJMP	0x9DD4
    09CC6 9140 0972 LDS	R20,_Adc_DiffBufPnt+3
    09CC8 2755      CLR	R21
    09CC9 3040      CPI	R20,0
    09CCA 0745      CPC	R20,R21
    09CCB F0D1      BEQ	0x9CE6
    09CCC 3041      CPI	R20,1
    09CCD E0E0      LDI	R30,0
    09CCE 075E      CPC	R21,R30
    09CCF F409      BNE	0x9CD1
    09CD0 C06D      RJMP	0x9D3E
    09CD1 3040      CPI	R20,0
    09CD2 E0E0      LDI	R30,0
    09CD3 075E      CPC	R21,R30
    09CD4 F40C      BGE	0x9CD6
    09CD5 C0FE      RJMP	0x9DD4
(0188) 	testTime1 = sampInfo->testTime1;	// 第二测试时间，如果值为零表示没有此测试
    09CD6 304C      CPI	R20,0xC
    09CD7 E0E0      LDI	R30,0
    09CD8 075E      CPC	R21,R30
    09CD9 F409      BNE	0x9CDB
    09CDA C08E      RJMP	0x9D69
    09CDB 304D      CPI	R20,0xD
    09CDC E0E0      LDI	R30,0
    09CDD 075E      CPC	R21,R30
    09CDE F409      BNE	0x9CE0
    09CDF C0AD      RJMP	0x9D8D
(0189) 	if(testTime1 != 0)
    09CE0 304E      CPI	R20,0xE
    09CE1 E0E0      LDI	R30,0
    09CE2 075E      CPC	R21,R30
    09CE3 F409      BNE	0x9CE5
    09CE4 C0CD      RJMP	0x9DB2
    09CE5 C0EE      RJMP	0x9DD4
    09CE6 9160 1A6F LDS	R22,uart0TxdBuf+502
    09CE8 9170 1A70 LDS	R23,uart0TxdBuf+503
(0190) 		testTime1 += SecondCount;
    09CEA 90A0 1A6D LDS	R10,uart0TxdBuf+500
    09CEC 90B0 1A6E LDS	R11,uart0TxdBuf+501
    09CEE 156A      CP	R22,R10
    09CEF 057B      CPC	R23,R11
    09CF0 F0C1      BEQ	0x9D09
    09CF1 9020 00C0 LDS	R2,0xC0
    09CF3 FE25      SBRS	R2,5
    09CF4 C014      RJMP	0x9D09
    09CF5 E789      LDI	R24,0x79
    09CF6 E198      LDI	R25,0x18
    09CF7 01FB      MOVW	R30,R22
    09CF8 0FE8      ADD	R30,R24
    09CF9 1FF9      ADC	R31,R25
    09CFA 8140      LD	R20,Z
    09CFB 9340 00C6 STS	0xC6,R20
    09CFD 5F6F      SUBI	R22,0xFF
(0191) 	
(0192) 	// 根据测试方法选则对应的测试队列
(0193) 	if(sampInfo->readType == 0)
    09CFE 4F7F      SBCI	R23,0xFF
    09CFF 3F64      CPI	R22,0xF4
    09D00 E0E1      LDI	R30,1
    09D01 077E      CPC	R23,R30
(0194) 		pTestQueue = &TestQueueA;
    09D02 F411      BNE	0x9D05
    09D03 2766      CLR	R22
    09D04 2777      CLR	R23
(0195) 	else
(0196) 		pTestQueue = &TestQueueB;
    09D05 9370 1A70 STS	uart0TxdBuf+503,R23
(0197) 	
(0198) 	inst0 = 0;
    09D07 9360 1A6F STS	uart0TxdBuf+502,R22
(0199) 	inst1 = 0;
    09D09 9180 17E8 LDS	R24,ControlModel+16
    09D0B 3081      CPI	R24,1
    09D0C F551      BNE	0x9D37
    09D0D 9180 17E6 LDS	R24,ControlModel+14
    09D0F 9190 17E7 LDS	R25,ControlModel+15
    09D11 9601      ADIW	R24,1
    09D12 9390 17E7 STS	ControlModel+15,R25
(0200) 	// 测试队列插入位置计算
(0201) 	if(testTime0)
(0202) 		inst0 = TestQueueInsertCalculate(pTestQueue,testTime0);
    09D14 9380 17E6 STS	ControlModel+14,R24
    09D16 E780      LDI	R24,0x70
    09D17 E197      LDI	R25,0x17
    09D18 9020 17E6 LDS	R2,ControlModel+14
(0203) 	if(testTime1)
    09D1A 9030 17E7 LDS	R3,ControlModel+15
    09D1C 1582      CP	R24,R2
    09D1D 0593      CPC	R25,R3
    09D1E F008      BCS	0x9D20
    09D1F C0B4      RJMP	0x9DD4
    09D20 2422      CLR	R2
    09D21 2433      CLR	R3
    09D22 9230 17E7 STS	ControlModel+15,R3
(0204) 		inst1 = TestQueueInsertCalculate(pTestQueue,testTime1);
    09D24 9220 17E6 STS	ControlModel+14,R2
    09D26 9220 17E8 STS	ControlModel+16,R2
    09D28 9180 00C1 LDS	R24,0xC1
(0205) 	if(inst0 != 0xff && inst1 != 0xff){		// 如果有两个测试时间，则必需要两个测试都插入成功才可以插入本次测试到测试队列
    09D2A 7E8F      ANDI	R24,0xEF
    09D2B 9380 00C1 STS	0xC1,R24
    09D2D E703      LDI	R16,0x73
(0206) 		// 测试插入计算成功，开始插入
(0207) 		if(testTime0)
    09D2E E019      LDI	R17,0x9
    09D2F 940E A90D CALL	_uart_Printf
    09D31 9180 00C1 LDS	R24,0xC1
    09D33 6180      ORI	R24,0x10
    09D34 9380 00C1 STS	0xC1,R24
    09D36 C09D      RJMP	0x9DD4
    09D37 2422      CLR	R2
(0208) 			TestQueueInsert(pTestQueue,inst0,ringNum,testTime0);
    09D38 2433      CLR	R3
    09D39 9230 17E7 STS	ControlModel+15,R3
    09D3B 9220 17E6 STS	ControlModel+14,R2
    09D3D C096      RJMP	0x9DD4
    09D3E 9160 1A6F LDS	R22,uart0TxdBuf+502
(0209) 		if(testTime1)
    09D40 9170 1A70 LDS	R23,uart0TxdBuf+503
    09D42 90A0 1A6D LDS	R10,uart0TxdBuf+500
    09D44 90B0 1A6E LDS	R11,uart0TxdBuf+501
    09D46 156A      CP	R22,R10
    09D47 057B      CPC	R23,R11
    09D48 F409      BNE	0x9D4A
    09D49 C08A      RJMP	0x9DD4
(0210) 			TestQueueInsert(pTestQueue,inst1,ringNum,testTime1);
    09D4A 9020 00C0 LDS	R2,0xC0
    09D4C FE25      SBRS	R2,5
    09D4D C086      RJMP	0x9DD4
    09D4E E789      LDI	R24,0x79
    09D4F E198      LDI	R25,0x18
    09D50 01FB      MOVW	R30,R22
    09D51 0FE8      ADD	R30,R24
(0211) 		// 同时计算卸片时间并放入卸片队列
(0212) 		
(0213) 		return 0;
    09D52 1FF9      ADC	R31,R25
    09D53 8140      LD	R20,Z
(0214) 		}
(0215) 	else{
(0216) 		return 0xff;
    09D54 9340 00C6 STS	0xC6,R20
    09D56 5F6F      SUBI	R22,0xFF
    09D57 4F7F      SBCI	R23,0xFF
_printf_TestProcess_StepState:
    09D58 3F64      CPI	R22,0xF4
(0217) 		}
(0218) }
(0219) 
(0220) static unsigned char TestAProcess_workStep,TestAProcess_mainStep;
(0221) static unsigned char TestBProcess_workStep,TestBProcess_mainStep;
(0222) 
(0223) void printf_TestProcess_StepState(void)
(0224) {
(0225) 	uart_Printf("*3204 TestAStepState $%2d $%2d\r\n",TestAProcess_mainStep,TestAProcess_workStep);
    09D59 E0E1      LDI	R30,1
    09D5A 077E      CPC	R23,R30
    09D5B F411      BNE	0x9D5E
    09D5C 2766      CLR	R22
    09D5D 2777      CLR	R23
    09D5E 9370 1A70 STS	uart0TxdBuf+503,R23
    09D60 9360 1A6F STS	uart0TxdBuf+502,R22
    09D62 304D      CPI	R20,0xD
    09D63 F009      BEQ	0x9D65
    09D64 C06F      RJMP	0x9DD4
(0226) 	uart_Printf("*3205 TestBStepState $%2d $%2d\r\n",TestBProcess_mainStep,TestBProcess_workStep);
    09D65 2422      CLR	R2
    09D66 9220 0972 STS	_Adc_DiffBufPnt+3,R2
    09D68 C06B      RJMP	0x9DD4
    09D69 EE8A      LDI	R24,0xEA
    09D6A E197      LDI	R25,0x17
    09D6B 91E0 17E9 LDS	R30,ControlModel+17
    09D6D 27FF      CLR	R31
    09D6E 0FE8      ADD	R30,R24
    09D6F 1FF9      ADC	R31,R25
    09D70 8020      LD	R2,Z
    09D71 2022      TST	R2
    09D72 F069      BEQ	0x9D80
_TestAQueueProcess:
  i                    --> Y,+5
  j                    --> R10
  ucTmp                --> R10
  l                    --> Y,+4
    09D73 91E0 17E9 LDS	R30,ControlModel+17
    09D75 27FF      CLR	R31
(0227) }
(0228) 
(0229) extern unsigned char _TestAMainStep, _TestAWorkStep;
(0230) unsigned char ReReadFlag; 		// 重新读取标记，在测试周期将此变量赋值将重新运行转盘和读数
(0231) unsigned char TestAQueueProcess(void){
(0232) 	// 监测测试队列上的测试时间，将到时间的测试任务启动
(0233) 	static unsigned char mainStep;		
(0234) 	static unsigned char workStep;
(0235) 	static unsigned char inWork;
(0236) 	static unsigned char ringNum;
(0237) 	static unsigned char watiMotTurnplate, waitMotLifter;
(0238) 	unsigned char ucTmp;
(0239) 	unsigned int i,j;
(0240) 	unsigned long l;
(0241) 	
(0242) 	TestAProcess_mainStep = mainStep;
    09D76 0FE8      ADD	R30,R24
    09D77 1FF9      ADC	R31,R25
    09D78 8100      LD	R16,Z
    09D79 D094      RCALL	_uart0SendChar
(0243) 	TestAProcess_workStep = workStep;
    09D7A 9180 17E9 LDS	R24,ControlModel+17
    09D7C 5F8F      SUBI	R24,0xFF
    09D7D 9380 17E9 STS	ControlModel+17,R24
(0244) 	
(0245) 	if(inWork){
    09D7F C054      RJMP	0x9DD4
    09D80 E00D      LDI	R16,0xD
    09D81 D08C      RCALL	_uart0SendChar
(0246) 		if(WaitDelayTime(MOT_TURN_PLATE)){
    09D82 E00A      LDI	R16,0xA
    09D83 D08A      RCALL	_uart0SendChar
    09D84 2422      CLR	R2
    09D85 9220 17E9 STS	ControlModel+17,R2
(0247) 			if(mainStep == 5){	// 测试期间
    09D87 E081      LDI	R24,1
    09D88 9380 17E8 STS	ControlModel+16,R24
    09D8A 9220 0972 STS	_Adc_DiffBufPnt+3,R2
(0248) 				if(ReReadFlag == 1){	// 重新测试标记
    09D8C C047      RJMP	0x9DD4
    09D8D EE8A      LDI	R24,0xEA
    09D8E E197      LDI	R25,0x17
(0249) 					MotRunToSite(MOT_TURN_PLATE,TestQueueA.ringNum[0]);		// 转盘转动
    09D8F 91E0 17E9 LDS	R30,ControlModel+17
    09D91 27FF      CLR	R31
    09D92 0FE8      ADD	R30,R24
    09D93 1FF9      ADC	R31,R25
(0250) 					ReReadFlag = 0;		// 执行完后清除重测标识
    09D94 8020      LD	R2,Z
    09D95 2022      TST	R2
    09D96 F099      BEQ	0x9DAA
(0251) 					watiMotTurnplate = 1;
    09D97 E081      LDI	R24,1
    09D98 9380 096A STS	checkFlag,R24
(0252) 					mainStep = 1;
    09D9A EE8A      LDI	R24,0xEA
    09D9B E197      LDI	R25,0x17
(0253) 					}
(0254) 				if(ReadColseAnswer){	// 接收到检测完成应答信号，关闭检测
    09D9C 91E0 17E9 LDS	R30,ControlModel+17
    09D9E 27FF      CLR	R31
    09D9F 0FE8      ADD	R30,R24
(0255) 					SetDelayTime(MOT_TURN_PLATE, 5);
    09DA0 1FF9      ADC	R31,R25
    09DA1 8100      LD	R16,Z
    09DA2 940E 2D35 CALL	_CommandExplain
    09DA4 9180 17E9 LDS	R24,ControlModel+17
(0256) 					ReadColseAnswer = 0;
    09DA6 5F8F      SUBI	R24,0xFF
    09DA7 9380 17E9 STS	ControlModel+17,R24
(0257) 					}
(0258) 				}
(0259) 			return 0;
    09DA9 C02A      RJMP	0x9DD4
(0260) 			}
(0261) 		if(watiMotTurnplate){	if(GetMotState(MOT_TURN_PLATE)!=STA_SLAVE_FREE)	return 0;	watiMotTurnplate = 0;	}
    09DAA 2422      CLR	R2
    09DAB 9220 096A STS	checkFlag,R2
    09DAD 9220 17E9 STS	ControlModel+17,R2
    09DAF 9220 0972 STS	_Adc_DiffBufPnt+3,R2
    09DB1 C022      RJMP	0x9DD4
    09DB2 EE8A      LDI	R24,0xEA
    09DB3 E197      LDI	R25,0x17
    09DB4 91E0 17E9 LDS	R30,ControlModel+17
    09DB6 27FF      CLR	R31
    09DB7 0FE8      ADD	R30,R24
(0262) 		}
(0263) 	switch(mainStep){
    09DB8 1FF9      ADC	R31,R25
    09DB9 8020      LD	R2,Z
    09DBA 2022      TST	R2
    09DBB F069      BEQ	0x9DC9
    09DBC 91E0 17E9 LDS	R30,ControlModel+17
    09DBE 27FF      CLR	R31
    09DBF 0FE8      ADD	R30,R24
    09DC0 1FF9      ADC	R31,R25
    09DC1 8100      LD	R16,Z
    09DC2 D04B      RCALL	_uart0SendChar
    09DC3 9180 17E9 LDS	R24,ControlModel+17
    09DC5 5F8F      SUBI	R24,0xFF
    09DC6 9380 17E9 STS	ControlModel+17,R24
    09DC8 C00B      RJMP	0x9DD4
    09DC9 E00D      LDI	R16,0xD
    09DCA D043      RCALL	_uart0SendChar
    09DCB E00A      LDI	R16,0xA
    09DCC D041      RCALL	_uart0SendChar
    09DCD E105      LDI	R16,0x15
    09DCE D03F      RCALL	_uart0SendChar
    09DCF 2422      CLR	R2
    09DD0 9220 17E9 STS	ControlModel+17,R2
    09DD2 9220 0972 STS	_Adc_DiffBufPnt+3,R2
    09DD4 940C AE9E JMP	pop_xgsetF00C
_uart0SendData:
    09DD6 940E AEB3 CALL	push_xgsetF03C
    09DD8 E081      LDI	R24,1
    09DD9 9380 0969 STS	uartBufProtect,R24
    09DDB 90A0 1A6F LDS	R10,uart0TxdBuf+502
    09DDD 90B0 1A70 LDS	R11,uart0TxdBuf+503
    09DDF 9140 1A6D LDS	R20,uart0TxdBuf+500
    09DE1 9150 1A6E LDS	R21,uart0TxdBuf+501
    09DE3 2766      CLR	R22
    09DE4 2777      CLR	R23
    09DE5 C01B      RJMP	0x9E01
    09DE6 016A      MOVW	R12,R20
    09DE7 5F4F      SUBI	R20,0xFF
    09DE8 4F5F      SBCI	R21,0xFF
(0264) 		case 0:		// 监测队头的测试时间
(0265) 			if(TestQueueA.ringNum[0] == 0xff)
    09DE9 3F44      CPI	R20,0xF4
    09DEA E0E1      LDI	R30,1
    09DEB 075E      CPC	R21,R30
    09DEC F411      BNE	0x9DEF
(0266) 			{
(0267) 		//		if(LampAState != 0)		// 无测试任务,关闭测试光源
(0268) 		//			TestALampClose();
(0269) 				return 1;	// 无测试任务
    09DED 2744      CLR	R20
    09DEE 2755      CLR	R21
(0270) 			}
(0271) 			else
(0272) 			{
(0273) 		//		if(LampAState == 0)		// 有测试任务,开启光源
(0274) 		//			TestALampOpen();
(0275) 			}
(0276) 			if(TestQueueA.testTime[0] != 0)
    09DEF 154A      CP	R20,R10
    09DF0 055B      CPC	R21,R11
    09DF1 F059      BEQ	0x9DFD
    09DF2 01FB      MOVW	R30,R22
    09DF3 0FE0      ADD	R30,R16
    09DF4 1FF1      ADC	R31,R17
    09DF5 8020      LD	R2,Z
    09DF6 E789      LDI	R24,0x79
    09DF7 E198      LDI	R25,0x18
    09DF8 01F6      MOVW	R30,R12
    09DF9 0FE8      ADD	R30,R24
    09DFA 1FF9      ADC	R31,R25
    09DFB 8220      ST	Z,R2
    09DFC C002      RJMP	0x9DFF
    09DFD 01A6      MOVW	R20,R12
(0277) 			{
(0278) 				ringNum = TestQueueA.ringNum[0];
    09DFE C005      RJMP	0x9E04
    09DFF 5F6F      SUBI	R22,0xFF
    09E00 4F7F      SBCI	R23,0xFF
    09E01 1762      CP	R22,R18
(0279) 				if(SecondCount > (TestQueueA.testTime[0]-10))
    09E02 0773      CPC	R23,R19
    09E03 F310      BCS	0x9DE6
    09E04 9350 1A6E STS	uart0TxdBuf+501,R21
    09E06 9340 1A6D STS	uart0TxdBuf+500,R20
    09E08 2422      CLR	R2
    09E09 9220 0969 STS	uartBufProtect,R2
    09E0B E001      LDI	R16,1
    09E0C 940C AEBC JMP	pop_xgsetF03C
_uart0SendChar:
    09E0E 940E AEA5 CALL	push_xgset303C
    09E10 2300      TST	R16
    09E11 F131      BEQ	0x9E38
    09E12 90C0 1A6F LDS	R12,uart0TxdBuf+502
    09E14 90D0 1A70 LDS	R13,uart0TxdBuf+503
    09E16 9140 1A6D LDS	R20,uart0TxdBuf+500
    09E18 9150 1A6E LDS	R21,uart0TxdBuf+501
    09E1A 015A      MOVW	R10,R20
    09E1B 5F4F      SUBI	R20,0xFF
    09E1C 4F5F      SBCI	R21,0xFF
    09E1D 3F44      CPI	R20,0xF4
    09E1E E0E1      LDI	R30,1
    09E1F 075E      CPC	R21,R30
(0280) 				{
(0281) 					// 测试时间到
(0282) 					if(TurnPlateUsedLock == 0)
    09E20 F411      BNE	0x9E23
    09E21 2744      CLR	R20
    09E22 2755      CLR	R21
    09E23 154C      CP	R20,R12
    09E24 055D      CPC	R21,R13
(0283) 					{
(0284) 						if(255 == insertflag[ringNum])
    09E25 F039      BEQ	0x9E2D
    09E26 E789      LDI	R24,0x79
    09E27 E198      LDI	R25,0x18
    09E28 01F5      MOVW	R30,R10
    09E29 0FE8      ADD	R30,R24
    09E2A 1FF9      ADC	R31,R25
    09E2B 8300      ST	Z,R16
    09E2C C002      RJMP	0x9E2F
    09E2D E001      LDI	R16,1
    09E2E C00A      RJMP	0x9E39
    09E2F 9350 1A6E STS	uart0TxdBuf+501,R21
(0285) 						{
(0286) 							insertflag[ringNum] = 200;
    09E31 9340 1A6D STS	uart0TxdBuf+500,R20
    09E33 2422      CLR	R2
    09E34 9220 0969 STS	uartBufProtect,R2
    09E36 2700      CLR	R16
    09E37 C001      RJMP	0x9E39
    09E38 E001      LDI	R16,1
(0287) 							Uart0ReUnable;
    09E39 940C AEAC JMP	pop_xgset303C
_uart0SendString:
    09E3B 940E AEA5 CALL	push_xgset303C
    09E3D E081      LDI	R24,1
(0288) 							uart_Printf("%s $%4d $%4d\r\n",strM3122,ringNum,insertflag[ringNum]);
    09E3E 9380 0969 STS	uartBufProtect,R24
    09E40 90A0 1A6F LDS	R10,uart0TxdBuf+502
    09E42 90B0 1A70 LDS	R11,uart0TxdBuf+503
    09E44 9140 1A6D LDS	R20,uart0TxdBuf+500
    09E46 9150 1A6E LDS	R21,uart0TxdBuf+501
    09E48 C01E      RJMP	0x9E67
    09E49 016A      MOVW	R12,R20
    09E4A 5F4F      SUBI	R20,0xFF
    09E4B 4F5F      SBCI	R21,0xFF
    09E4C 3F44      CPI	R20,0xF4
    09E4D E0E1      LDI	R30,1
    09E4E 075E      CPC	R21,R30
    09E4F F411      BNE	0x9E52
    09E50 2744      CLR	R20
    09E51 2755      CLR	R21
    09E52 154A      CP	R20,R10
    09E53 055B      CPC	R21,R11
(0289) 							Uart0ReEnable;
    09E54 F081      BEQ	0x9E65
    09E55 E789      LDI	R24,0x79
    09E56 E198      LDI	R25,0x18
    09E57 01F6      MOVW	R30,R12
    09E58 0FE8      ADD	R30,R24
(0290) 							TurnPlateUsedLock = 1;		// 占用转盘标识
    09E59 1FF9      ADC	R31,R25
    09E5A 01D8      MOVW	R26,R16
    09E5B 93FA      ST	-Y,R31
(0291) 							//mainStep = 1;
(0292) 							mainStep = 10;
    09E5C 93EA      ST	-Y,R30
    09E5D 01FD      MOVW	R30,R26
    09E5E 9026      ELPM	R2,Z
(0293) 							workStep = 0;
    09E5F 91E9      LD	R30,Y+
    09E60 91F9      LD	R31,Y+
    09E61 8220      ST	Z,R2
(0294) 							inWork = 1; 
    09E62 5F0F      SUBI	R16,0xFF
    09E63 4F1F      SBCI	R17,0xFF
    09E64 C002      RJMP	0x9E67
(0295) 						}
(0296) 					}
(0297) 				}
(0298) 			}
(0299) 			break;
    09E65 01A6      MOVW	R20,R12
(0300) 		case 10:
(0301) 			SetMotRunPam(MOT_TURN_PLATE,200,20,CURRENT_TURN_PLATE);// 140,2
    09E66 C004      RJMP	0x9E6B
    09E67 01F8      MOVW	R30,R16
    09E68 9026      ELPM	R2,Z
    09E69 2022      TST	R2
    09E6A F6F1      BNE	0x9E49
    09E6B 9350 1A6E STS	uart0TxdBuf+501,R21
    09E6D 9340 1A6D STS	uart0TxdBuf+500,R20
(0302) 			MotRunToSite(MOT_TURN_PLATE,0);		// 转盘转到零位	
    09E6F 2422      CLR	R2
    09E70 9220 0969 STS	uartBufProtect,R2
(0303) 			watiMotTurnplate = 1;
    09E72 E001      LDI	R16,1
    09E73 940C AEAC JMP	pop_xgset303C
(0304) 			mainStep = 11;
_uart0GetChar:
    09E75 9120 1878 LDS	R18,uart0RxdBuf+2
    09E77 9100 1877 LDS	R16,uart0RxdBuf+1
(0305) 			break;
    09E79 1702      CP	R16,R18
    09E7A F411      BNE	0x9E7D
    09E7B 2700      CLR	R16
    09E7C C016      RJMP	0x9E93
    09E7D E786      LDI	R24,0x76
(0306) 		case 11:
(0307) 			SetDelayTime(MOT_TURN_PLATE,2);
(0308) 			mainStep = 1;
    09E7E E198      LDI	R25,0x18
    09E7F 2FE2      MOV	R30,R18
    09E80 27FF      CLR	R31
(0309) 			break;
    09E81 0FE8      ADD	R30,R24
(0310) 		case 1:		// 转盘转到当前位置
(0311) 		//	ringNum = TestQueueA.ringNum[0];
(0312) 			ucTmp = ringNum + 11;
    09E82 1FF9      ADC	R31,R25
    09E83 8100      LD	R16,Z
    09E84 2FE2      MOV	R30,R18
    09E85 27FF      CLR	R31
(0313) #ifndef UartSendLong
(0314) 			Uart0ReUnable;
(0315) 			uart_Printf("%s $%8d",strM3148,RingQueue.sampInfo[ringNum].testSerial);//2016-05-17
(0316) #else
(0317) 			Uart0ReUnable;
    09E86 0FE8      ADD	R30,R24
    09E87 1FF9      ADC	R31,R25
    09E88 2422      CLR	R2
    09E89 8220      ST	Z,R2
    09E8A 9180 1878 LDS	R24,uart0RxdBuf+2
(0318) 			uart_Printf("%s $ ",strM3148);
    09E8C 5F8F      SUBI	R24,0xFF
    09E8D 9380 1878 STS	uart0RxdBuf+2,R24
    09E8F 3081      CPI	R24,1
    09E90 F411      BNE	0x9E93
(0319) 			uart0SendInt(RingQueue.sampInfo[ringNum].testSerial);
    09E91 9220 1878 STS	uart0RxdBuf+2,R2
    09E93 9508      RET
_RingQueueDatInit:
    09E94 E723      LDI	R18,0x73
    09E95 E13A      LDI	R19,0x1A
    09E96 2700      CLR	R16
    09E97 2711      CLR	R17
    09E98 C006      RJMP	0x9E9F
    09E99 2422      CLR	R2
    09E9A 01F9      MOVW	R30,R18
    09E9B 9221      ST	Z+,R2
    09E9C 019F      MOVW	R18,R30
    09E9D 5F0F      SUBI	R16,0xFF
    09E9E 4F1F      SBCI	R17,0xFF
    09E9F 3A05      CPI	R16,0xA5
(0320) #endif
(0321) 			uart_Printf(" $%4d\r\n",ringNum);//2016-05-17
    09EA0 E0E1      LDI	R30,1
    09EA1 071E      CPC	R17,R30
    09EA2 F3B0      BCS	0x9E99
    09EA3 2422      CLR	R2
    09EA4 9220 1C18 STS	TurnPlateUsedLock,R2
    09EA6 9508      RET
(0322) 			Uart0ReUnable;
_RingQueueInsertCalculate:
    09EA7 934A      ST	-Y,R20
    09EA8 936A      ST	-Y,R22
    09EA9 9722      SBIW	R28,2
    09EAA 9140 1C17 LDS	R20,LampAState+356
(0323) 			if(ucTmp>=RING_QUEUE_NUM)
    09EAC E16E      LDI	R22,0x1E
    09EAD C00E      RJMP	0x9EBC
    09EAE 9543      INC	R20
(0324) 				ucTmp -= RING_QUEUE_NUM;
    09EAF 314E      CPI	R20,0x1E
    09EB0 F409      BNE	0x9EB2
(0325) 			SetMotRunPam(MOT_TURN_PLATE,200,20,CURRENT_TURN_PLATE);// 140,2
    09EB1 2744      CLR	R20
    09EB2 EF89      LDI	R24,0xF9
    09EB3 E19B      LDI	R25,0x1B
    09EB4 2FE4      MOV	R30,R20
    09EB5 27FF      CLR	R31
    09EB6 0FE8      ADD	R30,R24
    09EB7 1FF9      ADC	R31,R25
    09EB8 8020      LD	R2,Z
(0326) 			MotRunToSite(MOT_TURN_PLATE,ucTmp);		// 转盘转到当前位置			
    09EB9 2022      TST	R2
    09EBA F409      BNE	0x9EBC
    09EBB C005      RJMP	0x9EC1
    09EBC 2E26      MOV	R2,R22
(0327) 			watiMotTurnplate = 1;
    09EBD 2433      CLR	R3
    09EBE 5061      SUBI	R22,1
    09EBF 2022      TST	R2
(0328) 			mainStep = 2;
    09EC0 F769      BNE	0x9EAE
    09EC1 3F6F      CPI	R22,0xFF
    09EC2 F4B9      BNE	0x9EDA
(0329) 			break;
    09EC3 9180 00C1 LDS	R24,0xC1
(0330) 		case 2:
(0331) 			MotRun(MOT_TURN_PLATE, 100);	// 20
    09EC5 7E8F      ANDI	R24,0xEF
    09EC6 9380 00C1 STS	0xC1,R24
    09EC8 9020 1C17 LDS	R2,LampAState+356
(0332) 			watiMotTurnplate = 1;
    09ECA 2433      CLR	R3
    09ECB 8239      STD	Y+1,R3
(0333) 			SetDelayTime(MOT_TURN_PLATE, 5);
    09ECC 8228      ST	Y,R2
    09ECD EC22      LDI	R18,0xC2
    09ECE E135      LDI	R19,0x15
    09ECF EB0B      LDI	R16,0xBB
    09ED0 E019      LDI	R17,0x9
(0334) 			mainStep = 3;
    09ED1 940E A90D CALL	_uart_Printf
    09ED3 9180 00C1 LDS	R24,0xC1
(0335) 			break;
    09ED5 6180      ORI	R24,0x10
    09ED6 9380 00C1 STS	0xC1,R24
    09ED8 EF0F      LDI	R16,0xFF
    09ED9 C003      RJMP	0x9EDD
    09EDA 9340 1C17 STS	LampAState+356,R20
    09EDC 2F04      MOV	R16,R20
(0336) 		case 3:
(0337) 			//MotRun(MOT_TURN_PLATE, -120);	// 20
(0338) 			//2016-06-16 回来的少走一点，速度变慢
(0339) 			SetMotRunPam(MOT_TURN_PLATE,140,20,CURRENT_TURN_PLATE);// 140,2
(0340) 			MotRun(MOT_TURN_PLATE, -110);	// 20
    09EDD 9622      ADIW	R28,2
    09EDE 9169      LD	R22,Y+
    09EDF 9149      LD	R20,Y+
    09EE0 9508      RET
_RingQueueInsert:
    09EE1 940E AE7E CALL	push_xgset003C
(0341) 			////////////////////////////////////////
(0342) 			watiMotTurnplate = 1;
    09EE3 0159      MOVW	R10,R18
    09EE4 2EC0      MOV	R12,R16
(0343) 			SetDelayTime(MOT_TURN_PLATE, 10);
    09EE5 9721      SBIW	R28,1
    09EE6 E08D      LDI	R24,0xD
    09EE7 8388      ST	Y,R24
    09EE8 E00D      LDI	R16,0xD
    09EE9 2D1C      MOV	R17,R12
(0344) 			ReReadFlag = 0;	// 重测标识初始化
    09EEA 0301      MULSU	R16,R17
    09EEB 0190      MOVW	R18,R0
    09EEC E783      LDI	R24,0x73
(0345) 			if(LampAState == 0)
    09EED E19A      LDI	R25,0x1A
    09EEE 0F28      ADD	R18,R24
    09EEF 1F39      ADC	R19,R25
    09EF0 0185      MOVW	R16,R10
(0346) 				TestALampOpen();
    09EF1 940E 7118 CALL	_MemCopy
(0347) 			mainStep = 4;
    09EF3 9621      ADIW	R28,1
    09EF4 940C AE58 JMP	pop_xgset003C
(0348) 			break;
_RingQueueDelete:
    09EF6 EF89      LDI	R24,0xF9
    09EF7 E19B      LDI	R25,0x1B
    09EF8 2FE0      MOV	R30,R16
    09EF9 27FF      CLR	R31
    09EFA 0FE8      ADD	R30,R24
    09EFB 1FF9      ADC	R31,R25
    09EFC 2422      CLR	R2
    09EFD 8220      ST	Z,R2
    09EFE 9508      RET
_SetRingQueueUnitUsed:
    09EFF EF89      LDI	R24,0xF9
    09F00 E19B      LDI	R25,0x1B
    09F01 2FE0      MOV	R30,R16
    09F02 27FF      CLR	R31
    09F03 0FE8      ADD	R30,R24
    09F04 1FF9      ADC	R31,R25
    09F05 E081      LDI	R24,1
    09F06 8380      ST	Z,R24
    09F07 9508      RET
_TestALampOpen:
    09F08 9180 0101 LDS	R24,0x101
    09F0A 6780      ORI	R24,0x70
(0349) 		case 4:		// 开始检测
(0350) 			if(SecondCount < (TestQueueA.testTime[0]))
(0351) 				break;
    09F0B 9380 0101 STS	0x101,R24
(0352) 			ringNum = TestQueueA.ringNum[0];
    09F0D 9180 0102 LDS	R24,0x102
    09F0F 7C8F      ANDI	R24,0xCF
(0353) 			// 开启检测光源
(0354) 		//	TestALampOpen();
(0355) 			l = RingQueue.sampInfo[ringNum].testSerial;
    09F10 9380 0102 STS	0x102,R24
    09F12 9180 0102 LDS	R24,0x102
    09F14 6480      ORI	R24,0x40
    09F15 9380 0102 STS	0x102,R24
    09F17 E081      LDI	R24,1
    09F18 9380 1C2E STS	ReReadFlag+7,R24
    09F1A 9508      RET
_TestALampClose:
    09F1B 9180 0101 LDS	R24,0x101
    09F1D 788F      ANDI	R24,0x8F
    09F1E 9380 0101 STS	0x101,R24
(0356) 		//	j = RingQueue.sampInfo[ringNum].testTime0;
(0357) 			j = RingQueue.sampInfo[ringNum].testTime0+(unsigned int)(SecondCount-(TestQueueA.testTime[0]));
    09F20 9180 0102 LDS	R24,0x102
    09F22 788F      ANDI	R24,0x8F
    09F23 9380 0102 STS	0x102,R24
    09F25 2422      CLR	R2
    09F26 9220 1C2E STS	ReReadFlag+7,R2
    09F28 9508      RET
_TestBLampOpen:
    09F29 9180 010A LDS	R24,0x10A
    09F2B 6780      ORI	R24,0x70
    09F2C 9380 010A STS	0x10A,R24
    09F2E 9180 010B LDS	R24,0x10B
    09F30 7C8F      ANDI	R24,0xCF
    09F31 9380 010B STS	0x10B,R24
    09F33 9180 010B LDS	R24,0x10B
    09F35 6480      ORI	R24,0x40
    09F36 9380 010B STS	0x10B,R24
    09F38 E081      LDI	R24,1
    09F39 9380 1C2D STS	ReReadFlag+6,R24
    09F3B 9508      RET
_TestBLampClose:
    09F3C 9180 010A LDS	R24,0x10A
(0358) #ifndef UartSendLong
(0359) 			Uart0ReUnable;
(0360) 			uart_Printf("%s $%8d",strM3112, l);
(0361) 			uart_Printf(" $%4d $%4d",j, ringNum);
(0362) 			uart_Printf(" $%8d\r\n",(unsigned long)SecondCount);
(0363) 			Uart0ReUnable;
(0364) #else
(0365) 			Uart0ReUnable;
    09F3E 788F      ANDI	R24,0x8F
    09F3F 9380 010A STS	0x10A,R24
    09F41 9180 010B LDS	R24,0x10B
(0366) 			uart_Printf("%s $ ",strM3112);
    09F43 788F      ANDI	R24,0x8F
    09F44 9380 010B STS	0x10B,R24
    09F46 2422      CLR	R2
    09F47 9220 1C2D STS	ReReadFlag+6,R2
(0367) 			uart0SendInt(l);
    09F49 9508      RET
_ReSetTestLampPWM:
    09F4A 934A      ST	-Y,R20
    09F4B 935A      ST	-Y,R21
    09F4C 2F40      MOV	R20,R16
    09F4D 9724      SBIW	R28,4
    09F4E 3044      CPI	R20,4
(0368) 			uart_Printf(" $%4d $%4d $ ",j, ringNum);
    09F4F F008      BCS	0x9F51
    09F50 C04B      RJMP	0x9F9C
    09F51 E082      LDI	R24,2
    09F52 E090      LDI	R25,0
    09F53 8399      STD	Y+1,R25
    09F54 8388      ST	Y,R24
    09F55 019E      MOVW	R18,R28
    09F56 5F2E      SUBI	R18,0xFE
    09F57 4F3F      SBCI	R19,0xFF
    09F58 2F04      MOV	R16,R20
(0369) 			uart0SendInt(SecondCount);
    09F59 2711      CLR	R17
    09F5A 0F00      LSL	R16
    09F5B 1F11      ROL	R17
    09F5C 5A0C      SUBI	R16,0xAC
    09F5D 4F1F      SBCI	R17,0xFF
    09F5E 940E AF2A CALL	_EEPROMReadBytes_extIO
    09F60 2755      CLR	R21
    09F61 3040      CPI	R20,0
    09F62 0745      CPC	R20,R21
(0370) 			uart_Printf("\r\n");
    09F63 F069      BEQ	0x9F71
    09F64 3041      CPI	R20,1
    09F65 E0E0      LDI	R30,0
    09F66 075E      CPC	R21,R30
(0371) 			Uart0ReUnable;
    09F67 F0A1      BEQ	0x9F7C
    09F68 3042      CPI	R20,2
    09F69 E0E0      LDI	R30,0
    09F6A 075E      CPC	R21,R30
    09F6B F0D9      BEQ	0x9F87
(0372) #endif
(0373) 			ReadColseAnswer = 0;	// 测试开始初始化关闭信号
    09F6C 3043      CPI	R20,3
    09F6D E0E0      LDI	R30,0
    09F6E 075E      CPC	R21,R30
(0374) 			SetDelayTime(MOT_TURN_PLATE, 100);	// 读数延迟
    09F6F F111      BEQ	0x9F92
    09F70 C02B      RJMP	0x9F9C
    09F71 802A      LDD	R2,Y+2
    09F72 803B      LDD	R3,Y+3
    09F73 2C23      MOV	R2,R3
(0375) 			mainStep = 5;
    09F74 2433      CLR	R3
    09F75 9220 00AB STS	0xAB,R2
(0376) 			break;
    09F77 802A      LDD	R2,Y+2
(0377) 		case 5:		// 检测完毕,释放转盘使用权,关闭检测光源
(0378) 			l = RingQueue.sampInfo[ringNum].testSerial;
    09F78 803B      LDD	R3,Y+3
    09F79 9220 00AA STS	0xAA,R2
    09F7B C020      RJMP	0x9F9C
    09F7C 802A      LDD	R2,Y+2
    09F7D 803B      LDD	R3,Y+3
    09F7E 2C23      MOV	R2,R3
    09F7F 2433      CLR	R3
    09F80 9220 00AD STS	0xAD,R2
    09F82 802A      LDD	R2,Y+2
    09F83 803B      LDD	R3,Y+3
    09F84 9220 00AC STS	0xAC,R2
    09F86 C015      RJMP	0x9F9C
    09F87 802A      LDD	R2,Y+2
    09F88 803B      LDD	R3,Y+3
(0379) #ifndef UartSendLong
(0380) 			Uart0ReUnable;
(0381) 			uart_Printf("%s $%8d",strM3114, l);
(0382) 			uart_Printf(" $%8d\r\n",(unsigned long)SecondCount);
(0383) 			Uart0ReEnable;
(0384) #else
(0385) 			Uart0ReUnable;
    09F89 2C23      MOV	R2,R3
    09F8A 2433      CLR	R3
    09F8B 9220 012B STS	0x12B,R2
    09F8D 802A      LDD	R2,Y+2
(0386) 			uart_Printf("%s $ ",strM3114);
    09F8E 803B      LDD	R3,Y+3
    09F8F 9220 012A STS	0x12A,R2
    09F91 C00A      RJMP	0x9F9C
    09F92 802A      LDD	R2,Y+2
    09F93 803B      LDD	R3,Y+3
(0387) 			uart0SendInt(l);
    09F94 2C23      MOV	R2,R3
    09F95 2433      CLR	R3
    09F96 9220 012D STS	0x12D,R2
    09F98 802A      LDD	R2,Y+2
    09F99 803B      LDD	R3,Y+3
(0388) 			uart_Printf(" $ ");
    09F9A 9220 012C STS	0x12C,R2
    09F9C 9624      ADIW	R28,4
    09F9D 9159      LD	R21,Y+
(0389) 			uart0SendInt(SecondCount);
    09F9E 9149      LD	R20,Y+
    09F9F 9508      RET
_ReadTestLampPWM:
    09FA0 934A      ST	-Y,R20
    09FA1 2F40      MOV	R20,R16
    09FA2 9724      SBIW	R28,4
    09FA3 3044      CPI	R20,4
    09FA4 F490      BCC	0x9FB7
    09FA5 E082      LDI	R24,2
    09FA6 E090      LDI	R25,0
    09FA7 8399      STD	Y+1,R25
(0390) 			uart_Printf("\r\n");
    09FA8 8388      ST	Y,R24
    09FA9 019E      MOVW	R18,R28
    09FAA 5F2E      SUBI	R18,0xFE
    09FAB 4F3F      SBCI	R19,0xFF
(0391) 			Uart0ReEnable;
    09FAC 2F04      MOV	R16,R20
    09FAD 2711      CLR	R17
    09FAE 0F00      LSL	R16
    09FAF 1F11      ROL	R17
    09FB0 5A0C      SUBI	R16,0xAC
(0392) #endif
(0393) 			// 关闭检测光源
(0394) 			if(LampAState != 0 && CardNoneUseful == 1)
    09FB1 4F1F      SBCI	R17,0xFF
    09FB2 940E AF2A CALL	_EEPROMReadBytes_extIO
    09FB4 810A      LDD	R16,Y+2
    09FB5 811B      LDD	R17,Y+3
    09FB6 C002      RJMP	0x9FB9
    09FB7 2700      CLR	R16
    09FB8 2711      CLR	R17
(0395) 				TestALampClose();
    09FB9 9624      ADIW	R28,4
(0396) 			TestQueueForward(&TestQueueA);		// 删除已完成的队头任务，队列前进一步
    09FBA 9149      LD	R20,Y+
    09FBB 9508      RET
_AdjustTestLamp:
    09FBC 940E AE8D CALL	push_xgsetF000
(0397) 			
(0398) 		//	MotRunToSite(MOT_TURN_PLATE,0);		// 转盘运行到零位
(0399) 		//	SetDelayTime(MOT_TURN_PLATE, 10);
(0400) 		//	watiMotTurnplate = 1;
(0401) 			mainStep = 6;
    09FBE 01B9      MOVW	R22,R18
    09FBF 2F40      MOV	R20,R16
(0402) 			break;
    09FC0 9724      SBIW	R28,4
(0403) 		case 6:		// 释放转盘使用权
(0404) 			mainStep = 0;
    09FC1 3044      CPI	R20,4
    09FC2 F4F8      BCC	0x9FE2
    09FC3 3060      CPI	R22,0
(0405) 			workStep = 0;
    09FC4 0767      CPC	R22,R23
    09FC5 F411      BNE	0x9FC8
(0406) 			inWork = 0;
    09FC6 E061      LDI	R22,1
    09FC7 E070      LDI	R23,0
(0407) 			TurnPlateUsedLock = 0;
    09FC8 EF8C      LDI	R24,0xFC
    09FC9 E093      LDI	R25,3
(0408) 			TurnPlateUsedLock = 0;
    09FCA 1786      CP	R24,R22
    09FCB 0797      CPC	R25,R23
(0409) 			break;
(0410) 		}
(0411) 	return 0;
    09FCC F410      BCC	0x9FCF
    09FCD EF6C      LDI	R22,0xFC
    09FCE E073      LDI	R23,3
    09FCF 837B      STD	Y+3,R23
_TestBQueueProcess:
  i                    --> Y,+5
  j                    --> R10
  ucTmp                --> R10
  l                    --> Y,+4
    09FD0 836A      STD	Y+2,R22
    09FD1 E082      LDI	R24,2
    09FD2 E090      LDI	R25,0
(0412) }
(0413) 
(0414) unsigned char TestBQueueProcess(void){
(0415) 	// 监测测试队列上的测试时间，将到时间的测试任务启动
(0416) 	static unsigned char mainStep;		
(0417) 	static unsigned char workStep;
(0418) 	static unsigned char inWork;
(0419) 	static unsigned char ringNum;
(0420) 	static unsigned char watiMotTurnplate, waitMotLifter;
(0421) 	static unsigned char ReTestCnt;				// 重复读取计数
(0422) 	unsigned char ucTmp;
(0423) 	unsigned int i, j;
(0424) 	unsigned long l;
(0425) 	TestBProcess_mainStep = mainStep;
    09FD3 8399      STD	Y+1,R25
    09FD4 8388      ST	Y,R24
    09FD5 019E      MOVW	R18,R28
    09FD6 5F2E      SUBI	R18,0xFE
(0426) 	TestBProcess_workStep = workStep;
    09FD7 4F3F      SBCI	R19,0xFF
    09FD8 2F04      MOV	R16,R20
    09FD9 2711      CLR	R17
    09FDA 0F00      LSL	R16
(0427) 	if(inWork){
    09FDB 1F11      ROL	R17
    09FDC 5A0C      SUBI	R16,0xAC
    09FDD 4F1F      SBCI	R17,0xFF
    09FDE 940E AF45 CALL	_EEPROMWriteBytes_extIO
(0428) 		if(WaitDelayTime(MOT_TURN_PLATE))
    09FE0 2F04      MOV	R16,R20
    09FE1 DF68      RCALL	_ReSetTestLampPWM
    09FE2 810A      LDD	R16,Y+2
    09FE3 811B      LDD	R17,Y+3
    09FE4 9624      ADIW	R28,4
(0429) 		{
(0430) 			if(mainStep == 5)	// 测试期间
    09FE5 940C AE92 JMP	pop_xgsetF000
_SetReadCloseAnswer:
    09FE7 E081      LDI	R24,1
    09FE8 9380 1C2C STS	ReReadFlag+5,R24
(0431) 			{
(0432) 				if(ReReadFlag == 1)
    09FEA 9180 00C1 LDS	R24,0xC1
    09FEC 7E8F      ANDI	R24,0xEF
(0433) 				{
(0434) 					ReTestCnt++;
    09FED 9380 00C1 STS	0xC1,R24
    09FEF EB22      LDI	R18,0xB2
    09FF0 E131      LDI	R19,0x11
    09FF1 E308      LDI	R16,0x38
(0435) 					if(ReTestCnt == 1)
    09FF2 E01A      LDI	R17,0xA
    09FF3 940E A90D CALL	_uart_Printf
(0436) 					{
(0437) 						MotRunToSite(MOT_TURN_PLATE,TestQueueB.ringNum[0]);		// 转盘转动
    09FF5 9180 00C1 LDS	R24,0xC1
    09FF7 6180      ORI	R24,0x10
    09FF8 9380 00C1 STS	0xC1,R24
(0438) 						ReReadFlag = 0;		// 执行完后清除重测标识
    09FFA 9508      RET
_TestQueueDatInit:
    09FFB 940E AE8D CALL	push_xgsetF000
(0439) 						watiMotTurnplate = 1;
    09FFD EF68      LDI	R22,0xF8
    09FFE E17C      LDI	R23,0x1C
(0440) 						mainStep = 1;
    09FFF 2744      CLR	R20
    0A000 2755      CLR	R21
(0441) 					}
    0A001 C006      RJMP	0xA008
(0442) 					else
(0443) 					{
(0444) 						ReReadFlag = 0;		// 执行完后清除重测标识
    0A002 2422      CLR	R2
    0A003 01FB      MOVW	R30,R22
    0A004 9221      ST	Z+,R2
(0445) 						mainStep = 21;
    0A005 01BF      MOVW	R22,R30
    0A006 5F4F      SUBI	R20,0xFF
    0A007 4F5F      SBCI	R21,0xFF
(0446) 					}
(0447) 				}
(0448) 				if(ReadColseAnswer){	// 接收到检测完成应答信号，关闭检测
    0A008 3C49      CPI	R20,0xC9
    0A009 E0E0      LDI	R30,0
    0A00A 075E      CPC	R21,R30
    0A00B F3B0      BCS	0xA002
(0449) 					SetDelayTime(MOT_TURN_PLATE, 5);
    0A00C E26F      LDI	R22,0x2F
    0A00D E17C      LDI	R23,0x1C
    0A00E 2744      CLR	R20
    0A00F 2755      CLR	R21
    0A010 C006      RJMP	0xA017
(0450) 					ReadColseAnswer = 0;
    0A011 2422      CLR	R2
    0A012 01FB      MOVW	R30,R22
    0A013 9221      ST	Z+,R2
(0451) 					}
(0452) 				}
(0453) 			return 0;
    0A014 01BF      MOVW	R22,R30
    0A015 5F4F      SUBI	R20,0xFF
(0454) 			}
(0455) 		if(watiMotTurnplate){	if(GetMotState(MOT_TURN_PLATE)!=STA_SLAVE_FREE)	return 0;	watiMotTurnplate = 0;	}
    0A016 4F5F      SBCI	R21,0xFF
    0A017 3C49      CPI	R20,0xC9
    0A018 E0E0      LDI	R30,0
    0A019 075E      CPC	R21,R30
    0A01A F3B0      BCS	0xA011
    0A01B 2744      CLR	R20
    0A01C 2755      CLR	R21
    0A01D C010      RJMP	0xA02E
    0A01E EF88      LDI	R24,0xF8
    0A01F E19C      LDI	R25,0x1C
    0A020 01FA      MOVW	R30,R20
    0A021 0FE8      ADD	R30,R24
    0A022 1FF9      ADC	R31,R25
    0A023 EF8F      LDI	R24,0xFF
(0456) 		}
(0457) 	
(0458) 	switch(mainStep)
    0A024 8380      ST	Z,R24
    0A025 E28F      LDI	R24,0x2F
    0A026 E19C      LDI	R25,0x1C
    0A027 01FA      MOVW	R30,R20
    0A028 0FE8      ADD	R30,R24
    0A029 1FF9      ADC	R31,R25
    0A02A EF8F      LDI	R24,0xFF
    0A02B 8380      ST	Z,R24
    0A02C 5F4F      SUBI	R20,0xFF
    0A02D 4F5F      SBCI	R21,0xFF
    0A02E 3248      CPI	R20,0x28
    0A02F E0E0      LDI	R30,0
    0A030 075E      CPC	R21,R30
    0A031 F360      BCS	0xA01E
    0A032 2700      CLR	R16
    0A033 DF16      RCALL	_ReSetTestLampPWM
    0A034 E001      LDI	R16,1
    0A035 DF14      RCALL	_ReSetTestLampPWM
    0A036 E002      LDI	R16,2
    0A037 DF12      RCALL	_ReSetTestLampPWM
    0A038 E003      LDI	R16,3
    0A039 DF10      RCALL	_ReSetTestLampPWM
    0A03A 940C AE92 JMP	pop_xgsetF000
_TestQueueInsertCalculate:
    0A03C 933A      ST	-Y,R19
    0A03D 932A      ST	-Y,R18
    0A03E 940E AE97 CALL	push_xgsetF00C
    0A040 9724      SBIW	R28,4
    0A041 24AA      CLR	R10
    0A042 C056      RJMP	0xA099
    0A043 01C8      MOVW	R24,R16
    0A044 9688      ADIW	R24,0x28
    0A045 2DEA      MOV	R30,R10
    0A046 27FF      CLR	R31
    0A047 0FEE      LSL	R30
    0A048 1FFF      ROL	R31
    0A049 0FEE      LSL	R30
    0A04A 1FFF      ROL	R31
    0A04B 0FE8      ADD	R30,R24
    0A04C 1FF9      ADC	R31,R25
    0A04D 8020      LD	R2,Z
    0A04E 8031      LDD	R3,Z+1
    0A04F 8042      LDD	R4,Z+2
    0A050 8053      LDD	R5,Z+3
    0A051 8228      ST	Y,R2
    0A052 8239      STD	Y+1,R3
    0A053 824A      STD	Y+2,R4
    0A054 825B      STD	Y+3,R5
    0A055 8028      LD	R2,Y
    0A056 8039      LDD	R3,Y+1
    0A057 804A      LDD	R4,Y+2
    0A058 805B      LDD	R5,Y+3
    0A059 9488      BCLR	0
    0A05A 2022      TST	R2
    0A05B 0432      CPC	R3,R2
    0A05C 0442      CPC	R4,R2
    0A05D 0452      CPC	R5,R2
    0A05E F411      BNE	0xA061
    0A05F 2D0A      MOV	R16,R10
    0A060 C03D      RJMP	0xA09E
(0459) 	{
(0460) 		case 0:		// 监测队头的测试时间
(0461) 			if(TestQueueB.ringNum[0] == 0xff)
    0A061 E04F      LDI	R20,0xF
    0A062 E050      LDI	R21,0
    0A063 E060      LDI	R22,0
    0A064 E070      LDI	R23,0
(0462) 			{
(0463) 			//	if(LampBState != 0)		// 无测试任务,关闭测试光源
(0464) 			//		TestBLampClose();
(0465) 				return 1;
    0A065 8028      LD	R2,Y
    0A066 8039      LDD	R3,Y+1
(0466) 			}
(0467) 			else
(0468) 			{
(0469) 			//	if(LampBState == 0)		// 有测试任务,开启光源
(0470) 			//		TestBLampOpen();
(0471) 			}
(0472) 			if(TestQueueB.testTime[0] != 0)
    0A067 804A      LDD	R4,Y+2
    0A068 805B      LDD	R5,Y+3
    0A069 0E24      ADD	R2,R20
    0A06A 1E35      ADC	R3,R21
    0A06B 1E46      ADC	R4,R22
    0A06C 1E57      ADC	R5,R23
    0A06D 8228      ST	Y,R2
    0A06E 8239      STD	Y+1,R3
    0A06F 824A      STD	Y+2,R4
    0A070 825B      STD	Y+3,R5
    0A071 8028      LD	R2,Y
    0A072 8039      LDD	R3,Y+1
    0A073 804A      LDD	R4,Y+2
    0A074 805B      LDD	R5,Y+3
    0A075 846A      LDD	R6,Y+10
(0473) 			{
(0474) 				if(SecondCount > (TestQueueB.testTime[0]-10))
    0A076 847B      LDD	R7,Y+11
    0A077 848C      LDD	R8,Y+12
    0A078 849D      LDD	R9,Y+13
    0A079 1426      CP	R2,R6
    0A07A 0437      CPC	R3,R7
    0A07B 0448      CPC	R4,R8
    0A07C 0459      CPC	R5,R9
    0A07D F40C      BGE	0xA07F
    0A07E C019      RJMP	0xA098
    0A07F E04F      LDI	R20,0xF
    0A080 E050      LDI	R21,0
    0A081 E060      LDI	R22,0
    0A082 E070      LDI	R23,0
    0A083 8028      LD	R2,Y
    0A084 8039      LDD	R3,Y+1
    0A085 804A      LDD	R4,Y+2
    0A086 805B      LDD	R5,Y+3
    0A087 1A24      SUB	R2,R20
    0A088 0A35      SBC	R3,R21
    0A089 0A46      SBC	R4,R22
    0A08A 0A57      SBC	R5,R23
    0A08B 846A      LDD	R6,Y+10
(0475) 				{
(0476) 					ringNum = TestQueueB.ringNum[0];	
    0A08C 847B      LDD	R7,Y+11
    0A08D 848C      LDD	R8,Y+12
    0A08E 849D      LDD	R9,Y+13
    0A08F 1426      CP	R2,R6
(0477) 					// 测试时间到
(0478) 					if(TurnPlateUsedLock == 0)
    0A090 0437      CPC	R3,R7
    0A091 0448      CPC	R4,R8
    0A092 0459      CPC	R5,R9
    0A093 F014      BLT	0xA096
    0A094 2D0A      MOV	R16,R10
(0479) 					{
(0480) 						if(255 == insertflag[ringNum])
    0A095 C008      RJMP	0xA09E
    0A096 EF0F      LDI	R16,0xFF
    0A097 C006      RJMP	0xA09E
    0A098 94A3      INC	R10
    0A099 2D8A      MOV	R24,R10
    0A09A 3288      CPI	R24,0x28
    0A09B F408      BCC	0xA09D
    0A09C CFA6      RJMP	0xA043
    0A09D EF0F      LDI	R16,0xFF
    0A09E 9624      ADIW	R28,4
    0A09F 940E AE9E CALL	pop_xgsetF00C
(0481) 						{
(0482) 							insertflag[ringNum] = 200;
    0A0A1 9622      ADIW	R28,2
    0A0A2 9508      RET
_TestQueueInsert:
    0A0A3 92AA      ST	-Y,R10
    0A0A4 934A      ST	-Y,R20
    0A0A5 80AA      LDD	R10,Y+2
    0A0A6 E247      LDI	R20,0x27
    0A0A7 C041      RJMP	0xA0E9
    0A0A8 1742      CP	R20,R18
(0483) 							Uart0ReUnable;
    0A0A9 F139      BEQ	0xA0D1
    0A0AA 01C8      MOVW	R24,R16
    0A0AB 9688      ADIW	R24,0x28
    0A0AC 2FE4      MOV	R30,R20
    0A0AD 27FF      CLR	R31
(0484) 							uart_Printf("%s $%4d $%4d\r\n",strM3122,ringNum,insertflag[ringNum]);
    0A0AE 9731      SBIW	R30,1
    0A0AF 0FEE      LSL	R30
    0A0B0 1FFF      ROL	R31
    0A0B1 0FEE      LSL	R30
    0A0B2 1FFF      ROL	R31
    0A0B3 0FE8      ADD	R30,R24
    0A0B4 1FF9      ADC	R31,R25
    0A0B5 8020      LD	R2,Z
    0A0B6 8031      LDD	R3,Z+1
    0A0B7 8042      LDD	R4,Z+2
    0A0B8 8053      LDD	R5,Z+3
    0A0B9 2FE4      MOV	R30,R20
    0A0BA 27FF      CLR	R31
    0A0BB 0FEE      LSL	R30
    0A0BC 1FFF      ROL	R31
    0A0BD 0FEE      LSL	R30
    0A0BE 1FFF      ROL	R31
    0A0BF 0FE8      ADD	R30,R24
    0A0C0 1FF9      ADC	R31,R25
    0A0C1 8220      ST	Z,R2
    0A0C2 8231      STD	Z+1,R3
    0A0C3 8242      STD	Z+2,R4
(0485) 							Uart0ReEnable;
    0A0C4 8253      STD	Z+3,R5
    0A0C5 2FE4      MOV	R30,R20
    0A0C6 27FF      CLR	R31
    0A0C7 9731      SBIW	R30,1
    0A0C8 0FE0      ADD	R30,R16
(0486) 							TurnPlateUsedLock = 1;		// 占用转盘标识
    0A0C9 1FF1      ADC	R31,R17
    0A0CA 8020      LD	R2,Z
    0A0CB 2FE4      MOV	R30,R20
(0487) 							//mainStep = 1;
(0488) 							mainStep = 10;
    0A0CC 27FF      CLR	R31
    0A0CD 0FE0      ADD	R30,R16
    0A0CE 1FF1      ADC	R31,R17
(0489) 							workStep = 0;
    0A0CF 8220      ST	Z,R2
    0A0D0 C018      RJMP	0xA0E9
    0A0D1 01C8      MOVW	R24,R16
(0490) 							inWork = 1; 
    0A0D2 9688      ADIW	R24,0x28
    0A0D3 2FE4      MOV	R30,R20
    0A0D4 27FF      CLR	R31
(0491) 						} 
(0492) 					}
(0493) 				}
(0494) 			}
(0495) 			break;
    0A0D5 0FEE      LSL	R30
(0496) 		case 10:
(0497) 			SetMotRunPam(MOT_TURN_PLATE,200,20,CURRENT_TURN_PLATE);// 140,2
    0A0D6 1FFF      ROL	R31
    0A0D7 0FEE      LSL	R30
    0A0D8 1FFF      ROL	R31
    0A0D9 0FE8      ADD	R30,R24
    0A0DA 1FF9      ADC	R31,R25
    0A0DB 802C      LDD	R2,Y+4
    0A0DC 803D      LDD	R3,Y+5
    0A0DD 804E      LDD	R4,Y+6
(0498) 			MotRunToSite(MOT_TURN_PLATE,0);		// 转盘转到零位	
    0A0DE 805F      LDD	R5,Y+7
    0A0DF 8220      ST	Z,R2
    0A0E0 8231      STD	Z+1,R3
    0A0E1 8242      STD	Z+2,R4
(0499) 			watiMotTurnplate = 1;
    0A0E2 8253      STD	Z+3,R5
    0A0E3 2FE4      MOV	R30,R20
    0A0E4 27FF      CLR	R31
(0500) 			mainStep = 11;
    0A0E5 0FE0      ADD	R30,R16
    0A0E6 1FF1      ADC	R31,R17
    0A0E7 82A0      ST	Z,R10
(0501) 			break;
    0A0E8 C006      RJMP	0xA0EF
(0502) 		case 11:
(0503) 			SetDelayTime(MOT_TURN_PLATE,2);
    0A0E9 2E24      MOV	R2,R20
    0A0EA 2433      CLR	R3
    0A0EB 5041      SUBI	R20,1
    0A0EC 2022      TST	R2
    0A0ED F009      BEQ	0xA0EF
(0504) 			mainStep = 1;
    0A0EE CFB9      RJMP	0xA0A8
    0A0EF 9149      LD	R20,Y+
    0A0F0 90A9      LD	R10,Y+
(0505) 			break;
    0A0F1 9508      RET
(0506) 		case 1:		// 转盘转到当前位置			
(0507) 		//	ringNum = TestQueueB.ringNum[0];
(0508) 			ucTmp = ringNum + 19;	
_TestQueueForward:
    0A0F2 934A      ST	-Y,R20
    0A0F3 2744      CLR	R20
    0A0F4 C03B      RJMP	0xA130
    0A0F5 3247      CPI	R20,0x27
(0509) #ifndef UartSendLong	
(0510) 			Uart0ReUnable;
(0511) 			uart_Printf("%s $%8d",strM3148,RingQueue.sampInfo[ringNum].testSerial);//2016-05-17
(0512) #else
(0513) 			Uart0ReUnable;
    0A0F6 F119      BEQ	0xA11A
    0A0F7 01C8      MOVW	R24,R16
    0A0F8 9688      ADIW	R24,0x28
    0A0F9 2FE4      MOV	R30,R20
    0A0FA 27FF      CLR	R31
(0514) 			uart_Printf("%s $ ",strM3148);
    0A0FB 9631      ADIW	R30,1
    0A0FC 0FEE      LSL	R30
    0A0FD 1FFF      ROL	R31
    0A0FE 0FEE      LSL	R30
    0A0FF 1FFF      ROL	R31
    0A100 0FE8      ADD	R30,R24
(0515) 			uart0SendInt(RingQueue.sampInfo[ringNum].testSerial);
    0A101 1FF9      ADC	R31,R25
    0A102 8020      LD	R2,Z
    0A103 8031      LDD	R3,Z+1
    0A104 8042      LDD	R4,Z+2
    0A105 8053      LDD	R5,Z+3
    0A106 2FE4      MOV	R30,R20
    0A107 27FF      CLR	R31
    0A108 0FEE      LSL	R30
    0A109 1FFF      ROL	R31
    0A10A 0FEE      LSL	R30
    0A10B 1FFF      ROL	R31
    0A10C 0FE8      ADD	R30,R24
    0A10D 1FF9      ADC	R31,R25
    0A10E 8220      ST	Z,R2
    0A10F 8231      STD	Z+1,R3
(0516) #endif
(0517) 			uart_Printf(" $%4d\r\n",ringNum);//2016-05-17
    0A110 8242      STD	Z+2,R4
    0A111 8253      STD	Z+3,R5
    0A112 2E24      MOV	R2,R20
    0A113 2433      CLR	R3
    0A114 0E20      ADD	R2,R16
    0A115 1E31      ADC	R3,R17
    0A116 01F1      MOVW	R30,R2
(0518) 			Uart0ReEnable;
    0A117 8021      LDD	R2,Z+1
    0A118 8220      ST	Z,R2
    0A119 C015      RJMP	0xA12F
    0A11A 01C8      MOVW	R24,R16
    0A11B 9688      ADIW	R24,0x28
(0519) 			if(ucTmp>=RING_QUEUE_NUM)
    0A11C 2FE4      MOV	R30,R20
    0A11D 27FF      CLR	R31
    0A11E 0FEE      LSL	R30
(0520) 				ucTmp -= RING_QUEUE_NUM;
    0A11F 1FFF      ROL	R31
    0A120 0FEE      LSL	R30
(0521) 			SetMotRunPam(MOT_TURN_PLATE,200,20,CURRENT_TURN_PLATE);
    0A121 1FFF      ROL	R31
    0A122 0FE8      ADD	R30,R24
    0A123 1FF9      ADC	R31,R25
    0A124 E080      LDI	R24,0
    0A125 8380      ST	Z,R24
    0A126 8381      STD	Z+1,R24
    0A127 8382      STD	Z+2,R24
    0A128 8383      STD	Z+3,R24
(0522) 			MotRunToSite(MOT_TURN_PLATE,ucTmp);		// 转盘转到当前位置
    0A129 2FE4      MOV	R30,R20
    0A12A 27FF      CLR	R31
    0A12B 0FE0      ADD	R30,R16
    0A12C 1FF1      ADC	R31,R17
(0523) 			watiMotTurnplate = 1;
    0A12D EF8F      LDI	R24,0xFF
    0A12E 8380      ST	Z,R24
    0A12F 9543      INC	R20
(0524) 			mainStep = 2;
    0A130 3248      CPI	R20,0x28
    0A131 F408      BCC	0xA133
    0A132 CFC2      RJMP	0xA0F5
(0525) 			workStep = 0;
    0A133 9149      LD	R20,Y+
    0A134 9508      RET
_InsertNewTest:
    0A135 940E AEB3 CALL	push_xgsetF03C
(0526) 			break;
    0A137 2EA2      MOV	R10,R18
    0A138 01A8      MOVW	R20,R16
    0A139 972E      SBIW	R28,0xE
    0A13A 01FA      MOVW	R30,R20
    0A13B 9639      ADIW	R30,0x9
(0527) 		case 2:
(0528) 			MotRun(MOT_TURN_PLATE, 100);	// 20
(0529) 			watiMotTurnplate = 1;
    0A13C 8020      LD	R2,Z
    0A13D 8031      LDD	R3,Z+1
    0A13E 2444      CLR	R4
(0530) 			SetDelayTime(MOT_TURN_PLATE, 5);
    0A13F 2455      CLR	R5
    0A140 822E      STD	Y+6,R2
    0A141 823F      STD	Y+7,R3
    0A142 8648      STD	Y+8,R4
    0A143 8659      STD	Y+9,R5
(0531) 			mainStep = 3;
    0A144 802E      LDD	R2,Y+6
    0A145 803F      LDD	R3,Y+7
    0A146 8448      LDD	R4,Y+8
(0532) 			break;
    0A147 8459      LDD	R5,Y+9
(0533) 		case 3:
(0534) 			MotRun(MOT_TURN_PLATE, -120);	// 20
    0A148 9488      BCLR	0
    0A149 2022      TST	R2
    0A14A 0432      CPC	R3,R2
    0A14B 0442      CPC	R4,R2
    0A14C 0452      CPC	R5,R2
(0535) 			watiMotTurnplate = 1;
    0A14D F0A1      BEQ	0xA162
    0A14E 9040 0529 LDS	R4,SecondCount+2
(0536) 			SetDelayTime(MOT_TURN_PLATE, 10);
    0A150 9050 052A LDS	R5,SecondCount+3
    0A152 9020 0527 LDS	R2,SecondCount
    0A154 9030 0528 LDS	R3,SecondCount+1
(0537) 			ReReadFlag = 0;	// 重测标识初始化
    0A156 806E      LDD	R6,Y+6
    0A157 807F      LDD	R7,Y+7
(0538) 			//将B改成A
(0539) 			if(LampAState == 0)
    0A158 8488      LDD	R8,Y+8
    0A159 8499      LDD	R9,Y+9
    0A15A 0C62      ADD	R6,R2
    0A15B 1C73      ADC	R7,R3
(0540) 				TestALampOpen();
    0A15C 1C84      ADC	R8,R4
(0541) 			mainStep = 4;
    0A15D 1C95      ADC	R9,R5
    0A15E 826E      STD	Y+6,R6
    0A15F 827F      STD	Y+7,R7
(0542) 			break;
    0A160 8688      STD	Y+8,R8
(0543) 		case 4:		// 开始检测
(0544) 			if(SecondCount < (TestQueueB.testTime[0]))
    0A161 8699      STD	Y+9,R9
    0A162 01FA      MOVW	R30,R20
    0A163 963B      ADIW	R30,0xB
    0A164 8020      LD	R2,Z
    0A165 8031      LDD	R3,Z+1
    0A166 2444      CLR	R4
    0A167 2455      CLR	R5
    0A168 862A      STD	Y+10,R2
    0A169 863B      STD	Y+11,R3
    0A16A 864C      STD	Y+12,R4
    0A16B 865D      STD	Y+13,R5
    0A16C 842A      LDD	R2,Y+10
    0A16D 843B      LDD	R3,Y+11
    0A16E 844C      LDD	R4,Y+12
    0A16F 845D      LDD	R5,Y+13
    0A170 9488      BCLR	0
    0A171 2022      TST	R2
    0A172 0432      CPC	R3,R2
    0A173 0442      CPC	R4,R2
    0A174 0452      CPC	R5,R2
    0A175 F0A1      BEQ	0xA18A
(0545) 				break;
    0A176 9040 0529 LDS	R4,SecondCount+2
(0546) 			ringNum = TestQueueB.ringNum[0];
    0A178 9050 052A LDS	R5,SecondCount+3
    0A17A 9020 0527 LDS	R2,SecondCount
(0547) 			// 开启检测光源
(0548) 		//	TestBLampOpen();
(0549) 			l = RingQueue.sampInfo[ringNum].testSerial;
    0A17C 9030 0528 LDS	R3,SecondCount+1
    0A17E 846A      LDD	R6,Y+10
    0A17F 847B      LDD	R7,Y+11
    0A180 848C      LDD	R8,Y+12
    0A181 849D      LDD	R9,Y+13
    0A182 0C62      ADD	R6,R2
    0A183 1C73      ADC	R7,R3
    0A184 1C84      ADC	R8,R4
    0A185 1C95      ADC	R9,R5
    0A186 866A      STD	Y+10,R6
    0A187 867B      STD	Y+11,R7
    0A188 868C      STD	Y+12,R8
    0A189 869D      STD	Y+13,R9
    0A18A 01FA      MOVW	R30,R20
(0550) 		//	j = RingQueue.sampInfo[ringNum].testTime0;
(0551) 			j = RingQueue.sampInfo[ringNum].testTime0+(unsigned int)(SecondCount-(TestQueueB.testTime[0]));
    0A18B 8420      LDD	R2,Z+8
    0A18C 2022      TST	R2
    0A18D F419      BNE	0xA191
    0A18E EF48      LDI	R20,0xF8
    0A18F E15C      LDI	R21,0x1C
    0A190 C002      RJMP	0xA193
    0A191 E24F      LDI	R20,0x2F
    0A192 E15C      LDI	R21,0x1C
    0A193 24CC      CLR	R12
    0A194 2766      CLR	R22
    0A195 802E      LDD	R2,Y+6
    0A196 803F      LDD	R3,Y+7
    0A197 8448      LDD	R4,Y+8
    0A198 8459      LDD	R5,Y+9
    0A199 9488      BCLR	0
    0A19A 2022      TST	R2
    0A19B 0432      CPC	R3,R2
    0A19C 0442      CPC	R4,R2
    0A19D 0452      CPC	R5,R2
    0A19E F031      BEQ	0xA1A5
    0A19F 8248      ST	Y,R4
    0A1A0 8259      STD	Y+1,R5
    0A1A1 0191      MOVW	R18,R2
    0A1A2 018A      MOVW	R16,R20
    0A1A3 DE98      RCALL	_TestQueueInsertCalculate
    0A1A4 2EC0      MOV	R12,R16
    0A1A5 842A      LDD	R2,Y+10
    0A1A6 843B      LDD	R3,Y+11
    0A1A7 844C      LDD	R4,Y+12
    0A1A8 845D      LDD	R5,Y+13
(0552) #ifndef UartSendLong
(0553) 			Uart0ReUnable;
(0554) 			uart_Printf("%s $%8d",strM3113, l);
(0555) 			uart_Printf(" $%4d $%4d",j, ringNum);
(0556) 			uart_Printf(" $%8d\r\n",(unsigned long)SecondCount);
(0557) 			Uart0ReEnable;
(0558) #else
(0559) 			Uart0ReUnable;
    0A1A9 9488      BCLR	0
    0A1AA 2022      TST	R2
    0A1AB 0432      CPC	R3,R2
    0A1AC 0442      CPC	R4,R2
    0A1AD 0452      CPC	R5,R2
(0560) 			uart_Printf("%s $ ",strM3113);
    0A1AE F031      BEQ	0xA1B5
    0A1AF 8248      ST	Y,R4
    0A1B0 8259      STD	Y+1,R5
    0A1B1 0191      MOVW	R18,R2
    0A1B2 018A      MOVW	R16,R20
    0A1B3 DE88      RCALL	_TestQueueInsertCalculate
(0561) 			uart0SendInt(l);
    0A1B4 2F60      MOV	R22,R16
    0A1B5 2D8C      MOV	R24,R12
    0A1B6 3F8F      CPI	R24,0xFF
    0A1B7 F141      BEQ	0xA1E0
    0A1B8 3F6F      CPI	R22,0xFF
    0A1B9 F131      BEQ	0xA1E0
(0562) 			uart_Printf(" $%4d $%4d $ ",j, ringNum);
    0A1BA 802E      LDD	R2,Y+6
    0A1BB 803F      LDD	R3,Y+7
    0A1BC 8448      LDD	R4,Y+8
    0A1BD 8459      LDD	R5,Y+9
    0A1BE 9488      BCLR	0
    0A1BF 2022      TST	R2
    0A1C0 0432      CPC	R3,R2
    0A1C1 0442      CPC	R4,R2
    0A1C2 0452      CPC	R5,R2
    0A1C3 F041      BEQ	0xA1CC
(0563) 			uart0SendInt(SecondCount);
    0A1C4 822A      STD	Y+2,R2
    0A1C5 823B      STD	Y+3,R3
    0A1C6 824C      STD	Y+4,R4
    0A1C7 825D      STD	Y+5,R5
    0A1C8 82A8      ST	Y,R10
    0A1C9 2F28      MOV	R18,R24
    0A1CA 018A      MOVW	R16,R20
    0A1CB DED7      RCALL	_TestQueueInsert
    0A1CC 842A      LDD	R2,Y+10
    0A1CD 843B      LDD	R3,Y+11
(0564) 			uart_Printf("\r\n");
    0A1CE 844C      LDD	R4,Y+12
    0A1CF 845D      LDD	R5,Y+13
    0A1D0 9488      BCLR	0
    0A1D1 2022      TST	R2
(0565) 			Uart0ReEnable;
    0A1D2 0432      CPC	R3,R2
    0A1D3 0442      CPC	R4,R2
    0A1D4 0452      CPC	R5,R2
    0A1D5 F041      BEQ	0xA1DE
    0A1D6 822A      STD	Y+2,R2
(0566) #endif
(0567) 			ReadColseAnswer = 0;	// 测试开始初始化关闭信号
    0A1D7 823B      STD	Y+3,R3
    0A1D8 824C      STD	Y+4,R4
    0A1D9 825D      STD	Y+5,R5
(0568) 			SetDelayTime(MOT_TURN_PLATE, 100);	// 读数延迟
    0A1DA 82A8      ST	Y,R10
    0A1DB 2F26      MOV	R18,R22
    0A1DC 018A      MOVW	R16,R20
    0A1DD DEC5      RCALL	_TestQueueInsert
    0A1DE 2700      CLR	R16
(0569) 			mainStep = 5;
    0A1DF C001      RJMP	0xA1E1
    0A1E0 EF0F      LDI	R16,0xFF
    0A1E1 962E      ADIW	R28,0xE
(0570) 			break;
    0A1E2 940C AEBC JMP	pop_xgsetF03C
(0571) 		case 5:		// 检测完毕,释放转盘使用权,关闭检测光源
(0572) 			l = RingQueue.sampInfo[ringNum].testSerial;
_printf_TestProcess_StepState:
    0A1E4 9722      SBIW	R28,2
    0A1E5 9020 1C2B LDS	R2,ReReadFlag+4
    0A1E7 2433      CLR	R3
    0A1E8 8239      STD	Y+1,R3
    0A1E9 8228      ST	Y,R2
    0A1EA 9120 1C2A LDS	R18,ReReadFlag+3
    0A1EC 2733      CLR	R19
    0A1ED E107      LDI	R16,0x17
    0A1EE E01A      LDI	R17,0xA
    0A1EF 940E A90D CALL	_uart_Printf
    0A1F1 9020 1C29 LDS	R2,ReReadFlag+2
    0A1F3 2433      CLR	R3
(0573) #ifndef UartSendLong
(0574) 			Uart0ReUnable;
(0575) 			uart_Printf("%s $%8d",strM3115, l);
(0576) 			uart_Printf(" $%8d\r\n",(unsigned long)SecondCount);
(0577) 			Uart0ReEnable;
(0578) #else
(0579) 			Uart0ReUnable;
    0A1F4 8239      STD	Y+1,R3
    0A1F5 8228      ST	Y,R2
    0A1F6 9120 1C28 LDS	R18,ReReadFlag+1
    0A1F8 2733      CLR	R19
(0580) 			uart_Printf("%s $ ",strM3115, l);
    0A1F9 EF06      LDI	R16,0xF6
    0A1FA E019      LDI	R17,0x9
    0A1FB 940E A90D CALL	_uart_Printf
    0A1FD 9622      ADIW	R28,2
    0A1FE 9508      RET
_TestAQueueProcess:
    0A1FF 940E AE97 CALL	push_xgsetF00C
    0A201 9728      SBIW	R28,0x8
    0A202 9020 1C19 LDS	R2,TurnPlateUsedLock+1
    0A204 9220 1C2A STS	ReReadFlag+3,R2
    0A206 9020 1C1A LDS	R2,TurnPlateUsedLock+2
(0581) 			uart0SendInt(l);
    0A208 9220 1C2B STS	ReReadFlag+4,R2
    0A20A 9020 1C1B LDS	R2,TurnPlateUsedLock+3
    0A20C 2022      TST	R2
(0582) 			uart_Printf(" $ ");
    0A20D F409      BNE	0xA20F
    0A20E C044      RJMP	0xA253
    0A20F E001      LDI	R16,1
    0A210 940E 97C6 CALL	_WaitDelayTime
(0583) 			uart0SendInt(SecondCount);
    0A212 2300      TST	R16
    0A213 F189      BEQ	0xA245
    0A214 9180 1C19 LDS	R24,TurnPlateUsedLock+1
    0A216 3085      CPI	R24,5
    0A217 F559      BNE	0xA243
    0A218 9180 1C27 LDS	R24,ReReadFlag
    0A21A 3081      CPI	R24,1
(0584) 			uart_Printf("\r\n");
    0A21B F4D9      BNE	0xA237
    0A21C 9180 1C1F LDS	R24,TurnPlateUsedLock+7
    0A21E 5F8F      SUBI	R24,0xFF
(0585) 			Uart0ReEnable;
    0A21F 9380 1C1F STS	TurnPlateUsedLock+7,R24
    0A221 3081      CPI	R24,1
    0A222 F471      BNE	0xA231
    0A223 9120 1CF8 LDS	R18,TestQueueA
(0586) #endif
(0587) 			// 关闭检测光源,B改成A
(0588) 			if(LampAState != 0 && CardNoneUseful == 1)
    0A225 E001      LDI	R16,1
    0A226 940E 6A7F CALL	_MotRunToSite
    0A228 2422      CLR	R2
    0A229 9220 1C27 STS	ReReadFlag,R2
    0A22B E081      LDI	R24,1
(0589) 				TestALampClose();
    0A22C 9380 1C1D STS	TurnPlateUsedLock+5,R24
(0590) 			TestQueueForward(&TestQueueB);		// 删除已完成的队头任务，队列前进一步
    0A22E 9380 1C19 STS	TurnPlateUsedLock+1,R24
(0591) 			
(0592) 		//	MotRunToSite(MOT_TURN_PLATE,0);		// 转盘运行到零位
(0593) 			SetDelayTime(MOT_TURN_PLATE, 10);
    0A230 C006      RJMP	0xA237
    0A231 2422      CLR	R2
    0A232 9220 1C27 STS	ReReadFlag,R2
    0A234 E185      LDI	R24,0x15
(0594) 		//	watiMotTurnplate = 1;
(0595) 			mainStep = 6;
    0A235 9380 1C19 STS	TurnPlateUsedLock+1,R24
    0A237 9020 1C2C LDS	R2,ReReadFlag+5
(0596) 			break;
    0A239 2022      TST	R2
    0A23A F041      BEQ	0xA243
    0A23B E025      LDI	R18,5
    0A23C E030      LDI	R19,0
    0A23D E001      LDI	R16,1
(0597) 			
(0598) 			case 21:		// 转盘转到当前位置			 //  20170518pan
(0599) #ifndef UartSendLong	
(0600) 			Uart0ReUnable;
(0601) 			uart_Printf("%s $%8d",strM3148,RingQueue.sampInfo[ringNum].testSerial);//2016-05-17
(0602) #else
(0603) 			Uart0ReUnable;
(0604) 			uart_Printf("%s $ ",strM3148);
    0A23E 940E 97B7 CALL	_SetDelayTime
    0A240 2422      CLR	R2
    0A241 9220 1C2C STS	ReReadFlag+5,R2
    0A243 2700      CLR	R16
(0605) 			uart0SendInt(RingQueue.sampInfo[ringNum].testSerial);
    0A244 C25C      RJMP	0xA4A1
    0A245 9020 1C1D LDS	R2,TurnPlateUsedLock+5
    0A247 2022      TST	R2
    0A248 F051      BEQ	0xA253
    0A249 E001      LDI	R16,1
    0A24A 940E 6A0C CALL	_GetMotState
    0A24C 3001      CPI	R16,1
    0A24D F011      BEQ	0xA250
    0A24E 2700      CLR	R16
    0A24F C251      RJMP	0xA4A1
    0A250 2422      CLR	R2
    0A251 9220 1C1D STS	TurnPlateUsedLock+5,R2
(0606) #endif
(0607) 			uart_Printf(" $%4d\r\n",ringNum);//2016-05-17
    0A253 90A0 1C19 LDS	R10,TurnPlateUsedLock+1
    0A255 24BB      CLR	R11
    0A256 20AA      TST	R10
    0A257 F419      BNE	0xA25B
    0A258 20BB      TST	R11
    0A259 F409      BNE	0xA25B
(0608) 			Uart0ReEnable;
    0A25A C035      RJMP	0xA290
    0A25B 01C5      MOVW	R24,R10
    0A25C 3081      CPI	R24,1
    0A25D E0E0      LDI	R30,0
    0A25E 079E      CPC	R25,R30
(0609) 			mainStep = 3;
    0A25F F409      BNE	0xA261
    0A260 C0C8      RJMP	0xA329
    0A261 3082      CPI	R24,2
(0610) 			workStep = 0;
    0A262 E0E0      LDI	R30,0
    0A263 079E      CPC	R25,R30
    0A264 F409      BNE	0xA266
(0611) 			break;
    0A265 C105      RJMP	0xA36B
(0612) 			
(0613) 		case 6:		// 释放转盘使用权
(0614) 			mainStep = 0;
    0A266 3083      CPI	R24,3
    0A267 E0E0      LDI	R30,0
    0A268 079E      CPC	R25,R30
(0615) 			workStep = 0;
    0A269 F409      BNE	0xA26B
    0A26A C111      RJMP	0xA37C
(0616) 			inWork = 0;
    0A26B 3084      CPI	R24,4
    0A26C E0E0      LDI	R30,0
(0617) 			ReTestCnt = 0;
    0A26D 079E      CPC	R25,R30
    0A26E F409      BNE	0xA270
(0618) 			TurnPlateUsedLock = 0;
    0A26F C12D      RJMP	0xA39D
    0A270 3085      CPI	R24,5
(0619) 			TurnPlateUsedLock = 0;
    0A271 E0E0      LDI	R30,0
    0A272 079E      CPC	R25,R30
(0620) 			break;
(0621) 		}
(0622) 	return 0;
    0A273 F409      BNE	0xA275
    0A274 C1AA      RJMP	0xA41F
    0A275 3086      CPI	R24,6
    0A276 E0E0      LDI	R30,0
(0623) }
(0624) 
(0625) void SetReReadFlag(void)
(0626) {
(0627) 	ReReadFlag = 1;
_SetReReadFlag:
    0A277 079E      CPC	R25,R30
    0A278 F409      BNE	0xA27A
    0A279 C21B      RJMP	0xA495
(0628) 	Uart0ReUnable;
    0A27A 308A      CPI	R24,0xA
    0A27B E0E0      LDI	R30,0
    0A27C 079E      CPC	R25,R30
    0A27D F409      BNE	0xA27F
    0A27E C08E      RJMP	0xA30D
(0629) 	uart_Printf("%s\r\n",strM3155);
    0A27F 308B      CPI	R24,0xB
    0A280 E0E0      LDI	R30,0
    0A281 079E      CPC	R25,R30
    0A282 F409      BNE	0xA284
    0A283 C09C      RJMP	0xA320
    0A284 3080      CPI	R24,0
(0630) 	Uart0ReEnable;
    0A285 E0E0      LDI	R30,0
    0A286 079E      CPC	R25,R30
    0A287 F40C      BGE	0xA289
    0A288 C217      RJMP	0xA4A0
    0A289 01C5      MOVW	R24,R10
    0A28A 3185      CPI	R24,0x15
_PutRepChar:
  a                    --> Y,+0
  p                    --> R10
  count                --> R20
  c                    --> R10
    0A28B E0E0      LDI	R30,0
    0A28C 079E      CPC	R25,R30
    0A28D F409      BNE	0xA28F
    0A28E C1D9      RJMP	0xA468
    0A28F C210      RJMP	0xA4A0
FILE: D:\Work\主控软件\2032A2~1\uart_Printf.c
(0001) /**************************************************
(0002) 
(0003) ***************************************************/
(0004) // File name: "uart_Printf.c"
(0005) /*************************************
(0006)  Editor: lihanyang
(0007)  Date:2010-2-10
(0008) *************************************/
(0009) 
(0010) #include	"B1404_LIB.h"
(0011) #include    <string.h>
(0012) 
(0013) #define vaStart(list, param) list = (char*)((int)&param + sizeof(param))
(0014) #define vaArg(list, type) ((type *)(list += sizeof(type)))[-1]
(0015) 
(0016) static void  PutRepChar(char c, unsigned char count)
(0017) {
(0018) 	unsigned char  a;
(0019) 	unsigned char * p;
(0020) 	a  = (unsigned char)c;
    0A290 9180 1CF8 LDS	R24,TestQueueA
(0021) 	p = &a;
    0A292 3F8F      CPI	R24,0xFF
    0A293 F411      BNE	0xA296
(0022)     while (count--)
(0023) 		uart0SendData(p, 1);
    0A294 E001      LDI	R16,1
    0A295 C20B      RJMP	0xA4A1
    0A296 9040 1D22 LDS	R4,TestQueueA+42
    0A298 9050 1D23 LDS	R5,TestQueueA+43
    0A29A 9020 1D20 LDS	R2,TestQueueA+40
    0A29C 9030 1D21 LDS	R3,TestQueueA+41
    0A29E 9488      BCLR	0
    0A29F 2022      TST	R2
    0A2A0 0432      CPC	R3,R2
_PutStringReverse:
  p                    --> R10
  index                --> R20
  s                    --> R12
    0A2A1 0442      CPC	R4,R2
    0A2A2 0452      CPC	R5,R2
    0A2A3 F409      BNE	0xA2A5
    0A2A4 C1FB      RJMP	0xA4A0
(0024) }
(0025) 
(0026) static void  PutStringReverse(char *s, unsigned char index)
(0027) {
(0028) 	unsigned char * p;
(0029) 	p = (unsigned char *)s;
    0A2A5 9020 1CF8 LDS	R2,TestQueueA
(0030)     while ((index--) > 0)
(0031) 		uart0SendData(p+index, 1);
    0A2A7 9220 1C1C STS	TurnPlateUsedLock+4,R2
    0A2A9 E04A      LDI	R20,0xA
    0A2AA E050      LDI	R21,0
    0A2AB E060      LDI	R22,0
    0A2AC E070      LDI	R23,0
    0A2AD 9040 1D22 LDS	R4,TestQueueA+42
    0A2AF 9050 1D23 LDS	R5,TestQueueA+43
    0A2B1 9020 1D20 LDS	R2,TestQueueA+40
    0A2B3 9030 1D21 LDS	R3,TestQueueA+41
    0A2B5 1A24      SUB	R2,R20
    0A2B6 0A35      SBC	R3,R21
_PutNumber:
  negative             --> R14
  left                 --> R10
  buffer               --> Y,+0
  bi                   --> Y,+40
  digit                --> R12
  uvalue               --> R22
  fill                 --> Y,+55
  width                --> Y,+53
  radix                --> Y,+51
  value                --> R20
    0A2B7 0A46      SBC	R4,R22
    0A2B8 0A57      SBC	R5,R23
    0A2B9 9080 0529 LDS	R8,SecondCount+2
    0A2BB 9090 052A LDS	R9,SecondCount+3
(0032) }
(0033) 
(0034) static void  PutNumber(int value, signed char radix, unsigned char width, char fill)
(0035) {
(0036)     char    buffer[40];
(0037)     unsigned char     bi = 0;
    0A2BD 9060 0527 LDS	R6,SecondCount
(0038)     unsigned int  uvalue;
(0039)     unsigned short  digit;
(0040)     unsigned char  left = 0;
    0A2BF 9070 0528 LDS	R7,SecondCount+1
(0041)     unsigned char  negative = 0;
    0A2C1 1426      CP	R2,R6
    0A2C2 0437      CPC	R3,R7
    0A2C3 0448      CPC	R4,R8
(0042) 
(0043)     if (fill == 0)
(0044)         fill = ' ';
    0A2C4 0459      CPC	R5,R9
    0A2C5 F008      BCS	0xA2C7
(0045) 
(0046)     if (width < 0)
    0A2C6 C1D9      RJMP	0xA4A0
    0A2C7 9020 1C18 LDS	R2,TurnPlateUsedLock
(0047)     {
(0048)         width = -width;
    0A2C9 2022      TST	R2
    0A2CA F009      BEQ	0xA2CC
    0A2CB C1D4      RJMP	0xA4A0
(0049)         left = 1;
    0A2CC EC81      LDI	R24,0xC1
    0A2CD E19D      LDI	R25,0x1D
(0050)     }
(0051) 
(0052)     if (width < 0 || width > 80)
    0A2CE 91E0 1C1C LDS	R30,TurnPlateUsedLock+4
    0A2D0 27FF      CLR	R31
    0A2D1 0FE8      ADD	R30,R24
    0A2D2 1FF9      ADC	R31,R25
    0A2D3 8180      LD	R24,Z
    0A2D4 3F8F      CPI	R24,0xFF
(0053)         width = 0;
    0A2D5 F009      BEQ	0xA2D7
    0A2D6 C1C9      RJMP	0xA4A0
(0054) 
(0055)     if (radix < 0)
    0A2D7 EC81      LDI	R24,0xC1
    0A2D8 E19D      LDI	R25,0x1D
    0A2D9 91E0 1C1C LDS	R30,TurnPlateUsedLock+4
(0056)     {
(0057)         radix = -radix;
    0A2DB 27FF      CLR	R31
    0A2DC 0FE8      ADD	R30,R24
(0058)         if (value < 0)
    0A2DD 1FF9      ADC	R31,R25
    0A2DE EC88      LDI	R24,0xC8
    0A2DF 8380      ST	Z,R24
    0A2E0 9180 00C1 LDS	R24,0xC1
(0059)         {
(0060)             negative = 1;
    0A2E2 7E8F      ANDI	R24,0xEF
(0061)             value = -value;
    0A2E3 9380 00C1 STS	0xC1,R24
    0A2E5 90A0 1C1C LDS	R10,TurnPlateUsedLock+4
(0062)         }
(0063)     }
(0064) 
(0065)     uvalue = value;
    0A2E7 EC81      LDI	R24,0xC1
(0066) 
(0067)     do
(0068)     {
(0069)         if (radix != 16)
    0A2E8 E19D      LDI	R25,0x1D
    0A2E9 2DEA      MOV	R30,R10
    0A2EA 27FF      CLR	R31
(0070)         {
(0071)             digit = uvalue % radix;
    0A2EB 0FE8      ADD	R30,R24
    0A2EC 1FF9      ADC	R31,R25
    0A2ED 8020      LD	R2,Z
    0A2EE 2433      CLR	R3
    0A2EF 823B      STD	Y+3,R3
    0A2F0 822A      STD	Y+2,R2
    0A2F1 2C2A      MOV	R2,R10
    0A2F2 2433      CLR	R3
(0072)             uvalue = uvalue / radix;
    0A2F3 8239      STD	Y+1,R3
    0A2F4 8228      ST	Y,R2
    0A2F5 E722      LDI	R18,0x72
    0A2F6 E03E      LDI	R19,0xE
    0A2F7 EE07      LDI	R16,0xE7
    0A2F8 E019      LDI	R17,0x9
    0A2F9 940E A90D CALL	_uart_Printf
(0073)         }
    0A2FB 9180 00C1 LDS	R24,0xC1
(0074)         else
(0075)         {
(0076)             digit = uvalue & 0xf;
    0A2FD 6180      ORI	R24,0x10
    0A2FE 9380 00C1 STS	0xC1,R24
(0077)             uvalue = uvalue >> 4;
    0A300 E081      LDI	R24,1
    0A301 9380 1C18 STS	TurnPlateUsedLock,R24
    0A303 E08A      LDI	R24,0xA
    0A304 9380 1C19 STS	TurnPlateUsedLock+1,R24
    0A306 2422      CLR	R2
    0A307 9220 1C1A STS	TurnPlateUsedLock+2,R2
(0078)         }
(0079)         buffer[bi] = digit + ((digit <= 9) ? '0' : ('A' - 10));
    0A309 E081      LDI	R24,1
    0A30A 9380 1C1B STS	TurnPlateUsedLock+3,R24
    0A30C C193      RJMP	0xA4A0
    0A30D E081      LDI	R24,1
    0A30E 838A      STD	Y+2,R24
    0A30F E184      LDI	R24,0x14
    0A310 8388      ST	Y,R24
    0A311 EC28      LDI	R18,0xC8
    0A312 E001      LDI	R16,1
    0A313 940E 6A9F CALL	_SetMotRunPam
    0A315 2722      CLR	R18
    0A316 E001      LDI	R16,1
    0A317 940E 6A7F CALL	_MotRunToSite
    0A319 E081      LDI	R24,1
    0A31A 9380 1C1D STS	TurnPlateUsedLock+5,R24
(0080)         bi++;
    0A31C E08B      LDI	R24,0xB
    0A31D 9380 1C19 STS	TurnPlateUsedLock+1,R24
(0081) 		/*
(0082)         if (uvalue != 0)
(0083)         {
(0084)             if ((radix == 10)	// 千位符
(0085)                 && ((bi == 3) || (bi == 7) || (bi == 11) | (bi == 15)))
(0086)             {
(0087)                 buffer[bi++] = ',';
(0088)             }
(0089)         }*/
(0090)     }
(0091)     while (uvalue != 0);
    0A31F C180      RJMP	0xA4A0
    0A320 E022      LDI	R18,2
    0A321 E030      LDI	R19,0
(0092) 
(0093)     if (negative)
    0A322 E001      LDI	R16,1
    0A323 940E 97B7 CALL	_SetDelayTime
(0094)     {
(0095)         buffer[bi] = '-';
    0A325 E081      LDI	R24,1
    0A326 9380 1C19 STS	TurnPlateUsedLock+1,R24
    0A328 C177      RJMP	0xA4A0
    0A329 9180 1C1C LDS	R24,TurnPlateUsedLock+4
(0096)         bi += 1;
    0A32B 5F85      SUBI	R24,0xF5
    0A32C 2EA8      MOV	R10,R24
    0A32D 9180 00C1 LDS	R24,0xC1
(0097)     }
(0098) 
(0099)     if (width <= bi)
    0A32F 7E8F      ANDI	R24,0xEF
    0A330 9380 00C1 STS	0xC1,R24
    0A332 ED25      LDI	R18,0xD5
    0A333 E130      LDI	R19,0x10
    0A334 EE01      LDI	R16,0xE1
(0100)         PutStringReverse(buffer, bi);
    0A335 E019      LDI	R17,0x9
    0A336 940E A90D CALL	_uart_Printf
    0A338 9110 1C1C LDS	R17,TurnPlateUsedLock+4
(0101)     else
(0102)     {
(0103)         width -= bi;
    0A33A E00D      LDI	R16,0xD
    0A33B 0301      MULSU	R16,R17
    0A33C E784      LDI	R24,0x74
(0104)         if (!left)
    0A33D E19A      LDI	R25,0x1A
    0A33E 01F0      MOVW	R30,R0
(0105)             PutRepChar(fill, width);
    0A33F 0FE8      ADD	R30,R24
    0A340 1FF9      ADC	R31,R25
    0A341 8100      LD	R16,Z
(0106)         PutStringReverse(buffer, bi);
    0A342 8111      LDD	R17,Z+1
    0A343 8122      LDD	R18,Z+2
    0A344 8133      LDD	R19,Z+3
(0107)         if (left)
    0A345 940E A940 CALL	_uart0SendInt
(0108)             PutRepChar(fill, width);
    0A347 9120 1C1C LDS	R18,TurnPlateUsedLock+4
    0A349 2733      CLR	R19
(0109)     }
    0A34A ED09      LDI	R16,0xD9
    0A34B E019      LDI	R17,0x9
    0A34C 940E A90D CALL	_uart_Printf
    0A34E 9180 00C1 LDS	R24,0xC1
    0A350 7E8F      ANDI	R24,0xEF
    0A351 9380 00C1 STS	0xC1,R24
    0A353 2D8A      MOV	R24,R10
(0110) }
(0111) 
(0112) static char  *FormatItem(char *f,  int a)
(0113) {
(0114)     char   c;
(0115) 	unsigned char uc;
(0116)     signed char    fieldwidth = 0;
    0A354 318E      CPI	R24,0x1E
    0A355 F010      BCS	0xA358
(0117)     signed char    leftjust = 0;
    0A356 518E      SUBI	R24,0x1E
(0118)     signed char    radix = 0;
    0A357 2EA8      MOV	R10,R24
(0119)     char   fill = ' ';
    0A358 E081      LDI	R24,1
    0A359 838A      STD	Y+2,R24
(0120) 
(0121)     if (*f == '0')
    0A35A E184      LDI	R24,0x14
    0A35B 8388      ST	Y,R24
    0A35C EC28      LDI	R18,0xC8
    0A35D E001      LDI	R16,1
    0A35E 940E 6A9F CALL	_SetMotRunPam
(0122)         fill = '0';
    0A360 2D2A      MOV	R18,R10
    0A361 E001      LDI	R16,1
    0A362 940E 6A7F CALL	_MotRunToSite
(0123) 
(0124)     while ((c = *f++) != 0)
(0125)     {
(0126)         if (c >= '0' && c <= '9')
    0A364 E081      LDI	R24,1
    0A365 9380 1C1D STS	TurnPlateUsedLock+5,R24
    0A367 E082      LDI	R24,2
(0127)         {
(0128)             fieldwidth = (fieldwidth * 10) + (c - '0');
    0A368 9380 1C19 STS	TurnPlateUsedLock+1,R24
    0A36A C135      RJMP	0xA4A0
    0A36B E624      LDI	R18,0x64
    0A36C E030      LDI	R19,0
    0A36D E001      LDI	R16,1
    0A36E 940E 6A2C CALL	_MotRun
(0129)         }
    0A370 E081      LDI	R24,1
(0130)         else
(0131)             switch (c)
    0A371 9380 1C1D STS	TurnPlateUsedLock+5,R24
    0A373 E025      LDI	R18,5
    0A374 E030      LDI	R19,0
    0A375 E001      LDI	R16,1
    0A376 940E 97B7 CALL	_SetDelayTime
    0A378 E083      LDI	R24,3
    0A379 9380 1C19 STS	TurnPlateUsedLock+1,R24
    0A37B C124      RJMP	0xA4A0
    0A37C E081      LDI	R24,1
    0A37D 838A      STD	Y+2,R24
    0A37E E184      LDI	R24,0x14
    0A37F 8388      ST	Y,R24
    0A380 E82C      LDI	R18,0x8C
    0A381 E001      LDI	R16,1
    0A382 940E 6A9F CALL	_SetMotRunPam
    0A384 E922      LDI	R18,0x92
    0A385 EF3F      LDI	R19,0xFF
    0A386 E001      LDI	R16,1
    0A387 940E 6A2C CALL	_MotRun
    0A389 E081      LDI	R24,1
    0A38A 9380 1C1D STS	TurnPlateUsedLock+5,R24
    0A38C E02A      LDI	R18,0xA
    0A38D E030      LDI	R19,0
    0A38E E001      LDI	R16,1
    0A38F 940E 97B7 CALL	_SetDelayTime
    0A391 2422      CLR	R2
    0A392 9220 1C27 STS	ReReadFlag,R2
    0A394 9020 1C2E LDS	R2,ReReadFlag+7
    0A396 2022      TST	R2
    0A397 F409      BNE	0xA399
    0A398 DB6F      RCALL	_TestALampOpen
    0A399 E084      LDI	R24,4
    0A39A 9380 1C19 STS	TurnPlateUsedLock+1,R24
    0A39C C103      RJMP	0xA4A0
    0A39D 9040 1D22 LDS	R4,TestQueueA+42
    0A39F 9050 1D23 LDS	R5,TestQueueA+43
    0A3A1 9020 1D20 LDS	R2,TestQueueA+40
    0A3A3 9030 1D21 LDS	R3,TestQueueA+41
    0A3A5 9080 0529 LDS	R8,SecondCount+2
    0A3A7 9090 052A LDS	R9,SecondCount+3
    0A3A9 9060 0527 LDS	R6,SecondCount
    0A3AB 9070 0528 LDS	R7,SecondCount+1
    0A3AD 1462      CP	R6,R2
    0A3AE 0473      CPC	R7,R3
    0A3AF 0484      CPC	R8,R4
    0A3B0 0495      CPC	R9,R5
    0A3B1 F408      BCC	0xA3B3
    0A3B2 C0ED      RJMP	0xA4A0
    0A3B3 9020 1CF8 LDS	R2,TestQueueA
    0A3B5 9220 1C1C STS	TurnPlateUsedLock+4,R2
    0A3B7 2D12      MOV	R17,R2
    0A3B8 E00D      LDI	R16,0xD
    0A3B9 0301      MULSU	R16,R17
    0A3BA E784      LDI	R24,0x74
    0A3BB E19A      LDI	R25,0x1A
    0A3BC 01F0      MOVW	R30,R0
    0A3BD 0FE8      ADD	R30,R24
    0A3BE 1FF9      ADC	R31,R25
    0A3BF 8020      LD	R2,Z
    0A3C0 8031      LDD	R3,Z+1
    0A3C1 8042      LDD	R4,Z+2
    0A3C2 8053      LDD	R5,Z+3
    0A3C3 822C      STD	Y+4,R2
    0A3C4 823D      STD	Y+5,R3
    0A3C5 824E      STD	Y+6,R4
    0A3C6 825F      STD	Y+7,R5
    0A3C7 0301      MULSU	R16,R17
(0132)             {
(0133)                 case '\000':
(0134)                     return (--f);
    0A3C8 E78C      LDI	R24,0x7C
    0A3C9 E19A      LDI	R25,0x1A
    0A3CA 01F0      MOVW	R30,R0
    0A3CB 0FE8      ADD	R30,R24
    0A3CC 1FF9      ADC	R31,R25
    0A3CD 80A0      LD	R10,Z
    0A3CE 80B1      LDD	R11,Z+1
    0A3CF 9040 1D22 LDS	R4,TestQueueA+42
(0135)                 case '%':
(0136) 					uart0SendData("%", 1);
    0A3D1 9050 1D23 LDS	R5,TestQueueA+43
    0A3D3 9020 1D20 LDS	R2,TestQueueA+40
    0A3D5 9030 1D21 LDS	R3,TestQueueA+41
(0137)                     return (f);
    0A3D7 9080 0529 LDS	R8,SecondCount+2
(0138)                 case '-':
(0139)                     leftjust = 1;
    0A3D9 9090 052A LDS	R9,SecondCount+3
(0140)                     break;
    0A3DB 9060 0527 LDS	R6,SecondCount
(0141)                 case 'c':
(0142)                     {
(0143)                         if (leftjust){
(0144) 							uc = (unsigned char)(a & 0x7f);
    0A3DD 9070 0528 LDS	R7,SecondCount+1
    0A3DF 1862      SUB	R6,R2
    0A3E0 0873      SBC	R7,R3
    0A3E1 0884      SBC	R8,R4
(0145) 							uart0SendData(&uc, 1);
    0A3E2 0895      SBC	R9,R5
    0A3E3 0CA6      ADD	R10,R6
    0A3E4 1CB7      ADC	R11,R7
    0A3E5 9180 00C1 LDS	R24,0xC1
    0A3E7 7E8F      ANDI	R24,0xEF
    0A3E8 9380 00C1 STS	0xC1,R24
(0146)                         	}
(0147) 
(0148)                         if (fieldwidth > 0)
    0A3EA EA27      LDI	R18,0xA7
    0A3EB E03D      LDI	R19,0xD
    0A3EC EE01      LDI	R16,0xE1
(0149)                             PutRepChar(fill, fieldwidth - 1);
    0A3ED E019      LDI	R17,0x9
    0A3EE 940E A90D CALL	_uart_Printf
    0A3F0 810C      LDD	R16,Y+4
(0150) 
(0151)                         if (!leftjust){
    0A3F1 811D      LDD	R17,Y+5
    0A3F2 812E      LDD	R18,Y+6
(0152) 							uc = (unsigned char)(a & 0x7f);
    0A3F3 813F      LDD	R19,Y+7
    0A3F4 940E A940 CALL	_uart0SendInt
    0A3F6 9020 1C1C LDS	R2,TurnPlateUsedLock+4
(0153) 							uart0SendData(&uc, 1);
    0A3F8 2433      CLR	R3
    0A3F9 8239      STD	Y+1,R3
    0A3FA 8228      ST	Y,R2
    0A3FB 0195      MOVW	R18,R10
    0A3FC EC0B      LDI	R16,0xCB
    0A3FD E019      LDI	R17,0x9
    0A3FE 940E A90D CALL	_uart_Printf
(0154)                         	}
(0155)                         return (f);
    0A400 9120 0529 LDS	R18,SecondCount+2
(0156)                     }
(0157)                 case 's':
(0158) 				/*	if (leftjust)
(0159) 						uart0SendData((unsigned char *)a, strlen((char *)a));
(0160) 					if (fieldwidth > strlen((char *)a))
(0161) 						PutRepChar(fill,  fieldwidth - strlen((char *)a));
(0162) 					if (!leftjust)
(0163) 						uart0SendData((unsigned char *)a, strlen((char *)a));
(0164) 				*/
(0165) 					uart0SendString((_CONST unsigned char *)a);
    0A402 9130 052A LDS	R19,SecondCount+3
    0A404 9100 0527 LDS	R16,SecondCount
(0166) 					return (f);
    0A406 9110 0528 LDS	R17,SecondCount+1
    0A408 940E A940 CALL	_uart0SendInt
(0167)                 case 'd':
(0168)                 case 'i':
(0169)                     radix = -10;
    0A40A EC08      LDI	R16,0xC8
(0170)                     break;
    0A40B E019      LDI	R17,0x9
(0171)                 case 'u':
(0172)                     radix = 10;
    0A40C 940E A90D CALL	_uart_Printf
(0173)                     break;
    0A40E 9180 00C1 LDS	R24,0xC1
(0174)                 case 'x':
(0175)                     radix = 16;
    0A410 7E8F      ANDI	R24,0xEF
(0176)                     break;
    0A411 9380 00C1 STS	0xC1,R24
(0177)                 case 'X':
(0178)                     radix = 16;
    0A413 2422      CLR	R2
(0179)                     break;
    0A414 9220 1C2C STS	ReReadFlag+5,R2
(0180)                 case 'o':
(0181)                     radix = 8;
    0A416 E624      LDI	R18,0x64
(0182)                     break;
    0A417 E030      LDI	R19,0
(0183)                 default:
(0184)                     radix = 3;
    0A418 E001      LDI	R16,1
    0A419 940E 97B7 CALL	_SetDelayTime
(0185)                     break;      /* unknown switch! */
(0186)             }
(0187)         if (radix)
    0A41B E085      LDI	R24,5
(0188)             break;
    0A41C 9380 1C19 STS	TurnPlateUsedLock+1,R24
    0A41E C081      RJMP	0xA4A0
    0A41F 9110 1C1C LDS	R17,TurnPlateUsedLock+4
    0A421 E00D      LDI	R16,0xD
    0A422 0301      MULSU	R16,R17
    0A423 E784      LDI	R24,0x74
    0A424 E19A      LDI	R25,0x1A
    0A425 01F0      MOVW	R30,R0
(0189)     }
(0190) 
(0191)     if (leftjust)
    0A426 0FE8      ADD	R30,R24
    0A427 1FF9      ADC	R31,R25
(0192)         fieldwidth = -fieldwidth;
    0A428 8020      LD	R2,Z
    0A429 8031      LDD	R3,Z+1
    0A42A 8042      LDD	R4,Z+2
(0193) 
(0194)     PutNumber(a, radix, fieldwidth, fill);
    0A42B 8053      LDD	R5,Z+3
    0A42C 822C      STD	Y+4,R2
    0A42D 823D      STD	Y+5,R3
    0A42E 824E      STD	Y+6,R4
    0A42F 825F      STD	Y+7,R5
    0A430 9180 00C1 LDS	R24,0xC1
(0195) 
(0196)     return (f);
    0A432 7E8F      ANDI	R24,0xEF
    0A433 9380 00C1 STS	0xC1,R24
    0A435 EC29      LDI	R18,0xC9
    0A436 E03D      LDI	R19,0xD
    0A437 EE01      LDI	R16,0xE1
    0A438 E019      LDI	R17,0x9
_uart_Printf:
  c                    --> Y,+1
  argP                 --> R20
  p                    --> R10
  f                    --> Y,+4
    0A439 940E A90D CALL	_uart_Printf
    0A43B 810C      LDD	R16,Y+4
    0A43C 811D      LDD	R17,Y+5
(0197) }
(0198) 
(0199) void  uart_Printf(char *f, ...) /* variable arguments */
(0200) {
(0201)     char  *argP;
(0202) 	unsigned char *p;
(0203) 	char c;
(0204) 	//c = 0x02;
(0205) 	//uart0SendData(&c, 1);
(0206)     vaStart(argP, f);       /* point at the end of the format string */
    0A43D 812E      LDD	R18,Y+6
    0A43E 813F      LDD	R19,Y+7
    0A43F 940E A940 CALL	_uart0SendInt
    0A441 EC04      LDI	R16,0xC4
    0A442 E019      LDI	R17,0x9
(0207)     while (*f)
(0208)     {                       /* this works because args are all ints */
(0209)         if (*f == '%')
    0A443 940E A90D CALL	_uart_Printf
    0A445 9120 0529 LDS	R18,SecondCount+2
    0A447 9130 052A LDS	R19,SecondCount+3
(0210)             f = FormatItem(f + 1, vaArg(argP, int));
    0A449 9100 0527 LDS	R16,SecondCount
    0A44B 9110 0528 LDS	R17,SecondCount+1
    0A44D 940E A940 CALL	_uart0SendInt
    0A44F EC08      LDI	R16,0xC8
    0A450 E019      LDI	R17,0x9
    0A451 940E A90D CALL	_uart_Printf
    0A453 9180 00C1 LDS	R24,0xC1
    0A455 6180      ORI	R24,0x10
    0A456 9380 00C1 STS	0xC1,R24
(0211) 
(0212)         else{
(0213) 		//	if(*f == '\n'){
(0214) 		//		uart0SendData("\r", 1);
(0215) 		//		}
(0216) 			p = (unsigned char *)f;
    0A458 9020 1C2E LDS	R2,ReReadFlag+7
(0217) 			uart0SendData(p, 1);
    0A45A 2022      TST	R2
    0A45B F029      BEQ	0xA461
    0A45C 9180 06F6 LDS	R24,CardNoneUseful
(0218) 			f ++;
    0A45E 3081      CPI	R24,1
    0A45F F409      BNE	0xA461
    0A460 DABA      RCALL	_TestALampClose
    0A461 EF08      LDI	R16,0xF8
    0A462 E11C      LDI	R17,0x1C
    0A463 DC8E      RCALL	_TestQueueForward
    0A464 E086      LDI	R24,6
    0A465 9380 1C19 STS	TurnPlateUsedLock+1,R24
    0A467 C038      RJMP	0xA4A0
    0A468 9180 00C1 LDS	R24,0xC1
    0A46A 7E8F      ANDI	R24,0xEF
    0A46B 9380 00C1 STS	0xC1,R24
    0A46D ED25      LDI	R18,0xD5
(0219)         	}
(0220)     }
(0221) 	//c = 0x03;		
(0222) 	//uart0SendData(&c, 1);
(0223) }
(0224) 
(0225) void uart0SendInt(unsigned long Num)
(0226) {
(0227)   if(Num < 10)
    0A46E E130      LDI	R19,0x10
    0A46F EE01      LDI	R16,0xE1
    0A470 E019      LDI	R17,0x9
    0A471 940E A90D CALL	_uart_Printf
    0A473 9110 1C1C LDS	R17,TurnPlateUsedLock+4
    0A475 E00D      LDI	R16,0xD
    0A476 0301      MULSU	R16,R17
    0A477 E784      LDI	R24,0x74
    0A478 E19A      LDI	R25,0x1A
    0A479 01F0      MOVW	R30,R0
    0A47A 0FE8      ADD	R30,R24
(0228)   {
(0229)     uart0SendChar(Num + '0');
    0A47B 1FF9      ADC	R31,R25
    0A47C 8100      LD	R16,Z
    0A47D 8111      LDD	R17,Z+1
    0A47E 8122      LDD	R18,Z+2
    0A47F 8133      LDD	R19,Z+3
    0A480 940E A940 CALL	_uart0SendInt
    0A482 9120 1C1C LDS	R18,TurnPlateUsedLock+4
    0A484 2733      CLR	R19
    0A485 ED09      LDI	R16,0xD9
(0230)   }
    0A486 E019      LDI	R17,0x9
(0231)   else
(0232)   {
(0233)     uart0SendInt(Num / 10);
    0A487 940E A90D CALL	_uart_Printf
    0A489 9180 00C1 LDS	R24,0xC1
    0A48B 6180      ORI	R24,0x10
    0A48C 9380 00C1 STS	0xC1,R24
    0A48E E083      LDI	R24,3
    0A48F 9380 1C19 STS	TurnPlateUsedLock+1,R24
    0A491 2422      CLR	R2
    0A492 9220 1C1A STS	TurnPlateUsedLock+2,R2
    0A494 C00B      RJMP	0xA4A0
    0A495 2422      CLR	R2
(0234)     uart0SendInt(Num % 10);
    0A496 9220 1C19 STS	TurnPlateUsedLock+1,R2
    0A498 9220 1C1A STS	TurnPlateUsedLock+2,R2
    0A49A 9220 1C1B STS	TurnPlateUsedLock+3,R2
    0A49C 9220 1C18 STS	TurnPlateUsedLock,R2
    0A49E 9220 1C18 STS	TurnPlateUsedLock,R2
    0A4A0 2700      CLR	R16
    0A4A1 9628      ADIW	R28,0x8
    0A4A2 940C AE9E JMP	pop_xgsetF00C
_TestBQueueProcess:
    0A4A4 940E AE97 CALL	push_xgsetF00C
(0235)   }
    0A4A6 9728      SBIW	R28,0x8
_SetWasteCardState:
  m                    --> R20
    0A4A7 9020 1C20 LDS	R2,TurnPlateUsedLock+8
    0A4A9 9220 1C28 STS	ReReadFlag+1,R2
FILE: D:\Work\主控软件\2032A2~1\unLoadProcess.c
(0001) 
(0002) #include <iom1280v.h>
(0003) #include "B1404_LIB.h"
(0004) #include "Common.h"
(0005) #include "eeprom.h"
(0006) 
(0007) 
(0008) extern RING_QUEUE	RingQueue;
(0009) extern unsigned char insertflag[30];
(0010) UNLOAD_QUEUE UnloadQueue;
(0011) extern unsigned long SecondCount;	// 秒时钟计数
(0012) extern unsigned char TurnPlateUsedLock;		// 转盘使用锁
(0013) 
(0014) // 废片盒处理
(0015) unsigned long TranCanCountBase;
(0016) unsigned char TrashCanState;
(0017) extern unsigned char WorkProcessStep;
(0018) extern SAMP_INFO NewTestInfo;
(0019) extern unsigned char stopTestFlag;			// 停止测试,如果废片仓连续开启时间超过20分钟
(0020) unsigned char wasteCardNoneUseful = 0;		// 废片仓功能开启 0   关闭 1
(0021) 
(0022) // 设置是否使用废片仓  0 使用  1 不使用
(0023) void SetWasteCardState(unsigned char m)
(0024) {
(0025) 	if(m > 1)
    0A4AB 9020 1C21 LDS	R2,TurnPlateUsedLock+9
(0026) 		m = 1;
    0A4AD 9220 1C29 STS	ReReadFlag+2,R2
(0027) 	wasteCardNoneUseful = m;
    0A4AF 9020 1C22 LDS	R2,TurnPlateUsedLock+10
(0028) 	Uart0ReUnable;
    0A4B1 2022      TST	R2
    0A4B2 F409      BNE	0xA4B4
    0A4B3 C044      RJMP	0xA4F8
    0A4B4 E001      LDI	R16,1
(0029) 	uart_Printf("%s $%4d\r\n", strM3118, m);
    0A4B5 940E 97C6 CALL	_WaitDelayTime
    0A4B7 2300      TST	R16
    0A4B8 F189      BEQ	0xA4EA
    0A4B9 9180 1C20 LDS	R24,TurnPlateUsedLock+8
    0A4BB 3085      CPI	R24,5
    0A4BC F559      BNE	0xA4E8
    0A4BD 9180 1C27 LDS	R24,ReReadFlag
(0030) 	Uart0ReEnable;
    0A4BF 3081      CPI	R24,1
    0A4C0 F4D9      BNE	0xA4DC
    0A4C1 9180 1C26 LDS	R24,TurnPlateUsedLock+14
    0A4C3 5F8F      SUBI	R24,0xFF
    0A4C4 9380 1C26 STS	TurnPlateUsedLock+14,R24
    0A4C6 3081      CPI	R24,1
(0031) }
(0032) 
(0033) unsigned char GetwasteCardState(void)
(0034) {
(0035) 	return wasteCardNoneUseful;
_GetwasteCardState:
    0A4C7 F471      BNE	0xA4D6
    0A4C8 9120 1C2F LDS	R18,TestQueueB
_UnloadQueueDatInit:
  pChar                --> R22
  i                    --> R20
    0A4CA E001      LDI	R16,1
    0A4CB 940E 6A7F CALL	_MotRunToSite
(0036) }
(0037) 
(0038) void UnloadQueueDatInit(void)
(0039) {
(0040) 	unsigned int i;
(0041) 	unsigned char *pChar;
(0042) 
(0043) 	pChar = (unsigned char *)&(UnloadQueue);
    0A4CD 2422      CLR	R2
(0044) 	for(i = 0; i < sizeof(UNLOAD_QUEUE); i++)
    0A4CE 9220 1C27 STS	ReReadFlag,R2
    0A4D0 E081      LDI	R24,1
(0045) 	{
(0046) 		*pChar++ = 0;
    0A4D1 9380 1C24 STS	TurnPlateUsedLock+12,R24
    0A4D3 9380 1C20 STS	TurnPlateUsedLock+8,R24
    0A4D5 C006      RJMP	0xA4DC
    0A4D6 2422      CLR	R2
    0A4D7 9220 1C27 STS	ReReadFlag,R2
    0A4D9 E185      LDI	R24,0x15
    0A4DA 9380 1C20 STS	TurnPlateUsedLock+8,R24
(0047) 	}
(0048) 	for(i = 0; i < TEST_QUEUE_NUM; i++)
    0A4DC 9020 1C2C LDS	R2,ReReadFlag+5
(0049) 	{
(0050) 		UnloadQueue.ringNum[i] = 0xff;
    0A4DE 2022      TST	R2
    0A4DF F041      BEQ	0xA4E8
    0A4E0 E025      LDI	R18,5
    0A4E1 E030      LDI	R19,0
    0A4E2 E001      LDI	R16,1
    0A4E3 940E 97B7 CALL	_SetDelayTime
    0A4E5 2422      CLR	R2
    0A4E6 9220 1C2C STS	ReReadFlag+5,R2
    0A4E8 2700      CLR	R16
    0A4E9 C25E      RJMP	0xA748
    0A4EA 9020 1C24 LDS	R2,TurnPlateUsedLock+12
(0051) 	}
(0052) 	TranCanCountBase = ReadCurTestSetial();
    0A4EC 2022      TST	R2
    0A4ED F051      BEQ	0xA4F8
    0A4EE E001      LDI	R16,1
    0A4EF 940E 6A0C CALL	_GetMotState
    0A4F1 3001      CPI	R16,1
    0A4F2 F011      BEQ	0xA4F5
    0A4F3 2700      CLR	R16
    0A4F4 C253      RJMP	0xA748
    0A4F5 2422      CLR	R2
    0A4F6 9220 1C24 STS	TurnPlateUsedLock+12,R2
    0A4F8 90A0 1C20 LDS	R10,TurnPlateUsedLock+8
    0A4FA 24BB      CLR	R11
(0053) }
(0054) 
(0055) // 卸片任务入队
(0056) void UnloadQueueAdd(unsigned char ringNum, signed long time)
(0057) {
(0058) 	// 根据时间先后顺序将待卸载干片位置号放入卸片队列中等待卸片
(0059) 	unsigned char n, i;
(0060) 
(0061) 	// 查找出插入位置
(0062) 	for(n=0; n<RING_QUEUE_NUM; n++)
    0A4FB 20AA      TST	R10
    0A4FC F419      BNE	0xA500
(0063) 	{
(0064) 		if(UnloadQueue.ringNum[n] == 0xff)		// 已经到队尾了，直接插入到队尾
    0A4FD 20BB      TST	R11
    0A4FE F409      BNE	0xA500
    0A4FF C035      RJMP	0xA535
    0A500 01C5      MOVW	R24,R10
    0A501 3081      CPI	R24,1
    0A502 E0E0      LDI	R30,0
    0A503 079E      CPC	R25,R30
    0A504 F409      BNE	0xA506
    0A505 C0C0      RJMP	0xA5C6
(0065) 			break;
    0A506 3082      CPI	R24,2
(0066) 		else
(0067) 		{
(0068) 			if(UnloadQueue.unloadTime[n] > time)
    0A507 E0E0      LDI	R30,0
    0A508 079E      CPC	R25,R30
    0A509 F409      BNE	0xA50B
    0A50A C100      RJMP	0xA60B
    0A50B 3083      CPI	R24,3
    0A50C E0E0      LDI	R30,0
    0A50D 079E      CPC	R25,R30
    0A50E F409      BNE	0xA510
    0A50F C10C      RJMP	0xA61C
    0A510 3084      CPI	R24,4
    0A511 E0E0      LDI	R30,0
    0A512 079E      CPC	R25,R30
    0A513 F409      BNE	0xA515
    0A514 C120      RJMP	0xA635
    0A515 3085      CPI	R24,5
    0A516 E0E0      LDI	R30,0
    0A517 079E      CPC	R25,R30
    0A518 F409      BNE	0xA51A
    0A519 C19D      RJMP	0xA6B7
    0A51A 3086      CPI	R24,6
    0A51B E0E0      LDI	R30,0
    0A51C 079E      CPC	R25,R30
    0A51D F409      BNE	0xA51F
(0069) 			{
(0070) 				break;							// 查找到当前的元素的卸载时间比插入的更晚，插入当前位置
    0A51E C21B      RJMP	0xA73A
    0A51F 308A      CPI	R24,0xA
    0A520 E0E0      LDI	R30,0
    0A521 079E      CPC	R25,R30
(0071) 			}
(0072) 		}
(0073) 	}
(0074) 	// n为查找到的插入位置
(0075) 	i = RING_QUEUE_NUM - 1;
    0A522 F409      BNE	0xA524
    0A523 C086      RJMP	0xA5AA
(0076) 	while(i--)
(0077) 	{
(0078) 		if(i != n)
    0A524 308B      CPI	R24,0xB
    0A525 E0E0      LDI	R30,0
(0079) 		{
(0080) 			// 插入位置后面的元素往后移动一步
(0081) 			UnloadQueue.unloadTime[i] = UnloadQueue.unloadTime[i-1];
    0A526 079E      CPC	R25,R30
    0A527 F409      BNE	0xA529
    0A528 C094      RJMP	0xA5BD
    0A529 3080      CPI	R24,0
    0A52A E0E0      LDI	R30,0
    0A52B 079E      CPC	R25,R30
    0A52C F40C      BGE	0xA52E
    0A52D C219      RJMP	0xA747
    0A52E 01C5      MOVW	R24,R10
    0A52F 3185      CPI	R24,0x15
    0A530 E0E0      LDI	R30,0
    0A531 079E      CPC	R25,R30
    0A532 F409      BNE	0xA534
    0A533 C1D9      RJMP	0xA70D
    0A534 C212      RJMP	0xA747
    0A535 9180 1C2F LDS	R24,TestQueueB
    0A537 3F8F      CPI	R24,0xFF
    0A538 F411      BNE	0xA53B
    0A539 E001      LDI	R16,1
    0A53A C20D      RJMP	0xA748
    0A53B 9040 1C59 LDS	R4,TestQueueB+42
    0A53D 9050 1C5A LDS	R5,TestQueueB+43
    0A53F 9020 1C57 LDS	R2,TestQueueB+40
(0082) 			UnloadQueue.ringNum[i] = UnloadQueue.ringNum[i-1];
    0A541 9030 1C58 LDS	R3,TestQueueB+41
    0A543 9488      BCLR	0
    0A544 2022      TST	R2
    0A545 0432      CPC	R3,R2
    0A546 0442      CPC	R4,R2
    0A547 0452      CPC	R5,R2
    0A548 F409      BNE	0xA54A
    0A549 C1FD      RJMP	0xA747
    0A54A E04A      LDI	R20,0xA
    0A54B E050      LDI	R21,0
    0A54C E060      LDI	R22,0
    0A54D E070      LDI	R23,0
    0A54E 1A24      SUB	R2,R20
(0083) 		}
    0A54F 0A35      SBC	R3,R21
(0084) 		else
(0085) 		{	
(0086) 			// 插入新的任务
(0087) 			UnloadQueue.unloadTime[i] = time;
    0A550 0A46      SBC	R4,R22
    0A551 0A57      SBC	R5,R23
    0A552 9080 0529 LDS	R8,SecondCount+2
    0A554 9090 052A LDS	R9,SecondCount+3
    0A556 9060 0527 LDS	R6,SecondCount
    0A558 9070 0528 LDS	R7,SecondCount+1
    0A55A 1426      CP	R2,R6
    0A55B 0437      CPC	R3,R7
    0A55C 0448      CPC	R4,R8
    0A55D 0459      CPC	R5,R9
    0A55E F008      BCS	0xA560
    0A55F C1E7      RJMP	0xA747
    0A560 9020 1C2F LDS	R2,TestQueueB
(0088) 			UnloadQueue.ringNum[i] = ringNum;
    0A562 9220 1C23 STS	TurnPlateUsedLock+11,R2
    0A564 9020 1C18 LDS	R2,TurnPlateUsedLock
    0A566 2022      TST	R2
    0A567 F009      BEQ	0xA569
    0A568 C1DE      RJMP	0xA747
(0089) 			break;
    0A569 EC81      LDI	R24,0xC1
    0A56A E19D      LDI	R25,0x1D
    0A56B 91E0 1C23 LDS	R30,TurnPlateUsedLock+11
    0A56D 27FF      CLR	R31
    0A56E 0FE8      ADD	R30,R24
    0A56F 1FF9      ADC	R31,R25
    0A570 8180      LD	R24,Z
    0A571 3F8F      CPI	R24,0xFF
    0A572 F009      BEQ	0xA574
    0A573 C1D3      RJMP	0xA747
(0090) 		}
(0091) 	}
(0092) }
(0093) 
(0094) void UnloadQueueForward(){
(0095) 	// 测试队列前进一步，当队头测试完毕后，队头元素删除队列前进一步
(0096) 	unsigned char i;
(0097) 	for(i=0; i<RING_QUEUE_NUM; i++)
_UnloadQueueForward:
  i                    --> R16
    0A574 EC81      LDI	R24,0xC1
    0A575 E19D      LDI	R25,0x1D
(0098) 	{
(0099) 		if(i != (RING_QUEUE_NUM-1))
    0A576 91E0 1C23 LDS	R30,TurnPlateUsedLock+11
(0100) 		{
(0101) 			// 每个元素往前移动一个，队头元素被后面覆盖
(0102) 			UnloadQueue.unloadTime[i] = UnloadQueue.unloadTime[i+1];
    0A578 27FF      CLR	R31
    0A579 0FE8      ADD	R30,R24
    0A57A 1FF9      ADC	R31,R25
    0A57B EC88      LDI	R24,0xC8
    0A57C 8380      ST	Z,R24
    0A57D 9180 00C1 LDS	R24,0xC1
    0A57F 7E8F      ANDI	R24,0xEF
    0A580 9380 00C1 STS	0xC1,R24
    0A582 90A0 1C23 LDS	R10,TurnPlateUsedLock+11
    0A584 EC81      LDI	R24,0xC1
    0A585 E19D      LDI	R25,0x1D
    0A586 2DEA      MOV	R30,R10
    0A587 27FF      CLR	R31
    0A588 0FE8      ADD	R30,R24
    0A589 1FF9      ADC	R31,R25
    0A58A 8020      LD	R2,Z
    0A58B 2433      CLR	R3
    0A58C 823B      STD	Y+3,R3
    0A58D 822A      STD	Y+2,R2
    0A58E 2C2A      MOV	R2,R10
    0A58F 2433      CLR	R3
    0A590 8239      STD	Y+1,R3
    0A591 8228      ST	Y,R2
    0A592 E722      LDI	R18,0x72
(0103) 			UnloadQueue.ringNum[i] = UnloadQueue.ringNum[i+1];
    0A593 E03E      LDI	R19,0xE
    0A594 EE07      LDI	R16,0xE7
    0A595 E019      LDI	R17,0x9
    0A596 940E A90D CALL	_uart_Printf
    0A598 9180 00C1 LDS	R24,0xC1
    0A59A 6180      ORI	R24,0x10
    0A59B 9380 00C1 STS	0xC1,R24
    0A59D E081      LDI	R24,1
    0A59E 9380 1C18 STS	TurnPlateUsedLock,R24
    0A5A0 E08A      LDI	R24,0xA
(0104) 		}
    0A5A1 9380 1C20 STS	TurnPlateUsedLock+8,R24
(0105) 		else
(0106) 		{
(0107) 			// 队尾填充零
(0108) 			UnloadQueue.unloadTime[i] = 0;
    0A5A3 2422      CLR	R2
    0A5A4 9220 1C21 STS	TurnPlateUsedLock+9,R2
    0A5A6 E081      LDI	R24,1
    0A5A7 9380 1C22 STS	TurnPlateUsedLock+10,R24
    0A5A9 C19D      RJMP	0xA747
    0A5AA E081      LDI	R24,1
    0A5AB 838A      STD	Y+2,R24
    0A5AC E184      LDI	R24,0x14
    0A5AD 8388      ST	Y,R24
    0A5AE EC28      LDI	R18,0xC8
    0A5AF E001      LDI	R16,1
    0A5B0 940E 6A9F CALL	_SetMotRunPam
(0109) 			UnloadQueue.ringNum[i] = 0xff;
    0A5B2 2722      CLR	R18
    0A5B3 E001      LDI	R16,1
    0A5B4 940E 6A7F CALL	_MotRunToSite
    0A5B6 E081      LDI	R24,1
    0A5B7 9380 1C24 STS	TurnPlateUsedLock+12,R24
    0A5B9 E08B      LDI	R24,0xB
    0A5BA 9380 1C20 STS	TurnPlateUsedLock+8,R24
    0A5BC C18A      RJMP	0xA747
    0A5BD E022      LDI	R18,2
_printf_UnloadProcess_StepState:
    0A5BE E030      LDI	R19,0
(0110) 		}
(0111) 	}
(0112) }
(0113) 
(0114) static unsigned char UnloadProcess_workStep,UnloadProcess_mainStep;
(0115) 
(0116) void printf_UnloadProcess_StepState(void)
(0117) {
(0118) 	uart_Printf("*3202 UnloadStepState $%2d $%2d\r\n",UnloadProcess_mainStep,UnloadProcess_workStep);
    0A5BF E001      LDI	R16,1
    0A5C0 940E 97B7 CALL	_SetDelayTime
    0A5C2 E081      LDI	R24,1
    0A5C3 9380 1C20 STS	TurnPlateUsedLock+8,R24
    0A5C5 C181      RJMP	0xA747
    0A5C6 9180 1C23 LDS	R24,TurnPlateUsedLock+11
    0A5C8 5E8D      SUBI	R24,0xED
    0A5C9 2EA8      MOV	R10,R24
    0A5CA 9180 00C1 LDS	R24,0xC1
    0A5CC 7E8F      ANDI	R24,0xEF
_UnloadQueueProcess:
  ucTmp                --> R20
  i                    --> R20
  l                    --> Y,+4
    0A5CD 9380 00C1 STS	0xC1,R24
    0A5CF ED25      LDI	R18,0xD5
(0119) }
(0120) 
(0121) unsigned char UnloadQueueProcess(void){
(0122) 	// 监测卸片队列上的卸片时间，将到时间的干片卸载
(0123) 	static unsigned char mainStep;		
(0124) 	static unsigned char workStep;
(0125) 	static unsigned char inWork;
(0126) 	static unsigned char ringNum;
(0127) 	static unsigned char n,m,j,k;
(0128) 	static unsigned char watiMotTurnplate, waitMotUnload;
(0129) 	unsigned char ucTmp;
(0130) 	unsigned int i;
(0131) 	unsigned long l;
(0132) 	UnloadProcess_mainStep = mainStep;
    0A5D0 E130      LDI	R19,0x10
    0A5D1 EE01      LDI	R16,0xE1
    0A5D2 E019      LDI	R17,0x9
    0A5D3 940E A90D CALL	_uart_Printf
(0133) 	UnloadProcess_workStep = workStep;
    0A5D5 9110 1C23 LDS	R17,TurnPlateUsedLock+11
    0A5D7 E00D      LDI	R16,0xD
(0134) 	if(inWork)
    0A5D8 0301      MULSU	R16,R17
    0A5D9 E784      LDI	R24,0x74
    0A5DA E19A      LDI	R25,0x1A
    0A5DB 01F0      MOVW	R30,R0
(0135) 	{
(0136) 		if(WaitDelayTime(MOT_CARD_UNLOAD))		return 0;
    0A5DC 0FE8      ADD	R30,R24
    0A5DD 1FF9      ADC	R31,R25
    0A5DE 8100      LD	R16,Z
    0A5DF 8111      LDD	R17,Z+1
    0A5E0 8122      LDD	R18,Z+2
    0A5E1 8133      LDD	R19,Z+3
    0A5E2 940E A940 CALL	_uart0SendInt
(0137) 		if(watiMotTurnplate)
    0A5E4 9120 1C23 LDS	R18,TurnPlateUsedLock+11
    0A5E6 2733      CLR	R19
(0138) 		{	// 等待转盘电机
(0139) 			if(GetMotState(MOT_TURN_PLATE)!=STA_SLAVE_FREE)	return 0;
    0A5E7 ED09      LDI	R16,0xD9
    0A5E8 E019      LDI	R17,0x9
    0A5E9 940E A90D CALL	_uart_Printf
    0A5EB 9180 00C1 LDS	R24,0xC1
    0A5ED 6180      ORI	R24,0x10
(0140) 			watiMotTurnplate = 0;
    0A5EE 9380 00C1 STS	0xC1,R24
    0A5F0 2D8A      MOV	R24,R10
(0141) 		}
(0142) 		if(waitMotUnload)	// 等待干片卸载电机
    0A5F1 318E      CPI	R24,0x1E
    0A5F2 F010      BCS	0xA5F5
    0A5F3 518E      SUBI	R24,0x1E
    0A5F4 2EA8      MOV	R10,R24
(0143) 		{
(0144) 			if(GetMotState(MOT_CARD_UNLOAD)!=STA_SLAVE_FREE)	return 0;
    0A5F5 E081      LDI	R24,1
    0A5F6 838A      STD	Y+2,R24
    0A5F7 E184      LDI	R24,0x14
    0A5F8 8388      ST	Y,R24
    0A5F9 EC28      LDI	R18,0xC8
    0A5FA E001      LDI	R16,1
    0A5FB 940E 6A9F CALL	_SetMotRunPam
(0145) 			waitMotUnload = 0;
    0A5FD 2D2A      MOV	R18,R10
    0A5FE E001      LDI	R16,1
    0A5FF 940E 6A7F CALL	_MotRunToSite
(0146) 		}
(0147) 	}
(0148) 	switch(mainStep)
    0A601 E081      LDI	R24,1
    0A602 9380 1C24 STS	TurnPlateUsedLock+12,R24
    0A604 E082      LDI	R24,2
    0A605 9380 1C20 STS	TurnPlateUsedLock+8,R24
    0A607 2422      CLR	R2
    0A608 9220 1C21 STS	TurnPlateUsedLock+9,R2
    0A60A C13C      RJMP	0xA747
    0A60B E624      LDI	R18,0x64
    0A60C E030      LDI	R19,0
    0A60D E001      LDI	R16,1
    0A60E 940E 6A2C CALL	_MotRun
    0A610 E081      LDI	R24,1
    0A611 9380 1C24 STS	TurnPlateUsedLock+12,R24
    0A613 E025      LDI	R18,5
    0A614 E030      LDI	R19,0
    0A615 E001      LDI	R16,1
(0149) 	{
(0150) 		case 0:		// 监测队头的时间
(0151) 			if(UnloadQueue.ringNum[0] != 0xff)
    0A616 940E 97B7 CALL	_SetDelayTime
    0A618 E083      LDI	R24,3
    0A619 9380 1C20 STS	TurnPlateUsedLock+8,R24
(0152) 			{
(0153) 				if(UnloadQueue.unloadTime[0] < SecondCount)
    0A61B C12B      RJMP	0xA747
    0A61C E828      LDI	R18,0x88
    0A61D EF3F      LDI	R19,0xFF
    0A61E E001      LDI	R16,1
    0A61F 940E 6A2C CALL	_MotRun
    0A621 E081      LDI	R24,1
    0A622 9380 1C24 STS	TurnPlateUsedLock+12,R24
    0A624 E02A      LDI	R18,0xA
    0A625 E030      LDI	R19,0
    0A626 E001      LDI	R16,1
    0A627 940E 97B7 CALL	_SetDelayTime
    0A629 2422      CLR	R2
    0A62A 9220 1C27 STS	ReReadFlag,R2
    0A62C 9020 1C2E LDS	R2,ReReadFlag+7
    0A62E 2022      TST	R2
    0A62F F409      BNE	0xA631
    0A630 D8D7      RCALL	_TestALampOpen
(0154) 				{
(0155) 					ringNum = UnloadQueue.ringNum[0];
    0A631 E084      LDI	R24,4
    0A632 9380 1C20 STS	TurnPlateUsedLock+8,R24
(0156) 					
(0157) 					// 废片仓功能开启
(0158) 					if(GetwasteCardState() == 0)
    0A634 C112      RJMP	0xA747
    0A635 9040 1C59 LDS	R4,TestQueueB+42
    0A637 9050 1C5A LDS	R5,TestQueueB+43
(0159) 					{
(0160) 						// 卸片时间到
(0161) 						if(TrashCanCheck())
    0A639 9020 1C57 LDS	R2,TestQueueB+40
    0A63B 9030 1C58 LDS	R3,TestQueueB+41
(0162) 						{
(0163) 							// 监测废片盒
(0164) 							return 0;
    0A63D 9080 0529 LDS	R8,SecondCount+2
(0165) 						}
(0166) 						if((PINK & 0x02) == 0)
    0A63F 9090 052A LDS	R9,SecondCount+3
    0A641 9060 0527 LDS	R6,SecondCount
(0167) 						{
(0168) 							return 0;
    0A643 9070 0528 LDS	R7,SecondCount+1
(0169) 						}
(0170) 					}
(0171) 					if(TurnPlateUsedLock == 0)
    0A645 1462      CP	R6,R2
    0A646 0473      CPC	R7,R3
    0A647 0484      CPC	R8,R4
    0A648 0495      CPC	R9,R5
(0172) 					{
(0173) 						if(200 == insertflag[ringNum])
    0A649 F408      BCC	0xA64B
    0A64A C0FC      RJMP	0xA747
    0A64B 9020 1C2F LDS	R2,TestQueueB
    0A64D 9220 1C23 STS	TurnPlateUsedLock+11,R2
    0A64F 2D12      MOV	R17,R2
    0A650 E00D      LDI	R16,0xD
    0A651 0301      MULSU	R16,R17
    0A652 E784      LDI	R24,0x74
    0A653 E19A      LDI	R25,0x1A
(0174) 						{
(0175) 							TurnPlateUsedLock = 1;		// 占用转盘标识
    0A654 01F0      MOVW	R30,R0
    0A655 0FE8      ADD	R30,R24
    0A656 1FF9      ADC	R31,R25
(0176) 							mainStep = 1;
    0A657 8020      LD	R2,Z
    0A658 8031      LDD	R3,Z+1
(0177) 							workStep = 0;
    0A659 8042      LDD	R4,Z+2
    0A65A 8053      LDD	R5,Z+3
    0A65B 822C      STD	Y+4,R2
(0178) 							inWork = 1; 
    0A65C 823D      STD	Y+5,R3
    0A65D 824E      STD	Y+6,R4
(0179) 						}
(0180) 					}
(0181) 				}
(0182) 			}
    0A65E 825F      STD	Y+7,R5
(0183) 			else
(0184) 			{
(0185) 				return 1;
    0A65F 0301      MULSU	R16,R17
    0A660 E78C      LDI	R24,0x7C
(0186) 			}
(0187) 			break;
(0188) 		case 1:		// 转盘转到当前位置，将干片卸载
(0189) 			switch(workStep)
    0A661 E19A      LDI	R25,0x1A
    0A662 01F0      MOVW	R30,R0
    0A663 0FE8      ADD	R30,R24
    0A664 1FF9      ADC	R31,R25
    0A665 80A0      LD	R10,Z
    0A666 80B1      LDD	R11,Z+1
    0A667 9040 1C59 LDS	R4,TestQueueB+42
    0A669 9050 1C5A LDS	R5,TestQueueB+43
    0A66B 9020 1C57 LDS	R2,TestQueueB+40
    0A66D 9030 1C58 LDS	R3,TestQueueB+41
    0A66F 9080 0529 LDS	R8,SecondCount+2
    0A671 9090 052A LDS	R9,SecondCount+3
    0A673 9060 0527 LDS	R6,SecondCount
    0A675 9070 0528 LDS	R7,SecondCount+1
    0A677 1862      SUB	R6,R2
    0A678 0873      SBC	R7,R3
    0A679 0884      SBC	R8,R4
    0A67A 0895      SBC	R9,R5
    0A67B 0CA6      ADD	R10,R6
    0A67C 1CB7      ADC	R11,R7
    0A67D 9180 00C1 LDS	R24,0xC1
    0A67F 7E8F      ANDI	R24,0xEF
    0A680 9380 00C1 STS	0xC1,R24
    0A682 EB28      LDI	R18,0xB8
    0A683 E03D      LDI	R19,0xD
    0A684 EE01      LDI	R16,0xE1
    0A685 E019      LDI	R17,0x9
    0A686 940E A90D CALL	_uart_Printf
    0A688 810C      LDD	R16,Y+4
    0A689 811D      LDD	R17,Y+5
(0190) 			{
(0191) 				case 0:		// 转盘转至0位
(0192) 					SetMotRunPam(MOT_TURN_PLATE,200,20,CURRENT_TURN_PLATE);
    0A68A 812E      LDD	R18,Y+6
    0A68B 813F      LDD	R19,Y+7
    0A68C 940E A940 CALL	_uart0SendInt
    0A68E 9020 1C23 LDS	R2,TurnPlateUsedLock+11
    0A690 2433      CLR	R3
    0A691 8239      STD	Y+1,R3
(0193) 					MotRunToSite(MOT_TURN_PLATE,0);		// 转盘运行到零位
    0A692 8228      ST	Y,R2
    0A693 0195      MOVW	R18,R10
    0A694 EC0B      LDI	R16,0xCB
    0A695 E019      LDI	R17,0x9
(0194) 					workStep = 10;
    0A696 940E A90D CALL	_uart_Printf
    0A698 9120 0529 LDS	R18,SecondCount+2
(0195) 					watiMotTurnplate = 1;
    0A69A 9130 052A LDS	R19,SecondCount+3
(0196) 					break;	
    0A69C 9100 0527 LDS	R16,SecondCount
(0197) 				case 10:		// 转盘转到当前位置
(0198) 					ringNum = UnloadQueue.ringNum[0];
    0A69E 9110 0528 LDS	R17,SecondCount+1
    0A6A0 940E A940 CALL	_uart0SendInt
(0199) 					ucTmp = ringNum + 25;
    0A6A2 EC08      LDI	R16,0xC8
(0200) 					if(ucTmp>=RING_QUEUE_NUM)
    0A6A3 E019      LDI	R17,0x9
    0A6A4 940E A90D CALL	_uart_Printf
(0201) 						ucTmp -= RING_QUEUE_NUM;
    0A6A6 9180 00C1 LDS	R24,0xC1
    0A6A8 6180      ORI	R24,0x10
    0A6A9 9380 00C1 STS	0xC1,R24
(0202) 					//SetMotRunPam(MOT_TURN_PLATE,200,20,CURRENT_TURN_PLATE);
(0203) 					MotRunToSite(MOT_TURN_PLATE,ucTmp);		// 转盘转到当前位置
(0204) 					watiMotTurnplate = 1;
    0A6AB 2422      CLR	R2
    0A6AC 9220 1C2C STS	ReReadFlag+5,R2
(0205) 					workStep = 1;
    0A6AE E624      LDI	R18,0x64
(0206) 					break;
    0A6AF E030      LDI	R19,0
(0207) 				//////////////////////////////////////////////////////
(0208) 				case 1:
(0209) 					SetDelayTime(MOT_CARD_UNLOAD,5);
    0A6B0 E001      LDI	R16,1
    0A6B1 940E 97B7 CALL	_SetDelayTime
    0A6B3 E085      LDI	R24,5
    0A6B4 9380 1C20 STS	TurnPlateUsedLock+8,R24
(0210) #ifndef LoadCheck
(0211) 					workStep = 3;
(0212) #else					
(0213) 					workStep = 2;
    0A6B6 C090      RJMP	0xA747
    0A6B7 9110 1C23 LDS	R17,TurnPlateUsedLock+11
(0214) #endif
(0215) 					break;
    0A6B9 E00D      LDI	R16,0xD
    0A6BA 0301      MULSU	R16,R17
    0A6BB E784      LDI	R24,0x74
    0A6BC E19A      LDI	R25,0x1A
    0A6BD 01F0      MOVW	R30,R0
(0216) 				case 2:
(0217) 					i = getLiqDetADC(UnloadChannel);
(0218) 					/*
(0219) 					if(i < 500)	// 当前位置没有试剂片
(0220) 					{
(0221) 						//mainStep = 2;
(0222) 						//workStep = 0;
(0223) 						//uart_Printf("%s $ %d\r\n",strE3933,i);
(0224) 						j++;
(0225) 						if(j > 1)
(0226) 						{
(0227) 							j = 0;
(0228) 							mainStep = 2;
(0229) 							workStep = 0;
(0230) 							uart_Printf("%s $ %d\r\n",strE3933,i);
(0231) 						}
(0232) 						else
(0233) 						{
(0234) 							workStep = 0;	// 重新转至该位置检测
(0235) 						}
(0236) 					}
(0237) 					else if(i > 900)	// 有试剂片
(0238) 					{
(0239) 						workStep = 3;
(0240) 						uart_Printf("%s $ %d\r\n",strM3194,i);
(0241) 					}
(0242) 					else
(0243) 					{
(0244) 						uart_Printf("!3945 UnloadAdcOutofScope $ %d\r\n",(unsigned int)i);
(0245) 						workStep = 3;
(0246) 					}
(0247) 					*/
(0248) 					if(i < CardLocationAD)	// 当前位置没有试剂片
    0A6BE 0FE8      ADD	R30,R24
    0A6BF 1FF9      ADC	R31,R25
    0A6C0 8020      LD	R2,Z
    0A6C1 8031      LDD	R3,Z+1
(0249) 					{
(0250) 						j++;
    0A6C2 8042      LDD	R4,Z+2
    0A6C3 8053      LDD	R5,Z+3
    0A6C4 822C      STD	Y+4,R2
    0A6C5 823D      STD	Y+5,R3
    0A6C6 824E      STD	Y+6,R4
(0251) 						if(j > 1)
    0A6C7 825F      STD	Y+7,R5
    0A6C8 9180 00C1 LDS	R24,0xC1
    0A6CA 7E8F      ANDI	R24,0xEF
    0A6CB 9380 00C1 STS	0xC1,R24
(0252) 						{
(0253) 							j = 0;
    0A6CD 802C      LDD	R2,Y+4
    0A6CE 803D      LDD	R3,Y+5
(0254) 							mainStep = 2;
    0A6CF 804E      LDD	R4,Y+6
    0A6D0 805F      LDD	R5,Y+7
    0A6D1 8228      ST	Y,R2
(0255) 							workStep = 0;
    0A6D2 8239      STD	Y+1,R3
    0A6D3 824A      STD	Y+2,R4
(0256) 							Uart0ReUnable;
    0A6D4 825B      STD	Y+3,R5
    0A6D5 ED2A      LDI	R18,0xDA
    0A6D6 E03D      LDI	R19,0xD
    0A6D7 EE01      LDI	R16,0xE1
    0A6D8 E019      LDI	R17,0x9
(0257) 							uart_Printf("%s $ %d\r\n",strE3933,i);
    0A6D9 940E A90D CALL	_uart_Printf
    0A6DB 810C      LDD	R16,Y+4
    0A6DC 811D      LDD	R17,Y+5
    0A6DD 812E      LDD	R18,Y+6
    0A6DE 813F      LDD	R19,Y+7
    0A6DF 940E A940 CALL	_uart0SendInt
(0258) 							Uart0ReEnable;
    0A6E1 EC04      LDI	R16,0xC4
    0A6E2 E019      LDI	R17,0x9
    0A6E3 940E A90D CALL	_uart_Printf
    0A6E5 9120 0529 LDS	R18,SecondCount+2
(0259) 						}
    0A6E7 9130 052A LDS	R19,SecondCount+3
    0A6E9 9100 0527 LDS	R16,SecondCount
(0260) 						else
(0261) 						{
(0262) 							workStep = 0;	// 重新转至该位置检测
(0263) 						}
(0264) 					}
    0A6EB 9110 0528 LDS	R17,SecondCount+1
    0A6ED 940E A940 CALL	_uart0SendInt
(0265) 					else 					// 有试剂片
(0266) 					{
(0267) 						workStep = 3;
(0268) 						Uart0ReUnable;
    0A6EF EC08      LDI	R16,0xC8
    0A6F0 E019      LDI	R17,0x9
    0A6F1 940E A90D CALL	_uart_Printf
(0269) 						uart_Printf("%s $ %d\r\n",strM3194,i);
    0A6F3 9180 00C1 LDS	R24,0xC1
    0A6F5 6180      ORI	R24,0x10
    0A6F6 9380 00C1 STS	0xC1,R24
    0A6F8 9020 1C2E LDS	R2,ReReadFlag+7
    0A6FA 2022      TST	R2
(0270) 						Uart0ReEnable;
    0A6FB F029      BEQ	0xA701
    0A6FC 9180 06F6 LDS	R24,CardNoneUseful
    0A6FE 3081      CPI	R24,1
    0A6FF F409      BNE	0xA701
(0271) 					}
(0272) 					break;
    0A700 D81A      RCALL	_TestALampClose
(0273) 				case 3:
(0274) 					if(GetwasteCardState() == 0)
    0A701 E20F      LDI	R16,0x2F
    0A702 E11C      LDI	R17,0x1C
    0A703 D9EE      RCALL	_TestQueueForward
    0A704 E02A      LDI	R18,0xA
(0275) 					{
(0276) 						if((PINK & 0x02) == 0)
    0A705 E030      LDI	R19,0
    0A706 E001      LDI	R16,1
    0A707 940E 97B7 CALL	_SetDelayTime
(0277) 						{		// 废片仓打开
(0278) 							TurnPlateUsedLock = 0;
    0A709 E086      LDI	R24,6
    0A70A 9380 1C20 STS	TurnPlateUsedLock+8,R24
(0279) 							TurnPlateUsedLock = 0;
    0A70C C03A      RJMP	0xA747
    0A70D 9180 00C1 LDS	R24,0xC1
(0280) 							insertflag[ringNum] = 200;
    0A70F 7E8F      ANDI	R24,0xEF
    0A710 9380 00C1 STS	0xC1,R24
    0A712 ED25      LDI	R18,0xD5
    0A713 E130      LDI	R19,0x10
    0A714 EE01      LDI	R16,0xE1
    0A715 E019      LDI	R17,0x9
    0A716 940E A90D CALL	_uart_Printf
(0281) 							mainStep = 0;
    0A718 9110 1C23 LDS	R17,TurnPlateUsedLock+11
(0282) 							workStep = 0;
    0A71A E00D      LDI	R16,0xD
(0283) 							inWork = 0;
    0A71B 0301      MULSU	R16,R17
    0A71C E784      LDI	R24,0x74
(0284) 							break;
    0A71D E19A      LDI	R25,0x1A
(0285) 						}
(0286) 					}
(0287) 					SetMotRunPam(MOT_CARD_UNLOAD,200,20,CURRENT_CARD_UNLOAD);
    0A71E 01F0      MOVW	R30,R0
    0A71F 0FE8      ADD	R30,R24
    0A720 1FF9      ADC	R31,R25
    0A721 8100      LD	R16,Z
    0A722 8111      LDD	R17,Z+1
    0A723 8122      LDD	R18,Z+2
    0A724 8133      LDD	R19,Z+3
    0A725 940E A940 CALL	_uart0SendInt
(0288) 					MotRunTo(MOT_CARD_UNLOAD,_POS_UNLOAD_OUT);		// 卸片行程67mm/0.08128 = 824
    0A727 9120 1C23 LDS	R18,TurnPlateUsedLock+11
    0A729 2733      CLR	R19
    0A72A ED09      LDI	R16,0xD9
(0289) 					waitMotUnload = 1;
    0A72B E019      LDI	R17,0x9
    0A72C 940E A90D CALL	_uart_Printf
(0290) 					workStep = 4;
    0A72E 9180 00C1 LDS	R24,0xC1
    0A730 6180      ORI	R24,0x10
(0291) 					break;
    0A731 9380 00C1 STS	0xC1,R24
(0292) 				case 4:
(0293) 					SetMotRunPam(MOT_CARD_UNLOAD,100,20,2);
    0A733 E083      LDI	R24,3
    0A734 9380 1C20 STS	TurnPlateUsedLock+8,R24
    0A736 2422      CLR	R2
    0A737 9220 1C21 STS	TurnPlateUsedLock+9,R2
    0A739 C00D      RJMP	0xA747
(0294) 					MotRunTo(MOT_CARD_UNLOAD,0);
    0A73A 2422      CLR	R2
    0A73B 9220 1C20 STS	TurnPlateUsedLock+8,R2
    0A73D 9220 1C21 STS	TurnPlateUsedLock+9,R2
(0295) 					waitMotUnload = 1;
    0A73F 9220 1C22 STS	TurnPlateUsedLock+10,R2
    0A741 9220 1C26 STS	TurnPlateUsedLock+14,R2
(0296) 					workStep = 5;
    0A743 9220 1C18 STS	TurnPlateUsedLock,R2
(0297) 					break;
    0A745 9220 1C18 STS	TurnPlateUsedLock,R2
(0298) 				case 5:
(0299) 					//SetDelayTime(MOT_CARD_UNLOAD,5);
(0300) 					SetDelayTime(MOT_CARD_UNLOAD,10);
    0A747 2700      CLR	R16
    0A748 9628      ADIW	R28,0x8
    0A749 940C AE9E JMP	pop_xgsetF00C
(0301) #ifndef LoadCheck
(0302) 					mainStep = 2; // 不检测下片
(0303) 					workStep = 0; // 不检测下片
(0304) #else
(0305) 					workStep = 6; // 检测下片
_SetReReadFlag:
    0A74B E081      LDI	R24,1
    0A74C 9380 1C27 STS	ReReadFlag,R24
(0306) #endif
(0307) 					break;
    0A74E 9180 00C1 LDS	R24,0xC1
(0308) 				case 6:	// 下片动作完成之后,重新检测是否有试剂片
(0309) 					i = getLiqDetADC(UnloadChannel);
    0A750 7E8F      ANDI	R24,0xEF
    0A751 9380 00C1 STS	0xC1,R24
    0A753 E623      LDI	R18,0x63
(0310) 					/*
(0311) 					if(i < 500)	// 当前位置没有试剂片
(0312) 					{
(0313) 						mainStep = 2;
(0314) 						workStep = 0;
(0315) 					}
(0316) 					else if(i > 900)	// 有试剂片
(0317) 					{
(0318) 						workStep = 0;
(0319) 						uart_Printf("%s $%4d $%4d\r\n",strM3117,ringNum,j + 2);		// 对应位置再次下片
(0320) 						j++;
(0321) 						if(j > 2)
(0322) 						{
(0323) 							j = 0;
(0324) 							mainStep = 2;
(0325) 							workStep = 0;
(0326) 							uart_Printf("%s $%4d\r\n",strE4909,ringNum);		// 对应位置连续3次下片失败
(0327) 						}
(0328) 					}
(0329) 					else
(0330) 					{
(0331) 						uart_Printf("!3945 UnloadAdcOutofScope $ %d\r\n",(unsigned int)i);
(0332) 						mainStep = 2;
(0333) 						workStep = 0;
(0334) 					}
(0335) 					*/
(0336) 					if(i < CardLocationAD)	// 当前位置没有试剂片
    0A754 E131      LDI	R19,0x11
    0A755 E308      LDI	R16,0x38
    0A756 E01A      LDI	R17,0xA
    0A757 940E A90D CALL	_uart_Printf
(0337) 					{
(0338) 						mainStep = 2;
    0A759 9180 00C1 LDS	R24,0xC1
(0339) 						workStep = 0;
    0A75B 6180      ORI	R24,0x10
    0A75C 9380 00C1 STS	0xC1,R24
(0340) 					}
    0A75E 9508      RET
(0341) 					else 					// 有试剂片
(0342) 					{
(0343) 						workStep = 0;
    0A75F 940E AE83 CALL	push_xgset300C
    0A761 2F42      MOV	R20,R18
(0344) 						Uart0ReUnable;
    0A762 2EA0      MOV	R10,R16
    0A763 9721      SBIW	R28,1
    0A764 82A8      ST	Y,R10
    0A765 01CE      MOVW	R24,R28
    0A766 015C      MOVW	R10,R24
(0345) 						uart_Printf("%s $%4d $%4d\r\n",strM3117,ringNum,j + 2);		// 对应位置再次下片
    0A767 C005      RJMP	0xA76D
    0A768 E021      LDI	R18,1
    0A769 E030      LDI	R19,0
    0A76A 0185      MOVW	R16,R10
    0A76B 940E 9DD6 CALL	_uart0SendData
    0A76D 2E24      MOV	R2,R20
    0A76E 2433      CLR	R3
    0A76F 5041      SUBI	R20,1
    0A770 2022      TST	R2
    0A771 F7B1      BNE	0xA768
    0A772 9621      ADIW	R28,1
    0A773 940C AE88 JMP	pop_xgset300C
    0A775 940E AEA5 CALL	push_xgset303C
    0A777 2F42      MOV	R20,R18
(0346) 						Uart0ReEnable;
    0A778 0168      MOVW	R12,R16
    0A779 0156      MOVW	R10,R12
    0A77A C008      RJMP	0xA783
    0A77B E021      LDI	R18,1
    0A77C E030      LDI	R19,0
(0347) 						j++;
    0A77D 2F04      MOV	R16,R20
    0A77E 2711      CLR	R17
    0A77F 0D0A      ADD	R16,R10
    0A780 1D1B      ADC	R17,R11
    0A781 940E 9DD6 CALL	_uart0SendData
(0348) 						if(j > 2)
    0A783 2E24      MOV	R2,R20
    0A784 2433      CLR	R3
    0A785 5041      SUBI	R20,1
    0A786 E080      LDI	R24,0
    0A787 1582      CP	R24,R2
(0349) 						{
(0350) 							j = 0;
    0A788 F390      BCS	0xA77B
    0A789 940C AEAC JMP	pop_xgset303C
(0351) 							mainStep = 2;
    0A78B 933A      ST	-Y,R19
    0A78C 932A      ST	-Y,R18
(0352) 							workStep = 0;
    0A78D 940E AE78 CALL	push_xgsetF0FC
(0353) 							Uart0ReUnable;
    0A78F 01A8      MOVW	R20,R16
    0A790 97A9      SBIW	R28,0x29
    0A791 2400      CLR	R0
    0A792 A608      STD	Y+40,R0
    0A793 24AA      CLR	R10
(0354) 							uart_Printf("%s $%4d\r\n",strE4909,ringNum);		// 对应位置连续3次下片失败
    0A794 24EE      CLR	R14
    0A795 A80F      LDD	R0,Y+55
    0A796 2000      TST	R0
    0A797 F411      BNE	0xA79A
    0A798 E280      LDI	R24,0x20
    0A799 AB8F      STD	Y+55,R24
    0A79A A98D      LDD	R24,Y+53
    0A79B 3080      CPI	R24,0
    0A79C F428      BCC	0xA7A2
    0A79D 2E08      MOV	R0,R24
    0A79E 9401      NEG	R0
(0355) 							Uart0ReEnable;
    0A79F AA0D      STD	Y+53,R0
    0A7A0 24AA      CLR	R10
    0A7A1 94A3      INC	R10
    0A7A2 A98D      LDD	R24,Y+53
    0A7A3 3080      CPI	R24,0
(0356) 						}
(0357) 					}
(0358) 					break;
(0359) 			}
(0360) 			break;
    0A7A4 F020      BCS	0xA7A9
(0361) 		case 2:		// 干片卸载，释放转盘使用权
(0362) 			TurnPlateUsedLock = 0;
    0A7A5 E580      LDI	R24,0x50
    0A7A6 A80D      LDD	R0,Y+53
    0A7A7 1580      CP	R24,R0
(0363) 			TurnPlateUsedLock = 0;					
    0A7A8 F410      BCC	0xA7AB
    0A7A9 2400      CLR	R0
(0364) 			ringNum = UnloadQueue.ringNum[0];
    0A7AA AA0D      STD	Y+53,R0
    0A7AB A98B      LDD	R24,Y+51
    0A7AC 3080      CPI	R24,0
    0A7AD F46C      BGE	0xA7BB
(0365) 			insertflag[ringNum] = 0;
    0A7AE 2E08      MOV	R0,R24
    0A7AF 9401      NEG	R0
    0A7B0 AA0B      STD	Y+51,R0
    0A7B1 3040      CPI	R20,0
    0A7B2 E0E0      LDI	R30,0
    0A7B3 075E      CPC	R21,R30
    0A7B4 F434      BGE	0xA7BB
    0A7B5 24EE      CLR	R14
(0366) 			l = RingQueue.sampInfo[ringNum].testSerial;
    0A7B6 94E3      INC	R14
    0A7B7 9540      COM	R20
    0A7B8 9550      COM	R21
    0A7B9 5F4F      SUBI	R20,0xFF
    0A7BA 4F5F      SBCI	R21,0xFF
    0A7BB 01BA      MOVW	R22,R20
    0A7BC A98B      LDD	R24,Y+51
    0A7BD 3180      CPI	R24,0x10
    0A7BE F089      BEQ	0xA7D0
    0A7BF 2F28      MOV	R18,R24
    0A7C0 2733      CLR	R19
    0A7C1 FD27      SBRC	R18,7
    0A7C2 9530      COM	R19
    0A7C3 018B      MOVW	R16,R22
    0A7C4 940E AD64 CALL	mod16u
    0A7C6 0168      MOVW	R12,R16
(0367) 			RingQueueDelete(ringNum);			// 删除转盘上对应位置的干片信息，释放出位置继续使用
    0A7C7 A92B      LDD	R18,Y+51
    0A7C8 2733      CLR	R19
    0A7C9 FD27      SBRC	R18,7
    0A7CA 9530      COM	R19
(0368) #ifndef UartSendLong
(0369) 			Uart0ReUnable;
(0370) 			uart_Printf("%s $%8d",strM3116 , l);
(0371) 			uart_Printf(" $%4d",(unsigned char)ringNum);
(0372) 			uart_Printf(" $%8d\r\n",(unsigned long)SecondCount);
(0373) 			Uart0ReEnable;
(0374) #else
(0375) 			Uart0ReUnable;
    0A7CB 018B      MOVW	R16,R22
    0A7CC 940E AD66 CALL	div16u
    0A7CE 01B8      MOVW	R22,R16
    0A7CF C00C      RJMP	0xA7DC
(0376) 			uart_Printf("%s $ ",strM3116);
    0A7D0 01CB      MOVW	R24,R22
    0A7D1 708F      ANDI	R24,0xF
    0A7D2 7090      ANDI	R25,0
    0A7D3 016C      MOVW	R12,R24
    0A7D4 9576      LSR	R23
    0A7D5 9567      ROR	R22
(0377) 			uart0SendInt(l);
    0A7D6 9576      LSR	R23
    0A7D7 9567      ROR	R22
    0A7D8 9576      LSR	R23
    0A7D9 9567      ROR	R22
    0A7DA 9576      LSR	R23
    0A7DB 9567      ROR	R22
(0378) 			uart_Printf(" $%4d $ ",(unsigned char)ringNum);
    0A7DC E089      LDI	R24,0x9
    0A7DD E090      LDI	R25,0
    0A7DE 158C      CP	R24,R12
    0A7DF 059D      CPC	R25,R13
    0A7E0 F018      BCS	0xA7E4
    0A7E1 E340      LDI	R20,0x30
    0A7E2 E050      LDI	R21,0
(0379) 			uart0SendInt(SecondCount);
    0A7E3 C002      RJMP	0xA7E6
    0A7E4 E347      LDI	R20,0x37
    0A7E5 E050      LDI	R21,0
    0A7E6 0116      MOVW	R2,R12
    0A7E7 0E24      ADD	R2,R20
    0A7E8 1E35      ADC	R3,R21
    0A7E9 01CE      MOVW	R24,R28
    0A7EA A5E8      LDD	R30,Y+40
    0A7EB 27FF      CLR	R31
    0A7EC 0FE8      ADD	R30,R24
(0380) 			uart_Printf("\r\n");
    0A7ED 1FF9      ADC	R31,R25
    0A7EE 8220      ST	Z,R2
    0A7EF A408      LDD	R0,Y+40
    0A7F0 9403      INC	R0
(0381) 			Uart0ReEnable;
    0A7F1 A608      STD	Y+40,R0
    0A7F2 3060      CPI	R22,0
    0A7F3 0767      CPC	R22,R23
    0A7F4 F009      BEQ	0xA7F6
    0A7F5 CFC6      RJMP	0xA7BC
(0382) #endif
(0383) 			mainStep = 3;
    0A7F6 20EE      TST	R14
    0A7F7 F051      BEQ	0xA802
    0A7F8 01CE      MOVW	R24,R28
(0384) 			break;
    0A7F9 A5E8      LDD	R30,Y+40
(0385) 		case 3:
(0386) 			// 废片盒容量监测处理
(0387) 			mainStep = 0;
    0A7FA 27FF      CLR	R31
    0A7FB 0FE8      ADD	R30,R24
    0A7FC 1FF9      ADC	R31,R25
(0388) 			workStep = 0;
    0A7FD E28D      LDI	R24,0x2D
    0A7FE 8380      ST	Z,R24
(0389) 			inWork = 0;
    0A7FF A408      LDD	R0,Y+40
    0A800 9403      INC	R0
(0390) 			UnloadQueueForward();		// 删除已完成的队头任务，队列前进一步
    0A801 A608      STD	Y+40,R0
(0391) 			break;
(0392) 		}
(0393) 	return 0;
    0A802 A428      LDD	R2,Y+40
    0A803 2433      CLR	R3
    0A804 A84D      LDD	R4,Y+53
    0A805 2455      CLR	R5
_TrashCanMonitor:
    0A806 1424      CP	R2,R4
(0394) }
(0395) 
(0396) 
(0397) 
(0398) void TrashCanMonitor(void){
(0399) 	static unsigned char delayCnt, delayCnt2;
(0400) 	static unsigned char dustbinOldState;
(0401) 	static unsigned int openTime;
(0402) 	
(0403) 	if(WorkProcessStep == 3)
    0A807 0435      CPC	R3,R5
    0A808 F024      BLT	0xA80D
    0A809 2D22      MOV	R18,R2
    0A80A 018E      MOVW	R16,R28
    0A80B DF69      RCALL	0xA775
(0404) 	{
(0405) 		if((PINK & 0x02) == 0)		// 废片仓打开
    0A80C C011      RJMP	0xA81E
    0A80D A80D      LDD	R0,Y+53
    0A80E A508      LDD	R16,Y+40
    0A80F 1A00      SUB	R0,R16
(0406) 		{
(0407) 			delayCnt ++;
    0A810 AA0D      STD	Y+53,R0
    0A811 20AA      TST	R10
    0A812 F419      BNE	0xA816
    0A813 2D20      MOV	R18,R0
    0A814 A90F      LDD	R16,Y+55
(0408) 			if(0 == stopTestFlag)
    0A815 DF49      RCALL	0xA75F
    0A816 A528      LDD	R18,Y+40
    0A817 018E      MOVW	R16,R28
    0A818 DF5C      RCALL	0xA775
(0409) 				openTime++;
    0A819 20AA      TST	R10
    0A81A F019      BEQ	0xA81E
    0A81B A92D      LDD	R18,Y+53
    0A81C A90F      LDD	R16,Y+55
    0A81D DF41      RCALL	0xA75F
    0A81E 96A9      ADIW	R28,0x29
    0A81F 940E AE6D CALL	pop_xgsetF0FC
    0A821 9622      ADIW	R28,2
(0410) 			if(delayCnt == 1)
    0A822 9508      RET
    0A823 940E AD5F CALL	push_arg4
    0A825 940E AE78 CALL	push_xgsetF0FC
(0411) 			{
(0412) 				if(dustbinOldState != 0)
    0A827 9725      SBIW	R28,5
    0A828 2400      CLR	R0
    0A829 820C      STD	Y+4,R0
(0413) 				{
(0414) 					dustbinOldState = 0;
    0A82A 2744      CLR	R20
    0A82B 24AA      CLR	R10
    0A82C E280      LDI	R24,0x20
(0415) 				}
(0416) 			}
(0417) 			if(delayCnt == 5)
    0A82D 2EE8      MOV	R14,R24
    0A82E 85EF      LDD	R30,Y+15
    0A82F 89F8      LDD	R31,Y+16
    0A830 8180      LD	R24,Z
(0418) 			{
(0419) 				// 片仓已打开并排空
(0420) 				TranCanCountBase = ReadCurTestSetial();		// 读取当前的测试自动序列号
    0A831 3380      CPI	R24,0x30
    0A832 F009      BEQ	0xA834
    0A833 C0BD      RJMP	0xA8F1
    0A834 E380      LDI	R24,0x30
    0A835 2EE8      MOV	R14,R24
    0A836 C0BA      RJMP	0xA8F1
    0A837 3360      CPI	R22,0x30
    0A838 F060      BCS	0xA845
    0A839 E389      LDI	R24,0x39
    0A83A 1786      CP	R24,R22
(0421) 				EEPROM_WRITE(EEP_ADD_TRANSH_CNT, TranCanCountBase);		// 写入新的废片基数基数
    0A83B F048      BCS	0xA845
    0A83C E00A      LDI	R16,0xA
    0A83D 811C      LDD	R17,Y+4
    0A83E 0201      MULS	R16,R17
    0A83F 2C20      MOV	R2,R0
    0A840 2F86      MOV	R24,R22
    0A841 5380      SUBI	R24,0x30
    0A842 0E28      ADD	R2,R24
    0A843 822C      STD	Y+4,R2
    0A844 C0A9      RJMP	0xA8EE
(0422) 			}
(0423) 			if(delayCnt == 60)	// 废片仓打开时间超时报警
    0A845 2EC6      MOV	R12,R22
    0A846 24DD      CLR	R13
    0A847 01C6      MOVW	R24,R12
    0A848 3588      CPI	R24,0x58
(0424) 			{
(0425) 				SetBeepWarning();
    0A849 E0E0      LDI	R30,0
    0A84A 079E      CPC	R25,R30
(0426) 				delayCnt = 40;
    0A84B F409      BNE	0xA84D
    0A84C C099      RJMP	0xA8E6
    0A84D E588      LDI	R24,0x58
(0427) 			}
(0428) 			if(openTime >= 1200)	// 片仓开启时间超过20分钟
    0A84E 158C      CP	R24,R12
    0A84F 059D      CPC	R25,R13
    0A850 F0C4      BLT	0xA869
    0A851 01C6      MOVW	R24,R12
    0A852 3285      CPI	R24,0x25
    0A853 E0E0      LDI	R30,0
    0A854 079E      CPC	R25,R30
    0A855 F409      BNE	0xA857
(0429) 			{
(0430) 				openTime = 0;
    0A856 C04D      RJMP	0xA8A4
    0A857 E285      LDI	R24,0x25
    0A858 E090      LDI	R25,0
    0A859 158C      CP	R24,R12
    0A85A 059D      CPC	R25,R13
    0A85B F034      BLT	0xA862
(0431) 				stopTestFlag = 1;
    0A85C 20CC      TST	R12
    0A85D F419      BNE	0xA861
    0A85E 20DD      TST	R13
(0432) 			}
(0433) 		}
    0A85F F409      BNE	0xA861
(0434) 		else		// 废片仓关闭
(0435) 		{
(0436) 			if(dustbinOldState == 0)
    0A860 C03B      RJMP	0xA89C
    0A861 C08A      RJMP	0xA8EC
    0A862 01C6      MOVW	R24,R12
    0A863 328D      CPI	R24,0x2D
(0437) 			{
(0438) 				dustbinOldState = 1;
    0A864 E0E0      LDI	R30,0
    0A865 079E      CPC	R25,R30
    0A866 F409      BNE	0xA868
(0439) 			}
(0440) 			delayCnt = 0;
    0A867 C045      RJMP	0xA8AD
    0A868 C083      RJMP	0xA8EC
    0A869 01C6      MOVW	R24,R12
(0441) 			openTime = 0;
    0A86A 3689      CPI	R24,0x69
    0A86B E0E0      LDI	R30,0
    0A86C 079E      CPC	R25,R30
    0A86D F409      BNE	0xA86F
    0A86E C06E      RJMP	0xA8DD
(0442) 			stopTestFlag = 0;
    0A86F E689      LDI	R24,0x69
    0A870 E090      LDI	R25,0
(0443) 			if(TrashCanState)
    0A871 158C      CP	R24,R12
    0A872 059D      CPC	R25,R13
    0A873 F064      BLT	0xA880
    0A874 01C6      MOVW	R24,R12
(0444) 			{
(0445) 				delayCnt2 ++;
    0A875 3683      CPI	R24,0x63
    0A876 E0E0      LDI	R30,0
    0A877 079E      CPC	R25,R30
    0A878 F409      BNE	0xA87A
    0A879 C035      RJMP	0xA8AF
(0446) 				if(delayCnt2 > 20)	// 废片仓满报警
    0A87A 3684      CPI	R24,0x64
    0A87B E0E0      LDI	R30,0
    0A87C 079E      CPC	R25,R30
    0A87D F409      BNE	0xA87F
    0A87E C05E      RJMP	0xA8DD
(0447) 					SetBeepWarning();
    0A87F C06C      RJMP	0xA8EC
    0A880 01C6      MOVW	R24,R12
(0448) 				delayCnt2 = 0;
    0A881 368F      CPI	R24,0x6F
    0A882 E0E0      LDI	R30,0
    0A883 079E      CPC	R25,R30
(0449) 			}
(0450) 		}
(0451) 	}
    0A884 F409      BNE	0xA886
    0A885 C063      RJMP	0xA8E9
(0452) }
(0453) unsigned char TrashCanCheck(void)
(0454) {
(0455) 	// 关闭废片仓满监控
(0456) /*	if((NewTestInfo.testSerial - TranCanCountBase) > 100){
(0457) 		TrashCanState = 1;
(0458) 		return 1;
(0459) 		}
(0460) 		*/
(0461) 	TrashCanState = 0;
_TrashCanCheck:
    0A886 368F      CPI	R24,0x6F
    0A887 E0E0      LDI	R30,0
    0A888 079E      CPC	R25,R30
(0462) 	return 0;
FILE: <library>
    0A889 F40C      BGE	0xA88B
    0A88A C061      RJMP	0xA8EC
    0A88B 01C6      MOVW	R24,R12
    0A88C 3783      CPI	R24,0x73
    0A88D E0E0      LDI	R30,0
    0A88E 079E      CPC	R25,R30
    0A88F F409      BNE	0xA891
    0A890 C045      RJMP	0xA8D6
    0A891 3785      CPI	R24,0x75
    0A892 E0E0      LDI	R30,0
    0A893 079E      CPC	R25,R30
    0A894 F409      BNE	0xA896
    0A895 C04A      RJMP	0xA8E0
    0A896 3788      CPI	R24,0x78
    0A897 E0E0      LDI	R30,0
    0A898 079E      CPC	R25,R30
    0A899 F409      BNE	0xA89B
    0A89A C048      RJMP	0xA8E3
    0A89B C050      RJMP	0xA8EC
    0A89C 858F      LDD	R24,Y+15
    0A89D 8998      LDD	R25,Y+16
    0A89E 9701      SBIW	R24,1
    0A89F 011C      MOVW	R2,R24
    0A8A0 8A38      STD	Y+16,R3
    0A8A1 862F      STD	Y+15,R2
    0A8A2 018C      MOVW	R16,R24
    0A8A3 C064      RJMP	0xA908
    0A8A4 E021      LDI	R18,1
    0A8A5 E030      LDI	R19,0
    0A8A6 E30D      LDI	R16,0x3D
    0A8A7 E01A      LDI	R17,0xA
    0A8A8 940E 9DD6 CALL	_uart0SendData
    0A8AA 850F      LDD	R16,Y+15
    0A8AB 8918      LDD	R17,Y+16
    0A8AC C05B      RJMP	0xA908
    0A8AD E041      LDI	R20,1
    0A8AE C03F      RJMP	0xA8EE
    0A8AF 2344      TST	R20
    0A8B0 F061      BEQ	0xA8BD
    0A8B1 8989      LDD	R24,Y+17
    0A8B2 899A      LDD	R25,Y+18
    0A8B3 778F      ANDI	R24,0x7F
    0A8B4 7090      ANDI	R25,0
    0A8B5 838B      STD	Y+3,R24
    0A8B6 E021      LDI	R18,1
    0A8B7 E030      LDI	R19,0
    0A8B8 018E      MOVW	R16,R28
    0A8B9 5F0D      SUBI	R16,0xFD
    0A8BA 4F1F      SBCI	R17,0xFF
    0A8BB 940E 9DD6 CALL	_uart0SendData
    0A8BD 2422      CLR	R2
    0A8BE 800C      LDD	R0,Y+4
    0A8BF 1420      CP	R2,R0
    0A8C0 F424      BGE	0xA8C5
    0A8C1 2D20      MOV	R18,R0
    0A8C2 5021      SUBI	R18,1
    0A8C3 2D0E      MOV	R16,R14
    0A8C4 DE9A      RCALL	0xA75F
    0A8C5 2344      TST	R20
    0A8C6 F461      BNE	0xA8D3
    0A8C7 8989      LDD	R24,Y+17
    0A8C8 899A      LDD	R25,Y+18
    0A8C9 778F      ANDI	R24,0x7F
    0A8CA 7090      ANDI	R25,0
    0A8CB 838B      STD	Y+3,R24
    0A8CC E021      LDI	R18,1
    0A8CD E030      LDI	R19,0
    0A8CE 018E      MOVW	R16,R28
    0A8CF 5F0D      SUBI	R16,0xFD
    0A8D0 4F1F      SBCI	R17,0xFF
    0A8D1 940E 9DD6 CALL	_uart0SendData
    0A8D3 850F      LDD	R16,Y+15
    0A8D4 8918      LDD	R17,Y+16
    0A8D5 C032      RJMP	0xA908
    0A8D6 8909      LDD	R16,Y+17
    0A8D7 891A      LDD	R17,Y+18
    0A8D8 940E 9E3B CALL	_uart0SendString
    0A8DA 850F      LDD	R16,Y+15
    0A8DB 8918      LDD	R17,Y+16
    0A8DC C02B      RJMP	0xA908
    0A8DD EF86      LDI	R24,0xF6
    0A8DE 2EA8      MOV	R10,R24
    0A8DF C00E      RJMP	0xA8EE
    0A8E0 E08A      LDI	R24,0xA
    0A8E1 2EA8      MOV	R10,R24
    0A8E2 C00B      RJMP	0xA8EE
    0A8E3 E180      LDI	R24,0x10
    0A8E4 2EA8      MOV	R10,R24
    0A8E5 C008      RJMP	0xA8EE
    0A8E6 E180      LDI	R24,0x10
    0A8E7 2EA8      MOV	R10,R24
    0A8E8 C005      RJMP	0xA8EE
    0A8E9 E088      LDI	R24,0x8
    0A8EA 2EA8      MOV	R10,R24
    0A8EB C002      RJMP	0xA8EE
    0A8EC E083      LDI	R24,3
    0A8ED 2EA8      MOV	R10,R24
    0A8EE 20AA      TST	R10
    0A8EF F009      BEQ	0xA8F1
    0A8F0 C009      RJMP	0xA8FA
    0A8F1 85EF      LDD	R30,Y+15
    0A8F2 89F8      LDD	R31,Y+16
    0A8F3 9021      LD	R2,Z+
    0A8F4 8BF8      STD	Y+16,R31
    0A8F5 87EF      STD	Y+15,R30
    0A8F6 2D62      MOV	R22,R2
    0A8F7 2366      TST	R22
    0A8F8 F009      BEQ	0xA8FA
    0A8F9 CF3D      RJMP	0xA837
    0A8FA 2344      TST	R20
    0A8FB F019      BEQ	0xA8FF
    0A8FC 800C      LDD	R0,Y+4
    0A8FD 9401      NEG	R0
    0A8FE 820C      STD	Y+4,R0
    0A8FF 82EA      STD	Y+2,R14
    0A900 800C      LDD	R0,Y+4
    0A901 8208      ST	Y,R0
    0A902 2D2A      MOV	R18,R10
    0A903 8909      LDD	R16,Y+17
    0A904 891A      LDD	R17,Y+18
    0A905 DE85      RCALL	0xA78B
    0A906 850F      LDD	R16,Y+15
    0A907 8918      LDD	R17,Y+16
    0A908 9625      ADIW	R28,5
    0A909 940E AE6D CALL	pop_xgsetF0FC
    0A90B 9624      ADIW	R28,4
    0A90C 9508      RET
_uart_Printf:
    0A90D 940E AD5F CALL	push_arg4
    0A90F 940E AE83 CALL	push_xgset300C
    0A911 01AE      MOVW	R20,R28
    0A912 5F4C      SUBI	R20,0xFC
    0A913 4F5F      SBCI	R21,0xFF
    0A914 5F4E      SUBI	R20,0xFE
    0A915 4F5F      SBCI	R21,0xFF
    0A916 C020      RJMP	0xA937
    0A917 81EC      LDD	R30,Y+4
    0A918 81FD      LDD	R31,Y+5
    0A919 8180      LD	R24,Z
    0A91A 3285      CPI	R24,0x25
    0A91B F479      BNE	0xA92B
    0A91C 01CA      MOVW	R24,R20
    0A91D 9602      ADIW	R24,2
    0A91E 01AC      MOVW	R20,R24
    0A91F 01FC      MOVW	R30,R24
    0A920 9732      SBIW	R30,2
    0A921 8120      LD	R18,Z
    0A922 8131      LDD	R19,Z+1
    0A923 810C      LDD	R16,Y+4
    0A924 811D      LDD	R17,Y+5
    0A925 5F0F      SUBI	R16,0xFF
    0A926 4F1F      SBCI	R17,0xFF
    0A927 DEFB      RCALL	0xA823
    0A928 831D      STD	Y+5,R17
    0A929 830C      STD	Y+4,R16
    0A92A C00C      RJMP	0xA937
    0A92B 80AC      LDD	R10,Y+4
    0A92C 80BD      LDD	R11,Y+5
    0A92D E021      LDI	R18,1
    0A92E E030      LDI	R19,0
    0A92F 0185      MOVW	R16,R10
    0A930 940E 9DD6 CALL	_uart0SendData
    0A932 818C      LDD	R24,Y+4
    0A933 819D      LDD	R25,Y+5
    0A934 9601      ADIW	R24,1
    0A935 839D      STD	Y+5,R25
    0A936 838C      STD	Y+4,R24
    0A937 81EC      LDD	R30,Y+4
    0A938 81FD      LDD	R31,Y+5
    0A939 8020      LD	R2,Z
    0A93A 2022      TST	R2
    0A93B F6D9      BNE	0xA917
    0A93C 940E AE88 CALL	pop_xgset300C
    0A93E 9624      ADIW	R28,4
    0A93F 9508      RET
_uart0SendInt:
    0A940 940E AD5F CALL	push_arg4
    0A942 E08A      LDI	R24,0xA
    0A943 E090      LDI	R25,0
    0A944 E0A0      LDI	R26,0
    0A945 E0B0      LDI	R27,0
    0A946 8028      LD	R2,Y
    0A947 8039      LDD	R3,Y+1
    0A948 804A      LDD	R4,Y+2
    0A949 805B      LDD	R5,Y+3
    0A94A 1628      CP	R2,R24
    0A94B 0639      CPC	R3,R25
    0A94C 064A      CPC	R4,R26
    0A94D 065B      CPC	R5,R27
    0A94E F460      BCC	0xA95B
    0A94F E380      LDI	R24,0x30
    0A950 E090      LDI	R25,0
    0A951 E0A0      LDI	R26,0
    0A952 E0B0      LDI	R27,0
    0A953 0E28      ADD	R2,R24
    0A954 1E39      ADC	R3,R25
    0A955 1E4A      ADC	R4,R26
    0A956 1E5B      ADC	R5,R27
    0A957 2D02      MOV	R16,R2
    0A958 940E 9E0E CALL	_uart0SendChar
    0A95A C01E      RJMP	0xA979
    0A95B E08A      LDI	R24,0xA
    0A95C E090      LDI	R25,0
    0A95D E0A0      LDI	R26,0
    0A95E E0B0      LDI	R27,0
    0A95F 8108      LD	R16,Y
    0A960 8119      LDD	R17,Y+1
    0A961 812A      LDD	R18,Y+2
    0A962 813B      LDD	R19,Y+3
    0A963 93BA      ST	-Y,R27
    0A964 93AA      ST	-Y,R26
    0A965 939A      ST	-Y,R25
    0A966 938A      ST	-Y,R24
    0A967 940E AD80 CALL	div32u
    0A969 DFD6      RCALL	_uart0SendInt
    0A96A E08A      LDI	R24,0xA
    0A96B E090      LDI	R25,0
    0A96C E0A0      LDI	R26,0
    0A96D E0B0      LDI	R27,0
    0A96E 8108      LD	R16,Y
    0A96F 8119      LDD	R17,Y+1
    0A970 812A      LDD	R18,Y+2
    0A971 813B      LDD	R19,Y+3
    0A972 93BA      ST	-Y,R27
    0A973 93AA      ST	-Y,R26
    0A974 939A      ST	-Y,R25
    0A975 938A      ST	-Y,R24
    0A976 940E AD82 CALL	mod32u
    0A978 DFC7      RCALL	_uart0SendInt
    0A979 9624      ADIW	R28,4
    0A97A 9508      RET
_SetWasteCardState:
    0A97B 934A      ST	-Y,R20
    0A97C 2F40      MOV	R20,R16
    0A97D 9722      SBIW	R28,2
    0A97E E081      LDI	R24,1
    0A97F 1784      CP	R24,R20
    0A980 F408      BCC	0xA982
    0A981 E041      LDI	R20,1
    0A982 9340 0A3F STS	wasteCardNoneUseful,R20
    0A984 9180 00C1 LDS	R24,0xC1
    0A986 7E8F      ANDI	R24,0xEF
    0A987 9380 00C1 STS	0xC1,R24
    0A989 2E24      MOV	R2,R20
    0A98A 2433      CLR	R3
    0A98B 8239      STD	Y+1,R3
    0A98C 8228      ST	Y,R2
    0A98D E122      LDI	R18,0x12
    0A98E E03E      LDI	R19,0xE
    0A98F E80D      LDI	R16,0x8D
    0A990 E01A      LDI	R17,0xA
    0A991 940E A90D CALL	_uart_Printf
    0A993 9180 00C1 LDS	R24,0xC1
    0A995 6180      ORI	R24,0x10
    0A996 9380 00C1 STS	0xC1,R24
    0A998 9622      ADIW	R28,2
    0A999 9149      LD	R20,Y+
    0A99A 9508      RET
_GetwasteCardState:
    0A99B 9100 0A3F LDS	R16,wasteCardNoneUseful
    0A99D 9508      RET
_UnloadQueueDatInit:
    0A99E 940E AE8D CALL	push_xgsetF000
    0A9A0 EF65      LDI	R22,0xF5
    0A9A1 E17D      LDI	R23,0x1D
    0A9A2 2744      CLR	R20
    0A9A3 2755      CLR	R21
    0A9A4 C006      RJMP	0xA9AB
    0A9A5 2422      CLR	R2
    0A9A6 01FB      MOVW	R30,R22
    0A9A7 9221      ST	Z+,R2
    0A9A8 01BF      MOVW	R22,R30
    0A9A9 5F4F      SUBI	R20,0xFF
    0A9AA 4F5F      SBCI	R21,0xFF
    0A9AB 3948      CPI	R20,0x98
    0A9AC E0E0      LDI	R30,0
    0A9AD 075E      CPC	R21,R30
    0A9AE F3B0      BCS	0xA9A5
    0A9AF 2744      CLR	R20
    0A9B0 2755      CLR	R21
    0A9B1 C009      RJMP	0xA9BB
    0A9B2 EF85      LDI	R24,0xF5
    0A9B3 E19D      LDI	R25,0x1D
    0A9B4 01FA      MOVW	R30,R20
    0A9B5 0FE8      ADD	R30,R24
    0A9B6 1FF9      ADC	R31,R25
    0A9B7 EF8F      LDI	R24,0xFF
    0A9B8 8380      ST	Z,R24
    0A9B9 5F4F      SUBI	R20,0xFF
    0A9BA 4F5F      SBCI	R21,0xFF
    0A9BB 3248      CPI	R20,0x28
    0A9BC E0E0      LDI	R30,0
    0A9BD 075E      CPC	R21,R30
    0A9BE F398      BCS	0xA9B2
    0A9BF 940E 53DC CALL	_ReadCurTestSetial
    0A9C1 9310 1DF2 STS	TranCanCountBase+1,R17
    0A9C3 9300 1DF1 STS	TranCanCountBase,R16
    0A9C5 9330 1DF4 STS	TranCanCountBase+3,R19
    0A9C7 9320 1DF3 STS	TranCanCountBase+2,R18
    0A9C9 940C AE92 JMP	pop_xgsetF000
_UnloadQueueAdd:
    0A9CB 933A      ST	-Y,R19
    0A9CC 932A      ST	-Y,R18
    0A9CD 934A      ST	-Y,R20
    0A9CE 936A      ST	-Y,R22
    0A9CF 2766      CLR	R22
    0A9D0 C023      RJMP	0xA9F4
    0A9D1 EF85      LDI	R24,0xF5
    0A9D2 E19D      LDI	R25,0x1D
    0A9D3 2FE6      MOV	R30,R22
    0A9D4 27FF      CLR	R31
    0A9D5 0FE8      ADD	R30,R24
    0A9D6 1FF9      ADC	R31,R25
    0A9D7 8180      LD	R24,Z
    0A9D8 3F8F      CPI	R24,0xFF
    0A9D9 F409      BNE	0xA9DB
    0A9DA C01B      RJMP	0xA9F6
    0A9DB E183      LDI	R24,0x13
    0A9DC E19E      LDI	R25,0x1E
    0A9DD 2FE6      MOV	R30,R22
    0A9DE 27FF      CLR	R31
    0A9DF 0FEE      LSL	R30
    0A9E0 1FFF      ROL	R31
    0A9E1 0FEE      LSL	R30
    0A9E2 1FFF      ROL	R31
    0A9E3 0FE8      ADD	R30,R24
    0A9E4 1FF9      ADC	R31,R25
    0A9E5 8020      LD	R2,Z
    0A9E6 8031      LDD	R3,Z+1
    0A9E7 8042      LDD	R4,Z+2
    0A9E8 8053      LDD	R5,Z+3
    0A9E9 806A      LDD	R6,Y+2
    0A9EA 807B      LDD	R7,Y+3
    0A9EB 808C      LDD	R8,Y+4
    0A9EC 809D      LDD	R9,Y+5
    0A9ED 1462      CP	R6,R2
    0A9EE 0473      CPC	R7,R3
    0A9EF 0484      CPC	R8,R4
    0A9F0 0495      CPC	R9,R5
    0A9F1 F40C      BGE	0xA9F3
    0A9F2 C003      RJMP	0xA9F6
    0A9F3 9563      INC	R22
    0A9F4 316E      CPI	R22,0x1E
    0A9F5 F2D8      BCS	0xA9D1
    0A9F6 E14D      LDI	R20,0x1D
    0A9F7 C046      RJMP	0xAA3E
    0A9F8 1746      CP	R20,R22
    0A9F9 F151      BEQ	0xAA24
    0A9FA E183      LDI	R24,0x13
    0A9FB E19E      LDI	R25,0x1E
    0A9FC 2FE4      MOV	R30,R20
    0A9FD 27FF      CLR	R31
    0A9FE 9731      SBIW	R30,1
    0A9FF 0FEE      LSL	R30
    0AA00 1FFF      ROL	R31
    0AA01 0FEE      LSL	R30
    0AA02 1FFF      ROL	R31
    0AA03 0FE8      ADD	R30,R24
    0AA04 1FF9      ADC	R31,R25
    0AA05 8020      LD	R2,Z
    0AA06 8031      LDD	R3,Z+1
    0AA07 8042      LDD	R4,Z+2
    0AA08 8053      LDD	R5,Z+3
    0AA09 2FE4      MOV	R30,R20
    0AA0A 27FF      CLR	R31
    0AA0B 0FEE      LSL	R30
    0AA0C 1FFF      ROL	R31
    0AA0D 0FEE      LSL	R30
    0AA0E 1FFF      ROL	R31
    0AA0F 0FE8      ADD	R30,R24
    0AA10 1FF9      ADC	R31,R25
    0AA11 8220      ST	Z,R2
    0AA12 8231      STD	Z+1,R3
    0AA13 8242      STD	Z+2,R4
    0AA14 8253      STD	Z+3,R5
    0AA15 EF84      LDI	R24,0xF4
    0AA16 E19D      LDI	R25,0x1D
    0AA17 2FE4      MOV	R30,R20
    0AA18 27FF      CLR	R31
    0AA19 0FE8      ADD	R30,R24
    0AA1A 1FF9      ADC	R31,R25
    0AA1B 8020      LD	R2,Z
    0AA1C EF85      LDI	R24,0xF5
    0AA1D E19D      LDI	R25,0x1D
    0AA1E 2FE4      MOV	R30,R20
    0AA1F 27FF      CLR	R31
    0AA20 0FE8      ADD	R30,R24
    0AA21 1FF9      ADC	R31,R25
    0AA22 8220      ST	Z,R2
    0AA23 C01A      RJMP	0xAA3E
    0AA24 E183      LDI	R24,0x13
    0AA25 E19E      LDI	R25,0x1E
    0AA26 2FE4      MOV	R30,R20
    0AA27 27FF      CLR	R31
    0AA28 0FEE      LSL	R30
    0AA29 1FFF      ROL	R31
    0AA2A 0FEE      LSL	R30
    0AA2B 1FFF      ROL	R31
    0AA2C 0FE8      ADD	R30,R24
    0AA2D 1FF9      ADC	R31,R25
    0AA2E 802A      LDD	R2,Y+2
    0AA2F 803B      LDD	R3,Y+3
    0AA30 804C      LDD	R4,Y+4
    0AA31 805D      LDD	R5,Y+5
    0AA32 8220      ST	Z,R2
    0AA33 8231      STD	Z+1,R3
    0AA34 8242      STD	Z+2,R4
    0AA35 8253      STD	Z+3,R5
    0AA36 EF85      LDI	R24,0xF5
    0AA37 E19D      LDI	R25,0x1D
    0AA38 2FE4      MOV	R30,R20
    0AA39 27FF      CLR	R31
    0AA3A 0FE8      ADD	R30,R24
    0AA3B 1FF9      ADC	R31,R25
    0AA3C 8300      ST	Z,R16
    0AA3D C006      RJMP	0xAA44
    0AA3E 2E24      MOV	R2,R20
    0AA3F 2433      CLR	R3
    0AA40 5041      SUBI	R20,1
    0AA41 2022      TST	R2
    0AA42 F009      BEQ	0xAA44
    0AA43 CFB4      RJMP	0xA9F8
    0AA44 9169      LD	R22,Y+
    0AA45 9149      LD	R20,Y+
    0AA46 9622      ADIW	R28,2
    0AA47 9508      RET
_UnloadQueueForward:
    0AA48 2700      CLR	R16
    0AA49 C044      RJMP	0xAA8E
    0AA4A 310D      CPI	R16,0x1D
    0AA4B F151      BEQ	0xAA76
    0AA4C E183      LDI	R24,0x13
    0AA4D E19E      LDI	R25,0x1E
    0AA4E 2FE0      MOV	R30,R16
    0AA4F 27FF      CLR	R31
    0AA50 9631      ADIW	R30,1
    0AA51 0FEE      LSL	R30
    0AA52 1FFF      ROL	R31
    0AA53 0FEE      LSL	R30
    0AA54 1FFF      ROL	R31
    0AA55 0FE8      ADD	R30,R24
    0AA56 1FF9      ADC	R31,R25
    0AA57 8020      LD	R2,Z
    0AA58 8031      LDD	R3,Z+1
    0AA59 8042      LDD	R4,Z+2
    0AA5A 8053      LDD	R5,Z+3
    0AA5B 2FE0      MOV	R30,R16
    0AA5C 27FF      CLR	R31
    0AA5D 0FEE      LSL	R30
    0AA5E 1FFF      ROL	R31
    0AA5F 0FEE      LSL	R30
    0AA60 1FFF      ROL	R31
    0AA61 0FE8      ADD	R30,R24
    0AA62 1FF9      ADC	R31,R25
    0AA63 8220      ST	Z,R2
    0AA64 8231      STD	Z+1,R3
    0AA65 8242      STD	Z+2,R4
    0AA66 8253      STD	Z+3,R5
    0AA67 EF86      LDI	R24,0xF6
    0AA68 E19D      LDI	R25,0x1D
    0AA69 2FE0      MOV	R30,R16
    0AA6A 27FF      CLR	R31
    0AA6B 0FE8      ADD	R30,R24
    0AA6C 1FF9      ADC	R31,R25
    0AA6D 8020      LD	R2,Z
    0AA6E EF85      LDI	R24,0xF5
    0AA6F E19D      LDI	R25,0x1D
    0AA70 2FE0      MOV	R30,R16
    0AA71 27FF      CLR	R31
    0AA72 0FE8      ADD	R30,R24
    0AA73 1FF9      ADC	R31,R25
    0AA74 8220      ST	Z,R2
    0AA75 C017      RJMP	0xAA8D
    0AA76 E183      LDI	R24,0x13
    0AA77 E19E      LDI	R25,0x1E
    0AA78 2FE0      MOV	R30,R16
    0AA79 27FF      CLR	R31
    0AA7A 0FEE      LSL	R30
    0AA7B 1FFF      ROL	R31
    0AA7C 0FEE      LSL	R30
    0AA7D 1FFF      ROL	R31
    0AA7E 0FE8      ADD	R30,R24
    0AA7F 1FF9      ADC	R31,R25
    0AA80 E080      LDI	R24,0
    0AA81 8380      ST	Z,R24
    0AA82 8381      STD	Z+1,R24
    0AA83 8382      STD	Z+2,R24
    0AA84 8383      STD	Z+3,R24
    0AA85 EF85      LDI	R24,0xF5
    0AA86 E19D      LDI	R25,0x1D
    0AA87 2FE0      MOV	R30,R16
    0AA88 27FF      CLR	R31
    0AA89 0FE8      ADD	R30,R24
    0AA8A 1FF9      ADC	R31,R25
    0AA8B EF8F      LDI	R24,0xFF
    0AA8C 8380      ST	Z,R24
    0AA8D 9503      INC	R16
    0AA8E 310E      CPI	R16,0x1E
    0AA8F F408      BCC	0xAA91
    0AA90 CFB9      RJMP	0xAA4A
    0AA91 9508      RET
_printf_UnloadProcess_StepState:
    0AA92 9722      SBIW	R28,2
    0AA93 9020 1DEF LDS	R2,insertflag+46
    0AA95 2433      CLR	R3
    0AA96 8239      STD	Y+1,R3
    0AA97 8228      ST	Y,R2
    0AA98 9120 1DEE LDS	R18,insertflag+45
    0AA9A 2733      CLR	R19
    0AA9B E60B      LDI	R16,0x6B
    0AA9C E01A      LDI	R17,0xA
    0AA9D 940E A90D CALL	_uart_Printf
    0AA9F 9622      ADIW	R28,2
    0AAA0 9508      RET
_UnloadQueueProcess:
    0AAA1 940E AE83 CALL	push_xgset300C
    0AAA3 9728      SBIW	R28,0x8
    0AAA4 9020 1DDF LDS	R2,insertflag+30
    0AAA6 9220 1DEE STS	insertflag+45,R2
    0AAA8 9020 1DE0 LDS	R2,insertflag+31
    0AAAA 9220 1DEF STS	insertflag+46,R2
    0AAAC 9020 1DE1 LDS	R2,insertflag+32
    0AAAE 2022      TST	R2
    0AAAF F121      BEQ	0xAAD4
    0AAB0 E005      LDI	R16,5
    0AAB1 940E 97C6 CALL	_WaitDelayTime
    0AAB3 2300      TST	R16
    0AAB4 F011      BEQ	0xAAB7
    0AAB5 2700      CLR	R16
    0AAB6 C220      RJMP	0xACD7
    0AAB7 9020 1DE7 LDS	R2,insertflag+38
    0AAB9 2022      TST	R2
    0AABA F051      BEQ	0xAAC5
    0AABB E001      LDI	R16,1
    0AABC 940E 6A0C CALL	_GetMotState
    0AABE 3001      CPI	R16,1
    0AABF F011      BEQ	0xAAC2
    0AAC0 2700      CLR	R16
    0AAC1 C215      RJMP	0xACD7
    0AAC2 2422      CLR	R2
    0AAC3 9220 1DE7 STS	insertflag+38,R2
    0AAC5 9020 1DE8 LDS	R2,insertflag+39
    0AAC7 2022      TST	R2
    0AAC8 F059      BEQ	0xAAD4
    0AAC9 E005      LDI	R16,5
    0AACA 940E 6A0C CALL	_GetMotState
    0AACC 2F40      MOV	R20,R16
    0AACD 3001      CPI	R16,1
    0AACE F011      BEQ	0xAAD1
    0AACF 2700      CLR	R16
    0AAD0 C206      RJMP	0xACD7
    0AAD1 2422      CLR	R2
    0AAD2 9220 1DE8 STS	insertflag+39,R2
    0AAD4 9140 1DDF LDS	R20,insertflag+30
    0AAD6 2755      CLR	R21
    0AAD7 3040      CPI	R20,0
    0AAD8 0745      CPC	R20,R21
    0AAD9 F081      BEQ	0xAAEA
    0AADA 3041      CPI	R20,1
    0AADB E0E0      LDI	R30,0
    0AADC 075E      CPC	R21,R30
    0AADD F409      BNE	0xAADF
    0AADE C056      RJMP	0xAB35
    0AADF 3042      CPI	R20,2
    0AAE0 E0E0      LDI	R30,0
    0AAE1 075E      CPC	R21,R30
    0AAE2 F409      BNE	0xAAE4
    0AAE3 C195      RJMP	0xAC79
    0AAE4 3043      CPI	R20,3
    0AAE5 E0E0      LDI	R30,0
    0AAE6 075E      CPC	R21,R30
    0AAE7 F409      BNE	0xAAE9
    0AAE8 C1E5      RJMP	0xACCE
    0AAE9 C1EC      RJMP	0xACD6
    0AAEA 9180 1DF5 LDS	R24,UnloadQueue
    0AAEC 3F8F      CPI	R24,0xFF
    0AAED F409      BNE	0xAAEF
    0AAEE C044      RJMP	0xAB33
    0AAEF 9040 0529 LDS	R4,SecondCount+2
    0AAF1 9050 052A LDS	R5,SecondCount+3
    0AAF3 9020 0527 LDS	R2,SecondCount
    0AAF5 9030 0528 LDS	R3,SecondCount+1
    0AAF7 9080 1E15 LDS	R8,UnloadQueue+32
    0AAF9 9090 1E16 LDS	R9,UnloadQueue+33
    0AAFB 9060 1E13 LDS	R6,UnloadQueue+30
    0AAFD 9070 1E14 LDS	R7,UnloadQueue+31
    0AAFF 1462      CP	R6,R2
    0AB00 0473      CPC	R7,R3
    0AB01 0484      CPC	R8,R4
    0AB02 0495      CPC	R9,R5
    0AB03 F008      BCS	0xAB05
    0AB04 C1D1      RJMP	0xACD6
    0AB05 2E28      MOV	R2,R24
    0AB06 9220 1DE2 STS	insertflag+33,R2
    0AB08 DE92      RCALL	_GetwasteCardState
    0AB09 2EA0      MOV	R10,R16
    0AB0A 2300      TST	R16
    0AB0B F461      BNE	0xAB18
    0AB0C D24D      RCALL	_TrashCanCheck
    0AB0D 2EA0      MOV	R10,R16
    0AB0E 2300      TST	R16
    0AB0F F011      BEQ	0xAB12
    0AB10 2700      CLR	R16
    0AB11 C1C5      RJMP	0xACD7
    0AB12 9020 0106 LDS	R2,0x106
    0AB14 FC21      SBRC	R2,1
    0AB15 C002      RJMP	0xAB18
    0AB16 2700      CLR	R16
    0AB17 C1BF      RJMP	0xACD7
    0AB18 9020 1C18 LDS	R2,TurnPlateUsedLock
    0AB1A 2022      TST	R2
    0AB1B F009      BEQ	0xAB1D
    0AB1C C1B9      RJMP	0xACD6
    0AB1D EC81      LDI	R24,0xC1
    0AB1E E19D      LDI	R25,0x1D
    0AB1F 91E0 1DE2 LDS	R30,insertflag+33
    0AB21 27FF      CLR	R31
    0AB22 0FE8      ADD	R30,R24
    0AB23 1FF9      ADC	R31,R25
    0AB24 8180      LD	R24,Z
    0AB25 3C88      CPI	R24,0xC8
    0AB26 F009      BEQ	0xAB28
    0AB27 C1AE      RJMP	0xACD6
    0AB28 E081      LDI	R24,1
    0AB29 9380 1C18 STS	TurnPlateUsedLock,R24
    0AB2B 9380 1DDF STS	insertflag+30,R24
    0AB2D 2422      CLR	R2
    0AB2E 9220 1DE0 STS	insertflag+31,R2
    0AB30 9380 1DE1 STS	insertflag+32,R24
    0AB32 C1A3      RJMP	0xACD6
    0AB33 E001      LDI	R16,1
    0AB34 C1A2      RJMP	0xACD7
    0AB35 9140 1DE0 LDS	R20,insertflag+31
    0AB37 2755      CLR	R21
    0AB38 3040      CPI	R20,0
    0AB39 0745      CPC	R20,R21
    0AB3A F119      BEQ	0xAB5E
    0AB3B 3041      CPI	R20,1
    0AB3C E0E0      LDI	R30,0
    0AB3D 075E      CPC	R21,R30
    0AB3E F409      BNE	0xAB40
    0AB3F C044      RJMP	0xAB84
    0AB40 3042      CPI	R20,2
    0AB41 E0E0      LDI	R30,0
    0AB42 075E      CPC	R21,R30
    0AB43 F409      BNE	0xAB45
    0AB44 C048      RJMP	0xAB8D
    0AB45 3043      CPI	R20,3
    0AB46 E0E0      LDI	R30,0
    0AB47 075E      CPC	R21,R30
    0AB48 F409      BNE	0xAB4A
    0AB49 C08B      RJMP	0xABD5
    0AB4A 3044      CPI	R20,4
    0AB4B E0E0      LDI	R30,0
    0AB4C 075E      CPC	R21,R30
    0AB4D F409      BNE	0xAB4F
    0AB4E C0B7      RJMP	0xAC06
    0AB4F 3045      CPI	R20,5
    0AB50 E0E0      LDI	R30,0
    0AB51 075E      CPC	R21,R30
    0AB52 F409      BNE	0xAB54
    0AB53 C0C6      RJMP	0xAC1A
    0AB54 3046      CPI	R20,6
    0AB55 E0E0      LDI	R30,0
    0AB56 075E      CPC	R21,R30
    0AB57 F409      BNE	0xAB59
    0AB58 C0CA      RJMP	0xAC23
    0AB59 304A      CPI	R20,0xA
    0AB5A E0E0      LDI	R30,0
    0AB5B 075E      CPC	R21,R30
    0AB5C F0A1      BEQ	0xAB71
    0AB5D C178      RJMP	0xACD6
    0AB5E E081      LDI	R24,1
    0AB5F 838A      STD	Y+2,R24
    0AB60 E184      LDI	R24,0x14
    0AB61 8388      ST	Y,R24
    0AB62 EC28      LDI	R18,0xC8
    0AB63 E001      LDI	R16,1
    0AB64 940E 6A9F CALL	_SetMotRunPam
    0AB66 2722      CLR	R18
    0AB67 E001      LDI	R16,1
    0AB68 940E 6A7F CALL	_MotRunToSite
    0AB6A E08A      LDI	R24,0xA
    0AB6B 9380 1DE0 STS	insertflag+31,R24
    0AB6D E081      LDI	R24,1
    0AB6E 9380 1DE7 STS	insertflag+38,R24
    0AB70 C165      RJMP	0xACD6
    0AB71 9020 1DF5 LDS	R2,UnloadQueue
    0AB73 9220 1DE2 STS	insertflag+33,R2
    0AB75 2D42      MOV	R20,R2
    0AB76 5E47      SUBI	R20,0xE7
    0AB77 314E      CPI	R20,0x1E
    0AB78 F008      BCS	0xAB7A
    0AB79 514E      SUBI	R20,0x1E
    0AB7A 2F24      MOV	R18,R20
    0AB7B E001      LDI	R16,1
    0AB7C 940E 6A7F CALL	_MotRunToSite
    0AB7E E081      LDI	R24,1
    0AB7F 9380 1DE7 STS	insertflag+38,R24
    0AB81 9380 1DE0 STS	insertflag+31,R24
    0AB83 C152      RJMP	0xACD6
    0AB84 E025      LDI	R18,5
    0AB85 E030      LDI	R19,0
    0AB86 E005      LDI	R16,5
    0AB87 940E 97B7 CALL	_SetDelayTime
    0AB89 E082      LDI	R24,2
    0AB8A 9380 1DE0 STS	insertflag+31,R24
    0AB8C C149      RJMP	0xACD6
    0AB8D E002      LDI	R16,2
    0AB8E 940E 9A52 CALL	_getLiqDetADC
    0AB90 0158      MOVW	R10,R16
    0AB91 01A5      MOVW	R20,R10
    0AB92 3804      CPI	R16,0x84
    0AB93 E0E3      LDI	R30,3
    0AB94 071E      CPC	R17,R30
    0AB95 F548      BCC	0xABBF
    0AB96 9180 1DE5 LDS	R24,insertflag+36
    0AB98 5F8F      SUBI	R24,0xFF
    0AB99 9380 1DE5 STS	insertflag+36,R24
    0AB9B E081      LDI	R24,1
    0AB9C 9020 1DE5 LDS	R2,insertflag+36
    0AB9E 1582      CP	R24,R2
    0AB9F F4D8      BCC	0xABBB
    0ABA0 2422      CLR	R2
    0ABA1 9220 1DE5 STS	insertflag+36,R2
    0ABA3 E082      LDI	R24,2
    0ABA4 9380 1DDF STS	insertflag+30,R24
    0ABA6 9220 1DE0 STS	insertflag+31,R2
    0ABA8 9180 00C1 LDS	R24,0xC1
    0ABAA 7E8F      ANDI	R24,0xEF
    0ABAB 9380 00C1 STS	0xC1,R24
    0ABAD 8359      STD	Y+1,R21
    0ABAE 8348      ST	Y,R20
    0ABAF E82E      LDI	R18,0x8E
    0ABB0 E135      LDI	R19,0x15
    0ABB1 E601      LDI	R16,0x61
    0ABB2 E01A      LDI	R17,0xA
    0ABB3 940E A90D CALL	_uart_Printf
    0ABB5 9180 00C1 LDS	R24,0xC1
    0ABB7 6180      ORI	R24,0x10
    0ABB8 9380 00C1 STS	0xC1,R24
    0ABBA C11B      RJMP	0xACD6
    0ABBB 2422      CLR	R2
    0ABBC 9220 1DE0 STS	insertflag+31,R2
    0ABBE C117      RJMP	0xACD6
    0ABBF E083      LDI	R24,3
    0ABC0 9380 1DE0 STS	insertflag+31,R24
    0ABC2 9180 00C1 LDS	R24,0xC1
    0ABC4 7E8F      ANDI	R24,0xEF
    0ABC5 9380 00C1 STS	0xC1,R24
    0ABC7 8359      STD	Y+1,R21
    0ABC8 8348      ST	Y,R20
    0ABC9 E628      LDI	R18,0x68
    0ABCA E133      LDI	R19,0x13
    0ABCB E601      LDI	R16,0x61
    0ABCC E01A      LDI	R17,0xA
    0ABCD 940E A90D CALL	_uart_Printf
    0ABCF 9180 00C1 LDS	R24,0xC1
    0ABD1 6180      ORI	R24,0x10
    0ABD2 9380 00C1 STS	0xC1,R24
    0ABD4 C101      RJMP	0xACD6
    0ABD5 DDC5      RCALL	_GetwasteCardState
    0ABD6 2EA0      MOV	R10,R16
    0ABD7 2300      TST	R16
    0ABD8 F4C9      BNE	0xABF2
    0ABD9 9020 0106 LDS	R2,0x106
    0ABDB FC21      SBRC	R2,1
    0ABDC C015      RJMP	0xABF2
    0ABDD 2422      CLR	R2
    0ABDE 9220 1C18 STS	TurnPlateUsedLock,R2
    0ABE0 9220 1C18 STS	TurnPlateUsedLock,R2
    0ABE2 EC81      LDI	R24,0xC1
    0ABE3 E19D      LDI	R25,0x1D
    0ABE4 91E0 1DE2 LDS	R30,insertflag+33
    0ABE6 27FF      CLR	R31
    0ABE7 0FE8      ADD	R30,R24
    0ABE8 1FF9      ADC	R31,R25
    0ABE9 EC88      LDI	R24,0xC8
    0ABEA 8380      ST	Z,R24
    0ABEB 9220 1DDF STS	insertflag+30,R2
    0ABED 9220 1DE0 STS	insertflag+31,R2
    0ABEF 9220 1DE1 STS	insertflag+32,R2
    0ABF1 C0E4      RJMP	0xACD6
    0ABF2 E084      LDI	R24,4
    0ABF3 838A      STD	Y+2,R24
    0ABF4 E184      LDI	R24,0x14
    0ABF5 8388      ST	Y,R24
    0ABF6 EC28      LDI	R18,0xC8
    0ABF7 E005      LDI	R16,5
    0ABF8 940E 6A9F CALL	_SetMotRunPam
    0ABFA E420      LDI	R18,0x40
    0ABFB E036      LDI	R19,6
    0ABFC E005      LDI	R16,5
    0ABFD 940E 6A5B CALL	_MotRunTo
    0ABFF E081      LDI	R24,1
    0AC00 9380 1DE8 STS	insertflag+39,R24
    0AC02 E084      LDI	R24,4
    0AC03 9380 1DE0 STS	insertflag+31,R24
    0AC05 C0D0      RJMP	0xACD6
    0AC06 E082      LDI	R24,2
    0AC07 838A      STD	Y+2,R24
    0AC08 E184      LDI	R24,0x14
    0AC09 8388      ST	Y,R24
    0AC0A E624      LDI	R18,0x64
    0AC0B E005      LDI	R16,5
    0AC0C 940E 6A9F CALL	_SetMotRunPam
    0AC0E 2722      CLR	R18
    0AC0F 2733      CLR	R19
    0AC10 E005      LDI	R16,5
    0AC11 940E 6A5B CALL	_MotRunTo
    0AC13 E081      LDI	R24,1
    0AC14 9380 1DE8 STS	insertflag+39,R24
    0AC16 E085      LDI	R24,5
    0AC17 9380 1DE0 STS	insertflag+31,R24
    0AC19 C0BC      RJMP	0xACD6
    0AC1A E02A      LDI	R18,0xA
    0AC1B E030      LDI	R19,0
    0AC1C E005      LDI	R16,5
    0AC1D 940E 97B7 CALL	_SetDelayTime
    0AC1F E086      LDI	R24,6
    0AC20 9380 1DE0 STS	insertflag+31,R24
    0AC22 C0B3      RJMP	0xACD6
    0AC23 E002      LDI	R16,2
    0AC24 940E 9A52 CALL	_getLiqDetADC
    0AC26 0158      MOVW	R10,R16
    0AC27 01A5      MOVW	R20,R10
    0AC28 3804      CPI	R16,0x84
    0AC29 E0E3      LDI	R30,3
    0AC2A 071E      CPC	R17,R30
    0AC2B F438      BCC	0xAC33
    0AC2C E082      LDI	R24,2
    0AC2D 9380 1DDF STS	insertflag+30,R24
    0AC2F 2422      CLR	R2
    0AC30 9220 1DE0 STS	insertflag+31,R2
    0AC32 C0A3      RJMP	0xACD6
    0AC33 2422      CLR	R2
    0AC34 9220 1DE0 STS	insertflag+31,R2
    0AC36 9180 00C1 LDS	R24,0xC1
    0AC38 7E8F      ANDI	R24,0xEF
    0AC39 9380 00C1 STS	0xC1,R24
    0AC3B 9180 1DE5 LDS	R24,insertflag+36
    0AC3D 2799      CLR	R25
    0AC3E 9602      ADIW	R24,2
    0AC3F 839B      STD	Y+3,R25
    0AC40 838A      STD	Y+2,R24
    0AC41 9020 1DE2 LDS	R2,insertflag+33
    0AC43 2433      CLR	R3
    0AC44 8239      STD	Y+1,R3
    0AC45 8228      ST	Y,R2
    0AC46 EF2C      LDI	R18,0xFC
    0AC47 E03D      LDI	R19,0xD
    0AC48 E502      LDI	R16,0x52
    0AC49 E01A      LDI	R17,0xA
    0AC4A 940E A90D CALL	_uart_Printf
    0AC4C 9180 00C1 LDS	R24,0xC1
    0AC4E 6180      ORI	R24,0x10
    0AC4F 9380 00C1 STS	0xC1,R24
    0AC51 9180 1DE5 LDS	R24,insertflag+36
    0AC53 5F8F      SUBI	R24,0xFF
    0AC54 9380 1DE5 STS	insertflag+36,R24
    0AC56 E082      LDI	R24,2
    0AC57 9020 1DE5 LDS	R2,insertflag+36
    0AC59 1582      CP	R24,R2
    0AC5A F008      BCS	0xAC5C
    0AC5B C07A      RJMP	0xACD6
    0AC5C 2422      CLR	R2
    0AC5D 9220 1DE5 STS	insertflag+36,R2
    0AC5F 9380 1DDF STS	insertflag+30,R24
    0AC61 9220 1DE0 STS	insertflag+31,R2
    0AC63 9180 00C1 LDS	R24,0xC1
    0AC65 7E8F      ANDI	R24,0xEF
    0AC66 9380 00C1 STS	0xC1,R24
    0AC68 9020 1DE2 LDS	R2,insertflag+33
    0AC6A 2433      CLR	R3
    0AC6B 8239      STD	Y+1,R3
    0AC6C 8228      ST	Y,R2
    0AC6D ED2D      LDI	R18,0xDD
    0AC6E E13B      LDI	R19,0x1B
    0AC6F E80D      LDI	R16,0x8D
    0AC70 E01A      LDI	R17,0xA
    0AC71 940E A90D CALL	_uart_Printf
    0AC73 9180 00C1 LDS	R24,0xC1
    0AC75 6180      ORI	R24,0x10
    0AC76 9380 00C1 STS	0xC1,R24
    0AC78 C05D      RJMP	0xACD6
    0AC79 2422      CLR	R2
    0AC7A 9220 1C18 STS	TurnPlateUsedLock,R2
    0AC7C 9220 1C18 STS	TurnPlateUsedLock,R2
    0AC7E 9020 1DF5 LDS	R2,UnloadQueue
    0AC80 9220 1DE2 STS	insertflag+33,R2
    0AC82 EC81      LDI	R24,0xC1
    0AC83 E19D      LDI	R25,0x1D
    0AC84 2DE2      MOV	R30,R2
    0AC85 27FF      CLR	R31
    0AC86 0FE8      ADD	R30,R24
    0AC87 1FF9      ADC	R31,R25
    0AC88 2422      CLR	R2
    0AC89 8220      ST	Z,R2
    0AC8A 9110 1DE2 LDS	R17,insertflag+33
    0AC8C E00D      LDI	R16,0xD
    0AC8D 0301      MULSU	R16,R17
    0AC8E E784      LDI	R24,0x74
    0AC8F E19A      LDI	R25,0x1A
    0AC90 01F0      MOVW	R30,R0
    0AC91 0FE8      ADD	R30,R24
    0AC92 1FF9      ADC	R31,R25
    0AC93 8020      LD	R2,Z
    0AC94 8031      LDD	R3,Z+1
    0AC95 8042      LDD	R4,Z+2
    0AC96 8053      LDD	R5,Z+3
    0AC97 822C      STD	Y+4,R2
    0AC98 823D      STD	Y+5,R3
    0AC99 824E      STD	Y+6,R4
    0AC9A 825F      STD	Y+7,R5
    0AC9B 2F01      MOV	R16,R17
    0AC9C 2711      CLR	R17
    0AC9D 940E 9EF6 CALL	_RingQueueDelete
    0AC9F 9180 00C1 LDS	R24,0xC1
    0ACA1 7E8F      ANDI	R24,0xEF
    0ACA2 9380 00C1 STS	0xC1,R24
    0ACA4 EE2B      LDI	R18,0xEB
    0ACA5 E03D      LDI	R19,0xD
    0ACA6 E40C      LDI	R16,0x4C
    0ACA7 E01A      LDI	R17,0xA
    0ACA8 940E A90D CALL	_uart_Printf
    0ACAA 810C      LDD	R16,Y+4
    0ACAB 811D      LDD	R17,Y+5
    0ACAC 812E      LDD	R18,Y+6
    0ACAD 813F      LDD	R19,Y+7
    0ACAE 940E A940 CALL	_uart0SendInt
    0ACB0 9120 1DE2 LDS	R18,insertflag+33
    0ACB2 2733      CLR	R19
    0ACB3 E403      LDI	R16,0x43
    0ACB4 E01A      LDI	R17,0xA
    0ACB5 940E A90D CALL	_uart_Printf
    0ACB7 9120 0529 LDS	R18,SecondCount+2
    0ACB9 9130 052A LDS	R19,SecondCount+3
    0ACBB 9100 0527 LDS	R16,SecondCount
    0ACBD 9110 0528 LDS	R17,SecondCount+1
    0ACBF 940E A940 CALL	_uart0SendInt
    0ACC1 E400      LDI	R16,0x40
    0ACC2 E01A      LDI	R17,0xA
    0ACC3 940E A90D CALL	_uart_Printf
    0ACC5 9180 00C1 LDS	R24,0xC1
    0ACC7 6180      ORI	R24,0x10
    0ACC8 9380 00C1 STS	0xC1,R24
    0ACCA E083      LDI	R24,3
    0ACCB 9380 1DDF STS	insertflag+30,R24
    0ACCD C008      RJMP	0xACD6
    0ACCE 2422      CLR	R2
    0ACCF 9220 1DDF STS	insertflag+30,R2
    0ACD1 9220 1DE0 STS	insertflag+31,R2
    0ACD3 9220 1DE1 STS	insertflag+32,R2
    0ACD5 DD72      RCALL	_UnloadQueueForward
    0ACD6 2700      CLR	R16
    0ACD7 9628      ADIW	R28,0x8
    0ACD8 940C AE88 JMP	pop_xgset300C
_TrashCanMonitor:
    0ACDA 9722      SBIW	R28,2
    0ACDB 9180 17D7 LDS	R24,WorkProcessStep
    0ACDD 3083      CPI	R24,3
    0ACDE F009      BEQ	0xACE0
    0ACDF C078      RJMP	0xAD58
    0ACE0 9020 0106 LDS	R2,0x106
    0ACE2 FC21      SBRC	R2,1
    0ACE3 C050      RJMP	0xAD34
    0ACE4 9180 1DE9 LDS	R24,insertflag+40
    0ACE6 5F8F      SUBI	R24,0xFF
    0ACE7 9380 1DE9 STS	insertflag+40,R24
    0ACE9 9020 0534 LDS	R2,stopTestFlag
    0ACEB 2022      TST	R2
    0ACEC F449      BNE	0xACF6
    0ACED 9180 1DEC LDS	R24,insertflag+43
    0ACEF 9190 1DED LDS	R25,insertflag+44
    0ACF1 9601      ADIW	R24,1
    0ACF2 9390 1DED STS	insertflag+44,R25
    0ACF4 9380 1DEC STS	insertflag+43,R24
    0ACF6 9180 1DE9 LDS	R24,insertflag+40
    0ACF8 3081      CPI	R24,1
    0ACF9 F439      BNE	0xAD01
    0ACFA 9020 1DEB LDS	R2,insertflag+42
    0ACFC 2022      TST	R2
    0ACFD F019      BEQ	0xAD01
    0ACFE 2422      CLR	R2
    0ACFF 9220 1DEB STS	insertflag+42,R2
    0AD01 9180 1DE9 LDS	R24,insertflag+40
    0AD03 3085      CPI	R24,5
    0AD04 F4A1      BNE	0xAD19
    0AD05 940E 53DC CALL	_ReadCurTestSetial
    0AD07 9310 1DF2 STS	TranCanCountBase+1,R17
    0AD09 9300 1DF1 STS	TranCanCountBase,R16
    0AD0B 9330 1DF4 STS	TranCanCountBase+3,R19
    0AD0D 9320 1DF3 STS	TranCanCountBase+2,R18
    0AD0F E084      LDI	R24,4
    0AD10 E090      LDI	R25,0
    0AD11 8399      STD	Y+1,R25
    0AD12 8388      ST	Y,R24
    0AD13 EF21      LDI	R18,0xF1
    0AD14 E13D      LDI	R19,0x1D
    0AD15 EC08      LDI	R16,0xC8
    0AD16 E010      LDI	R17,0
    0AD17 940E AF45 CALL	_EEPROMWriteBytes_extIO
    0AD19 9180 1DE9 LDS	R24,insertflag+40
    0AD1B 338C      CPI	R24,0x3C
    0AD1C F429      BNE	0xAD22
    0AD1D 940E 372D CALL	_SetBeepWarning
    0AD1F E288      LDI	R24,0x28
    0AD20 9380 1DE9 STS	insertflag+40,R24
    0AD22 9180 1DEC LDS	R24,insertflag+43
    0AD24 9190 1DED LDS	R25,insertflag+44
    0AD26 3B80      CPI	R24,0xB0
    0AD27 E0E4      LDI	R30,4
    0AD28 079E      CPC	R25,R30
    0AD29 F170      BCS	0xAD58
    0AD2A 2422      CLR	R2
    0AD2B 2433      CLR	R3
    0AD2C 9230 1DED STS	insertflag+44,R3
    0AD2E 9220 1DEC STS	insertflag+43,R2
    0AD30 E081      LDI	R24,1
    0AD31 9380 0534 STS	stopTestFlag,R24
    0AD33 C024      RJMP	0xAD58
    0AD34 9020 1DEB LDS	R2,insertflag+42
    0AD36 2022      TST	R2
    0AD37 F419      BNE	0xAD3B
    0AD38 E081      LDI	R24,1
    0AD39 9380 1DEB STS	insertflag+42,R24
    0AD3B 2422      CLR	R2
    0AD3C 9220 1DE9 STS	insertflag+40,R2
    0AD3E 2433      CLR	R3
    0AD3F 9230 1DED STS	insertflag+44,R3
    0AD41 9220 1DEC STS	insertflag+43,R2
    0AD43 9220 0534 STS	stopTestFlag,R2
    0AD45 9020 1DF0 LDS	R2,TrashCanState
    0AD47 2022      TST	R2
    0AD48 F079      BEQ	0xAD58
    0AD49 9180 1DEA LDS	R24,insertflag+41
    0AD4B 5F8F      SUBI	R24,0xFF
    0AD4C 9380 1DEA STS	insertflag+41,R24
    0AD4E E184      LDI	R24,0x14
    0AD4F 9020 1DEA LDS	R2,insertflag+41
    0AD51 1582      CP	R24,R2
    0AD52 F410      BCC	0xAD55
    0AD53 940E 372D CALL	_SetBeepWarning
    0AD55 2422      CLR	R2
    0AD56 9220 1DEA STS	insertflag+41,R2
    0AD58 9622      ADIW	R28,2
    0AD59 9508      RET
_TrashCanCheck:
    0AD5A 2422      CLR	R2
    0AD5B 9220 1DF0 STS	TrashCanState,R2
    0AD5D 2700      CLR	R16
    0AD5E 9508      RET
push_arg4:
    0AD5F 933A      ST	-Y,R19
    0AD60 932A      ST	-Y,R18
push_arg2:
    0AD61 931A      ST	-Y,R17
    0AD62 930A      ST	-Y,R16
    0AD63 9508      RET
mod16u:
    0AD64 9468      BSET	6
    0AD65 C001      RJMP	xdiv16u
div16u:
    0AD66 94E8      BCLR	6
xdiv16u:
    0AD67 92EA      ST	-Y,R14
    0AD68 92FA      ST	-Y,R15
    0AD69 938A      ST	-Y,R24
    0AD6A 24EE      CLR	R14
    0AD6B 24FF      CLR	R15
    0AD6C E180      LDI	R24,0x10
    0AD6D 0F00      LSL	R16
    0AD6E 1F11      ROL	R17
    0AD6F 1CEE      ROL	R14
    0AD70 1CFF      ROL	R15
    0AD71 16E2      CP	R14,R18
    0AD72 06F3      CPC	R15,R19
    0AD73 F018      BCS	0xAD77
    0AD74 1AE2      SUB	R14,R18
    0AD75 0AF3      SBC	R15,R19
    0AD76 9503      INC	R16
    0AD77 958A      DEC	R24
    0AD78 F7A1      BNE	0xAD6D
    0AD79 F416      BRTC	0xAD7C
    0AD7A 2D0E      MOV	R16,R14
    0AD7B 2D1F      MOV	R17,R15
    0AD7C 9189      LD	R24,Y+
    0AD7D 90F9      LD	R15,Y+
    0AD7E 90E9      LD	R14,Y+
    0AD7F 9508      RET
div32u:
    0AD80 94E8      BCLR	6
    0AD81 C001      RJMP	0xAD83
mod32u:
    0AD82 9468      BSET	6
    0AD83 D030      RCALL	long_div_prolog
    0AD84 24CC      CLR	R12
    0AD85 C009      RJMP	0xAD8F
div32s:
    0AD86 94E8      BCLR	6
    0AD87 C001      RJMP	0xAD89
mod32s:
    0AD88 9468      BSET	6
    0AD89 D02A      RCALL	long_div_prolog
    0AD8A FD37      SBRC	R19,7
    0AD8B 940E AECE CALL	neg32
    0AD8D FDB7      SBRC	R27,7
    0AD8E D052      RCALL	neg_R24_R27
    0AD8F 2477      CLR	R7
    0AD90 2488      CLR	R8
    0AD91 2499      CLR	R9
    0AD92 24AA      CLR	R10
    0AD93 24BB      CLR	R11
    0AD94 D042      RCALL	tst_R16_R19
    0AD95 F0C1      BEQ	0xADAE
    0AD96 D045      RCALL	tst_R24_R27
    0AD97 F0B1      BEQ	0xADAE
    0AD98 E2E8      LDI	R30,0x28
    0AD99 0F00      LSL	R16
    0AD9A 1F11      ROL	R17
    0AD9B 1F22      ROL	R18
    0AD9C 1F33      ROL	R19
    0AD9D 1C77      ROL	R7
    0AD9E 1C88      ROL	R8
    0AD9F 1C99      ROL	R9
    0ADA0 1CAA      ROL	R10
    0ADA1 1CBB      ROL	R11
    0ADA2 1688      CP	R8,R24
    0ADA3 0699      CPC	R9,R25
    0ADA4 06AA      CPC	R10,R26
    0ADA5 06BB      CPC	R11,R27
    0ADA6 F028      BCS	0xADAC
    0ADA7 1A88      SUB	R8,R24
    0ADA8 0A99      SBC	R9,R25
    0ADA9 0AAA      SBC	R10,R26
    0ADAA 0ABB      SBC	R11,R27
    0ADAB 9503      INC	R16
    0ADAC 95EA      DEC	R30
    0ADAD F759      BNE	0xAD99
    0ADAE F426      BRTC	0xADB3
    0ADAF 2D08      MOV	R16,R8
    0ADB0 2D19      MOV	R17,R9
    0ADB1 2D2A      MOV	R18,R10
    0ADB2 2D3B      MOV	R19,R11
    0ADB3 C013      RJMP	long_div_epilog
long_div_prolog:
    0ADB4 927A      ST	-Y,R7
    0ADB5 928A      ST	-Y,R8
    0ADB6 929A      ST	-Y,R9
    0ADB7 92AA      ST	-Y,R10
    0ADB8 92BA      ST	-Y,R11
    0ADB9 92CA      ST	-Y,R12
    0ADBA 93EA      ST	-Y,R30
    0ADBB 938A      ST	-Y,R24
    0ADBC 939A      ST	-Y,R25
    0ADBD 93AA      ST	-Y,R26
    0ADBE 93BA      ST	-Y,R27
    0ADBF 858B      LDD	R24,Y+11
    0ADC0 859C      LDD	R25,Y+12
    0ADC1 85AD      LDD	R26,Y+13
    0ADC2 85BE      LDD	R27,Y+14
    0ADC3 2EC3      MOV	R12,R19
    0ADC4 F00E      BRTS	0xADC6
    0ADC5 26CB      EOR	R12,R27
    0ADC6 9508      RET
long_div_epilog:
    0ADC7 FCC7      SBRC	R12,7
    0ADC8 940E AECE CALL	neg32
    0ADCA 91B9      LD	R27,Y+
    0ADCB 91A9      LD	R26,Y+
    0ADCC 9199      LD	R25,Y+
    0ADCD 9189      LD	R24,Y+
    0ADCE 91E9      LD	R30,Y+
    0ADCF 90C9      LD	R12,Y+
    0ADD0 90B9      LD	R11,Y+
    0ADD1 90A9      LD	R10,Y+
    0ADD2 9099      LD	R9,Y+
    0ADD3 9089      LD	R8,Y+
    0ADD4 9079      LD	R7,Y+
    0ADD5 9624      ADIW	R28,4
    0ADD6 9508      RET
tst_R16_R19:
    0ADD7 2FE0      MOV	R30,R16
    0ADD8 2BE1      OR	R30,R17
    0ADD9 2BE2      OR	R30,R18
    0ADDA 2BE3      OR	R30,R19
    0ADDB 9508      RET
tst_R24_R27:
    0ADDC 2FE8      MOV	R30,R24
    0ADDD 2BE9      OR	R30,R25
    0ADDE 2BEA      OR	R30,R26
    0ADDF 2BEB      OR	R30,R27
    0ADE0 9508      RET
neg_R24_R27:
    0ADE1 9580      COM	R24
    0ADE2 9590      COM	R25
    0ADE3 95A0      COM	R26
    0ADE4 95B0      COM	R27
    0ADE5 5F8F      SUBI	R24,0xFF
    0ADE6 4F9F      SBCI	R25,0xFF
    0ADE7 4FAF      SBCI	R26,0xFF
    0ADE8 4FBF      SBCI	R27,0xFF
    0ADE9 9508      RET
mod8s:
    0ADEA 92EA      ST	-Y,R14
    0ADEB 9468      BSET	6
    0ADEC 2EE0      MOV	R14,R16
    0ADED C004      RJMP	0xADF2
div8s:
    0ADEE 92EA      ST	-Y,R14
    0ADEF 94E8      BCLR	6
    0ADF0 2EE0      MOV	R14,R16
    0ADF1 26E1      EOR	R14,R17
    0ADF2 FD07      SBRC	R16,7
    0ADF3 9501      NEG	R16
    0ADF4 FD17      SBRC	R17,7
    0ADF5 9511      NEG	R17
    0ADF6 940E ADFF CALL	xdiv8u
    0ADF8 FCE7      SBRC	R14,7
    0ADF9 9501      NEG	R16
    0ADFA 90E9      LD	R14,Y+
    0ADFB 9508      RET
mod8u:
    0ADFC 9468      BSET	6
    0ADFD C001      RJMP	xdiv8u
div8u:
    0ADFE 94E8      BCLR	6
xdiv8u:
    0ADFF 932A      ST	-Y,R18
    0AE00 92FA      ST	-Y,R15
    0AE01 92EA      ST	-Y,R14
    0AE02 24FF      CLR	R15
    0AE03 24EE      CLR	R14
    0AE04 E120      LDI	R18,0x10
    0AE05 0F00      LSL	R16
    0AE06 1CFF      ROL	R15
    0AE07 1CEE      ROL	R14
    0AE08 16E1      CP	R14,R17
    0AE09 F010      BCS	0xAE0C
    0AE0A 1AE1      SUB	R14,R17
    0AE0B 9503      INC	R16
    0AE0C 952A      DEC	R18
    0AE0D F7B9      BNE	0xAE05
    0AE0E F40E      BRTC	0xAE10
    0AE0F 2D0E      MOV	R16,R14
    0AE10 90E9      LD	R14,Y+
    0AE11 90F9      LD	R15,Y+
    0AE12 9129      LD	R18,Y+
    0AE13 9508      RET
empy16s:
    0AE14 920A      ST	-Y,R0
    0AE15 921A      ST	-Y,R1
    0AE16 938A      ST	-Y,R24
    0AE17 939A      ST	-Y,R25
    0AE18 9F02      MUL	R16,R18
    0AE19 01C0      MOVW	R24,R0
    0AE1A 9F12      MUL	R17,R18
    0AE1B 0D90      ADD	R25,R0
    0AE1C 9F03      MUL	R16,R19
    0AE1D 0D90      ADD	R25,R0
    0AE1E 018C      MOVW	R16,R24
    0AE1F 9199      LD	R25,Y+
    0AE20 9189      LD	R24,Y+
    0AE21 9019      LD	R1,Y+
    0AE22 9009      LD	R0,Y+
    0AE23 9508      RET
empy32s|empy32u:
    0AE24 940E AED7 CALL	long_prolog
    0AE26 927A      ST	-Y,R7
    0AE27 940E AEF0 CALL	tstzero1
    0AE29 F159      BEQ	0xAE55
    0AE2A 2477      CLR	R7
    0AE2B 940E AEF6 CALL	tstzero2
    0AE2D F419      BNE	0xAE31
    0AE2E 018C      MOVW	R16,R24
    0AE2F 019D      MOVW	R18,R26
    0AE30 C024      RJMP	0xAE55
    0AE31 920A      ST	-Y,R0
    0AE32 921A      ST	-Y,R1
    0AE33 9F08      MUL	R16,R24
    0AE34 2CB0      MOV	R11,R0
    0AE35 2CA1      MOV	R10,R1
    0AE36 9F28      MUL	R18,R24
    0AE37 2C90      MOV	R9,R0
    0AE38 2C81      MOV	R8,R1
    0AE39 9F18      MUL	R17,R24
    0AE3A 0CA0      ADD	R10,R0
    0AE3B 1C91      ADC	R9,R1
    0AE3C 1C87      ADC	R8,R7
    0AE3D 9F09      MUL	R16,R25
    0AE3E 0CA0      ADD	R10,R0
    0AE3F 1C91      ADC	R9,R1
    0AE40 1C87      ADC	R8,R7
    0AE41 9F19      MUL	R17,R25
    0AE42 0C90      ADD	R9,R0
    0AE43 1C81      ADC	R8,R1
    0AE44 9F0A      MUL	R16,R26
    0AE45 0C90      ADD	R9,R0
    0AE46 1C81      ADC	R8,R1
    0AE47 9F38      MUL	R19,R24
    0AE48 0C80      ADD	R8,R0
    0AE49 9F29      MUL	R18,R25
    0AE4A 0C80      ADD	R8,R0
    0AE4B 9F1A      MUL	R17,R26
    0AE4C 0C80      ADD	R8,R0
    0AE4D 9F0B      MUL	R16,R27
    0AE4E 0C80      ADD	R8,R0
    0AE4F 9019      LD	R1,Y+
    0AE50 9009      LD	R0,Y+
    0AE51 2D0B      MOV	R16,R11
    0AE52 2D1A      MOV	R17,R10
    0AE53 2D29      MOV	R18,R9
    0AE54 2D38      MOV	R19,R8
    0AE55 9079      LD	R7,Y+
    0AE56 940C AEE5 JMP	long_epilog
pop_xgset003C:
    0AE58 90A9      LD	R10,Y+
    0AE59 90B9      LD	R11,Y+
    0AE5A 90C9      LD	R12,Y+
    0AE5B 90D9      LD	R13,Y+
    0AE5C 9508      RET
pop_xgset00FC:
    0AE5D 90A9      LD	R10,Y+
    0AE5E 90B9      LD	R11,Y+
    0AE5F 90C9      LD	R12,Y+
    0AE60 90D9      LD	R13,Y+
    0AE61 90E9      LD	R14,Y+
    0AE62 90F9      LD	R15,Y+
    0AE63 9508      RET
pop_xgset30FC:
    0AE64 90A9      LD	R10,Y+
    0AE65 90B9      LD	R11,Y+
    0AE66 90C9      LD	R12,Y+
    0AE67 90D9      LD	R13,Y+
    0AE68 90E9      LD	R14,Y+
    0AE69 90F9      LD	R15,Y+
    0AE6A 9149      LD	R20,Y+
    0AE6B 9159      LD	R21,Y+
    0AE6C 9508      RET
pop_xgsetF0FC:
    0AE6D 90A9      LD	R10,Y+
    0AE6E 90B9      LD	R11,Y+
    0AE6F 90C9      LD	R12,Y+
    0AE70 90D9      LD	R13,Y+
    0AE71 90E9      LD	R14,Y+
    0AE72 90F9      LD	R15,Y+
    0AE73 9149      LD	R20,Y+
    0AE74 9159      LD	R21,Y+
    0AE75 9169      LD	R22,Y+
    0AE76 9179      LD	R23,Y+
    0AE77 9508      RET
push_xgsetF0FC:
    0AE78 937A      ST	-Y,R23
    0AE79 936A      ST	-Y,R22
push_xgset30FC:
    0AE7A 935A      ST	-Y,R21
    0AE7B 934A      ST	-Y,R20
push_xgset00FC:
    0AE7C 92FA      ST	-Y,R15
    0AE7D 92EA      ST	-Y,R14
push_xgset003C:
    0AE7E 92DA      ST	-Y,R13
    0AE7F 92CA      ST	-Y,R12
    0AE80 92BA      ST	-Y,R11
    0AE81 92AA      ST	-Y,R10
    0AE82 9508      RET
push_xgset300C:
    0AE83 935A      ST	-Y,R21
    0AE84 934A      ST	-Y,R20
    0AE85 92BA      ST	-Y,R11
    0AE86 92AA      ST	-Y,R10
    0AE87 9508      RET
pop_xgset300C:
    0AE88 90A9      LD	R10,Y+
    0AE89 90B9      LD	R11,Y+
    0AE8A 9149      LD	R20,Y+
    0AE8B 9159      LD	R21,Y+
    0AE8C 9508      RET
push_xgsetF000:
    0AE8D 937A      ST	-Y,R23
    0AE8E 936A      ST	-Y,R22
    0AE8F 935A      ST	-Y,R21
    0AE90 934A      ST	-Y,R20
    0AE91 9508      RET
pop_xgsetF000:
    0AE92 9149      LD	R20,Y+
    0AE93 9159      LD	R21,Y+
    0AE94 9169      LD	R22,Y+
    0AE95 9179      LD	R23,Y+
    0AE96 9508      RET
push_xgsetF00C:
    0AE97 937A      ST	-Y,R23
    0AE98 936A      ST	-Y,R22
    0AE99 935A      ST	-Y,R21
    0AE9A 934A      ST	-Y,R20
    0AE9B 92BA      ST	-Y,R11
    0AE9C 92AA      ST	-Y,R10
    0AE9D 9508      RET
pop_xgsetF00C:
    0AE9E 90A9      LD	R10,Y+
    0AE9F 90B9      LD	R11,Y+
    0AEA0 9149      LD	R20,Y+
    0AEA1 9159      LD	R21,Y+
    0AEA2 9169      LD	R22,Y+
    0AEA3 9179      LD	R23,Y+
    0AEA4 9508      RET
push_xgset303C:
    0AEA5 935A      ST	-Y,R21
    0AEA6 934A      ST	-Y,R20
    0AEA7 92DA      ST	-Y,R13
    0AEA8 92CA      ST	-Y,R12
    0AEA9 92BA      ST	-Y,R11
    0AEAA 92AA      ST	-Y,R10
    0AEAB 9508      RET
pop_xgset303C:
    0AEAC 90A9      LD	R10,Y+
    0AEAD 90B9      LD	R11,Y+
    0AEAE 90C9      LD	R12,Y+
    0AEAF 90D9      LD	R13,Y+
    0AEB0 9149      LD	R20,Y+
    0AEB1 9159      LD	R21,Y+
    0AEB2 9508      RET
push_xgsetF03C:
    0AEB3 937A      ST	-Y,R23
    0AEB4 936A      ST	-Y,R22
    0AEB5 935A      ST	-Y,R21
    0AEB6 934A      ST	-Y,R20
    0AEB7 92DA      ST	-Y,R13
    0AEB8 92CA      ST	-Y,R12
    0AEB9 92BA      ST	-Y,R11
    0AEBA 92AA      ST	-Y,R10
    0AEBB 9508      RET
pop_xgsetF03C:
    0AEBC 90A9      LD	R10,Y+
    0AEBD 90B9      LD	R11,Y+
    0AEBE 90C9      LD	R12,Y+
    0AEBF 90D9      LD	R13,Y+
    0AEC0 9149      LD	R20,Y+
    0AEC1 9159      LD	R21,Y+
    0AEC2 9169      LD	R22,Y+
    0AEC3 9179      LD	R23,Y+
    0AEC4 9508      RET
xicallx:
    0AEC5 920A      ST	-Y,R0
    0AEC6 95D8      ELPM
    0AEC7 920A      ST	-Y,R0
    0AEC8 9631      ADIW	R30,1
    0AEC9 95D8      ELPM
    0AECA 2DF0      MOV	R31,R0
    0AECB 91E9      LD	R30,Y+
    0AECC 9009      LD	R0,Y+
    0AECD 9409      IJMP
neg32:
    0AECE 9500      COM	R16
    0AECF 9510      COM	R17
    0AED0 9520      COM	R18
    0AED1 9530      COM	R19
    0AED2 5F0F      SUBI	R16,0xFF
    0AED3 4F1F      SBCI	R17,0xFF
    0AED4 4F2F      SBCI	R18,0xFF
    0AED5 4F3F      SBCI	R19,0xFF
    0AED6 9508      RET
long_prolog:
    0AED7 928A      ST	-Y,R8
    0AED8 929A      ST	-Y,R9
    0AED9 92AA      ST	-Y,R10
    0AEDA 92BA      ST	-Y,R11
    0AEDB 93EA      ST	-Y,R30
    0AEDC 938A      ST	-Y,R24
    0AEDD 939A      ST	-Y,R25
    0AEDE 93AA      ST	-Y,R26
    0AEDF 93BA      ST	-Y,R27
    0AEE0 8589      LDD	R24,Y+9
    0AEE1 859A      LDD	R25,Y+10
    0AEE2 85AB      LDD	R26,Y+11
    0AEE3 85BC      LDD	R27,Y+12
    0AEE4 9508      RET
long_epilog:
    0AEE5 91B9      LD	R27,Y+
    0AEE6 91A9      LD	R26,Y+
    0AEE7 9199      LD	R25,Y+
    0AEE8 9189      LD	R24,Y+
    0AEE9 91E9      LD	R30,Y+
    0AEEA 90B9      LD	R11,Y+
    0AEEB 90A9      LD	R10,Y+
    0AEEC 9099      LD	R9,Y+
    0AEED 9089      LD	R8,Y+
    0AEEE 9624      ADIW	R28,4
    0AEEF 9508      RET
tstzero1:
    0AEF0 27EE      CLR	R30
    0AEF1 2BE0      OR	R30,R16
    0AEF2 2BE1      OR	R30,R17
    0AEF3 2BE2      OR	R30,R18
    0AEF4 2BE3      OR	R30,R19
    0AEF5 9508      RET
tstzero2:
    0AEF6 27EE      CLR	R30
    0AEF7 2BE8      OR	R30,R24
    0AEF8 2BE9      OR	R30,R25
    0AEF9 2BEA      OR	R30,R26
    0AEFA 2BEB      OR	R30,R27
    0AEFB 9508      RET
asgnblk:
    0AEFC 93AA      ST	-Y,R26
    0AEFD 93BA      ST	-Y,R27
    0AEFE 93EA      ST	-Y,R30
    0AEFF 93FA      ST	-Y,R31
    0AF00 920A      ST	-Y,R0
    0AF01 81AF      LDD	R26,Y+7
    0AF02 85B8      LDD	R27,Y+8
    0AF03 81ED      LDD	R30,Y+5
    0AF04 81FE      LDD	R31,Y+6
    0AF05 3000      CPI	R16,0
    0AF06 0701      CPC	R16,R17
    0AF07 F029      BEQ	0xAF0D
    0AF08 9001      LD	R0,Z+
    0AF09 920D      ST	X+,R0
    0AF0A 5001      SUBI	R16,1
    0AF0B 4010      SBCI	R17,0
    0AF0C CFF8      RJMP	0xAF05
    0AF0D 9009      LD	R0,Y+
    0AF0E 91F9      LD	R31,Y+
    0AF0F 91E9      LD	R30,Y+
    0AF10 91B9      LD	R27,Y+
    0AF11 91A9      LD	R26,Y+
    0AF12 9624      ADIW	R28,4
    0AF13 9508      RET
_EEPROMread_extIO:
    0AF14 99F9      SBIC	0x1F,1
    0AF15 CFFE      RJMP	_EEPROMread_extIO
    0AF16 BD12      OUT	0x22,R17
    0AF17 BD01      OUT	0x21,R16
    0AF18 9AF8      SBI	0x1F,0
    0AF19 B500      IN	R16,0x20
    0AF1A 9508      RET
_EEPROMwrite_extIO:
    0AF1B 92AA      ST	-Y,R10
    0AF1C 99F9      SBIC	0x1F,1
    0AF1D CFFE      RJMP	0xAF1C
    0AF1E BD12      OUT	0x22,R17
    0AF1F BD01      OUT	0x21,R16
    0AF20 BD20      OUT	0x20,R18
    0AF21 B6AF      IN	R10,0x3F
    0AF22 94F8      BCLR	7
    0AF23 9AFA      SBI	0x1F,2
    0AF24 9AF9      SBI	0x1F,1
    0AF25 BEAF      OUT	0x3F,R10
    0AF26 2700      CLR	R16
    0AF27 2711      CLR	R17
    0AF28 90A9      LD	R10,Y+
    0AF29 9508      RET
_EEPROMReadBytes_extIO:
    0AF2A 940E AEB3 CALL	push_xgsetF03C
    0AF2C 0169      MOVW	R12,R18
    0AF2D 01B8      MOVW	R22,R16
    0AF2E 84A8      LDD	R10,Y+8
    0AF2F 84B9      LDD	R11,Y+9
    0AF30 01A6      MOVW	R20,R12
    0AF31 C009      RJMP	0xAF3B
    0AF32 018B      MOVW	R16,R22
    0AF33 940E AF14 CALL	_EEPROMread_extIO
    0AF35 01FA      MOVW	R30,R20
    0AF36 8300      ST	Z,R16
    0AF37 5F6F      SUBI	R22,0xFF
    0AF38 4F7F      SBCI	R23,0xFF
    0AF39 5F4F      SUBI	R20,0xFF
    0AF3A 4F5F      SBCI	R21,0xFF
    0AF3B 0115      MOVW	R2,R10
    0AF3C 01C1      MOVW	R24,R2
    0AF3D 9701      SBIW	R24,1
    0AF3E 015C      MOVW	R10,R24
    0AF3F 2022      TST	R2
    0AF40 F789      BNE	0xAF32
    0AF41 2033      TST	R3
    0AF42 F779      BNE	0xAF32
    0AF43 940C AEBC JMP	pop_xgsetF03C
_EEPROMWriteBytes_extIO:
    0AF45 940E AEB3 CALL	push_xgsetF03C
    0AF47 0169      MOVW	R12,R18
    0AF48 01B8      MOVW	R22,R16
    0AF49 84A8      LDD	R10,Y+8
    0AF4A 84B9      LDD	R11,Y+9
    0AF4B 01A6      MOVW	R20,R12
    0AF4C C009      RJMP	0xAF56
    0AF4D 01FA      MOVW	R30,R20
    0AF4E 8120      LD	R18,Z
    0AF4F 018B      MOVW	R16,R22
    0AF50 940E AF1B CALL	_EEPROMwrite_extIO
    0AF52 5F6F      SUBI	R22,0xFF
    0AF53 4F7F      SBCI	R23,0xFF
    0AF54 5F4F      SUBI	R20,0xFF
    0AF55 4F5F      SBCI	R21,0xFF
    0AF56 0115      MOVW	R2,R10
    0AF57 01C1      MOVW	R24,R2
    0AF58 9701      SBIW	R24,1
    0AF59 015C      MOVW	R10,R24
    0AF5A 2022      TST	R2
    0AF5B F789      BNE	0xAF4D
    0AF5C 2033      TST	R3
    0AF5D F779      BNE	0xAF4D
    0AF5E 940C AEBC JMP	pop_xgsetF03C
