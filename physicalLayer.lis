                        .module physicalLayer.c
                        .area data(ram, con, rel)
 0000           _uartBufProtect::
 0000                   .blkb 1
                        .area idata
 0000 00                .byte 0
                        .area data(ram, con, rel)
 0001           _checkFlag::
 0001                   .blkb 1
                        .area idata
 0001 00                .byte 0
                        .area data(ram, con, rel)
                        .area text(rom, con, rel)
                        .even
 0000           _port_init::
 0000           ; #include <iom1280v.h>
 0000           ; #include <macros.h>
 0000           ; #include "B1404_LIB.h"
 0000           ; #include "LibCommon.h"
 0000           ; #include "Common.h"
 0000           ; 
 0000           ; 
 0000           ; extern unsigned char ControlModel;			// 0:正常， 1:超级终端调试
 0000           ; 
 0000           ; 
 0000           ; //void uartDataInit(void);
 0000           ; //void uart0DataReceive(unsigned char dat);
 0000           ; 
 0000           ; UARTBUF_TXD		uart0TxdBuf;	// 发送数据缓冲区
 0000           ; UARTBUF_RXD 	uart0RxdBuf;
 0000           ; unsigned char 	uartBufProtect = 0;
 0000           ; 
 0000           ; unsigned char checkFlag = 0;
 0000           ; 
 0000           ; void port_init(void)
 0000           ; {
 0000           ; 	PORTA = 0x00;
 0000 2224              clr R2
 0002 22B8              out 0x2,R2
 0004           ;       DDRA  = 0x00;
 0004 21B8              out 0x1,R2
 0006           ;       PORTB = 0x80;
 0006 80E8              ldi R24,128
 0008 85B9              out 0x5,R24
 000A           ;       DDRB  = 0x00;
 000A 24B8              out 0x4,R2
 000C           ;       PORTC = 0x00; //m103 output only
 000C 28B8              out 0x8,R2
 000E           ;       DDRC  = 0x00;
 000E 27B8              out 0x7,R2
 0010           ;       PORTD = 0xFF;
 0010 8FEF              ldi R24,255
 0012 8BB9              out 0xb,R24
 0014           ;       //DDRD  = 0x00;
 0014           ;       DDRD  = 0x80;
 0014 80E8              ldi R24,128
 0016 8AB9              out 0xa,R24
 0018           ;       PORTE = 0x33;
 0018 83E3              ldi R24,51
 001A 8EB9              out 0xe,R24
 001C           ;       DDRE  = 0x32;
 001C 82E3              ldi R24,50
 001E 8DB9              out 0xd,R24
 0020           ;       PORTF = 0x00;
 0020 21BA              out 0x11,R2
 0022           ;       DDRF  = 0x03;
 0022 83E0              ldi R24,3
 0024 80BB              out 0x10,R24
 0026           ;       PORTG = 0x00;
 0026 24BA              out 0x14,R2
 0028           ;       DDRG  = 0x00;
 0028 23BA              out 0x13,R2
 002A           ;       PORTH = 0x03;
 002A 80930201          sts 258,R24
 002E           ;       DDRH  = 0x0c;
 002E 8CE0              ldi R24,12
 0030 80930101          sts 257,R24
 0034           ;       PORTJ = 0x03;
 0034 83E0              ldi R24,3
 0036 80930501          sts 261,R24
 003A           ;       DDRJ  = 0x0c;
 003A 8CE0              ldi R24,12
 003C 80930401          sts 260,R24
 0040           ;       PORTK = 0x0f;
 0040 8FE0              ldi R24,15
 0042 80930801          sts 264,R24
 0046           ;       DDRK  = 0x00;
 0046 20920701          sts 263,R2
 004A           ;       PORTL = 0x00;
 004A 20920B01          sts 267,R2
 004E           ;       DDRL  = 0x00;
 004E 20920A01          sts 266,R2
 0052           L2:
 0052                   .dbline 0 ; func end
 0052 0895              ret
                        .even
 0054           _timer0_init::
 0054           ; }
 0054           ; 
 0054           ; //TIMER0 initialize - prescale:64
 0054           ; // WGM: Normal
 0054           ; // desired value: 8KHz
 0054           ; // actual value: 8.229KHz (2.8%)
 0054           ; void timer0_init(void){
 0054           ; 	TCCR0B = 0x00; //stop
 0054 2224              clr R2
 0056 25BC              out 0x25,R2
 0058           ;       TCNT0 = 0x8d;//0xc7;//0xE4; //set count
 0058 8DE8              ldi R24,141
 005A 86BD              out 0x26,R24
 005C           ;       OCR0A  = 0xc6;//0x39;//0x1C;
 005C 86EC              ldi R24,198
 005E 87BD              out 0x27,R24
 0060           ;       TCCR0A = 0x40; //start timer
 0060 80E4              ldi R24,64
 0062 84BD              out 0x24,R24
 0064           ;       TCCR0B = 0x03; //start timer
 0064 83E0              ldi R24,3
 0066 85BD              out 0x25,R24
 0068           L3:
 0068                   .dbline 0 ; func end
 0068 0895              ret
                        .area vector(rom, abs)
                        .org 92
 005C 0C943500          jmp _timer0_ovf_isr
                        .area text(rom, con, rel)
                        .even
 006A           _timer0_ovf_isr::
 006A 0A92              st -y,R0
 006C 1A92              st -y,R1
 006E 2A92              st -y,R2
 0070 3A92              st -y,R3
 0072 4A92              st -y,R4
 0074 5A92              st -y,R5
 0076 6A92              st -y,R6
 0078 7A92              st -y,R7
 007A 8A92              st -y,R8
 007C 9A92              st -y,R9
 007E 0A93              st -y,R16
 0080 1A93              st -y,R17
 0082 2A93              st -y,R18
 0084 3A93              st -y,R19
 0086 8A93              st -y,R24
 0088 9A93              st -y,R25
 008A AA93              st -y,R26
 008C BA93              st -y,R27
 008E EA93              st -y,R30
 0090 FA93              st -y,R31
 0092 0FB6              IN R0,63
 0094 0A92              st -y,R0
 0096           ; }
 0096           ; 
 0096           ; 
 0096           ; #pragma interrupt_handler timer0_ovf_isr:iv_TIM0_OVF
 0096           ; void timer0_ovf_isr(void)
 0096           ; {
 0096           ;       // OCR0A  = 0x04;
 0096           ;       SendCommandData();
 0096 0E940000          xcall _SendCommandData
 009A           ;       uart0Transfer();                // 串口0数据自动发送
 009A 4CD5              xcall _uart0Transfer
 009C           ;       SendInfoEvent();
 009C 0E940000          xcall _SendInfoEvent
 00A0           ;       
 00A0           ; //    CardTrolleyTurnProcess();
 00A0           ;       
 00A0           ;       Beep();
 00A0 0E940000          xcall _Beep
 00A4           ;       // 0xb4 3k, 0x8d 2k, 0x67 1k5, 0x1a 1k
 00A4           ;       TCNT0 = 0x8d;//0xc7;//0x01; //reload counter value
 00A4 8DE8              ldi R24,141
 00A6 86BD              out 0x26,R24
 00A8           L4:
 00A8                   .dbline 0 ; func end
 00A8 0990              ld R0,y+
 00AA 0FBE              OUT 63,R0
 00AC F991              ld R31,y+
 00AE E991              ld R30,y+
 00B0 B991              ld R27,y+
 00B2 A991              ld R26,y+
 00B4 9991              ld R25,y+
 00B6 8991              ld R24,y+
 00B8 3991              ld R19,y+
 00BA 2991              ld R18,y+
 00BC 1991              ld R17,y+
 00BE 0991              ld R16,y+
 00C0 9990              ld R9,y+
 00C2 8990              ld R8,y+
 00C4 7990              ld R7,y+
 00C6 6990              ld R6,y+
 00C8 5990              ld R5,y+
 00CA 4990              ld R4,y+
 00CC 3990              ld R3,y+
 00CE 2990              ld R2,y+
 00D0 1990              ld R1,y+
 00D2 0990              ld R0,y+
 00D4 1895              reti
                        .even
 00D6           _timer1_init::
 00D6           ; }
 00D6           ; 
 00D6           ; //TIMER1 initialize - prescale:256
 00D6           ; // WGM: 0) Normal, TOP=0xFFFF
 00D6           ; // desired value: 100mSec
 00D6           ; // actual value: 99.983mSec (0.0%)
 00D6           ; void timer1_init(void){
 00D6           ; 	TCCR1B = 0x00; //stop
 00D6 2224              clr R2
 00D8 20928100          sts 129,R2
 00DC           ;       TCNT1H = 0xE9; //setup
 00DC 89EE              ldi R24,233
 00DE 80938500          sts 133,R24
 00E2           ;       TCNT1L = 0x81;
 00E2 81E8              ldi R24,129
 00E4 80938400          sts 132,R24
 00E8           ;       OCR1AH = 0x16;
 00E8 86E1              ldi R24,22
 00EA 80938900          sts 137,R24
 00EE           ;       OCR1AL = 0x7F;
 00EE 8FE7              ldi R24,127
 00F0 80938800          sts 136,R24
 00F4           ;       OCR1BH = 0x16;
 00F4 86E1              ldi R24,22
 00F6 80938B00          sts 139,R24
 00FA           ;       OCR1BL = 0x7F;
 00FA 8FE7              ldi R24,127
 00FC 80938A00          sts 138,R24
 0100           ;       OCR1CH = 0x00;
 0100 20928D00          sts 141,R2
 0104           ;       OCR1CL = 0x00;
 0104 20928C00          sts 140,R2
 0108           ;       ICR1H  = 0x16;
 0108 86E1              ldi R24,22
 010A 80938700          sts 135,R24
 010E           ;       ICR1L  = 0x7F;
 010E 8FE7              ldi R24,127
 0110 80938600          sts 134,R24
 0114           ;       TCCR1A = 0x00;
 0114 20928000          sts 128,R2
 0118           ;       TCCR1C = 0x00;
 0118 20928200          sts 130,R2
 011C           ;       TCCR1B = 0x04; //start Timer
 011C 84E0              ldi R24,4
 011E 80938100          sts 129,R24
 0122           L5:
 0122                   .dbline 0 ; func end
 0122 0895              ret
 0124           ;              t -> R18,R19
 0124           ;            num -> R16
                        .even
 0124           _SetDelayTime::
 0124           ; }
 0124           ; 
 0124           ; unsigned int DelayCount[16];
 0124           ; void SetDelayTime(unsigned char num, unsigned int t){
 0124           ; 	// 100mS
 0124           ; 	if(num>15)
 0124 8FE0              ldi R24,15
 0126 8017              cp R24,R16
 0128 08F4              brsh L7
 012A           X0:
 012A           ; 		return;
 012A 0AC0              xjmp L6
 012C           L7:
 012C           ; 	DelayCount[num] = t;
 012C 80E0              ldi R24,<_DelayCount
 012E 90E0              ldi R25,>_DelayCount
 0130 E02F              mov R30,R16
 0132 FF27              clr R31
 0134 EE0F              lsl R30
 0136 FF1F              rol R31
 0138 E80F              add R30,R24
 013A F91F              adc R31,R25
 013C 3183              std z+1,R19
 013E 2083              std z+0,R18
 0140           L6:
 0140                   .dbline 0 ; func end
 0140 0895              ret
 0142           ;            num -> R16
                        .even
 0142           _WaitDelayTime::
 0142           ; }
 0142           ; unsigned char WaitDelayTime(unsigned char num){
 0142           ; 	if(num>15)
 0142 8FE0              ldi R24,15
 0144 8017              cp R24,R16
 0146 10F4              brsh L10
 0148           X1:
 0148           ; 		return 0;
 0148 0027              clr R16
 014A 11C0              xjmp L9
 014C           L10:
 014C           ; 	if(DelayCount[num] == 0)
 014C 80E0              ldi R24,<_DelayCount
 014E 90E0              ldi R25,>_DelayCount
 0150 E02F              mov R30,R16
 0152 FF27              clr R31
 0154 EE0F              lsl R30
 0156 FF1F              rol R31
 0158 E80F              add R30,R24
 015A F91F              adc R31,R25
 015C 2080              ldd R2,z+0
 015E 3180              ldd R3,z+1
 0160 2220              tst R2
 0162 21F4              brne L12
 0164 3320              tst R3
 0166 11F4              brne L12
 0168           X2:
 0168           ; 		return 0;
 0168 0027              clr R16
 016A 01C0              xjmp L9
 016C           L12:
 016C           ; 	else
 016C           ; 		return 1;
 016C 01E0              ldi R16,1
 016E           L9:
 016E                   .dbline 0 ; func end
 016E 0895              ret
                        .area vector(rom, abs)
                        .org 80
 0050 0C94B800          jmp _timer1_ovf_isr
                        .area text(rom, con, rel)
                        .area bss(ram, con, rel)
 0000           L15:
 0000                   .blkb 1
 0001           L16:
 0001                   .blkb 1
                        .area text(rom, con, rel)
                ;              n -> R20
                        .even
 0170           _timer1_ovf_isr::
 0170 0A92              st -y,R0
 0172 1A92              st -y,R1
 0174 2A92              st -y,R2
 0176 3A92              st -y,R3
 0178 4A92              st -y,R4
 017A 5A92              st -y,R5
 017C 6A92              st -y,R6
 017E 7A92              st -y,R7
 0180 8A92              st -y,R8
 0182 9A92              st -y,R9
 0184 0A93              st -y,R16
 0186 1A93              st -y,R17
 0188 2A93              st -y,R18
 018A 3A93              st -y,R19
 018C 8A93              st -y,R24
 018E 9A93              st -y,R25
 0190 AA93              st -y,R26
 0192 BA93              st -y,R27
 0194 EA93              st -y,R30
 0196 FA93              st -y,R31
 0198 0FB6              IN R0,63
 019A 0A92              st -y,R0
 019C 0E940000          xcall push_xgset300C
 01A0           ; }
 01A0           ; extern unsigned long SecondCount;
 01A0           ; #pragma interrupt_handler timer1_ovf_isr:iv_TIM1_OVF
 01A0           ; void timer1_ovf_isr(void){
 01A0           ;       unsigned char n;
 01A0           ;       static unsigned char i,j;
 01A0           ;       //TIMER1 has overflowed
 01A0           ;       TCNT1H = 0xE9; //reload counter high value
 01A0 89EE              ldi R24,233
 01A2 80938500          sts 133,R24
 01A6           ;       TCNT1L = 0x81; //reload counter low value
 01A6 81E8              ldi R24,129
 01A8 80938400          sts 132,R24
 01AC           ; 
 01AC           ;       for(n=0; n<16; n++){            // 为每个延时计数计时
 01AC 4427              clr R20
 01AE 1BC0              xjmp L20
 01B0           L17:
 01B0           ; 		if(DelayCount[n] != 0)
 01B0 80E0              ldi R24,<_DelayCount
 01B2 90E0              ldi R25,>_DelayCount
 01B4 E42F              mov R30,R20
 01B6 FF27              clr R31
 01B8 EE0F              lsl R30
 01BA FF1F              rol R31
 01BC E80F              add R30,R24
 01BE F91F              adc R31,R25
 01C0 2080              ldd R2,z+0
 01C2 3180              ldd R3,z+1
 01C4 2220              tst R2
 01C6 11F4              brne X3
 01C8 3320              tst R3
 01CA 61F0              breq L21
 01CC           X3:
 01CC           ; 			DelayCount[n] --;	// 计数值减到零时停止
 01CC 242E              mov R2,R20
 01CE 3324              clr R3
 01D0 220C              lsl R2
 01D2 331C              rol R3
 01D4 280E              add R2,R24
 01D6 391E              adc R3,R25
 01D8 F101              movw R30,R2
 01DA 8081              ldd R24,z+0
 01DC 9181              ldd R25,z+1
 01DE 0197              sbiw R24,1
 01E0 9183              std z+1,R25
 01E2 8083              std z+0,R24
 01E4           L21:
 01E4           ; 		}
 01E4           L18:
 01E4 4395              inc R20
 01E6           L20:
 01E6 4031              cpi R20,16
 01E8 18F3              brlo L17
 01EA           X4:
 01EA           ; //	CardTrolleyTurnProcess();
 01EA           ; 	i++;
 01EA 80910000          lds R24,L15
 01EE 8F5F              subi R24,255    ; addi 1
 01F0 80930000          sts L15,R24
 01F4           ;       j++;
 01F4 80910100          lds R24,L16
 01F8 8F5F              subi R24,255    ; addi 1
 01FA 80930100          sts L16,R24
 01FE           ;       if(i>9)
 01FE 89E0              ldi R24,9
 0200 20900000          lds R2,L15
 0204 8215              cp R24,R2
 0206 08F5              brsh L23
 0208           X5:
 0208           ; 	{
 0208           ; 		SecondCount ++;
 0208 81E0              ldi R24,1
 020A 90E0              ldi R25,0
 020C A0E0              ldi R26,0
 020E B0E0              ldi R27,0
 0210 40900200          lds R4,_SecondCount+2
 0214 50900300          lds R5,_SecondCount+2+1
 0218 20900000          lds R2,_SecondCount
 021C 30900100          lds R3,_SecondCount+1
 0220 280E              add R2,R24
 0222 391E              adc R3,R25
 0224 4A1E              adc R4,R26
 0226 5B1E              adc R5,R27
 0228 30920100          sts _SecondCount+1,R3
 022C 20920000          sts _SecondCount,R2
 0230 50920300          sts _SecondCount+2+1,R5
 0234 40920200          sts _SecondCount+2,R4
 0238           ;               i = 0;
 0238 2224              clr R2
 023A 20920000          sts L15,R2
 023E           ;               // 废片仓功能开启
 023E           ;               if(GetwasteCardState() == 0)    
 023E 0E940000          xcall _GetwasteCardState
 0242 0023              tst R16
 0244 11F4              brne L25
 0246           X6:
 0246           ; 			TrashCanMonitor();
 0246 0E940000          xcall _TrashCanMonitor
 024A           L25:
 024A           ; 	}
 024A           L23:
 024A           ; 	if(j > 4)
 024A 84E0              ldi R24,4
 024C 20900100          lds R2,L16
 0250 8215              cp R24,R2
 0252 50F4              brsh L27
 0254           X7:
 0254           ; 	{
 0254           ; 		j = 0;
 0254 2224              clr R2
 0256 20920100          sts L16,R2
 025A           ;               PORTD ^= (1 << 7);
 025A 80E8              ldi R24,128
 025C 90E0              ldi R25,0
 025E 2BB0              in R2,0xb
 0260 3324              clr R3
 0262 2826              eor R2,R24
 0264 3926              eor R3,R25
 0266 2BB8              out 0xb,R2
 0268           ;       }
 0268           L27:
 0268           L14:
 0268                   .dbline 0 ; func end
 0268 0E940000          xcall pop_xgset300C
 026C 0990              ld R0,y+
 026E 0FBE              OUT 63,R0
 0270 F991              ld R31,y+
 0272 E991              ld R30,y+
 0274 B991              ld R27,y+
 0276 A991              ld R26,y+
 0278 9991              ld R25,y+
 027A 8991              ld R24,y+
 027C 3991              ld R19,y+
 027E 2991              ld R18,y+
 0280 1991              ld R17,y+
 0282 0991              ld R16,y+
 0284 9990              ld R9,y+
 0286 8990              ld R8,y+
 0288 7990              ld R7,y+
 028A 6990              ld R6,y+
 028C 5990              ld R5,y+
 028E 4990              ld R4,y+
 0290 3990              ld R3,y+
 0292 2990              ld R2,y+
 0294 1990              ld R1,y+
 0296 0990              ld R0,y+
 0298 1895              reti
                        .even
 029A           _timer4_init::
 029A           ; }
 029A           ; //TIMER4 initialize - prescale:1
 029A           ; // WGM: 7) PWM 10bit fast, TOP=0x03FF
 029A           ; // desired value: 10KHz
 029A           ; // actual value: 14.400KHz (30.6%)
 029A           ; void timer4_init(void)
 029A           ; {
 029A           ;  TCCR4B = 0x00; //stop
 029A 2224              clr R2
 029C 2092A100          sts 161,R2
 02A0           ;  TCNT4H = 0xFC; //setup
 02A0 8CEF              ldi R24,252
 02A2 8093A500          sts 165,R24
 02A6           ;  TCNT4L = 0x01;
 02A6 81E0              ldi R24,1
 02A8 8093A400          sts 164,R24
 02AC           ;  OCR4AH = 0x03;
 02AC 83E0              ldi R24,3
 02AE 8093A900          sts 169,R24
 02B2           ;  OCR4AL = 0xFF;
 02B2 8FEF              ldi R24,255
 02B4 8093A800          sts 168,R24
 02B8           ;  OCR4BH = 0x03;
 02B8 83E0              ldi R24,3
 02BA 8093AB00          sts 171,R24
 02BE           ;  OCR4BL = 0xFF;
 02BE 8FEF              ldi R24,255
 02C0 8093AA00          sts 170,R24
 02C4           ;  OCR4CH = 0x03;
 02C4 83E0              ldi R24,3
 02C6 8093AD00          sts 173,R24
 02CA           ;  OCR4CL = 0xFF;
 02CA 8FEF              ldi R24,255
 02CC 8093AC00          sts 172,R24
 02D0           ;  ICR4H  = 0x03;
 02D0 83E0              ldi R24,3
 02D2 8093A700          sts 167,R24
 02D6           ;  ICR4L  = 0xFF;
 02D6 8FEF              ldi R24,255
 02D8 8093A600          sts 166,R24
 02DC           ;  TCCR4A = 0x2B; //0x2B;       //0x3F;
 02DC 8BE2              ldi R24,43
 02DE 8093A000          sts 160,R24
 02E2           ;  TCCR4C = 0x00;
 02E2 2092A200          sts 162,R2
 02E6           ;  TCCR4B = 0x09; //start Timer
 02E6 89E0              ldi R24,9
 02E8 8093A100          sts 161,R24
 02EC           L29:
 02EC                   .dbline 0 ; func end
 02EC 0895              ret
                        .even
 02EE           _timer5_init::
 02EE           ; }
 02EE           ; 
 02EE           ; //TIMER5 initialize - prescale:1
 02EE           ; // WGM: 7) PWM 10bit fast, TOP=0x03FF
 02EE           ; // desired value: 10KHz
 02EE           ; // actual value: 14.400KHz (30.6%)
 02EE           ; void timer5_init(void)
 02EE           ; {
 02EE           ;  TCCR5B = 0x00; //stop
 02EE 2224              clr R2
 02F0 20922101          sts 289,R2
 02F4           ;  TCNT5H = 0xFC; //setup
 02F4 8CEF              ldi R24,252
 02F6 80932501          sts 293,R24
 02FA           ;  TCNT5L = 0x01;
 02FA 81E0              ldi R24,1
 02FC 80932401          sts 292,R24
 0300           ;  OCR5AH = 0x03;
 0300 83E0              ldi R24,3
 0302 80932901          sts 297,R24
 0306           ;  OCR5AL = 0xFF;
 0306 8FEF              ldi R24,255
 0308 80932801          sts 296,R24
 030C           ;  OCR5BH = 0x03;
 030C 83E0              ldi R24,3
 030E 80932B01          sts 299,R24
 0312           ;  OCR5BL = 0xFF;
 0312 8FEF              ldi R24,255
 0314 80932A01          sts 298,R24
 0318           ;  OCR5CH = 0x03;
 0318 83E0              ldi R24,3
 031A 80932D01          sts 301,R24
 031E           ;  OCR5CL = 0xFF;
 031E 8FEF              ldi R24,255
 0320 80932C01          sts 300,R24
 0324           ;  ICR5H  = 0x03;
 0324 83E0              ldi R24,3
 0326 80932701          sts 295,R24
 032A           ;  ICR5L  = 0xFF;
 032A 8FEF              ldi R24,255
 032C 80932601          sts 294,R24
 0330           ;  TCCR5A = 0x2B; //0x2B;       //0x3F;
 0330 8BE2              ldi R24,43
 0332 80932001          sts 288,R24
 0336           ;  TCCR5C = 0x00;
 0336 20922201          sts 290,R2
 033A           ;  TCCR5B = 0x09; //start Timer
 033A 89E0              ldi R24,9
 033C 80932101          sts 289,R24
 0340           L30:
 0340                   .dbline 0 ; func end
 0340 0895              ret
                        .even
 0342           _uart0_init::
 0342           ; }
 0342           ; 
 0342           ; //UART0 initialize
 0342           ; // desired baud rate: 115200
 0342           ; // actual: baud rate:115200 (0.0%) 
 0342           ; // char size: 8 bit
 0342           ; // parity: Disabled
 0342           ; void uart0_init(void){
 0342           ; 	UCSR0B = 0x00; //disable while setting baud rate
 0342 2224              clr R2
 0344 2092C100          sts 193,R2
 0348           ;       UCSR0A = 0x00;
 0348 2092C000          sts 192,R2
 034C           ;       UCSR0C = 0x06;
 034C 86E0              ldi R24,6
 034E 8093C200          sts 194,R24
 0352           ;       //UBRR0L = 0x07; //set baud rate lo
 0352           ;       UBRR0L = 0X0F;
 0352 8FE0              ldi R24,15
 0354 8093C400          sts 196,R24
 0358           ;       UBRR0H = 0x00; //set baud rate hi
 0358 2092C500          sts 197,R2
 035C           ;       UCSR0B = 0x98;//0xD8;
 035C 88E9              ldi R24,152
 035E 8093C100          sts 193,R24
 0362           L31:
 0362                   .dbline 0 ; func end
 0362 0895              ret
 0364           ;              n -> R20
 0364           ;              c -> R16
                        .even
 0364           _HexToBin::
 0364 4A93              st -y,R20
 0366 5A93              st -y,R21
 0368           ; }
 0368           ; 
 0368           ; unsigned char HexToBin(unsigned char c){
 0368           ;       unsigned char n=0;
 0368 4427              clr R20
 036A           ;       if(c>='0' && c<='9')
 036A 0033              cpi R16,48
 036C 28F0              brlo L33
 036E           X8:
 036E 89E3              ldi R24,57
 0370 8017              cp R24,R16
 0372 10F0              brlo L33
 0374           X9:
 0374           ; 		n = c-0x30;
 0374 402F              mov R20,R16
 0376 4053              subi R20,48
 0378           L33:
 0378           ; 	if(c>='a' && c<='f')
 0378 0136              cpi R16,97
 037A 30F0              brlo L35
 037C           X10:
 037C 86E6              ldi R24,102
 037E 8017              cp R24,R16
 0380 18F0              brlo L35
 0382           X11:
 0382           ; 		n = c-'a' + 10;
 0382 402F              mov R20,R16
 0384 4156              subi R20,97
 0386 465F              subi R20,246    ; addi 10
 0388           L35:
 0388           ; 	if(c>='A' && c<='F')
 0388 0134              cpi R16,65
 038A 30F0              brlo L37
 038C           X12:
 038C 86E4              ldi R24,70
 038E 8017              cp R24,R16
 0390 18F0              brlo L37
 0392           X13:
 0392           ; 		n = c-'A' + 10;
 0392 402F              mov R20,R16
 0394 4154              subi R20,65
 0396 465F              subi R20,246    ; addi 10
 0398           L37:
 0398           ; 	return n;
 0398 042F              mov R16,R20
 039A           L32:
 039A                   .dbline 0 ; func end
 039A 5991              ld R21,y+
 039C 4991              ld R20,y+
 039E 0895              ret
                        .area vector(rom, abs)
                        .org 100
 0064 0C94D001          jmp _uart0_rx_isr
                        .area text(rom, con, rel)
                ;            dat -> R10
                        .even
 03A0           _uart0_rx_isr::
 03A0 0A92              st -y,R0
 03A2 1A92              st -y,R1
 03A4 2A92              st -y,R2
 03A6 3A92              st -y,R3
 03A8 4A92              st -y,R4
 03AA 5A92              st -y,R5
 03AC 6A92              st -y,R6
 03AE 7A92              st -y,R7
 03B0 8A92              st -y,R8
 03B2 9A92              st -y,R9
 03B4 0A93              st -y,R16
 03B6 1A93              st -y,R17
 03B8 2A93              st -y,R18
 03BA 3A93              st -y,R19
 03BC 8A93              st -y,R24
 03BE 9A93              st -y,R25
 03C0 AA93              st -y,R26
 03C2 BA93              st -y,R27
 03C4 EA93              st -y,R30
 03C6 FA93              st -y,R31
 03C8 0FB6              IN R0,63
 03CA 0A92              st -y,R0
 03CC AA92              st -y,R10
 03CE           ;       
 03CE           ; }
 03CE           ; //unsigned char CmdBuf[30];
 03CE           ; //unsigned char CmdLen=0;
 03CE           ; //unsigned char rxBuf[60];
 03CE           ; //unsigned char rxPnt=0;
 03CE           ; #pragma interrupt_handler uart0_rx_isr:iv_USART0_RXC
 03CE           ; void uart0_rx_isr(void){
 03CE           ;  //uart has received a character in UDR
 03CE           ;       unsigned char dat;
 03CE           ;       dat = UDR0;
 03CE A090C600          lds R10,198
 03D2           ;       uart0DataReceive(dat);
 03D2 0A2D              mov R16,R10
 03D4 B1D2              xcall _uart0DataReceive
 03D6           L39:
 03D6                   .dbline 0 ; func end
 03D6 A990              ld R10,y+
 03D8 0990              ld R0,y+
 03DA 0FBE              OUT 63,R0
 03DC F991              ld R31,y+
 03DE E991              ld R30,y+
 03E0 B991              ld R27,y+
 03E2 A991              ld R26,y+
 03E4 9991              ld R25,y+
 03E6 8991              ld R24,y+
 03E8 3991              ld R19,y+
 03EA 2991              ld R18,y+
 03EC 1991              ld R17,y+
 03EE 0991              ld R16,y+
 03F0 9990              ld R9,y+
 03F2 8990              ld R8,y+
 03F4 7990              ld R7,y+
 03F6 6990              ld R6,y+
 03F8 5990              ld R5,y+
 03FA 4990              ld R4,y+
 03FC 3990              ld R3,y+
 03FE 2990              ld R2,y+
 0400 1990              ld R1,y+
 0402 0990              ld R0,y+
 0404 1895              reti
                        .area vector(rom, abs)
                        .org 108
 006C 0C940302          jmp _uart0_tx_isr
                        .area text(rom, con, rel)
                        .even
 0406           _uart0_tx_isr::
 0406           ; }
 0406           ; 
 0406           ; #pragma interrupt_handler uart0_tx_isr:iv_USART0_TXC
 0406           ; void uart0_tx_isr(void){
 0406           L40:
 0406                   .dbline 0 ; func end
 0406 1895              reti
                        .even
 0408           _uart1_init::
 0408           ; 	//character has been transmitted
 0408           ; 
 0408           ; }
 0408           ; 
 0408           ; //UART1 initialize
 0408           ; // desired baud rate:9600
 0408           ; // actual baud rate:9600 (0.0%)
 0408           ; // char size: 8 bit
 0408           ; // parity: Disabled
 0408           ; void uart1_init(void){
 0408           ; 	UCSR1B = 0x00; //disable while setting baud rate
 0408 2224              clr R2
 040A 2092C900          sts 201,R2
 040E           ;       UCSR1A = 0x00;
 040E 2092C800          sts 200,R2
 0412           ;       UCSR1C = 0x06;
 0412 86E0              ldi R24,6
 0414 8093CA00          sts 202,R24
 0418           ;       UBRR1L = 0x5F; //set baud rate lo
 0418 8FE5              ldi R24,95
 041A 8093CC00          sts 204,R24
 041E           ;       UBRR1H = 0x00; //set baud rate hi
 041E 2092CD00          sts 205,R2
 0422           ;       UCSR1B = 0x98;
 0422 88E9              ldi R24,152
 0424 8093C900          sts 201,R24
 0428           L41:
 0428                   .dbline 0 ; func end
 0428 0895              ret
                        .area vector(rom, abs)
                        .org 144
 0090 0C941502          jmp _uart1_rx_isr
                        .area text(rom, con, rel)
                        .even
 042A           _uart1_rx_isr::
 042A           ; }
 042A           ; 
 042A           ; #pragma interrupt_handler uart1_rx_isr:iv_USART1_RXC
 042A           ; void uart1_rx_isr(void){
 042A           L42:
 042A                   .dbline 0 ; func end
 042A 1895              reti
                        .even
 042C           _uart2_init::
 042C           ;  //uart has received a character in UDR
 042C           ; 	
 042C           ; }
 042C           ; 
 042C           ; //UART2 initialize
 042C           ; // desired baud rate:115200
 042C           ; // actual baud rate:115200 (0.0%)
 042C           ; // char size: 9 bit
 042C           ; // parity: Disabled
 042C           ; void uart2_init(void){
 042C           ; 	UCSR2B = 0x00; //disable while setting baud rate
 042C 2224              clr R2
 042E 2092D100          sts 209,R2
 0432           ;       UCSR2A = 0x00;
 0432 2092D000          sts 208,R2
 0436           ;       UCSR2C = 0x06;
 0436 86E0              ldi R24,6
 0438 8093D200          sts 210,R24
 043C           ;       UBRR2L = 0x07; //set baud rate lo       115200
 043C 87E0              ldi R24,7
 043E 8093D400          sts 212,R24
 0442           ;       UBRR2H = 0x00; //set baud rate hi
 0442 2092D500          sts 213,R2
 0446           ;       UCSR2B = 0xDC;//0xDC;
 0446 8CED              ldi R24,220
 0448 8093D100          sts 209,R24
 044C           L43:
 044C                   .dbline 0 ; func end
 044C 0895              ret
                        .area data(ram, con, rel)
 0002           __Uart2DetectorSelfFlag::
 0002                   .blkb 1
                        .area idata
 0002 00                .byte 0
                        .area data(ram, con, rel)
 0003           __Uart2DataSendResult::
 0003                   .blkb 1
                        .area idata
 0003 00                .byte 0
                        .area data(ram, con, rel)
                        .area text(rom, con, rel)
                        .even
 044E           _GetUart2DataSendResult::
 044E           ; }
 044E           ; 
 044E           ; unsigned char _Uart2DetectorSelfFlag = 0;	// 数据发送标记, 用于在线侦测发送数据
 044E           ; unsigned char _Uart2DetectorSelfData;		// 接收在线侦测到的数据
 044E           ; unsigned char _Uart2CurrentSendData;		// 当前发送的数据
 044E           ; unsigned char _Uart2DataSendResult = 0;
 044E           ; /*void SetUart2DetectorSelf(void){
 044E           ; 	_Uart2DetectorSelfFlag = 1;
 044E           ; }
 044E           ; unsigned char GetUart2DetectorSelfData(void){
 044E           ; 	return _Uart2DetectorSelfData;
 044E           ; }*/
 044E           ; unsigned char GetUart2DataSendResult(void){
 044E           ; 	return _Uart2DataSendResult;
 044E 00910300          lds R16,__Uart2DataSendResult
 0452           L44:
 0452                   .dbline 0 ; func end
 0452 0895              ret
                        .area vector(rom, abs)
                        .org 204
 00CC 0C942A02          jmp _uart2_rx_isr
                        .area text(rom, con, rel)
                ;            dat -> R10
                        .even
 0454           _uart2_rx_isr::
 0454 0A92              st -y,R0
 0456 1A92              st -y,R1
 0458 2A92              st -y,R2
 045A 3A92              st -y,R3
 045C 4A92              st -y,R4
 045E 5A92              st -y,R5
 0460 6A92              st -y,R6
 0462 7A92              st -y,R7
 0464 8A92              st -y,R8
 0466 9A92              st -y,R9
 0468 0A93              st -y,R16
 046A 1A93              st -y,R17
 046C 2A93              st -y,R18
 046E 3A93              st -y,R19
 0470 8A93              st -y,R24
 0472 9A93              st -y,R25
 0474 AA93              st -y,R26
 0476 BA93              st -y,R27
 0478 EA93              st -y,R30
 047A FA93              st -y,R31
 047C 0FB6              IN R0,63
 047E 0A92              st -y,R0
 0480 AA92              st -y,R10
 0482           ; }
 0482           ; 
 0482           ; #pragma interrupt_handler uart2_rx_isr:iv_USART2_RXC
 0482           ; void uart2_rx_isr(void)
 0482           ; {
 0482           ;       //uart has received a character in UDR
 0482           ;       unsigned char dat;
 0482           ;       dat = UDR2;
 0482 A090D600          lds R10,214
 0486           ;       if(_Uart2DetectorSelfFlag)
 0486 20900200          lds R2,__Uart2DetectorSelfFlag
 048A 2220              tst R2
 048C 89F0              breq L46
 048E           X14:
 048E           ; 	{
 048E           ; 		_Uart2DetectorSelfData = dat;
 048E A0927400          sts __Uart2DetectorSelfData,R10
 0492           ;               _Uart2DetectorSelfFlag = 0;
 0492 2224              clr R2
 0494 20920200          sts __Uart2DetectorSelfFlag,R2
 0498           ;               if(_Uart2DetectorSelfData == _Uart2CurrentSendData)
 0498 20907300          lds R2,__Uart2CurrentSendData
 049C A214              cp R10,R2
 049E 21F4              brne L48
 04A0           X15:
 04A0           ; 			_Uart2DataSendResult = 0;
 04A0 2224              clr R2
 04A2 20920300          sts __Uart2DataSendResult,R2
 04A6 07C0              xjmp L47
 04A8           L48:
 04A8           ; 		else
 04A8           ; 			_Uart2DataSendResult = 1;
 04A8 81E0              ldi R24,1
 04AA 80930300          sts __Uart2DataSendResult,R24
 04AE           ;       }
 04AE 03C0              xjmp L47
 04B0           L46:
 04B0           ; 	else
 04B0           ; 		ReceiveSlaveInfo(dat);
 04B0 0A2D              mov R16,R10
 04B2 0E940000          xcall _ReceiveSlaveInfo
 04B6           L47:
 04B6           L45:
 04B6                   .dbline 0 ; func end
 04B6 A990              ld R10,y+
 04B8 0990              ld R0,y+
 04BA 0FBE              OUT 63,R0
 04BC F991              ld R31,y+
 04BE E991              ld R30,y+
 04C0 B991              ld R27,y+
 04C2 A991              ld R26,y+
 04C4 9991              ld R25,y+
 04C6 8991              ld R24,y+
 04C8 3991              ld R19,y+
 04CA 2991              ld R18,y+
 04CC 1991              ld R17,y+
 04CE 0991              ld R16,y+
 04D0 9990              ld R9,y+
 04D2 8990              ld R8,y+
 04D4 7990              ld R7,y+
 04D6 6990              ld R6,y+
 04D8 5990              ld R5,y+
 04DA 4990              ld R4,y+
 04DC 3990              ld R3,y+
 04DE 2990              ld R2,y+
 04E0 1990              ld R1,y+
 04E2 0990              ld R0,y+
 04E4 1895              reti
                        .area vector(rom, abs)
                        .org 212
 00D4 0C947302          jmp _uart2_tx_isr
                        .area text(rom, con, rel)
                        .even
 04E6           _uart2_tx_isr::
 04E6 8A93              st -y,R24
 04E8 8FB7              IN R24,63
 04EA 8A93              st -y,R24
 04EC           ; }
 04EC           ; 
 04EC           ; #pragma interrupt_handler uart2_tx_isr:iv_USART2_TXC
 04EC           ; void uart2_tx_isr(void){
 04EC           ;       //character has been transmitted
 04EC           ;       PORTH = 0x03;
 04EC 83E0              ldi R24,3
 04EE 80930201          sts 258,R24
 04F2           ;       PORTH = 0x03;
 04F2 80930201          sts 258,R24
 04F6           L50:
 04F6                   .dbline 0 ; func end
 04F6 8991              ld R24,y+
 04F8 8FBF              OUT 63,R24
 04FA 8991              ld R24,y+
 04FC 1895              reti
 04FE           ;            add -> R16
                        .even
 04FE           _Uart2SendAdd::
 04FE           ; //	BeepNum = 2;
 04FE           ; }
 04FE           ; void Uart2SendAdd(unsigned char add)
 04FE           ; {
 04FE           ; 	PORTH = 0x0b;	//0x0f;
 04FE 8BE0              ldi R24,11
 0500 80930201          sts 258,R24
 0504           ;       _Uart2DetectorSelfFlag = 1;
 0504 81E0              ldi R24,1
 0506 80930200          sts __Uart2DetectorSelfFlag,R24
 050A           L52:
 050A           ; 	while(!(UCSR2A & 0x20));
 050A           L53:
 050A 2090D000          lds R2,208
 050E 25FE              sbrs R2,5
 0510 FCCF              rjmp L52
 0512           X16:
 0512           ; 	UCSR2B |= 0x01;
 0512 8091D100          lds R24,209
 0516 8160              ori R24,1
 0518 8093D100          sts 209,R24
 051C           ;       UDR2 = add;
 051C 0093D600          sts 214,R16
 0520           ;       _Uart2CurrentSendData = add;
 0520 00937300          sts __Uart2CurrentSendData,R16
 0524           L51:
 0524                   .dbline 0 ; func end
 0524 0895              ret
 0526           ;            dat -> R16
                        .even
 0526           _Uart2SendDat::
 0526           ; }
 0526           ; void Uart2SendDat(unsigned char dat)
 0526           ; {
 0526           ; 	PORTH = 0x0b;	//0x0f;
 0526 8BE0              ldi R24,11
 0528 80930201          sts 258,R24
 052C           ;       _Uart2DetectorSelfFlag = 1;
 052C 81E0              ldi R24,1
 052E 80930200          sts __Uart2DetectorSelfFlag,R24
 0532           L56:
 0532           ; 	while(!(UCSR2A & 0x20));
 0532           L57:
 0532 2090D000          lds R2,208
 0536 25FE              sbrs R2,5
 0538 FCCF              rjmp L56
 053A           X17:
 053A           ; 	UCSR2B &= 0xFE;
 053A 8091D100          lds R24,209
 053E 8E7F              andi R24,254
 0540 8093D100          sts 209,R24
 0544           ;       UDR2 = dat;
 0544 0093D600          sts 214,R16
 0548           ;       _Uart2CurrentSendData = dat;
 0548 00937300          sts __Uart2CurrentSendData,R16
 054C           L55:
 054C                   .dbline 0 ; func end
 054C 0895              ret
                        .even
 054E           _uart3_init::
 054E           ; }
 054E           ; 
 054E           ; //UART3 initialize
 054E           ; // desired baud rate:115200
 054E           ; // actual baud rate:115200 (0.0%)
 054E           ; // char size: 9 bit
 054E           ; // parity: Disabled
 054E           ; void uart3_init(void){
 054E           ; 	UCSR3B = 0x00; //disable while setting baud rate
 054E 2224              clr R2
 0550 20923101          sts 305,R2
 0554           ;       UCSR3A = 0x00;
 0554 20923001          sts 304,R2
 0558           ;       UCSR3C = 0x06;
 0558 86E0              ldi R24,6
 055A 80933201          sts 306,R24
 055E           ;       UBRR3L = 0x07; //set baud rate lo
 055E 87E0              ldi R24,7
 0560 80933401          sts 308,R24
 0564           ; //    UBRR3L = 0x0f; //set baud rate lo
 0564           ;       UBRR3H = 0x00; //set baud rate hi
 0564 20923501          sts 309,R2
 0568           ;       UCSR3B = 0xDC;//0xDC;
 0568 8CED              ldi R24,220
 056A 80933101          sts 305,R24
 056E           L59:
 056E                   .dbline 0 ; func end
 056E 0895              ret
                        .area vector(rom, abs)
                        .org 216
 00D8 0C94B802          jmp _uart3_rx_isr
                        .area text(rom, con, rel)
                ;            dat -> R16
                        .even
 0570           _uart3_rx_isr::
 0570 2A92              st -y,R2
 0572 0A93              st -y,R16
 0574 2FB6              IN R2,63
 0576 2A92              st -y,R2
 0578           ; }
 0578           ; 
 0578           ; #pragma interrupt_handler uart3_rx_isr:iv_USART3_RXC
 0578           ; void uart3_rx_isr(void){
 0578           L61:
 0578           ; 	//uart has received a character in UDR
 0578           ; 	unsigned char dat;
 0578           ; 	while(!(UCSR3A & 0x80));
 0578           L62:
 0578 20903001          lds R2,304
 057C 27FE              sbrs R2,7
 057E FCCF              rjmp L61
 0580           X18:
 0580           ; 	dat = UDR3;
 0580 00913601          lds R16,310
 0584           L64:
 0584           ; 	while(!(UCSR0A & 0x20));
 0584           L65:
 0584 2090C000          lds R2,192
 0588 25FE              sbrs R2,5
 058A FCCF              rjmp L64
 058C           X19:
 058C           ; 	UDR0 = dat;
 058C 0093C600          sts 198,R16
 0590           L60:
 0590                   .dbline 0 ; func end
 0590 2990              ld R2,y+
 0592 2FBE              OUT 63,R2
 0594 0991              ld R16,y+
 0596 2990              ld R2,y+
 0598 1895              reti
                        .area vector(rom, abs)
                        .org 224
 00E0 0C94CD02          jmp _uart3_tx_isr
                        .area text(rom, con, rel)
                        .even
 059A           _uart3_tx_isr::
 059A 8A93              st -y,R24
 059C 8FB7              IN R24,63
 059E 8A93              st -y,R24
 05A0           ; //    dat = dat;
 05A0           ;       //BeepNum = 2;
 05A0           ; }
 05A0           ; 
 05A0           ; #pragma interrupt_handler uart3_tx_isr:iv_USART3_TXC
 05A0           ; void uart3_tx_isr(void){
 05A0           ;       //character has been transmitted
 05A0           ;       PORTJ = 0x03;
 05A0 83E0              ldi R24,3
 05A2 80930501          sts 261,R24
 05A6           ;       PORTJ = 0x03;
 05A6 80930501          sts 261,R24
 05AA           L67:
 05AA                   .dbline 0 ; func end
 05AA 8991              ld R24,y+
 05AC 8FBF              OUT 63,R24
 05AE 8991              ld R24,y+
 05B0 1895              reti
 05B2           ;            add -> R16
                        .even
 05B2           _Uart3SendAdd::
 05B2           ; }
 05B2           ; void Uart3SendAdd(unsigned char add){
 05B2           ; 	PORTJ = 0x0f;
 05B2 8FE0              ldi R24,15
 05B4 80930501          sts 261,R24
 05B8           L69:
 05B8           ; 	while(!(UCSR2A & 0x20));
 05B8           L70:
 05B8 2090D000          lds R2,208
 05BC 25FE              sbrs R2,5
 05BE FCCF              rjmp L69
 05C0           X20:
 05C0           ; 	UCSR3B |= 0x01;
 05C0 80913101          lds R24,305
 05C4 8160              ori R24,1
 05C6 80933101          sts 305,R24
 05CA           ;       UDR3 = add;
 05CA 00933601          sts 310,R16
 05CE           L68:
 05CE                   .dbline 0 ; func end
 05CE 0895              ret
 05D0           ;            dat -> R16
                        .even
 05D0           _Uart3SendDat::
 05D0           ; }
 05D0           ; void Uart3SendDat(unsigned char dat){
 05D0           ; 	PORTJ = 0x0f;
 05D0 8FE0              ldi R24,15
 05D2 80930501          sts 261,R24
 05D6           L73:
 05D6           ; 	while(!(UCSR3A & 0x20));
 05D6           L74:
 05D6 20903001          lds R2,304
 05DA 25FE              sbrs R2,5
 05DC FCCF              rjmp L73
 05DE           X21:
 05DE           ; 	UCSR3B &= 0xFE;
 05DE 80913101          lds R24,305
 05E2 8E7F              andi R24,254
 05E4 80933101          sts 305,R24
 05E8           ;       UDR3 = dat;
 05E8 00933601          sts 310,R16
 05EC           L72:
 05EC                   .dbline 0 ; func end
 05EC 0895              ret
                        .area vector(rom, abs)
                        .org 44
 002C 0C94F702          jmp _pcint2_isr
                        .area text(rom, con, rel)
                        .even
 05EE           _pcint2_isr::
 05EE           ; }
 05EE           ; 
 05EE           ; #pragma interrupt_handler pcint2_isr:iv_PCINT2
 05EE           ; void pcint2_isr(void){
 05EE           L76:
 05EE                   .dbline 0 ; func end
 05EE 1895              reti
                        .even
 05F0           _adc_init::
 05F0           ; 	//pin change interrupt 2
 05F0           ; }
 05F0           ; 
 05F0           ; //ADC initialize
 05F0           ; // Conversion time: 112uS
 05F0           ; void adc_init(void){
 05F0           ; 	ADCSRA = 0x00; //disable adc
 05F0 2224              clr R2
 05F2 20927A00          sts 122,R2
 05F6           ;       ADMUX = 0x42;  //select adc input 2
 05F6 82E4              ldi R24,66
 05F8 80937C00          sts 124,R24
 05FC           ;       ACSR  = 0x80;
 05FC 80E8              ldi R24,128
 05FE 80BF              out 0x30,R24
 0600           ;       ADCSRB = 0x00;
 0600 20927B00          sts 123,R2
 0604           ;       ADCSRA = 0xEF;
 0604 8FEE              ldi R24,239
 0606 80937A00          sts 122,R24
 060A           L77:
 060A                   .dbline 0 ; func end
 060A 0895              ret
 060C           ;            num -> R16
                        .even
 060C           _SetNextADChannel::
 060C 4A93              st -y,R20
 060E 5A93              st -y,R21
 0610           ; }
 0610           ; 
 0610           ; void SetNextADChannel(unsigned char num)
 0610           ; {
 0610           ;       switch(num)
 0610 402F              mov R20,R16
 0612 5527              clr R21
 0614 4030              cpi R20,0
 0616 4507              cpc R20,R21
 0618 49F0              breq L82
 061A           X22:
 061A 4130              cpi R20,1
 061C E0E0              ldi R30,0
 061E 5E07              cpc R21,R30
 0620 61F0              breq L83
 0622           X23:
 0622 4230              cpi R20,2
 0624 E0E0              ldi R30,0
 0626 5E07              cpc R21,R30
 0628 79F0              breq L84
 062A           X24:
 062A 14C0              xjmp L80
 062C           L82:
 062C           ; 	{
 062C           ; 		case NeedleChannel:	ADCSRB = 0X08;ADMUX = 0X42;break;	 // Next ADC 10
 062C 88E0              ldi R24,8
 062E 80937B00          sts 123,R24
 0632 82E4              ldi R24,66
 0634 80937C00          sts 124,R24
 0638 0DC0              xjmp L80
 063A           L83:
 063A           ; 		case LoadChannel:	ADCSRB = 0X08;ADMUX = 0X43;break;	 // Next ADC 11
 063A 88E0              ldi R24,8
 063C 80937B00          sts 123,R24
 0640 83E4              ldi R24,67
 0642 80937C00          sts 124,R24
 0646 06C0              xjmp L80
 0648           L84:
 0648           ; 		case UnloadChannel: ADCSRB = 0X00;ADMUX = 0X42;break;	 // Next ADC 02
 0648 2224              clr R2
 064A 20927B00          sts 123,R2
 064E 82E4              ldi R24,66
 0650 80937C00          sts 124,R24
 0654           ;       //      case NeedleChannel:     ADCSRB = 0X08;ADMUX = 0X43;break;        // ADC 2
 0654           ;       //      case LoadChannel:       ADCSRB = 0X00;ADMUX = 0X42;break;        // ADC 11
 0654           ;       //      case UnloadChannel: ADCSRB = 0X08;ADMUX = 0X42;break;    // ADC 10 
 0654           ;               default:break;
 0654           L80:
 0654           L78:
 0654                   .dbline 0 ; func end
 0654 5991              ld R21,y+
 0656 4991              ld R20,y+
 0658 0895              ret
                        .area data(ram, con, rel)
 0004           __Adc_Wave::
 0004                   .blkb 2
                        .area idata
 0004 0000              .word 0
                        .area data(ram, con, rel)
 0006           __Adc_DiffBufPnt::
 0006                   .blkb 1
                        .area idata
 0006 00                .byte 0
                        .area data(ram, con, rel)
                        .area text(rom, con, rel)
                ;            num -> R16
                        .even
 065A           _getLiqDetADC::
 065A           ; 	}
 065A           ; }
 065A           ; 
 065A           ; unsigned int AdcResult[3];		// 0 NeedleChannel,1 LoadChannel, 2 UnloadChannel 
 065A           ; #define _ADC_DIFF_BUF_LEN 20
 065A           ; signed int _Adc_DiffBuf[_ADC_DIFF_BUF_LEN];
 065A           ; signed int _Adc_Wave = 0;
 065A           ; unsigned char _Adc_DiffBufPnt=0;
 065A           ; 
 065A           ; unsigned int getLiqDetADC(unsigned char num)
 065A           ; {
 065A           ; 	return AdcResult[num];
 065A 80E0              ldi R24,<_AdcResult
 065C 90E0              ldi R25,>_AdcResult
 065E E02F              mov R30,R16
 0660 FF27              clr R31
 0662 EE0F              lsl R30
 0664 FF1F              rol R31
 0666 E80F              add R30,R24
 0668 F91F              adc R31,R25
 066A 0081              ldd R16,z+0
 066C 1181              ldd R17,z+1
 066E           L85:
 066E                   .dbline 0 ; func end
 066E 0895              ret
                        .even
 0670           _CheckLiqDetBase::
 0670           ; }
 0670           ; unsigned char CheckLiqDetBase(void)
 0670           ; {
 0670           ; 	if(AdcResult[NeedleChannel] > 1015)	// 液体探测电极未连接
 0670 87EF              ldi R24,1015
 0672 93E0              ldi R25,3
 0674 20906D00          lds R2,_AdcResult
 0678 30906E00          lds R3,_AdcResult+1
 067C 8215              cp R24,R2
 067E 9305              cpc R25,R3
 0680 B0F4              brsh L87
 0682           X25:
 0682           ; 	{		
 0682           ; 		SetBeepWarning();
 0682 0E940000          xcall _SetBeepWarning
 0686           ;               Uart0ReUnable;
 0686 8091C100          lds R24,193
 068A 8F7E              andi R24,239
 068C 8093C100          sts 193,R24
 0690           ;               uart_Printf("!2901 $%d\r\n", AdcResult[NeedleChannel]);         // 液体探测电极未连接, 请检查液体探测电极连接是否完好
 0690 20916D00          lds R18,_AdcResult
 0694 30916E00          lds R19,_AdcResult+1
 0698 00E0              ldi R16,<L89
 069A 10E0              ldi R17,>L89
 069C 0E940000          xcall _uart_Printf
 06A0           ;               Uart0ReEnable;
 06A0 8091C100          lds R24,193
 06A4 8061              ori R24,16
 06A6 8093C100          sts 193,R24
 06AA           ;               return 2;
 06AA 02E0              ldi R16,2
 06AC 1FC0              xjmp L86
 06AE           L87:
 06AE           ; 	}
 06AE           ; 	else if(AdcResult[NeedleChannel] < 400) // 液体探测电极附带影响大
 06AE 80916D00          lds R24,_AdcResult
 06B2 90916E00          lds R25,_AdcResult+1
 06B6 8039              cpi R24,144
 06B8 E1E0              ldi R30,1
 06BA 9E07              cpc R25,R30
 06BC B0F4              brsh L90
 06BE           X26:
 06BE           ; 	{
 06BE           ; 		SetBeepWarning();
 06BE 0E940000          xcall _SetBeepWarning
 06C2           ;               Uart0ReUnable;
 06C2 8091C100          lds R24,193
 06C6 8F7E              andi R24,239
 06C8 8093C100          sts 193,R24
 06CC           ;               uart_Printf("!2902 $%d\r\n", AdcResult[NeedleChannel]); // 液体探测电极受影响，请检查取样针接头处以及清洗头处是否有污染物
 06CC 20916D00          lds R18,_AdcResult
 06D0 30916E00          lds R19,_AdcResult+1
 06D4 00E0              ldi R16,<L92
 06D6 10E0              ldi R17,>L92
 06D8 0E940000          xcall _uart_Printf
 06DC           ;               Uart0ReEnable;
 06DC 8091C100          lds R24,193
 06E0 8061              ori R24,16
 06E2 8093C100          sts 193,R24
 06E6           ;               return 1;
 06E6 01E0              ldi R16,1
 06E8 01C0              xjmp L86
 06EA           L90:
 06EA           ; 	}
 06EA           ; 	
 06EA           ; 	return 0;
 06EA 0027              clr R16
 06EC           L86:
 06EC                   .dbline 0 ; func end
 06EC 0895              ret
                        .even
 06EE           _GetLiqDetDiff::
 06EE           ; }
 06EE           ; signed int GetLiqDetDiff(void){
 06EE           ; 	return _Adc_Wave;
 06EE 00910400          lds R16,__Adc_Wave
 06F2 10910500          lds R17,__Adc_Wave+1
 06F6           L93:
 06F6                   .dbline 0 ; func end
 06F6 0895              ret
 06F8           ;            ref -> R10,R11
                        .even
 06F8           _GetLiqDetResult::
 06F8 AA92              st -y,R10
 06FA BA92              st -y,R11
 06FC 5801              movw R10,R16
 06FE           ; }
 06FE           ; unsigned char GetLiqDetResult(signed int ref){
 06FE           ;       if(ref>0){
 06FE 2224              clr R2
 0700 3324              clr R3
 0702 2A14              cp R2,R10
 0704 3B04              cpc R3,R11
 0706 C4F4              brge L95
 0708           X27:
 0708           ; 		if(_Adc_Wave > ref){
 0708 20900400          lds R2,__Adc_Wave
 070C 30900500          lds R3,__Adc_Wave+1
 0710 A214              cp R10,R2
 0712 B304              cpc R11,R3
 0714 4CF5              brge L96
 0716           X28:
 0716           ; 			Uart0ReUnable;
 0716 8091C100          lds R24,193
 071A 8F7E              andi R24,239
 071C 8093C100          sts 193,R24
 0720           ;                       uart_Printf("// Liquid detect: %d\r\n", _Adc_Wave);
 0720 9101              movw R18,R2
 0722 00E0              ldi R16,<L99
 0724 10E0              ldi R17,>L99
 0726 0E940000          xcall _uart_Printf
 072A           ;                       Uart0ReEnable;
 072A 8091C100          lds R24,193
 072E 8061              ori R24,16
 0730 8093C100          sts 193,R24
 0734           ;                       return 1;
 0734 01E0              ldi R16,1
 0736 19C0              xjmp L94
 0738           L95:
 0738           ; 			}
 0738           ; 		}
 0738           ; 	else{
 0738           ; 		if(_Adc_Wave < ref){
 0738 20900400          lds R2,__Adc_Wave
 073C 30900500          lds R3,__Adc_Wave+1
 0740 2A14              cp R2,R10
 0742 3B04              cpc R3,R11
 0744 8CF4              brge L100
 0746           X29:
 0746           ; 			Uart0ReUnable;
 0746 8091C100          lds R24,193
 074A 8F7E              andi R24,239
 074C 8093C100          sts 193,R24
 0750           ;                       uart_Printf("// Liquid detect: %d\r\n", _Adc_Wave);
 0750 9101              movw R18,R2
 0752 00E0              ldi R16,<L99
 0754 10E0              ldi R17,>L99
 0756 0E940000          xcall _uart_Printf
 075A           ;                       Uart0ReEnable;
 075A 8091C100          lds R24,193
 075E 8061              ori R24,16
 0760 8093C100          sts 193,R24
 0764           ;                       return 1;
 0764 01E0              ldi R16,1
 0766 01C0              xjmp L94
 0768           L100:
 0768           ; 			}
 0768           ; 		}
 0768           L96:
 0768           ; 	return 0;
 0768 0027              clr R16
 076A           L94:
 076A                   .dbline 0 ; func end
 076A B990              ld R11,y+
 076C A990              ld R10,y+
 076E 0895              ret
                        .area vector(rom, abs)
                        .org 116
 0074 0C94B803          jmp _adc_isr
                        .area text(rom, con, rel)
                        .area data(ram, con, rel)
 0007           L103:
 0007                   .blkb 2
                        .area idata
 0007 0000              .word 0
                        .area data(ram, con, rel)
                        .area text(rom, con, rel)
                ;            tmp -> R10,R11
                        .even
 0770           _adc_isr::
 0770 0A92              st -y,R0
 0772 1A92              st -y,R1
 0774 2A92              st -y,R2
 0776 3A92              st -y,R3
 0778 4A92              st -y,R4
 077A 5A92              st -y,R5
 077C 6A92              st -y,R6
 077E 7A92              st -y,R7
 0780 8A92              st -y,R8
 0782 9A92              st -y,R9
 0784 0A93              st -y,R16
 0786 1A93              st -y,R17
 0788 2A93              st -y,R18
 078A 3A93              st -y,R19
 078C 8A93              st -y,R24
 078E 9A93              st -y,R25
 0790 AA93              st -y,R26
 0792 BA93              st -y,R27
 0794 EA93              st -y,R30
 0796 FA93              st -y,R31
 0798 0FB6              IN R0,63
 079A 0A92              st -y,R0
 079C AA92              st -y,R10
 079E BA92              st -y,R11
 07A0           ; }
 07A0           ; 
 07A0           ; #pragma interrupt_handler adc_isr:iv_ADC
 07A0           ; void adc_isr(void)
 07A0           ; {
 07A0           ;       unsigned int tmp;
 07A0           ;       static signed int adc_change = 0;       
 07A0           ;       tmp = ADCL;            //Read 8 low bits first (important)
 07A0 A0907800          lds R10,120
 07A4 BB24              clr R11
 07A6           ;       tmp  += ((unsigned int)ADCH << 8); //read 2 high bits and shift into top byte
 07A6 20907900          lds R2,121
 07AA 3324              clr R3
 07AC 322C              mov R3,R2
 07AE 2224              clr R2
 07B0 A20C              add R10,R2
 07B2 B31C              adc R11,R3
 07B4           ;       if(tmp > AdcResult[adc_change])
 07B4 80E0              ldi R24,<_AdcResult
 07B6 90E0              ldi R25,>_AdcResult
 07B8 E0910700          lds R30,L103
 07BC F0910800          lds R31,L103+1
 07C0 EE0F              lsl R30
 07C2 FF1F              rol R31
 07C4 E80F              add R30,R24
 07C6 F91F              adc R31,R25
 07C8 2080              ldd R2,z+0
 07CA 3180              ldd R3,z+1
 07CC 2A14              cp R2,R10
 07CE 3B04              cpc R3,R11
 07D0 78F4              brsh L104
 07D2           X30:
 07D2           ; 	{
 07D2           ; 		AdcResult[adc_change] ++;
 07D2 20900700          lds R2,L103
 07D6 30900800          lds R3,L103+1
 07DA 220C              lsl R2
 07DC 331C              rol R3
 07DE 280E              add R2,R24
 07E0 391E              adc R3,R25
 07E2 F101              movw R30,R2
 07E4 8081              ldd R24,z+0
 07E6 9181              ldd R25,z+1
 07E8 0196              adiw R24,1
 07EA 9183              std z+1,R25
 07EC 8083              std z+0,R24
 07EE           ;       }
 07EE 1DC0              xjmp L105
 07F0           L104:
 07F0           ; 	else if(tmp < AdcResult[adc_change])
 07F0 80E0              ldi R24,<_AdcResult
 07F2 90E0              ldi R25,>_AdcResult
 07F4 E0910700          lds R30,L103
 07F8 F0910800          lds R31,L103+1
 07FC EE0F              lsl R30
 07FE FF1F              rol R31
 0800 E80F              add R30,R24
 0802 F91F              adc R31,R25
 0804 2080              ldd R2,z+0
 0806 3180              ldd R3,z+1
 0808 A214              cp R10,R2
 080A B304              cpc R11,R3
 080C 70F4              brsh L106
 080E           X31:
 080E           ; 	{
 080E           ; 		AdcResult[adc_change] --;
 080E 20900700          lds R2,L103
 0812 30900800          lds R3,L103+1
 0816 220C              lsl R2
 0818 331C              rol R3
 081A 280E              add R2,R24
 081C 391E              adc R3,R25
 081E F101              movw R30,R2
 0820 8081              ldd R24,z+0
 0822 9181              ldd R25,z+1
 0824 0197              sbiw R24,1
 0826 9183              std z+1,R25
 0828 8083              std z+0,R24
 082A           ;       }
 082A           L106:
 082A           L105:
 082A           ; 	adc_change++;
 082A 80910700          lds R24,L103
 082E 90910800          lds R25,L103+1
 0832 0196              adiw R24,1
 0834 90930800          sts L103+1,R25
 0838 80930700          sts L103,R24
 083C           ;       if(adc_change > 2)
 083C 82E0              ldi R24,2
 083E 90E0              ldi R25,0
 0840 20900700          lds R2,L103
 0844 30900800          lds R3,L103+1
 0848 8215              cp R24,R2
 084A 9305              cpc R25,R3
 084C 34F4              brge L108
 084E           X32:
 084E           ; 		adc_change = 0;
 084E 2224              clr R2
 0850 3324              clr R3
 0852 30920800          sts L103+1,R3
 0856 20920700          sts L103,R2
 085A           L108:
 085A           ; 	SetNextADChannel(adc_change);
 085A 00910700          lds R16,L103
 085E 10910800          lds R17,L103+1
 0862 D4DE              xcall _SetNextADChannel
 0864           L102:
 0864                   .dbline 0 ; func end
 0864 B990              ld R11,y+
 0866 A990              ld R10,y+
 0868 0990              ld R0,y+
 086A 0FBE              OUT 63,R0
 086C F991              ld R31,y+
 086E E991              ld R30,y+
 0870 B991              ld R27,y+
 0872 A991              ld R26,y+
 0874 9991              ld R25,y+
 0876 8991              ld R24,y+
 0878 3991              ld R19,y+
 087A 2991              ld R18,y+
 087C 1991              ld R17,y+
 087E 0991              ld R16,y+
 0880 9990              ld R9,y+
 0882 8990              ld R8,y+
 0884 7990              ld R7,y+
 0886 6990              ld R6,y+
 0888 5990              ld R5,y+
 088A 4990              ld R4,y+
 088C 3990              ld R3,y+
 088E 2990              ld R2,y+
 0890 1990              ld R1,y+
 0892 0990              ld R0,y+
 0894 1895              reti
                        .even
 0896           _init_devices::
 0896           ; }
 0896           ; 
 0896           ; //call this routine to initialize all peripherals
 0896           ; void init_devices(void){
 0896           ; 	//stop errant interrupts until set up
 0896           ; 	CLI(); //disable all interrupts
 0896 F894              cli
 0898           ; //    XMCRA = 0x98; //external memory
 0898           ; //    XMCRB = 0x00; //external memory
 0898           ;       uartDataInit();
 0898 2AD0              xcall _uartDataInit
 089A           ;       port_init();
 089A B2DB              xcall _port_init
 089C           ;       timer0_init();
 089C DBDB              xcall _timer0_init
 089E           ;       timer1_init();
 089E 1BDC              xcall _timer1_init
 08A0           ;       timer4_init();
 08A0 FCDC              xcall _timer4_init
 08A2           ;       timer5_init();
 08A2 25DD              xcall _timer5_init
 08A4           ;       uart0_init();
 08A4 4EDD              xcall _uart0_init
 08A6           ; //    uart1_init();
 08A6           ;       uart2_init();
 08A6 C2DD              xcall _uart2_init
 08A8           ; //    uart3_init();
 08A8           ;       adc_init();
 08A8 A3DE              xcall _adc_init
 08AA           ;       TWI_Init();
 08AA 0E940000          xcall _TWI_Init
 08AE           ; 
 08AE           ;       MCUCR  = 0x00;
 08AE 2224              clr R2
 08B0 25BE              out 0x35,R2
 08B2           ;       EICRA  = 0x00; //pin change int edge 0:3
 08B2 20926900          sts 105,R2
 08B6           ;       EICRB  = 0x00; //pin change int edge 4:7
 08B6 20926A00          sts 106,R2
 08BA           ;       // PCICR  = 0x04; //pin change int enable
 08BA           ;       PCMSK0 = 0x00; //pin change mask
 08BA 20926B00          sts 107,R2
 08BE           ;       PCMSK1 = 0x00; //pin change mask
 08BE 20926C00          sts 108,R2
 08C2           ;       PCMSK2 = 0x00; //pin change mask
 08C2 20926D00          sts 109,R2
 08C6           ;       EIMSK  = 0x00;
 08C6 2DBA              out 0x1d,R2
 08C8           ;       TIMSK0 = 0x01; //timer0 interrupt sources
 08C8 81E0              ldi R24,1
 08CA 80936E00          sts 110,R24
 08CE           ;       TIMSK1 = 0x01; //timer1 interrupt sources
 08CE 80936F00          sts 111,R24
 08D2           ;       TIMSK2 = 0x00; //timer2 interrupt sources
 08D2 20927000          sts 112,R2
 08D6           ;       TIMSK3 = 0x00; //timer3 interrupt sources
 08D6 20927100          sts 113,R2
 08DA           ;       TIMSK4 = 0x00; //timer4 interrupt sources
 08DA 20927200          sts 114,R2
 08DE           ;       TIMSK5 = 0x00; //timer5 interrupt sources
 08DE 20927300          sts 115,R2
 08E2           ;       PRR0   = 0x00;
 08E2 20926400          sts 100,R2
 08E6           ;       PRR1   = 0x00;
 08E6 20926500          sts 101,R2
 08EA           ;  
 08EA           ;       SEI(); //re-enable interrupts
 08EA 7894              sei
 08EC           L110:
 08EC                   .dbline 0 ; func end
 08EC 0895              ret
 08EE           ;             p1 -> <dead>
 08EE           ;             p0 -> R18,R19
 08EE           ;              i -> R16,R17
                        .even
 08EE           _uartDataInit::
 08EE           ; 	//all peripherals are now initialized
 08EE           ; }
 08EE           ; 
 08EE           ; ///////////////// Uart1 buffer /////////////////////
 08EE           ; void uartDataInit(void){
 08EE           ; 	unsigned int i;
 08EE           ; 	unsigned char *p0, *p1;
 08EE           ; 
 08EE           ; 	p0 = (unsigned char *)(&uart0RxdBuf);
 08EE 20E0              ldi R18,<_uart0RxdBuf
 08F0 30E0              ldi R19,>_uart0RxdBuf
 08F2           ;       for(i=0; i<sizeof(UARTBUF_RXD); i++){
 08F2 0027              clr R16
 08F4 1127              clr R17
 08F6 06C0              xjmp L115
 08F8           L112:
 08F8           ; 		*(p0++) = 0;
 08F8 2224              clr R2
 08FA F901              movw R30,R18
 08FC 2192              st Z+,R2
 08FE 9F01              movw R18,R30
 0900           ;               }
 0900           L113:
 0900 0F5F              subi R16,255  ; offset = 1
 0902 1F4F              sbci R17,255
 0904           L115:
 0904 0330              cpi R16,3
 0906 E0E0              ldi R30,0
 0908 1E07              cpc R17,R30
 090A B0F3              brlo L112
 090C           X33:
 090C           ; 	p0 = (unsigned char *)(&uart0TxdBuf);
 090C 20E0              ldi R18,<_uart0TxdBuf
 090E 30E0              ldi R19,>_uart0TxdBuf
 0910           ;       for(i=0; i<sizeof(UARTBUF_TXD); i++){
 0910 0027              clr R16
 0912 1127              clr R17
 0914 06C0              xjmp L119
 0916           L116:
 0916           ; 		*(p0++) = 0;
 0916 2224              clr R2
 0918 F901              movw R30,R18
 091A 2192              st Z+,R2
 091C 9F01              movw R18,R30
 091E           ;               }
 091E           L117:
 091E 0F5F              subi R16,255  ; offset = 1
 0920 1F4F              sbci R17,255
 0922           L119:
 0922 0A3F              cpi R16,250
 0924 E1E0              ldi R30,1
 0926 1E07              cpc R17,R30
 0928 B0F3              brlo L116
 092A           X34:
 092A           ; 	uart0TxdBuf.remanentLen = UARTBUF_TXD_LEN-1;
 092A 83EF              ldi R24,499
 092C 91E0              ldi R25,1
 092E 90939102          sts _uart0TxdBuf+504+1,R25
 0932 80939002          sts _uart0TxdBuf+504,R24
 0936           L111:
 0936                   .dbline 0 ; func end
 0936 0895              ret
                        .area data(ram, con, rel)
 0009           _PacketState:
 0009                   .blkb 1
                        .area idata
 0009 00                .byte 0
                        .area data(ram, con, rel)
                        .area bss(ram, con, rel)
 0002           L122:
 0002                   .blkb 1
 0003           L123:
 0003                   .blkb 1
 0004           L124:
 0004                   .blkb 1
                        .area text(rom, con, rel)
                ;              i -> <dead>
                ;            dat -> R20
                        .even
 0938           _uart0DataReceive::
 0938 0E940000          xcall push_xgsetF000
 093C 402F              mov R20,R16
 093E           ; }
 093E           ; 
 093E           ; // 0x15(NAK), 0x06(ACK),      0x02(STX),      0x03(ETX)
 093E           ; static unsigned char PacketState=0;
 093E           ; //static unsigned char UartReceiveBuf[60];    // 从主机接收串口接收缓存
 093E           ; unsigned char UartReceiveBuf[60];
 093E           ; static unsigned char PRecBuf;
 093E           ; static unsigned char WaitAnswer;
 093E           ; void CommandExplain(unsigned char c);
 093E           ; 
 093E           ; void uart0DataReceive(unsigned char dat)
 093E           ; {
 093E           ;       unsigned char i;
 093E           ;       static unsigned char checkSum,  checkLB, checkHB;       // 校验和
 093E           ;       switch(PacketState)
 093E 60910900          lds R22,_PacketState
 0942 7727              clr R23
 0944 6030              cpi R22,0
 0946 6707              cpc R22,R23
 0948 21F1              breq L128
 094A           X35:
 094A 6130              cpi R22,1
 094C E0E0              ldi R30,0
 094E 7E07              cpc R23,R30
 0950 09F4              brne X51
 0952 4FC0              xjmp L137
 0954           X51:
 0954           X36:
 0954 6230              cpi R22,2
 0956 E0E0              ldi R30,0
 0958 7E07              cpc R23,R30
 095A 09F4              brne X52
 095C 61C0              xjmp L140
 095E           X52:
 095E           X37:
 095E 6A30              cpi R22,10
 0960 E0E0              ldi R30,0
 0962 7E07              cpc R23,R30
 0964 09F4              brne X53
 0966 96C0              xjmp L145
 0968           X53:
 0968           X38:
 0968 6B30              cpi R22,11
 096A E0E0              ldi R30,0
 096C 7E07              cpc R23,R30
 096E 09F4              brne X54
 0970 A6C0              xjmp L146
 0972           X54:
 0972           X39:
 0972 6C30              cpi R22,12
 0974 E0E0              ldi R30,0
 0976 7E07              cpc R23,R30
 0978 09F4              brne X55
 097A D8C0              xjmp L150
 097C           X55:
 097C           X40:
 097C 6D30              cpi R22,13
 097E E0E0              ldi R30,0
 0980 7E07              cpc R23,R30
 0982 09F4              brne X56
 0984 D3C0              xjmp L150
 0986           X56:
 0986           X41:
 0986 6E30              cpi R22,14
 0988 E0E0              ldi R30,0
 098A 7E07              cpc R23,R30
 098C 09F4              brne X57
 098E CEC0              xjmp L150
 0990           X57:
 0990           X42:
 0990 CFC0              xjmp L126
 0992           L128:
 0992           ; 	{
 0992           ; 		case 0:
 0992           ; 			if(WaitAnswer)
 0992 20900700          lds R2,_WaitAnswer
 0996 2220              tst R2
 0998 79F0              breq L129
 099A           X43:
 099A           ; 			{
 099A           ; 				if(dat == ACK)
 099A 4630              cpi R20,6
 099C 39F4              brne L131
 099E           X44:
 099E           ; 				{
 099E           ; 					WaitAnswer = 0;
 099E 2224              clr R2
 09A0 20920700          sts _WaitAnswer,R2
 09A4           ;                                       PacketState = 13;
 09A4 8DE0              ldi R24,13
 09A6 80930900          sts _PacketState,R24
 09AA           ;                               }
 09AA C2C0              xjmp L126
 09AC           L131:
 09AC           ; 				else
 09AC           ; 				{	
 09AC           ; 					uart0SendChar(0x0F);	// 等待ACK过程中,接收到非ACK命令
 09AC 0FE0              ldi R16,15
 09AE 11D2              xcall _uart0SendChar
 09B0           ;                                       WaitAnswer = 0;
 09B0 2224              clr R2
 09B2 20920700          sts _WaitAnswer,R2
 09B6           ;                               }
 09B6           ;                               break;
 09B6 BCC0              xjmp L126
 09B8           L129:
 09B8           ; 			}
 09B8           ; 			else
 09B8           ; 			{
 09B8           ; 				if(dat == STX)
 09B8 4230              cpi R20,2
 09BA A1F4              brne L133
 09BC           X45:
 09BC           ; 				{
 09BC           ; 					PacketState = 2;
 09BC 82E0              ldi R24,2
 09BE 80930900          sts _PacketState,R24
 09C2           ;                                       checkSum = 0;
 09C2 2224              clr R2
 09C4 20920200          sts L122,R2
 09C8           ;                                       PRecBuf = 0;
 09C8 20920800          sts _PRecBuf,R2
 09CC           ;                                       UartReceiveBuf[PRecBuf] = STX;
 09CC 80E0              ldi R24,<_UartReceiveBuf
 09CE 90E0              ldi R25,>_UartReceiveBuf
 09D0 E22D              mov R30,R2
 09D2 FF27              clr R31
 09D4 E80F              add R30,R24
 09D6 F91F              adc R31,R25
 09D8 82E0              ldi R24,2
 09DA 8083              std z+0,R24
 09DC           ;                                       CommandExplain(0x0d);   // 结束当前命令 
 09DC 0DE0              ldi R16,13
 09DE 0E940000          xcall _CommandExplain
 09E2           ;                                       break;
 09E2 A6C0              xjmp L126
 09E4           L133:
 09E4           ; 				}
 09E4           ; 				if(dat < 128)
 09E4 4038              cpi R20,128
 09E6 08F0              brlo X58
 09E8 A3C0              xjmp L126
 09EA           X58:
 09EA           X46:
 09EA           ; 					CommandExplain(dat);	// 命令解析
 09EA 042F              mov R16,R20
 09EC 0E940000          xcall _CommandExplain
 09F0           ;                       }
 09F0           ;                       break;
 09F0 9FC0              xjmp L126
 09F2           L137:
 09F2           ; 		case 1:
 09F2           ; 			if(dat == STX)
 09F2 4230              cpi R20,2
 09F4 09F0              breq X59
 09F6 9CC0              xjmp L126
 09F8           X59:
 09F8           X47:
 09F8           ; 			{
 09F8           ; 				PacketState = 2;
 09F8 82E0              ldi R24,2
 09FA 80930900          sts _PacketState,R24
 09FE           ;                               checkSum = 0;
 09FE 2224              clr R2
 0A00 20920200          sts L122,R2
 0A04           ;                               PRecBuf = 0;
 0A04 20920800          sts _PRecBuf,R2
 0A08           ;                               UartReceiveBuf[PRecBuf] = STX;
 0A08 80E0              ldi R24,<_UartReceiveBuf
 0A0A 90E0              ldi R25,>_UartReceiveBuf
 0A0C E22D              mov R30,R2
 0A0E FF27              clr R31
 0A10 E80F              add R30,R24
 0A12 F91F              adc R31,R25
 0A14 82E0              ldi R24,2
 0A16 8083              std z+0,R24
 0A18           ;                               CommandExplain(0x0d);   // 结束当前命令 
 0A18 0DE0              ldi R16,13
 0A1A 0E940000          xcall _CommandExplain
 0A1E           ;                       }
 0A1E           ;                       break;
 0A1E 88C0              xjmp L126
 0A20           L140:
 0A20           ; 		case 2:			// 本机接收数据包状态
 0A20           ; 			if(dat == ETX)
 0A20 4330              cpi R20,3
 0A22 91F4              brne L141
 0A24           X48:
 0A24           ; 			{
 0A24           ; 				PRecBuf ++;
 0A24 80910800          lds R24,_PRecBuf
 0A28 8F5F              subi R24,255    ; addi 1
 0A2A 80930800          sts _PRecBuf,R24
 0A2E           ;                               UartReceiveBuf[PRecBuf] = ETX;
 0A2E 80E0              ldi R24,<_UartReceiveBuf
 0A30 90E0              ldi R25,>_UartReceiveBuf
 0A32 E0910800          lds R30,_PRecBuf
 0A36 FF27              clr R31
 0A38 E80F              add R30,R24
 0A3A F91F              adc R31,R25
 0A3C 83E0              ldi R24,3
 0A3E 8083              std z+0,R24
 0A40           ;                               PacketState = 10;
 0A40 8AE0              ldi R24,10
 0A42 80930900          sts _PacketState,R24
 0A46           ;                       }
 0A46 74C0              xjmp L126
 0A48           L141:
 0A48           ; 			else if(dat == STX)		// 重新开始接收
 0A48 4230              cpi R20,2
 0A4A 89F4              brne L143
 0A4C           X49:
 0A4C           ; 			{
 0A4C           ; 				checkSum = 0;
 0A4C 2224              clr R2
 0A4E 20920200          sts L122,R2
 0A52           ;                               PRecBuf = 0;
 0A52 20920800          sts _PRecBuf,R2
 0A56           ;                               UartReceiveBuf[PRecBuf] = STX;
 0A56 80E0              ldi R24,<_UartReceiveBuf
 0A58 90E0              ldi R25,>_UartReceiveBuf
 0A5A E22D              mov R30,R2
 0A5C FF27              clr R31
 0A5E E80F              add R30,R24
 0A60 F91F              adc R31,R25
 0A62 82E0              ldi R24,2
 0A64 8083              std z+0,R24
 0A66           ;                               CommandExplain(0x0d);   // 结束当前命令 
 0A66 0DE0              ldi R16,13
 0A68 0E940000          xcall _CommandExplain
 0A6C           ;                               break;
 0A6C 61C0              xjmp L126
 0A6E           L143:
 0A6E           ; 			}
 0A6E           ; 			else 				// 接收数据
 0A6E           ; 			{
 0A6E           ; 				PRecBuf ++;
 0A6E 80910800          lds R24,_PRecBuf
 0A72 8F5F              subi R24,255    ; addi 1
 0A74 80930800          sts _PRecBuf,R24
 0A78           ;                               UartReceiveBuf[PRecBuf] = dat;
 0A78 80E0              ldi R24,<_UartReceiveBuf
 0A7A 90E0              ldi R25,>_UartReceiveBuf
 0A7C E0910800          lds R30,_PRecBuf
 0A80 FF27              clr R31
 0A82 E80F              add R30,R24
 0A84 F91F              adc R31,R25
 0A86 4083              std z+0,R20
 0A88           ;                               checkSum += dat;
 0A88 20900200          lds R2,L122
 0A8C 240E              add R2,R20
 0A8E 20920200          sts L122,R2
 0A92           ;                       }
 0A92           ;                       break;
 0A92 4EC0              xjmp L126
 0A94           L145:
 0A94           ; 		case 10:	// 接收第一字节校验
 0A94           ; 			PRecBuf ++;
 0A94 80910800          lds R24,_PRecBuf
 0A98 8F5F              subi R24,255    ; addi 1
 0A9A 80930800          sts _PRecBuf,R24
 0A9E           ;                       UartReceiveBuf[PRecBuf] = dat;
 0A9E 80E0              ldi R24,<_UartReceiveBuf
 0AA0 90E0              ldi R25,>_UartReceiveBuf
 0AA2 E0910800          lds R30,_PRecBuf
 0AA6 FF27              clr R31
 0AA8 E80F              add R30,R24
 0AAA F91F              adc R31,R25
 0AAC 4083              std z+0,R20
 0AAE           ;                       checkLB = dat - 'A';
 0AAE 842F              mov R24,R20
 0AB0 8154              subi R24,65
 0AB2 80930300          sts L123,R24
 0AB6           ;                       PacketState = 11;
 0AB6 8BE0              ldi R24,11
 0AB8 80930900          sts _PacketState,R24
 0ABC           ;                       break;
 0ABC 39C0              xjmp L126
 0ABE           L146:
 0ABE           ; 		case 11:	// 接收第二字节校验
 0ABE           ; 			checkHB = dat - 'A';
 0ABE 842F              mov R24,R20
 0AC0 8154              subi R24,65
 0AC2 80930400          sts L124,R24
 0AC6           ;                       checkHB <<= 4;
 0AC6 8F70              andi R24,#0x0F
 0AC8 8295              swap R24
 0ACA 80930400          sts L124,R24
 0ACE           ;                       PRecBuf ++;
 0ACE 80910800          lds R24,_PRecBuf
 0AD2 8F5F              subi R24,255    ; addi 1
 0AD4 80930800          sts _PRecBuf,R24
 0AD8           ;                       UartReceiveBuf[PRecBuf] = dat;
 0AD8 80E0              ldi R24,<_UartReceiveBuf
 0ADA 90E0              ldi R25,>_UartReceiveBuf
 0ADC E0910800          lds R30,_PRecBuf
 0AE0 FF27              clr R31
 0AE2 E80F              add R30,R24
 0AE4 F91F              adc R31,R25
 0AE6 4083              std z+0,R20
 0AE8           ;                       UartReceiveBuf[PRecBuf + 1] = 0;
 0AE8 80E0              ldi R24,<_UartReceiveBuf+1
 0AEA 90E0              ldi R25,>_UartReceiveBuf+1
 0AEC E0910800          lds R30,_PRecBuf
 0AF0 FF27              clr R31
 0AF2 E80F              add R30,R24
 0AF4 F91F              adc R31,R25
 0AF6 2224              clr R2
 0AF8 2082              std z+0,R2
 0AFA           ;                       if(checkSum == checkLB + checkHB)
 0AFA 20900400          lds R2,L124
 0AFE 30900300          lds R3,L123
 0B02 320C              add R3,R2
 0B04 20900200          lds R2,L122
 0B08 2314              cp R2,R3
 0B0A 49F4              brne L148
 0B0C           X50:
 0B0C           ; 			{
 0B0C           ; 				uart0SendChar(ACK);
 0B0C 06E0              ldi R16,6
 0B0E 61D1              xcall _uart0SendChar
 0B10           ;                               PacketState = 12;
 0B10 8CE0              ldi R24,12
 0B12 80930900          sts _PacketState,R24
 0B16           ;                               PRecBuf = 0;
 0B16 2224              clr R2
 0B18 20920800          sts _PRecBuf,R2
 0B1C           ;                       }
 0B1C 09C0              xjmp L126
 0B1E           L148:
 0B1E           ; 			else
 0B1E           ; 			{
 0B1E           ; 				PacketState = 14; //PacketState = 1;
 0B1E 8EE0              ldi R24,14
 0B20 80930900          sts _PacketState,R24
 0B24           ;                               PRecBuf = 0;
 0B24 2224              clr R2
 0B26 20920800          sts _PRecBuf,R2
 0B2A           ;                       }
 0B2A           ;                       break;
 0B2A 02C0              xjmp L126
 0B2C           L150:
 0B2C           ; 		case 12:	// 处理接收到的数据,放到数据发送定时处理函数中处理
 0B2C           ; 		case 13:
 0B2C           ; 		case 14:
 0B2C           ; 			uart0SendChar(0X0E);
 0B2C 0EE0              ldi R16,14
 0B2E 51D1              xcall _uart0SendChar
 0B30           ;                       break;
 0B30           ;               default:
 0B30           ;                       break;
 0B30           L126:
 0B30           L121:
 0B30                   .dbline 0 ; func end
 0B30 0C940000          xjmp pop_xgsetF000
                        .area bss(ram, con, rel)
 0005           L152:
 0005                   .blkb 2
                        .area text(rom, con, rel)
                ;              c -> R20
                ;           pEnd -> R10,R11
                ;           pTop -> R22,R23
                        .even
 0B34           _uart0Transfer::
 0B34 0E940000          xcall push_xgsetF00C
 0B38           ;       }
 0B38           ; }
 0B38           ; 
 0B38           ; void uart0Transfer(void)
 0B38           ; {
 0B38           ; // 串口0发送1字节数据
 0B38           ;       //static unsigned int  pTextStart;      // 数据包起始指针
 0B38           ;       //static unsigned int  pTransfer;       // 数据发送指针
 0B38           ;       //static unsigned char checkSum,        checkLB, checkHB;       // 校验和
 0B38           ;       //static unsigned char reTransferCnt;   // 重发计数
 0B38           ;       unsigned int pTop, pEnd;
 0B38           ;       unsigned char c;
 0B38           ;       static unsigned int timeOut;
 0B38           ;       if(uartBufProtect )             // 发送缓存保护
 0B38 20900000          lds R2,_uartBufProtect
 0B3C 2220              tst R2
 0B3E 09F0              breq L153
 0B40           X60:
 0B40           ; 		return;
 0B40 0EC1              xjmp L151
 0B42           L153:
 0B42           ; 	switch(PacketState){
 0B42 40910900          lds R20,_PacketState
 0B46 5527              clr R21
 0B48 4030              cpi R20,0
 0B4A 4507              cpc R20,R21
 0B4C D1F0              breq L158
 0B4E           X61:
 0B4E 4130              cpi R20,1
 0B50 E0E0              ldi R30,0
 0B52 5E07              cpc R21,R30
 0B54 09F4              brne X79
 0B56 6DC0              xjmp L173
 0B58           X79:
 0B58           X62:
 0B58 4030              cpi R20,0
 0B5A E0E0              ldi R30,0
 0B5C 5E07              cpc R21,R30
 0B5E 0CF4              brge X80
 0B60 FEC0              xjmp L156
 0B62           X80:
 0B62           X63:
 0B62           L194:
 0B62 4C30              cpi R20,12
 0B64 E0E0              ldi R30,0
 0B66 5E07              cpc R21,R30
 0B68 09F4              brne X81
 0B6A 8EC0              xjmp L185
 0B6C           X81:
 0B6C           X64:
 0B6C 4D30              cpi R20,13
 0B6E E0E0              ldi R30,0
 0B70 5E07              cpc R21,R30
 0B72 09F4              brne X82
 0B74 ADC0              xjmp L188
 0B76           X82:
 0B76           X65:
 0B76 4E30              cpi R20,14
 0B78 E0E0              ldi R30,0
 0B7A 5E07              cpc R21,R30
 0B7C 09F4              brne X83
 0B7E CDC0              xjmp L191
 0B80           X83:
 0B80           X66:
 0B80 EEC0              xjmp L156
 0B82           L158:
 0B82           ; 		case 0:		// 普通模式
 0B82           ; 			pTop = uart0TxdBuf.pHead;
 0B82 60918E02          lds R22,_uart0TxdBuf+502
 0B86 70918F02          lds R23,_uart0TxdBuf+502+1
 0B8A           ;                       pEnd = uart0TxdBuf.pEnd;
 0B8A A0908C02          lds R10,_uart0TxdBuf+500
 0B8E B0908D02          lds R11,_uart0TxdBuf+500+1
 0B92           ;                       if(pTop != pEnd)
 0B92 6A15              cp R22,R10
 0B94 7B05              cpc R23,R11
 0B96 C1F0              breq L161
 0B98           X67:
 0B98           ; 			{
 0B98           ; 				if(UCSR0A & 0x20 )
 0B98 2090C000          lds R2,192
 0B9C 25FE              sbrs R2,5
 0B9E 14C0              rjmp L163
 0BA0           X68:
 0BA0           ; 				{
 0BA0           ; 					c = uart0TxdBuf.buffer[pTop];
 0BA0 80E0              ldi R24,<_uart0TxdBuf
 0BA2 90E0              ldi R25,>_uart0TxdBuf
 0BA4 FB01              movw R30,R22
 0BA6 E80F              add R30,R24
 0BA8 F91F              adc R31,R25
 0BAA 4081              ldd R20,z+0
 0BAC           ;                                       //if((c != STX) && (c!= ETX))           
 0BAC           ;                                               UDR0 = c;
 0BAC 4093C600          sts 198,R20
 0BB0           ;                                       pTop ++;
 0BB0 6F5F              subi R22,255  ; offset = 1
 0BB2 7F4F              sbci R23,255
 0BB4           ;                                       if(pTop == UARTBUF_TXD_LEN)
 0BB4 643F              cpi R22,244
 0BB6 E1E0              ldi R30,1
 0BB8 7E07              cpc R23,R30
 0BBA 11F4              brne L165
 0BBC           X69:
 0BBC           ; 						pTop = 0;
 0BBC 6627              clr R22
 0BBE 7727              clr R23
 0BC0           L165:
 0BC0           ; 					uart0TxdBuf.pHead = pTop;
 0BC0 70938F02          sts _uart0TxdBuf+502+1,R23
 0BC4 60938E02          sts _uart0TxdBuf+502,R22
 0BC8           ;                               }
 0BC8           L163:
 0BC8           ; 			}
 0BC8           L161:
 0BC8           ; 			
 0BC8           ; 			// ACK 超时等待
 0BC8           ; 			if(WaitAnswer == 1)
 0BC8 80910700          lds R24,_WaitAnswer
 0BCC 8130              cpi R24,1
 0BCE 51F5              brne L168
 0BD0           X70:
 0BD0           ; 			{
 0BD0           ; 				timeOut++;
 0BD0 80910500          lds R24,L152
 0BD4 90910600          lds R25,L152+1
 0BD8 0196              adiw R24,1
 0BDA 90930600          sts L152+1,R25
 0BDE 80930500          sts L152,R24
 0BE2           ;                               //if(timeOut > 800)     // 0.5 * 800  -> 400ms
 0BE2           ;                               //if(timeOut > 2000)    
 0BE2           ;                               if(timeOut > 6000)      
 0BE2 80E7              ldi R24,6000
 0BE4 97E1              ldi R25,23
 0BE6 20900500          lds R2,L152
 0BEA 30900600          lds R3,L152+1
 0BEE 8215              cp R24,R2
 0BF0 9305              cpc R25,R3
 0BF2 08F0              brlo X84
 0BF4 B4C0              xjmp L156
 0BF6           X84:
 0BF6           X71:
 0BF6           ; 				{
 0BF6           ; 					timeOut = 0;
 0BF6 2224              clr R2
 0BF8 3324              clr R3
 0BFA 30920600          sts L152+1,R3
 0BFE 20920500          sts L152,R2
 0C02           ;                                       WaitAnswer = 0;
 0C02 20920700          sts _WaitAnswer,R2
 0C06           ;                                       Uart0ReUnable;
 0C06 8091C100          lds R24,193
 0C0A 8F7E              andi R24,239
 0C0C 8093C100          sts 193,R24
 0C10           ;                                       uart_Printf("*3344 WaitAckOutOfTime\r\n");      
 0C10 00E0              ldi R16,<L172
 0C12 10E0              ldi R17,>L172
 0C14 0E940000          xcall _uart_Printf
 0C18           ;                                       Uart0ReEnable;
 0C18 8091C100          lds R24,193
 0C1C 8061              ori R24,16
 0C1E 8093C100          sts 193,R24
 0C22           ;                               }
 0C22           ;                       }
 0C22 9DC0              xjmp L156
 0C24           L168:
 0C24           ; 			else
 0C24           ; 			{
 0C24           ; 				timeOut = 0;
 0C24 2224              clr R2
 0C26 3324              clr R3
 0C28 30920600          sts L152+1,R3
 0C2C 20920500          sts L152,R2
 0C30           ;                       }
 0C30           ;                       break;  
 0C30 96C0              xjmp L156
 0C32           L173:
 0C32           ; 		case 1:		// 空闲,数据包未开始
 0C32           ; 			pTop = uart0TxdBuf.pHead;
 0C32 60918E02          lds R22,_uart0TxdBuf+502
 0C36 70918F02          lds R23,_uart0TxdBuf+502+1
 0C3A           ;                       pEnd = uart0TxdBuf.pEnd;
 0C3A A0908C02          lds R10,_uart0TxdBuf+500
 0C3E B0908D02          lds R11,_uart0TxdBuf+500+1
 0C42           ;                       if(pTop != pEnd)
 0C42 6A15              cp R22,R10
 0C44 7B05              cpc R23,R11
 0C46 09F4              brne X85
 0C48 8AC0              xjmp L156
 0C4A           X85:
 0C4A           X72:
 0C4A           ; 			{
 0C4A           ; 				if(UCSR0A & 0x20)
 0C4A 2090C000          lds R2,192
 0C4E 25FE              sbrs R2,5
 0C50 86C0              rjmp L156
 0C52           X73:
 0C52           ; 				{
 0C52           ; 					c = uart0TxdBuf.buffer[pTop];
 0C52 80E0              ldi R24,<_uart0TxdBuf
 0C54 90E0              ldi R25,>_uart0TxdBuf
 0C56 FB01              movw R30,R22
 0C58 E80F              add R30,R24
 0C5A F91F              adc R31,R25
 0C5C 4081              ldd R20,z+0
 0C5E           ;                                       UDR0 = c;
 0C5E 4093C600          sts 198,R20
 0C62           ;                                       pTop ++;
 0C62 6F5F              subi R22,255  ; offset = 1
 0C64 7F4F              sbci R23,255
 0C66           ;                                       if(pTop == UARTBUF_TXD_LEN)
 0C66 643F              cpi R22,244
 0C68 E1E0              ldi R30,1
 0C6A 7E07              cpc R23,R30
 0C6C 11F4              brne L180
 0C6E           X74:
 0C6E           ; 						pTop = 0;
 0C6E 6627              clr R22
 0C70 7727              clr R23
 0C72           L180:
 0C72           ; 					uart0TxdBuf.pHead = pTop;
 0C72 70938F02          sts _uart0TxdBuf+502+1,R23
 0C76 60938E02          sts _uart0TxdBuf+502,R22
 0C7A           ;                                       if(c == 0x0d)   // 数据包结束
 0C7A 4D30              cpi R20,13
 0C7C 09F0              breq X86
 0C7E 6FC0              xjmp L156
 0C80           X86:
 0C80           X75:
 0C80           ; 					{
 0C80           ; 						PacketState = 0;
 0C80 2224              clr R2
 0C82 20920900          sts _PacketState,R2
 0C86           ;                                               break;
 0C86 6BC0              xjmp L156
 0C88           L185:
 0C88           ; 					}
 0C88           ; 				}
 0C88           ; 			}
 0C88           ; 			break;
 0C88           ; 		case 12:	// 返回收到的数据
 0C88           ; 			if(UartReceiveBuf[PRecBuf] != 0)
 0C88 80E0              ldi R24,<_UartReceiveBuf
 0C8A 90E0              ldi R25,>_UartReceiveBuf
 0C8C E0910800          lds R30,_PRecBuf
 0C90 FF27              clr R31
 0C92 E80F              add R30,R24
 0C94 F91F              adc R31,R25
 0C96 2080              ldd R2,z+0
 0C98 2220              tst R2
 0C9A 69F0              breq L186
 0C9C           X76:
 0C9C           ; 			{
 0C9C           ; 				uart0SendChar(UartReceiveBuf[PRecBuf]);
 0C9C E0910800          lds R30,_PRecBuf
 0CA0 FF27              clr R31
 0CA2 E80F              add R30,R24
 0CA4 F91F              adc R31,R25
 0CA6 0081              ldd R16,z+0
 0CA8 94D0              xcall _uart0SendChar
 0CAA           ;                               PRecBuf++;
 0CAA 80910800          lds R24,_PRecBuf
 0CAE 8F5F              subi R24,255    ; addi 1
 0CB0 80930800          sts _PRecBuf,R24
 0CB4           ;                       }
 0CB4 54C0              xjmp L156
 0CB6           L186:
 0CB6           ; 			else
 0CB6           ; 			{
 0CB6           ; 				uart0SendChar('\r');
 0CB6 0DE0              ldi R16,13
 0CB8 8CD0              xcall _uart0SendChar
 0CBA           ;                               uart0SendChar('\n');
 0CBA 0AE0              ldi R16,10
 0CBC 8AD0              xcall _uart0SendChar
 0CBE           ;                               PRecBuf = 0;
 0CBE 2224              clr R2
 0CC0 20920800          sts _PRecBuf,R2
 0CC4           ;                               WaitAnswer = 1;
 0CC4 81E0              ldi R24,1
 0CC6 80930700          sts _WaitAnswer,R24
 0CCA           ;                               PacketState = 0;
 0CCA 20920900          sts _PacketState,R2
 0CCE           ;                               
 0CCE           ;                       }
 0CCE           ;                       break;
 0CCE 47C0              xjmp L156
 0CD0           L188:
 0CD0           ; 		case 13:	// 处理收到的数据
 0CD0           ; 			if(UartReceiveBuf[PRecBuf] != 0)
 0CD0 80E0              ldi R24,<_UartReceiveBuf
 0CD2 90E0              ldi R25,>_UartReceiveBuf
 0CD4 E0910800          lds R30,_PRecBuf
 0CD8 FF27              clr R31
 0CDA E80F              add R30,R24
 0CDC F91F              adc R31,R25
 0CDE 2080              ldd R2,z+0
 0CE0 2220              tst R2
 0CE2 99F0              breq L189
 0CE4           X77:
 0CE4           ; 			{
 0CE4           ; 				checkFlag = 1;
 0CE4 81E0              ldi R24,1
 0CE6 80930100          sts _checkFlag,R24
 0CEA           ;                               CommandExplain(UartReceiveBuf[PRecBuf]);        // 命令解析
 0CEA 80E0              ldi R24,<_UartReceiveBuf
 0CEC 90E0              ldi R25,>_UartReceiveBuf
 0CEE E0910800          lds R30,_PRecBuf
 0CF2 FF27              clr R31
 0CF4 E80F              add R30,R24
 0CF6 F91F              adc R31,R25
 0CF8 0081              ldd R16,z+0
 0CFA 0E940000          xcall _CommandExplain
 0CFE           ;                               PRecBuf ++;
 0CFE 80910800          lds R24,_PRecBuf
 0D02 8F5F              subi R24,255    ; addi 1
 0D04 80930800          sts _PRecBuf,R24
 0D08           ;                       }
 0D08 2AC0              xjmp L156
 0D0A           L189:
 0D0A           ; 			else
 0D0A           ; 			{
 0D0A           ; 				checkFlag = 0;
 0D0A 2224              clr R2
 0D0C 20920100          sts _checkFlag,R2
 0D10           ;                               PRecBuf = 0;
 0D10 20920800          sts _PRecBuf,R2
 0D14           ;                               PacketState = 0;
 0D14 20920900          sts _PacketState,R2
 0D18           ;                       }
 0D18           ;                       break;
 0D18 22C0              xjmp L156
 0D1A           L191:
 0D1A           ; 		case 14:
 0D1A           ; 			if(UartReceiveBuf[PRecBuf] != 0)
 0D1A 80E0              ldi R24,<_UartReceiveBuf
 0D1C 90E0              ldi R25,>_UartReceiveBuf
 0D1E E0910800          lds R30,_PRecBuf
 0D22 FF27              clr R31
 0D24 E80F              add R30,R24
 0D26 F91F              adc R31,R25
 0D28 2080              ldd R2,z+0
 0D2A 2220              tst R2
 0D2C 69F0              breq L192
 0D2E           X78:
 0D2E           ; 			{
 0D2E           ; 				uart0SendChar(UartReceiveBuf[PRecBuf]);
 0D2E E0910800          lds R30,_PRecBuf
 0D32 FF27              clr R31
 0D34 E80F              add R30,R24
 0D36 F91F              adc R31,R25
 0D38 0081              ldd R16,z+0
 0D3A 4BD0              xcall _uart0SendChar
 0D3C           ;                               PRecBuf++;
 0D3C 80910800          lds R24,_PRecBuf
 0D40 8F5F              subi R24,255    ; addi 1
 0D42 80930800          sts _PRecBuf,R24
 0D46           ;                       }
 0D46 0BC0              xjmp L156
 0D48           L192:
 0D48           ; 			else
 0D48           ; 			{
 0D48           ; 				uart0SendChar('\r');
 0D48 0DE0              ldi R16,13
 0D4A 43D0              xcall _uart0SendChar
 0D4C           ;                               uart0SendChar('\n');
 0D4C 0AE0              ldi R16,10
 0D4E 41D0              xcall _uart0SendChar
 0D50           ;                               uart0SendChar(NAK);
 0D50 05E1              ldi R16,21
 0D52 3FD0              xcall _uart0SendChar
 0D54           ;                               PRecBuf = 0;
 0D54 2224              clr R2
 0D56 20920800          sts _PRecBuf,R2
 0D5A           ;                               PacketState = 0;
 0D5A 20920900          sts _PacketState,R2
 0D5E           ;                       }
 0D5E           ;                       break;
 0D5E           ;               default:
 0D5E           ;                       break;
 0D5E           L156:
 0D5E           L151:
 0D5E                   .dbline 0 ; func end
 0D5E 0C940000          xjmp pop_xgsetF00C
 0D62           ;           pTop -> R10,R11
 0D62           ;              p -> R12,R13
 0D62           ;              i -> R22,R23
 0D62           ;           pEnd -> R20,R21
 0D62           ;            len -> R18,R19
 0D62           ;           data -> R16,R17
                        .even
 0D62           _uart0SendData::
 0D62 0E940000          xcall push_xgsetF03C
 0D66           ;               }
 0D66           ; }
 0D66           ; 
 0D66           ; unsigned char uart0SendData(unsigned char * data, unsigned short len)
 0D66           ; {
 0D66           ;       // 指定长度数据写入缓冲区
 0D66           ;       unsigned short i;
 0D66           ;       unsigned int pTop, pEnd, p;
 0D66           ;       uartBufProtect = 1;
 0D66 81E0              ldi R24,1
 0D68 80930000          sts _uartBufProtect,R24
 0D6C           ;       pTop = uart0TxdBuf.pHead;
 0D6C A0908E02          lds R10,_uart0TxdBuf+502
 0D70 B0908F02          lds R11,_uart0TxdBuf+502+1
 0D74           ;       pEnd = uart0TxdBuf.pEnd;
 0D74 40918C02          lds R20,_uart0TxdBuf+500
 0D78 50918D02          lds R21,_uart0TxdBuf+500+1
 0D7C           ;       for(i=0; i<len; i++)
 0D7C 6627              clr R22
 0D7E 7727              clr R23
 0D80 1BC0              xjmp L201
 0D82           L198:
 0D82           ; 	{
 0D82           ; 		p = pEnd;
 0D82 6A01              movw R12,R20
 0D84           ;               pEnd ++;
 0D84 4F5F              subi R20,255  ; offset = 1
 0D86 5F4F              sbci R21,255
 0D88           ;               if(pEnd == UARTBUF_TXD_LEN)
 0D88 443F              cpi R20,244
 0D8A E1E0              ldi R30,1
 0D8C 5E07              cpc R21,R30
 0D8E 11F4              brne L202
 0D90           X87:
 0D90           ; 			pEnd = 0;
 0D90 4427              clr R20
 0D92 5527              clr R21
 0D94           L202:
 0D94           ; 		if(pEnd != pTop)
 0D94 4A15              cp R20,R10
 0D96 5B05              cpc R21,R11
 0D98 59F0              breq L204
 0D9A           X88:
 0D9A           ; 			uart0TxdBuf.buffer[p] = (* (data+i));
 0D9A FB01              movw R30,R22
 0D9C E00F              add R30,R16
 0D9E F11F              adc R31,R17
 0DA0 2080              ldd R2,z+0
 0DA2 80E0              ldi R24,<_uart0TxdBuf
 0DA4 90E0              ldi R25,>_uart0TxdBuf
 0DA6 F601              movw R30,R12
 0DA8 E80F              add R30,R24
 0DAA F91F              adc R31,R25
 0DAC 2082              std z+0,R2
 0DAE 02C0              xjmp L205
 0DB0           L204:
 0DB0           ; 		else
 0DB0           ; 		{
 0DB0           ; 			pEnd = p;
 0DB0 A601              movw R20,R12
 0DB2           ;                       break;
 0DB2 05C0              xjmp L200
 0DB4           L205:
 0DB4           ; 		}
 0DB4           ; 	}
 0DB4           L199:
 0DB4 6F5F              subi R22,255  ; offset = 1
 0DB6 7F4F              sbci R23,255
 0DB8           L201:
 0DB8 6217              cp R22,R18
 0DBA 7307              cpc R23,R19
 0DBC 10F3              brlo L198
 0DBE           X89:
 0DBE           L200:
 0DBE           ; 	uart0TxdBuf.pEnd = pEnd;
 0DBE 50938D02          sts _uart0TxdBuf+500+1,R21
 0DC2 40938C02          sts _uart0TxdBuf+500,R20
 0DC6           ;       uartBufProtect = 0;
 0DC6 2224              clr R2
 0DC8 20920000          sts _uartBufProtect,R2
 0DCC           ;       return 1;
 0DCC 01E0              ldi R16,1
 0DCE           L195:
 0DCE                   .dbline 0 ; func end
 0DCE 0C940000          xjmp pop_xgsetF03C
 0DD2           ;              p -> R10,R11
 0DD2           ;           pTop -> R12,R13
 0DD2           ;           pEnd -> R20,R21
 0DD2           ;              c -> R16
                        .even
 0DD2           _uart0SendChar::
 0DD2 0E940000          xcall push_xgset303C
 0DD6           ; }
 0DD6           ; 
 0DD6           ; unsigned char uart0SendChar(unsigned char c){
 0DD6           ;       // 1字符数据写入缓冲区
 0DD6           ;       unsigned int pTop, pEnd, p;
 0DD6           ;       if(c){
 0DD6 0023              tst R16
 0DD8 31F1              breq L208
 0DDA           X90:
 0DDA           ; 		pTop = uart0TxdBuf.pHead;
 0DDA C0908E02          lds R12,_uart0TxdBuf+502
 0DDE D0908F02          lds R13,_uart0TxdBuf+502+1
 0DE2           ;               pEnd = uart0TxdBuf.pEnd;
 0DE2 40918C02          lds R20,_uart0TxdBuf+500
 0DE6 50918D02          lds R21,_uart0TxdBuf+500+1
 0DEA           ;               p = pEnd;
 0DEA 5A01              movw R10,R20
 0DEC           ;               pEnd ++;
 0DEC 4F5F              subi R20,255  ; offset = 1
 0DEE 5F4F              sbci R21,255
 0DF0           ;               if(pEnd == UARTBUF_TXD_LEN)
 0DF0 443F              cpi R20,244
 0DF2 E1E0              ldi R30,1
 0DF4 5E07              cpc R21,R30
 0DF6 11F4              brne L212
 0DF8           X91:
 0DF8           ; 			pEnd = 0;
 0DF8 4427              clr R20
 0DFA 5527              clr R21
 0DFC           L212:
 0DFC           ; 		if(pEnd != pTop)
 0DFC 4C15              cp R20,R12
 0DFE 5D05              cpc R21,R13
 0E00 39F0              breq L214
 0E02           X92:
 0E02           ; 			uart0TxdBuf.buffer[p] = c;
 0E02 80E0              ldi R24,<_uart0TxdBuf
 0E04 90E0              ldi R25,>_uart0TxdBuf
 0E06 F501              movw R30,R10
 0E08 E80F              add R30,R24
 0E0A F91F              adc R31,R25
 0E0C 0083              std z+0,R16
 0E0E 02C0              xjmp L215
 0E10           L214:
 0E10           ; 		else
 0E10           ; 			return 1;
 0E10 01E0              ldi R16,1
 0E12 0AC0              xjmp L207
 0E14           L215:
 0E14           ; 		uart0TxdBuf.pEnd = pEnd;
 0E14 50938D02          sts _uart0TxdBuf+500+1,R21
 0E18 40938C02          sts _uart0TxdBuf+500,R20
 0E1C           ;       
 0E1C           ;               uartBufProtect = 0;
 0E1C 2224              clr R2
 0E1E 20920000          sts _uartBufProtect,R2
 0E22           ;               return 0;
 0E22 0027              clr R16
 0E24 01C0              xjmp L207
 0E26           L208:
 0E26           ; 		}
 0E26           ; 	return 1;
 0E26 01E0              ldi R16,1
 0E28           L207:
 0E28                   .dbline 0 ; func end
 0E28 0C940000          xjmp pop_xgset303C
 0E2C           ;              i -> <dead>
 0E2C           ;           pTop -> R10,R11
 0E2C           ;              p -> R12,R13
 0E2C           ;           pEnd -> R20,R21
 0E2C           ;             pS -> R16,R17
                        .even
 0E2C           _uart0SendString::
 0E2C 0E940000          xcall push_xgset303C
 0E30           ; }
 0E30           ; 
 0E30           ; unsigned char uart0SendString(_CONST  char * pS)
 0E30           ; {
 0E30           ;       unsigned short i;
 0E30           ;       unsigned int pTop, pEnd, p;
 0E30           ;       // 字符串数据写入缓冲区
 0E30           ;       uartBufProtect = 1;
 0E30 81E0              ldi R24,1
 0E32 80930000          sts _uartBufProtect,R24
 0E36           ;       pTop = uart0TxdBuf.pHead;
 0E36 A0908E02          lds R10,_uart0TxdBuf+502
 0E3A B0908F02          lds R11,_uart0TxdBuf+502+1
 0E3E           ;       pEnd = uart0TxdBuf.pEnd;
 0E3E 40918C02          lds R20,_uart0TxdBuf+500
 0E42 50918D02          lds R21,_uart0TxdBuf+500+1
 0E46 1EC0              xjmp L221
 0E48           L220:
 0E48           ; 	while(*pS){
 0E48           ; 		p = pEnd;
 0E48 6A01              movw R12,R20
 0E4A           ;               pEnd ++;
 0E4A 4F5F              subi R20,255  ; offset = 1
 0E4C 5F4F              sbci R21,255
 0E4E           ;               if(pEnd == UARTBUF_TXD_LEN){
 0E4E 443F              cpi R20,244
 0E50 E1E0              ldi R30,1
 0E52 5E07              cpc R21,R30
 0E54 11F4              brne L223
 0E56           X93:
 0E56           ; 			pEnd = 0;
 0E56 4427              clr R20
 0E58 5527              clr R21
 0E5A           ;                       }
 0E5A           L223:
 0E5A           ; 		if(pEnd != pTop){
 0E5A 4A15              cp R20,R10
 0E5C 5B05              cpc R21,R11
 0E5E 81F0              breq L225
 0E60           X94:
 0E60           ; 			uart0TxdBuf.buffer[p] = (* (pS));
 0E60 80E0              ldi R24,<_uart0TxdBuf
 0E62 90E0              ldi R25,>_uart0TxdBuf
 0E64 F601              movw R30,R12
 0E66 E80F              add R30,R24
 0E68 F91F              adc R31,R25
 0E6A D801              movw R26,R16
 0E6C FA93              st -y,R31
 0E6E EA93              st -y,R30
 0E70 FD01              movw R30,R26
 0E72 2690              elpm R2,Z
 0E74 E991              ld R30,y+
 0E76 F991              ld R31,y+
 0E78 2082              std z+0,R2
 0E7A           ;                       pS ++;
 0E7A 0F5F              subi R16,255  ; offset = 1
 0E7C 1F4F              sbci R17,255
 0E7E           ;                       }
 0E7E 02C0              xjmp L226
 0E80           L225:
 0E80           ; 		else{
 0E80           ; 			pEnd = p;
 0E80 A601              movw R20,R12
 0E82           ;                       break;
 0E82 04C0              xjmp L222
 0E84           L226:
 0E84           ; 			}
 0E84           ; 		}
 0E84           L221:
 0E84 F801              movw R30,R16
 0E86 2690              elpm R2,Z
 0E88 2220              tst R2
 0E8A F1F6              brne L220
 0E8C           X95:
 0E8C           L222:
 0E8C           ; 	uart0TxdBuf.pEnd = pEnd;
 0E8C 50938D02          sts _uart0TxdBuf+500+1,R21
 0E90 40938C02          sts _uart0TxdBuf+500,R20
 0E94           ;       uartBufProtect = 0;
 0E94 2224              clr R2
 0E96 20920000          sts _uartBufProtect,R2
 0E9A           ;       return 1;
 0E9A 01E0              ldi R16,1
 0E9C           L217:
 0E9C                   .dbline 0 ; func end
 0E9C 0C940000          xjmp pop_xgset303C
 0EA0           ;              c -> R16
 0EA0           ;           pEnd -> R16
 0EA0           ;          pHead -> R18
                        .even
 0EA0           _uart0GetChar::
 0EA0           ; }
 0EA0           ; 
 0EA0           ; unsigned char uart0GetChar(void){
 0EA0           ; 	unsigned char c;
 0EA0           ; 	unsigned char pHead, pEnd;
 0EA0           ; 	pHead = uart0RxdBuf.pHead;
 0EA0 20919700          lds R18,_uart0RxdBuf+2
 0EA4           ;       pEnd  = uart0RxdBuf.pEnd;
 0EA4 00919600          lds R16,_uart0RxdBuf+1
 0EA8           ;       if(pEnd == pHead){
 0EA8 0217              cp R16,R18
 0EAA 11F4              brne L231
 0EAC           X96:
 0EAC           ; 		return 0;
 0EAC 0027              clr R16
 0EAE 16C0              xjmp L228
 0EB0           L231:
 0EB0           ; 		}
 0EB0           ; 	else{
 0EB0           ; //		UCSR0B &= 0x7f;		// 禁止接收中断
 0EB0           ; 		c = uart0RxdBuf.buf[pHead];
 0EB0 80E0              ldi R24,<_uart0RxdBuf
 0EB2 90E0              ldi R25,>_uart0RxdBuf
 0EB4 E22F              mov R30,R18
 0EB6 FF27              clr R31
 0EB8 E80F              add R30,R24
 0EBA F91F              adc R31,R25
 0EBC 0081              ldd R16,z+0
 0EBE           ;               uart0RxdBuf.buf[pHead] = 0;
 0EBE E22F              mov R30,R18
 0EC0 FF27              clr R31
 0EC2 E80F              add R30,R24
 0EC4 F91F              adc R31,R25
 0EC6 2224              clr R2
 0EC8 2082              std z+0,R2
 0ECA           ;               uart0RxdBuf.pHead ++;
 0ECA 80919700          lds R24,_uart0RxdBuf+2
 0ECE 8F5F              subi R24,255    ; addi 1
 0ED0 80939700          sts _uart0RxdBuf+2,R24
 0ED4           ;               if(uart0RxdBuf.pHead == UARTBUF_RXD_LEN)
 0ED4 8130              cpi R24,1
 0ED6 11F4              brne L234
 0ED8           X97:
 0ED8           ; 			uart0RxdBuf.pHead = 0;
 0ED8 20929700          sts _uart0RxdBuf+2,R2
 0EDC           L234:
 0EDC           ; 		}
 0EDC           ; //	UCSR0B |= 0x80;		// 开启接收中断
 0EDC           ; 	return c;
 0EDC           L228:
 0EDC                   .dbline 0 ; func end
 0EDC 0895              ret
                        .area bss(ram, con, rel)
 0007           _WaitAnswer:
 0007                   .blkb 1
 0008           _PRecBuf:
 0008                   .blkb 1
 0009           _UartReceiveBuf::
 0009                   .blkb 60
 0045           __Adc_DiffBuf::
 0045                   .blkb 40
 006D           _AdcResult::
 006D                   .blkb 6
 0073           __Uart2CurrentSendData::
 0073                   .blkb 1
 0074           __Uart2DetectorSelfData::
 0074                   .blkb 1
 0075           _DelayCount::
 0075                   .blkb 32
 0095           _uart0RxdBuf::
 0095                   .blkb 3
 0098           _uart0TxdBuf::
 0098                   .blkb 506
                        .area data(ram, con, rel)
 000A           L172:
 000A                   .blkb 25
                        .area idata
 000A 2A33333434205761697441636B4F7574  .byte 42,51,51,52,52,32,'W,'a,'i,'t,'A,'c,'k,'O,'u,'t
 001A 4F6654696D650D0A00        .byte 'O,'f,'T,'i,'m,'e,13,10,0
                        .area data(ram, con, rel)
 0023           L99:
 0023                   .blkb 23
                        .area idata
 0023 2F2F204C697175696420646574656374  .byte 47,47,32,'L,'i,'q,'u,'i,'d,32,'d,'e,'t,'e,'c,'t
 0033 3A2025640D0A00    .byte 58,32,37,'d,13,10,0
                        .area data(ram, con, rel)
 003A           L92:
 003A                   .blkb 12
                        .area idata
 003A 2132393032202425640D0A00  .byte 33,50,57,48,50,32,36,37,'d,13,10,0
                        .area data(ram, con, rel)
 0046           L89:
 0046                   .blkb 12
                        .area idata
 0046 2132393031202425640D0A00  .byte 33,50,57,48,49,32,36,37,'d,13,10,0
                        .area data(ram, con, rel)
                ; }
                ; 
                ; /********************************************* File end **********************************************/
