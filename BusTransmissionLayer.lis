                        .module BusTransmissionLayer.c
                        .area text(rom, con, rel)
                ;              p -> R18,R19
                ;              i -> R16,R17
                        .even
 0000           _InitCommandTransferData::
 0000           ; 
 0000           ; #include <iom1280v.h>
 0000           ; #include <macros.h>
 0000           ; #include "B1404_LIB.h"
 0000           ; #include "LibCommon.h"
 0000           ; 
 0000           ; 
 0000           ; 
 0000           ; /************************* 从机命令缓冲区 **************************/
 0000           ; typedef struct _COMMAND_BUF
 0000           ; {
 0000           ; 	COMMAND_STRING buf[COMMAND_BUF_LEN];
 0000           ; 	unsigned char pTop;
 0000           ; 	unsigned char pEnd;
 0000           ; 	unsigned char transmitState;	// 命令发送状态 0已经执行完毕或空命令，1新命令存入等待送， 2新命令已发送处于执行状态
 0000           ; }COMMAND_BUF;
 0000           ; 
 0000           ; // 命令发送控制
 0000           ; typedef struct _COMMAND_TRANSMIT_CONTROL
 0000           ; {
 0000           ; 	unsigned char registerSlave[SLAVE_NUM];	// 使用的从机在这里登记
 0000           ; 	unsigned char curSlave;					// 当前的通信的从机
 0000           ; 	unsigned char waitCount;				// 信息返回超时计时
 0000           ; 	COMMAND_BUF cmdBuf[SLAVE_NUM];			// 命令缓冲组，每个元素下标表示相应的从机编号
 0000           ; 	unsigned char slaveState[SLAVE_NUM];	// 记录每个从机的状态
 0000           ; }COMMAND_TRANSMIT_CONTROL;
 0000           ; 
 0000           ; // 当前命令发送缓冲区
 0000           ; typedef struct _TRANSFER_BUF
 0000           ; {
 0000           ; 	COMMAND_STRING cmd;
 0000           ; 	unsigned char pSend;					// 命令数据发送指针
 0000           ; }TRANSFER_BUF;
 0000           ; 
 0000           ; /*typedef struct _COMMAND_URGENT_BUF{
 0000           ; 	COMMAND_STRING buf[COMMAND_BUF_LEN];
 0000           ; 	unsigned char slaveNum[COMMAND_BUF_LEN];	// 命令对应的从机号
 0000           ; 	unsigned char pTop;
 0000           ; 	unsigned char pEnd;
 0000           ; }COMMAND_URGENT_BUF;*/
 0000           ; typedef struct _COMMAND_URGENT_BUF{
 0000           ; 	COMMAND_STRING buf[SLAVE_NUM];	// 数组下标对应从机号
 0000           ; 	unsigned char state[SLAVE_NUM];	// 命令有效状态, 0:无效，1:有效
 0000           ; //	unsigned char pTop;
 0000           ; //	unsigned char pEnd;
 0000           ; }COMMAND_URGENT_BUF;
 0000           ; 
 0000           ; 
 0000           ; /*************************** 信息事件堆 *****************************/
 0000           ; 
 0000           ; // 信息事件队列
 0000           ; typedef struct _INFO_EVENT_STACK{	// 信息事件队列
 0000           ; 	unsigned char pTop;
 0000           ; 	unsigned char pEnd;
 0000           ; 	INFO_EVENT info[INFO_EVENT_NUM];
 0000           ; }INFO_EVENT_STACK;
 0000           ; /*************************** 错误事件堆 *****************************
 0000           ; typedef struct _ERROR_EVENT{
 0000           ; 	unsigned char slaveNum;				// 从机编号
 0000           ; 	unsigned char error;				// 错误信息
 0000           ; }ERROR_EVENT;
 0000           ; typedef struct _ERROR_EVENT_STACK{
 0000           ; 	unsigned char pTop;
 0000           ; 	unsigned char pEnd;
 0000           ; 	unsigned char error[ERROR_EVENT_NUM];
 0000           ; }ERROR_EVENT_STACK;
 0000           ; */
 0000           ; typedef struct _DEVIVE_INFO{
 0000           ; 	unsigned char buf[20];
 0000           ; 	unsigned char pRec;
 0000           ; 	unsigned char infoLen;
 0000           ; 	unsigned char isValid;
 0000           ; }DEVICE_INFO;
 0000           ; 
 0000           ; 
 0000           ; INFO_EVENT_STACK InfoEventStack;
 0000           ; //ERROR_EVENT_STACK ErrorEventStack;
 0000           ; COMMAND_TRANSMIT_CONTROL TransmitControl;
 0000           ; TRANSFER_BUF TransferBuf;
 0000           ; unsigned char TransferStart;		// 命令传输启动标识
 0000           ; DEVICE_INFO DeviceInfo;
 0000           ; COMMAND_URGENT_BUF CmdUrgentBuf;	// 紧急命令
 0000           ; extern unsigned char ControlModel;			// 0:正常， 1:超级终端调试
 0000           ; 
 0000           ; void InitCommandTransferData(void){
 0000           ; 	unsigned int i;
 0000           ; 	unsigned char *p;
 0000           ; 
 0000           ; 	TransferStart = 0;
 0000 2224              clr R2
 0002 2092A200          sts _TransferStart,R2
 0006           ;       p = (unsigned char *)&InfoEventStack;
 0006 20E0              ldi R18,<_InfoEventStack
 0008 30E0              ldi R19,>_InfoEventStack
 000A           ;       for(i=0; i<sizeof(INFO_EVENT_STACK); i++){
 000A 0027              clr R16
 000C 1127              clr R17
 000E 06C0              xjmp L6
 0010           L3:
 0010           ; 		*(p++) = 0;
 0010 2224              clr R2
 0012 F901              movw R30,R18
 0014 2192              st Z+,R2
 0016 9F01              movw R18,R30
 0018           ;               }
 0018           L4:
 0018 0F5F              subi R16,255  ; offset = 1
 001A 1F4F              sbci R17,255
 001C           L6:
 001C 0C38              cpi R16,140
 001E E2E0              ldi R30,2
 0020 1E07              cpc R17,R30
 0022 B0F3              brlo L3
 0024           X0:
 0024           ; /*	p = (unsigned char *)&ErrorEventStack;
 0024           ; 	for(i=0; i<sizeof(ERROR_EVENT_STACK); i++){
 0024           ; 		*(p++) = 0;
 0024           ; 		}*/
 0024           ; 	p = (unsigned char *)&TransmitControl;
 0024 20E0              ldi R18,<_TransmitControl
 0026 30E0              ldi R19,>_TransmitControl
 0028           ;       for(i=0; i<sizeof(COMMAND_TRANSMIT_CONTROL); i++){
 0028 0027              clr R16
 002A 1127              clr R17
 002C 06C0              xjmp L10
 002E           L7:
 002E           ; 		*(p++) = 0;
 002E 2224              clr R2
 0030 F901              movw R30,R18
 0032 2192              st Z+,R2
 0034 9F01              movw R18,R30
 0036           ;               }
 0036           L8:
 0036 0F5F              subi R16,255  ; offset = 1
 0038 1F4F              sbci R17,255
 003A           L10:
 003A 0535              cpi R16,85
 003C E7E0              ldi R30,7
 003E 1E07              cpc R17,R30
 0040 B0F3              brlo L7
 0042           X1:
 0042           ; 	p = (unsigned char *)&TransferBuf;
 0042 20E0              ldi R18,<_TransferBuf
 0044 30E0              ldi R19,>_TransferBuf
 0046           ;       for(i=0; i<sizeof(TRANSFER_BUF); i++){
 0046 0027              clr R16
 0048 1127              clr R17
 004A 06C0              xjmp L14
 004C           L11:
 004C           ; 		*(p++) = 0;
 004C 2224              clr R2
 004E F901              movw R30,R18
 0050 2192              st Z+,R2
 0052 9F01              movw R18,R30
 0054           ;               }
 0054           L12:
 0054 0F5F              subi R16,255  ; offset = 1
 0056 1F4F              sbci R17,255
 0058           L14:
 0058 0930              cpi R16,9
 005A E0E0              ldi R30,0
 005C 1E07              cpc R17,R30
 005E B0F3              brlo L11
 0060           X2:
 0060           ; 	p = (unsigned char *)&CmdUrgentBuf;
 0060 20E0              ldi R18,<_CmdUrgentBuf
 0062 30E0              ldi R19,>_CmdUrgentBuf
 0064           ;       for(i=0; i<sizeof(COMMAND_URGENT_BUF); i++){
 0064 0027              clr R16
 0066 1127              clr R17
 0068 06C0              xjmp L18
 006A           L15:
 006A           ; 		*(p++) = 0;
 006A 2224              clr R2
 006C F901              movw R30,R18
 006E 2192              st Z+,R2
 0070 9F01              movw R18,R30
 0072           ;               }
 0072           L16:
 0072 0F5F              subi R16,255  ; offset = 1
 0074 1F4F              sbci R17,255
 0076           L18:
 0076 0738              cpi R16,135
 0078 E0E0              ldi R30,0
 007A 1E07              cpc R17,R30
 007C B0F3              brlo L15
 007E           X3:
 007E           L2:
 007E                   .dbline 0 ; func end
 007E 0895              ret
 0080           ;           pEnd -> R10
 0080           ;              p -> R20
 0080           ;          pChar -> R22,R23
 0080           ;              i -> R10
 0080           ;            len -> R14
 0080           ;           info -> R12,R13
 0080           ;          slave -> y+10
                        .even
 0080           _AddInfoEventToStack::
 0080 0E940000          xcall push_arg4
 0084 0E940000          xcall push_xgsetF0FC
 0088 6901              movw R12,R18
 008A EE84              ldd R14,y+14
 008C           ; }
 008C           ; 
 008C           ; 
 008C           ; // 将收到的从机信息放入信息队列等待处理
 008C           ; void AddInfoEventToStack(unsigned char slave, unsigned char * info, unsigned char len){
 008C           ;       unsigned char pEnd, i, p;
 008C           ;       unsigned char *pChar;
 008C           ;       pEnd = InfoEventStack.pEnd;
 008C A0900208          lds R10,_InfoEventStack+1
 0090           ;       p = pEnd;
 0090 4A2D              mov R20,R10
 0092           ;       p ++;
 0092 4395              inc R20
 0094           ;       if(p == INFO_EVENT_NUM)
 0094 4233              cpi R20,50
 0096 09F4              brne L21
 0098           X4:
 0098           ; 		p = 0;
 0098 4427              clr R20
 009A           L21:
 009A           ; 	if(p != InfoEventStack.pTop){
 009A 20900108          lds R2,_InfoEventStack
 009E 4215              cp R20,R2
 00A0 09F4              brne X7
 00A2 30C0              xjmp L23
 00A4           X7:
 00A4           X5:
 00A4           ; 		InfoEventStack.info[pEnd].slaveNum = slave;
 00A4 0DE0              ldi R16,13
 00A6 1A2D              mov R17,R10
 00A8 0103              mulsu R16,R17
 00AA 80E0              ldi R24,<_InfoEventStack+2
 00AC 90E0              ldi R25,>_InfoEventStack+2
 00AE F001              movw R30,R0
 00B0 E80F              add R30,R24
 00B2 F91F              adc R31,R25
 00B4 0A84              ldd R0,y+10
 00B6 0082              std z+0,R0
 00B8           ;               InfoEventStack.info[pEnd].event = *(info ++);   // 消息类型
 00B8 0103              mulsu R16,R17
 00BA 80E0              ldi R24,<_InfoEventStack+2+1
 00BC 90E0              ldi R25,>_InfoEventStack+2+1
 00BE F001              movw R30,R0
 00C0 E80F              add R30,R24
 00C2 F91F              adc R31,R25
 00C4 D601              movw R26,R12
 00C6 2D90              ld R2,X+
 00C8 6D01              movw R12,R26
 00CA 2082              std z+0,R2
 00CC           ;               len --;
 00CC EA94              dec R14
 00CE           ;               InfoEventStack.info[pEnd].infoLen = len;        // 消息参数长度
 00CE 0103              mulsu R16,R17
 00D0 80E0              ldi R24,<_InfoEventStack+2+12
 00D2 90E0              ldi R25,>_InfoEventStack+2+12
 00D4 F001              movw R30,R0
 00D6 E80F              add R30,R24
 00D8 F91F              adc R31,R25
 00DA E082              std z+0,R14
 00DC           ;               pChar = &InfoEventStack.info[pEnd].info[0];
 00DC 0103              mulsu R16,R17
 00DE B001              movw R22,R0
 00E0 80E0              ldi R24,<_InfoEventStack+2+2
 00E2 90E0              ldi R25,>_InfoEventStack+2+2
 00E4 680F              add R22,R24
 00E6 791F              adc R23,R25
 00E8           ;               for(i=0; i<len; i++){
 00E8 AA24              clr R10
 00EA 07C0              xjmp L35
 00EC           L32:
 00EC           ; 			*(pChar++) = *(info++);
 00EC F601              movw R30,R12
 00EE DB01              movw R26,R22
 00F0 0190              ld R0,Z+
 00F2 6F01              movw R12,R30
 00F4 0D92              st X+,R0
 00F6 BD01              movw R22,R26
 00F8           ;                       }
 00F8           L33:
 00F8 A394              inc R10
 00FA           L35:
 00FA AE14              cp R10,R14
 00FC B8F3              brlo L32
 00FE           X6:
 00FE           ; 		InfoEventStack.pEnd = p;
 00FE 40930208          sts _InfoEventStack+1,R20
 0102           ;               }
 0102 10C0              xjmp L24
 0104           L23:
 0104           ; 	else
 0104           ; 	{
 0104           ; 		Uart0ReUnable;
 0104 8091C100          lds R24,193
 0108 8F7E              andi R24,239
 010A 8093C100          sts 193,R24
 010E           ;               uart_Printf("// Even save fail [%d]\r\n", slave);
 010E 2A85              ldd R18,y+10
 0110 3327              clr R19
 0112 00E0              ldi R16,<L37
 0114 10E0              ldi R17,>L37
 0116 0E940000          xcall _uart_Printf
 011A           ;               Uart0ReEnable;
 011A 8091C100          lds R24,193
 011E 8061              ori R24,16
 0120 8093C100          sts 193,R24
 0124           ;       }
 0124           L24:
 0124           L19:
 0124                   .dbline 0 ; func end
 0124 0E940000          xcall pop_xgsetF0FC
 0128 2496              adiw R28,4
 012A 0895              ret
 012C           ;       slaveNum -> R20
                        .even
 012C           _SetTransferBufStateQueryCmd::
 012C 4A93              st -y,R20
 012E 402F              mov R20,R16
 0130 2197              sbiw R28,1
 0132           ; }
 0132           ; /*void SetTransferBufStateQueryCmd(unsigned char slaveNum){
 0132           ;       unsigned char pEnd, pTop, p;
 0132           ;       pTop = CmdUrgentBuf.pTop;
 0132           ;       pEnd = CmdUrgentBuf.pEnd;
 0132           ;       
 0132           ;       if(pTop != pEnd){
 0132           ;               if(CmdUrgentBuf.slaveNum[pTop] == slaveNum){
 0132           ;                       MemCopy(&(CmdUrgentBuf.buf[pTop]),&TransferBuf.cmd, sizeof(COMMAND_STRING));    // 将新命令存入发送缓冲区
 0132           ;                       pTop ++;
 0132           ;                       if(pTop == COMMAND_BUF_LEN)
 0132           ;                               pTop = 0;
 0132           ;                       CmdUrgentBuf.pTop = pTop;
 0132           ;                       return;
 0132           ;                       }
 0132           ;               }
 0132           ;       TransferBuf.cmd.cmd = (slaveNum<<3) & 0xf8;
 0132           ;       TransferBuf.cmd.cmdLen = 1;
 0132           ;       
 0132           ; }*/
 0132           ; void SetTransferBufStateQueryCmd(unsigned char slaveNum)
 0132           ; {
 0132           ;       if(slaveNum>=SLAVE_NUM)
 0132 4F30              cpi R20,15
 0134 70F0              brlo L39
 0136           X8:
 0136           ; 	{
 0136           ; 		Uart0ReUnable;
 0136 8091C100          lds R24,193
 013A 8F7E              andi R24,239
 013C 8093C100          sts 193,R24
 0140           ;               uart_Printf("// SlaveNum error! \r\n");
 0140 00E0              ldi R16,<L41
 0142 10E0              ldi R17,>L41
 0144 0E940000          xcall _uart_Printf
 0148           ;               Uart0ReEnable;
 0148 8091C100          lds R24,193
 014C 8061              ori R24,16
 014E 8093C100          sts 193,R24
 0152           ;       }
 0152           L39:
 0152           ; 	if(CmdUrgentBuf.state[slaveNum])
 0152 80E0              ldi R24,<_CmdUrgentBuf+120
 0154 90E0              ldi R25,>_CmdUrgentBuf+120
 0156 E42F              mov R30,R20
 0158 FF27              clr R31
 015A E80F              add R30,R24
 015C F91F              adc R31,R25
 015E 2080              ldd R2,z+0
 0160 2220              tst R2
 0162 D9F0              breq L42
 0164           X9:
 0164           ; 	{
 0164           ; 		// 有紧急命令
 0164           ; 		MemCopy(&(CmdUrgentBuf.buf[slaveNum]),&TransferBuf.cmd, sizeof(COMMAND_STRING));	// 将新命令存入发送缓冲区
 0164 88E0              ldi R24,8
 0166 8883              std y+0,R24
 0168 20E0              ldi R18,<_TransferBuf
 016A 30E0              ldi R19,>_TransferBuf
 016C 80E0              ldi R24,<_CmdUrgentBuf
 016E 90E0              ldi R25,>_CmdUrgentBuf
 0170 042F              mov R16,R20
 0172 1127              clr R17
 0174 000F              lsl R16
 0176 111F              rol R17
 0178 000F              lsl R16
 017A 111F              rol R17
 017C 000F              lsl R16
 017E 111F              rol R17
 0180 080F              add R16,R24
 0182 191F              adc R17,R25
 0184 0E940000          xcall _MemCopy
 0188           ;               CmdUrgentBuf.state[slaveNum] = 0;       // 命令已处理，清除
 0188 80E0              ldi R24,<_CmdUrgentBuf+120
 018A 90E0              ldi R25,>_CmdUrgentBuf+120
 018C E42F              mov R30,R20
 018E FF27              clr R31
 0190 E80F              add R30,R24
 0192 F91F              adc R31,R25
 0194 2224              clr R2
 0196 2082              std z+0,R2
 0198           ;       }
 0198 0AC0              xjmp L43
 019A           L42:
 019A           ; 	else	// 无紧急命令，发送空闲查询
 019A           ; 	{
 019A           ; 		TransferBuf.cmd.cmd = (slaveNum<<3) & 0xf8;
 019A 842F              mov R24,R20
 019C 880F              lsl R24
 019E 880F              lsl R24
 01A0 880F              lsl R24
 01A2 887F              andi R24,248
 01A4 8093A300          sts _TransferBuf,R24
 01A8           ;               TransferBuf.cmd.cmdLen = 1;
 01A8 81E0              ldi R24,1
 01AA 8093AA00          sts _TransferBuf+7,R24
 01AE           ;       }
 01AE           L43:
 01AE           L38:
 01AE                   .dbline 0 ; func end
 01AE 2196              adiw R28,1
 01B0 4991              ld R20,y+
 01B2 0895              ret
 01B4           ;           pEnd -> R12
 01B4           ;           pTop -> R10
 01B4           ;        pCmdBuf -> R22,R23
 01B4           ;       slaveNum -> R20
                        .even
 01B4           _InsertCmdToTransferBuf::
 01B4 0E940000          xcall push_xgsetF03C
 01B8 402F              mov R20,R16
 01BA 2197              sbiw R28,1
 01BC           ; }
 01BC           ; 
 01BC           ; void InsertCmdToTransferBuf(unsigned char slaveNum)
 01BC           ; {
 01BC           ;       COMMAND_BUF * pCmdBuf;
 01BC           ;       unsigned char pTop, pEnd;
 01BC           ;       
 01BC           ;       if(slaveNum>=SLAVE_NUM)
 01BC 4F30              cpi R20,15
 01BE 70F0              brlo L48
 01C0           X10:
 01C0           ; 	{
 01C0           ; 		Uart0ReUnable;
 01C0 8091C100          lds R24,193
 01C4 8F7E              andi R24,239
 01C6 8093C100          sts 193,R24
 01CA           ;               uart_Printf("// SlaveNum error! \r\n");
 01CA 00E0              ldi R16,<L41
 01CC 10E0              ldi R17,>L41
 01CE 0E940000          xcall _uart_Printf
 01D2           ;               Uart0ReEnable;
 01D2 8091C100          lds R24,193
 01D6 8061              ori R24,16
 01D8 8093C100          sts 193,R24
 01DC           ;       }
 01DC           L48:
 01DC           ; 	if(CmdUrgentBuf.state[slaveNum])
 01DC 80E0              ldi R24,<_CmdUrgentBuf+120
 01DE 90E0              ldi R25,>_CmdUrgentBuf+120
 01E0 E42F              mov R30,R20
 01E2 FF27              clr R31
 01E4 E80F              add R30,R24
 01E6 F91F              adc R31,R25
 01E8 2080              ldd R2,z+0
 01EA 2220              tst R2
 01EC D9F0              breq L50
 01EE           X11:
 01EE           ; 	{
 01EE           ; 		// 有紧急命令
 01EE           ; 		MemCopy(&(CmdUrgentBuf.buf[slaveNum]),&TransferBuf.cmd, sizeof(COMMAND_STRING));	// 将新命令存入发送缓冲区
 01EE 88E0              ldi R24,8
 01F0 8883              std y+0,R24
 01F2 20E0              ldi R18,<_TransferBuf
 01F4 30E0              ldi R19,>_TransferBuf
 01F6 80E0              ldi R24,<_CmdUrgentBuf
 01F8 90E0              ldi R25,>_CmdUrgentBuf
 01FA 042F              mov R16,R20
 01FC 1127              clr R17
 01FE 000F              lsl R16
 0200 111F              rol R17
 0202 000F              lsl R16
 0204 111F              rol R17
 0206 000F              lsl R16
 0208 111F              rol R17
 020A 080F              add R16,R24
 020C 191F              adc R17,R25
 020E 0E940000          xcall _MemCopy
 0212           ;               CmdUrgentBuf.state[slaveNum] = 0;       // 命令已处理，清除
 0212 80E0              ldi R24,<_CmdUrgentBuf+120
 0214 90E0              ldi R25,>_CmdUrgentBuf+120
 0216 E42F              mov R30,R20
 0218 FF27              clr R31
 021A E80F              add R30,R24
 021C F91F              adc R31,R25
 021E 2224              clr R2
 0220 2082              std z+0,R2
 0222           ;       }
 0222 30C0              xjmp L51
 0224           L50:
 0224           ; 	else	// 无紧急命令
 0224           ; 	{
 0224           ; 		pCmdBuf = &TransmitControl.cmdBuf[slaveNum];
 0224 0BE7              ldi R16,123
 0226 142F              mov R17,R20
 0228 0103              mulsu R16,R17
 022A B001              movw R22,R0
 022C 80E0              ldi R24,<_TransmitControl+17
 022E 90E0              ldi R25,>_TransmitControl+17
 0230 680F              add R22,R24
 0232 791F              adc R23,R25
 0234           ;               pTop = pCmdBuf->pTop;
 0234 FB01              movw R30,R22
 0236 E858              subi R30,136  ; addi 120
 0238 FF4F              sbci R31,255
 023A A080              ldd R10,z+0
 023C E857              subi R30,120
 023E F040              sbci R31,0
 0240           ;               pEnd = pCmdBuf->pEnd;
 0240 E758              subi R30,135  ; addi 121
 0242 FF4F              sbci R31,255
 0244 C080              ldd R12,z+0
 0246 E957              subi R30,121
 0248 F040              sbci R31,0
 024A           ;               if(pTop != pEnd)                        // 设置新的指针
 024A AC14              cp R10,R12
 024C 89F0              breq L55
 024E           X12:
 024E           ; 		{
 024E           ; 			MemCopy(&(pCmdBuf->buf[pTop]),&TransferBuf.cmd, sizeof(COMMAND_STRING));
 024E 88E0              ldi R24,8
 0250 8883              std y+0,R24
 0252 20E0              ldi R18,<_TransferBuf
 0254 30E0              ldi R19,>_TransferBuf
 0256 0A2D              mov R16,R10
 0258 1127              clr R17
 025A 000F              lsl R16
 025C 111F              rol R17
 025E 000F              lsl R16
 0260 111F              rol R17
 0262 000F              lsl R16
 0264 111F              rol R17
 0266 0E0F              add R16,R30
 0268 1F1F              adc R17,R31
 026A 0E940000          xcall _MemCopy
 026E           ;               }
 026E 0AC0              xjmp L56
 0270           L55:
 0270           ; 		else
 0270           ; 		{
 0270           ; 			TransferBuf.cmd.cmd = (slaveNum<<3) & 0xf8;
 0270 842F              mov R24,R20
 0272 880F              lsl R24
 0274 880F              lsl R24
 0276 880F              lsl R24
 0278 887F              andi R24,248
 027A 8093A300          sts _TransferBuf,R24
 027E           ;                       TransferBuf.cmd.cmdLen = 1;
 027E 81E0              ldi R24,1
 0280 8093AA00          sts _TransferBuf+7,R24
 0284           ;               }
 0284           L56:
 0284           ; 			//	SetTransferBufStateQueryCmd(slaveNum);
 0284           ; 	}
 0284           L51:
 0284           L47:
 0284                   .dbline 0 ; func end
 0284 2196              adiw R28,1
 0286 0C940000          xjmp pop_xgsetF03C
                        .area bss(ram, con, rel)
 0000           L59:
 0000                   .blkb 1
                        .area data(ram, con, rel)
 0000           L60:
 0000                   .blkb 1
                        .area idata
 0000 00                .byte 0
                        .area data(ram, con, rel)
                        .area text(rom, con, rel)
                ;              l -> <dead>
                ;              p -> <dead>
                ;        pCmdBuf -> R22,R23
                ;              c -> R14
                ;           pEnd -> R10
                ;           pTop -> R12
                ;       curSlave -> R20
                        .even
 028A           _SendCommandData::
 028A 0E940000          xcall push_xgsetF0FC
 028E           ; }
 028E           ; static unsigned char CommandBackFlag; // 命令发送返回标识，如果没收到返回信息表示从机丢失
 028E           ; // 发送命令字节
 028E           ; void SendCommandData(void)
 028E           ; {
 028E           ;       // 发送命令数据
 028E           ;       unsigned char curSlave;
 028E           ;       unsigned char p,l,c;
 028E           ;       unsigned char pTop, pEnd;
 028E           ;       static unsigned char checkSum;
 028E           ;       static unsigned char cmdReSendCnt = 0;
 028E           ;       COMMAND_BUF * pCmdBuf;
 028E           ; 
 028E           ;       if(TransferStart == 0)
 028E 2090A200          lds R2,_TransferStart
 0292 2220              tst R2
 0294 09F4              brne L61
 0296           X13:
 0296           ; 		return;				// 命令传输未启动
 0296 ABC0              xjmp L58
 0298           L61:
 0298           ; 	
 0298           ; 	curSlave = TransmitControl.curSlave;
 0298 4091BB00          lds R20,_TransmitControl+15
 029C           ;       pTop = TransferBuf.pSend;
 029C C090AB00          lds R12,_TransferBuf+8
 02A0           ;       pEnd = TransferBuf.cmd.cmdLen;
 02A0 A090AA00          lds R10,_TransferBuf+7
 02A4           ;       
 02A4           ;       if(pTop < pEnd)
 02A4 CA14              cp R12,R10
 02A6 08F0              brlo X26
 02A8 41C0              xjmp L66
 02AA           X26:
 02AA           X14:
 02AA           ; 	{
 02AA           ; 		// 发送命令
 02AA           ; 		if(pTop == 0)
 02AA CC20              tst R12
 02AC A9F4              brne L68
 02AE           X15:
 02AE           ; 		{
 02AE           ; 			if(cmdReSendCnt == 0)
 02AE 20900000          lds R2,L60
 02B2 2220              tst R2
 02B4 39F4              brne L70
 02B6           X16:
 02B6           ; 			{
 02B6           ; 				Uart2SendAdd(0);
 02B6 0027              clr R16
 02B8 0E940000          xcall _Uart2SendAdd
 02BC           ;                               cmdReSendCnt = 1;
 02BC 81E0              ldi R24,1
 02BE 80930000          sts L60,R24
 02C2           ;                               return; // 地址重发
 02C2 95C0              xjmp L58
 02C4           L70:
 02C4           ; 			}
 02C4           ; 			Uart2SendAdd(TransferBuf.cmd.cmd);		// 发送地址和命令
 02C4 0091A300          lds R16,_TransferBuf
 02C8 0E940000          xcall _Uart2SendAdd
 02CC           ;                       cmdReSendCnt = 0;
 02CC 2224              clr R2
 02CE 20920000          sts L60,R2
 02D2           ;                       checkSum = 0;
 02D2 20920000          sts L59,R2
 02D6           ;               }
 02D6 24C0              xjmp L69
 02D8           L68:
 02D8           ; 		else
 02D8           ; 		{
 02D8           ; 			if(GetUart2DataSendResult()!=0)
 02D8 0E940000          xcall _GetUart2DataSendResult
 02DC 0023              tst R16
 02DE 89F0              breq L72
 02E0           X17:
 02E0           ; 			{
 02E0           ; 				pTop = 0;
 02E0 CC24              clr R12
 02E2           ;                               Uart0ReUnable;
 02E2 8091C100          lds R24,193
 02E6 8F7E              andi R24,239
 02E8 8093C100          sts 193,R24
 02EC           ;                               uart_Printf("//DataSendErr1,No:%d\r\n", curSlave);
 02EC 242F              mov R18,R20
 02EE 3327              clr R19
 02F0 00E0              ldi R16,<L74
 02F2 10E0              ldi R17,>L74
 02F4 0E940000          xcall _uart_Printf
 02F8           ;                               Uart0ReEnable;
 02F8 8091C100          lds R24,193
 02FC 8061              ori R24,16
 02FE 8093C100          sts 193,R24
 0302           ;                       }
 0302           L72:
 0302           ; 			c = TransferBuf.cmd.pam[pTop-1];
 0302 80E0              ldi R24,<_TransferBuf+1-1
 0304 90E0              ldi R25,>_TransferBuf+1-1
 0306 EC2D              mov R30,R12
 0308 FF27              clr R31
 030A E80F              add R30,R24
 030C F91F              adc R31,R25
 030E E080              ldd R14,z+0
 0310           ;                       Uart2SendDat(c);        // 发送参数
 0310 0E2D              mov R16,R14
 0312 0E940000          xcall _Uart2SendDat
 0316           ;                       checkSum += c;
 0316 20900000          lds R2,L59
 031A 2E0C              add R2,R14
 031C 20920000          sts L59,R2
 0320           ;               }
 0320           L69:
 0320           ; 		TransferBuf.pSend ++;	// 数据发送指针加一
 0320 8091AB00          lds R24,_TransferBuf+8
 0324 8F5F              subi R24,255    ; addi 1
 0326 8093AB00          sts _TransferBuf+8,R24
 032A           ;       }
 032A 61C0              xjmp L67
 032C           L66:
 032C           ; 	else if(pTop == pEnd)
 032C CA14              cp R12,R10
 032E 29F5              brne L78
 0330           X18:
 0330           ; 	{
 0330           ; 		// 发送校验
 0330           ; 		if(GetUart2DataSendResult()!=0)
 0330 0E940000          xcall _GetUart2DataSendResult
 0334 0023              tst R16
 0336 89F0              breq L80
 0338           X19:
 0338           ; 		{
 0338           ; 			pTop = 0;
 0338 CC24              clr R12
 033A           ;                       Uart0ReUnable;
 033A 8091C100          lds R24,193
 033E 8F7E              andi R24,239
 0340 8093C100          sts 193,R24
 0344           ;                       uart_Printf("//DataSendErr2,No:%d\r\n", curSlave);
 0344 242F              mov R18,R20
 0346 3327              clr R19
 0348 00E0              ldi R16,<L82
 034A 10E0              ldi R17,>L82
 034C 0E940000          xcall _uart_Printf
 0350           ;                       Uart0ReEnable;
 0350 8091C100          lds R24,193
 0354 8061              ori R24,16
 0356 8093C100          sts 193,R24
 035A           ;               }
 035A           L80:
 035A           ; 		if(pEnd > 1)
 035A 81E0              ldi R24,1
 035C 8A15              cp R24,R10
 035E 20F4              brsh L83
 0360           X20:
 0360           ; 			Uart2SendDat(checkSum);	// 发送校验和
 0360 00910000          lds R16,L59
 0364 0E940000          xcall _Uart2SendDat
 0368           L83:
 0368           ; 		TransferBuf.pSend ++;	// 数据发送指针加一
 0368 8091AB00          lds R24,_TransferBuf+8
 036C 8F5F              subi R24,255    ; addi 1
 036E 8093AB00          sts _TransferBuf+8,R24
 0372           ;               DeviceInfo.pRec == 0;
 0372           ;               TransmitControl.waitCount = 15;//5
 0372 8FE0              ldi R24,15
 0374 8093BC00          sts _TransmitControl+16,R24
 0378           ;       }
 0378 3AC0              xjmp L79
 037A           L78:
 037A           ; 	else
 037A           ; 	{
 037A           ; 		if(TransmitControl.waitCount)
 037A 2090BC00          lds R2,_TransmitControl+16
 037E 2220              tst R2
 0380 29F0              breq L88
 0382           X21:
 0382           ; 		{
 0382           ; 			TransmitControl.waitCount --;
 0382 822D              mov R24,R2
 0384 8150              subi R24,1
 0386 8093BC00          sts _TransmitControl+16,R24
 038A           ;               }
 038A 31C0              xjmp L89
 038C           L88:
 038C           ; 		else
 038C           ; 		{
 038C           ; 		/*	if(CommandBackFlag != 255){	// 前一次发送的命令未收到反馈信息，需要重新发送
 038C           ; 			//	TransmitControl.cmdBuf[curSlave].transmitState = 2;	// 重新发送命令
 038C           ; 				if(CommandBackFlag == 28)
 038C           ; 					uart_Printf("// Command back lose: %d %d %d %d %d\r\n", DeviceInfo.buf[0], DeviceInfo.buf[1], DeviceInfo.buf[2], DeviceInfo.buf[3], DeviceInfo.buf[4]);
 038C           ; 				else
 038C           ; 					uart_Printf("// Command back lose :%d %d, cmd%d\r\n", CommandBackFlag,DeviceInfo.pRec,TransferBuf.cmd.cmd);
 038C           ; 				}*/
 038C           ; 			CommandBackFlag = 0;
 038C 2224              clr R2
 038E 20920300          sts _CommandBackFlag,R2
 0392           L92:
 0392           ; 			do
 0392           ; 			{
 0392           ; 				curSlave ++;
 0392 4395              inc R20
 0394           ;                               if(curSlave == SLAVE_NUM)
 0394 4F30              cpi R20,15
 0396 09F4              brne L95
 0398           X22:
 0398           ; 					curSlave = 0;
 0398 4427              clr R20
 039A           L95:
 039A           ; 			}while(TransmitControl.registerSlave[curSlave]==0);
 039A           L93:
 039A 80E0              ldi R24,<_TransmitControl
 039C 90E0              ldi R25,>_TransmitControl
 039E E42F              mov R30,R20
 03A0 FF27              clr R31
 03A2 E80F              add R30,R24
 03A4 F91F              adc R31,R25
 03A6 2080              ldd R2,z+0
 03A8 2220              tst R2
 03AA 99F3              breq L92
 03AC           X23:
 03AC           ; 				
 03AC           ; 			TransmitControl.curSlave = curSlave;		// 指向下一个有效的从机
 03AC 4093BB00          sts _TransmitControl+15,R20
 03B0           ;                       pCmdBuf = &TransmitControl.cmdBuf[curSlave];
 03B0 0BE7              ldi R16,123
 03B2 142F              mov R17,R20
 03B4 0103              mulsu R16,R17
 03B6 B001              movw R22,R0
 03B8 80E0              ldi R24,<_TransmitControl+17
 03BA 90E0              ldi R25,>_TransmitControl+17
 03BC 680F              add R22,R24
 03BE 791F              adc R23,R25
 03C0           ;                       switch(pCmdBuf->transmitState)
 03C0 FB01              movw R30,R22
 03C2 E658              subi R30,134  ; addi 122
 03C4 FF4F              sbci R31,255
 03C6 6081              ldd R22,z+0
 03C8 7727              clr R23
 03CA 6030              cpi R22,0
 03CC 6707              cpc R22,R23
 03CE 29F0              breq L102
 03D0           X24:
 03D0 6230              cpi R22,2
 03D2 E0E0              ldi R30,0
 03D4 7E07              cpc R23,R30
 03D6 21F0              breq L103
 03D8           X25:
 03D8 05C0              xjmp L100
 03DA           L102:
 03DA           ; 			{
 03DA           ; 				case 0:				// 开始新传输
 03DA           ; 					InsertCmdToTransferBuf(curSlave);
 03DA 042F              mov R16,R20
 03DC EBDE              xcall _InsertCmdToTransferBuf
 03DE           ;                               /*      pTop = CmdUrgentBuf.pTop;
 03DE           ;                                       pEnd = CmdUrgentBuf.pEnd;
 03DE           ;                                       if(pTop == pEnd){       // 保证紧急命令先发送
 03DE           ;                                               pTop = pCmdBuf->pTop;
 03DE           ;                                               pEnd = pCmdBuf->pEnd;
 03DE           ;                                               if(pTop != pEnd){                       // 设置新的指针
 03DE           ;                                                       pCmdBuf->transmitState = 1;     // 设置命令处于等待发送状态
 03DE           ;                                                       MemCopy(&(pCmdBuf->buf[pTop]),&TransferBuf.cmd, sizeof(COMMAND_STRING));        // 将新命令存入发送缓冲区
 03DE           ;                                                       }
 03DE           ;                                               else
 03DE           ;                                                       SetTransferBufStateQueryCmd(curSlave);
 03DE           ;                                               }
 03DE           ;                                       else
 03DE           ;                                               SetTransferBufStateQueryCmd(curSlave);*/
 03DE           ;                                       break;
 03DE 02C0              xjmp L100
 03E0           L103:
 03E0           ; 				case 2:				// 命令发送完毕，查询从机状态
 03E0           ; 					SetTransferBufStateQueryCmd(curSlave);
 03E0 042F              mov R16,R20
 03E2 A4DE              xcall _SetTransferBufStateQueryCmd
 03E4           ;                                       break;
 03E4           ;                               default:
 03E4           ;                                       break;
 03E4           L100:
 03E4           ; 			}
 03E4           ; 			TransferBuf.pSend = 0;	// 初始化发送指针
 03E4 2224              clr R2
 03E6 2092AB00          sts _TransferBuf+8,R2
 03EA           ;                       DeviceInfo.pRec = 0;
 03EA 20929F00          sts _DeviceInfo+20,R2
 03EE           ;               }
 03EE           L89:
 03EE           ; 	}
 03EE           L79:
 03EE           L67:
 03EE           L58:
 03EE                   .dbline 0 ; func end
 03EE 0C940000          xjmp pop_xgsetF0FC
                        .area bss(ram, con, rel)
 0001           L107:
 0001                   .blkb 1
 0002           L108:
 0002                   .blkb 1
                        .area text(rom, con, rel)
                ;          pChar -> <dead>
                ;           pEnd -> R12
                ;           pTop -> R20
                ;       curSlave -> R10
                ;           info -> R20
                        .even
 03F2           _ReceiveSlaveInfo::
 03F2 0E940000          xcall push_xgset303C
 03F6 402F              mov R20,R16
 03F8 2897              sbiw R28,8
 03FA           ; }
 03FA           ; // 接收一个字节的从机消息存入消息缓冲区
 03FA           ; void ReceiveSlaveInfo(unsigned char info)
 03FA           ; {
 03FA           ;       // 接收从机返回信息
 03FA           ;       unsigned char curSlave;
 03FA           ;       static unsigned char state;
 03FA           ;       static unsigned char checkSum;
 03FA           ;       unsigned char pTop, pEnd;
 03FA           ;       unsigned char *pChar;
 03FA           ; 
 03FA           ;       curSlave = TransmitControl.curSlave;    // 当前从机号
 03FA A090BB00          lds R10,_TransmitControl+15
 03FE           ;       TransmitControl.waitCount = 15;                 // 超时等待计数 5
 03FE 8FE0              ldi R24,15
 0400 8093BC00          sts _TransmitControl+16,R24
 0404           ;       // 接收设备消息
 0404           ;       if(DeviceInfo.pRec == 0)
 0404 20909F00          lds R2,_DeviceInfo+20
 0408 2220              tst R2
 040A 19F5              brne L111
 040C           X27:
 040C           ; 	{
 040C           ; 		// 接收状态字节
 040C           ; 		CommandBackFlag = info;      //返回到的第一个命令就是状态加上长度
 040C 40930300          sts _CommandBackFlag,R20
 0410           ;               state = info >> 3;
 0410 242E              mov R2,R20
 0412 2694              lsr R2
 0414 2694              lsr R2
 0416 2694              lsr R2
 0418 20920100          sts L107,R2
 041C           ;               DeviceInfo.infoLen = info & 0x07;      //长度是后三位来表示
 041C 842F              mov R24,R20
 041E 8770              andi R24,7
 0420 8093A000          sts _DeviceInfo+21,R24
 0424           ;               if(DeviceInfo.infoLen == 0)     
 0424 8823              tst R24
 0426 21F4              brne L115
 0428           X28:
 0428           ; 			DeviceInfo.isValid = 1;
 0428 81E0              ldi R24,1
 042A 8093A100          sts _DeviceInfo+22,R24
 042E 6AC0              xjmp L112
 0430           L115:
 0430           ; 		else                                   //命令长度不是为0，有命令
 0430           ; 		{
 0430           ; 			DeviceInfo.buf[DeviceInfo.pRec] = info;
 0430 80E0              ldi R24,<_DeviceInfo
 0432 90E0              ldi R25,>_DeviceInfo
 0434 E0919F00          lds R30,_DeviceInfo+20
 0438 FF27              clr R31
 043A E80F              add R30,R24
 043C F91F              adc R31,R25
 043E 4083              std z+0,R20
 0440           ;                       DeviceInfo.pRec ++;
 0440 80919F00          lds R24,_DeviceInfo+20
 0444 8F5F              subi R24,255    ; addi 1
 0446 80939F00          sts _DeviceInfo+20,R24
 044A           ;                       checkSum = 0;
 044A 2224              clr R2
 044C 20920200          sts L108,R2
 0450           ;               }
 0450           ;       }
 0450 59C0              xjmp L112
 0452           L111:
 0452           ; 	else
 0452           ; 	{
 0452           ; 		// 接收设备返回消息
 0452           ; 		if(DeviceInfo.pRec < DeviceInfo.infoLen + 1)
 0452 8091A000          lds R24,_DeviceInfo+21
 0456 8F5F              subi R24,255    ; addi 1
 0458 20909F00          lds R2,_DeviceInfo+20
 045C 2816              cp R2,R24
 045E 90F4              brsh L121
 0460           X29:
 0460           ; 		{
 0460           ; 			DeviceInfo.buf[DeviceInfo.pRec] = info;
 0460 80E0              ldi R24,<_DeviceInfo
 0462 90E0              ldi R25,>_DeviceInfo
 0464 E22D              mov R30,R2
 0466 FF27              clr R31
 0468 E80F              add R30,R24
 046A F91F              adc R31,R25
 046C 4083              std z+0,R20
 046E           ;                       DeviceInfo.pRec ++;
 046E 80919F00          lds R24,_DeviceInfo+20
 0472 8F5F              subi R24,255    ; addi 1
 0474 80939F00          sts _DeviceInfo+20,R24
 0478           ;                       checkSum += info;
 0478 20900200          lds R2,L108
 047C 240E              add R2,R20
 047E 20920200          sts L108,R2
 0482           ;               }
 0482 40C0              xjmp L122
 0484           L121:
 0484           ; 		else         //最后一个数据就是校验和的数值
 0484           ; 		{
 0484           ; 			if(checkSum == info)				// 设备返回消息接收成功
 0484 20900200          lds R2,L108
 0488 2416              cp R2,R20
 048A 39F4              brne L127
 048C           X30:
 048C           ; 			{
 048C           ; 				DeviceInfo.isValid = 1;         //整个消息接受完成了
 048C 81E0              ldi R24,1
 048E 8093A100          sts _DeviceInfo+22,R24
 0492           ;                               Uart2SendDat(STA_SLAVE_RECEIVE_OK);     
 0492 06E0              ldi R16,6
 0494 0E940000          xcall _Uart2SendDat
 0498           ;                       }
 0498 35C0              xjmp L128
 049A           L127:
 049A           ; 			else
 049A           ; 			{							
 049A           ; 				CommandBackFlag = 254;
 049A 8EEF              ldi R24,254
 049C 80930300          sts _CommandBackFlag,R24
 04A0           ;                               Uart2SendDat(STA_SLAVE_RECEIVE_ERR);
 04A0 07E0              ldi R16,7
 04A2 0E940000          xcall _Uart2SendDat
 04A6           ;                               if(ControlModel != 0)
 04A6 20900000          lds R2,_ControlModel
 04AA 2220              tst R2
 04AC 19F1              breq L130
 04AE           X31:
 04AE           ; 				{                    //校验和错误报错了
 04AE           ; 					Uart0ReUnable;
 04AE 8091C100          lds R24,193
 04B2 8F7E              andi R24,239
 04B4 8093C100          sts 193,R24
 04B8           ;                                       uart_Printf("// Info err,Num:%d,Sum:%d,%d(%d,%d)\r\n",curSlave,checkSum,info,DeviceInfo.buf[1],DeviceInfo.buf[2]);
 04B8 20908D00          lds R2,_DeviceInfo+2
 04BC 3324              clr R3
 04BE 3F82              std y+7,R3
 04C0 2E82              std y+6,R2
 04C2 20908C00          lds R2,_DeviceInfo+1
 04C6 3324              clr R3
 04C8 3D82              std y+5,R3
 04CA 2C82              std y+4,R2
 04CC 242E              mov R2,R20
 04CE 3324              clr R3
 04D0 3B82              std y+3,R3
 04D2 2A82              std y+2,R2
 04D4 20900200          lds R2,L108
 04D8 3324              clr R3
 04DA 3982              std y+1,R3
 04DC 2882              std y+0,R2
 04DE 2A2D              mov R18,R10
 04E0 3327              clr R19
 04E2 00E0              ldi R16,<L132
 04E4 10E0              ldi R17,>L132
 04E6 0E940000          xcall _uart_Printf
 04EA           ;                                       Uart0ReEnable;
 04EA 8091C100          lds R24,193
 04EE 8061              ori R24,16
 04F0 8093C100          sts 193,R24
 04F4           ;                               }
 04F4           L130:
 04F4           ; 				DeviceInfo.infoLen = 0;
 04F4 2224              clr R2
 04F6 2092A000          sts _DeviceInfo+21,R2
 04FA           ;                               DeviceInfo.pRec = 0;
 04FA 20929F00          sts _DeviceInfo+20,R2
 04FE           ;                               TransmitControl.waitCount = 2;
 04FE 82E0              ldi R24,2
 0500 8093BC00          sts _TransmitControl+16,R24
 0504           ;                       }
 0504           L128:
 0504           ; 		}
 0504           L122:
 0504           ; 	}
 0504           L112:
 0504           ; 	// 设备消息处理
 0504           ; 	if(DeviceInfo.isValid)
 0504 2090A100          lds R2,_DeviceInfo+22
 0508 2220              tst R2
 050A 09F4              brne X48
 050C E3C0              xjmp L138
 050E           X48:
 050E           X32:
 050E           ; 	{
 050E           ; 		CommandBackFlag = 255;
 050E 8FEF              ldi R24,255
 0510 80930300          sts _CommandBackFlag,R24
 0514           ;               switch(state)
 0514 40910100          lds R20,L107
 0518 5527              clr R21
 051A 4030              cpi R20,0
 051C 4507              cpc R20,R21
 051E 19F1              breq L144
 0520           X33:
 0520 4130              cpi R20,1
 0522 E0E0              ldi R30,0
 0524 5E07              cpc R21,R30
 0526 49F1              breq L146
 0528           X34:
 0528 4230              cpi R20,2
 052A E0E0              ldi R30,0
 052C 5E07              cpc R21,R30
 052E 09F4              brne X49
 0530 71C0              xjmp L165
 0532           X49:
 0532           X35:
 0532 4330              cpi R20,3
 0534 E0E0              ldi R30,0
 0536 5E07              cpc R21,R30
 0538 09F4              brne X50
 053A 76C0              xjmp L167
 053C           X50:
 053C           X36:
 053C 4430              cpi R20,4
 053E E0E0              ldi R30,0
 0540 5E07              cpc R21,R30
 0542 09F4              brne X51
 0544 71C0              xjmp L167
 0546           X51:
 0546           X37:
 0546 4530              cpi R20,5
 0548 E0E0              ldi R30,0
 054A 5E07              cpc R21,R30
 054C 09F4              brne X52
 054E 95C0              xjmp L180
 0550           X52:
 0550           X38:
 0550 4630              cpi R20,6
 0552 E0E0              ldi R30,0
 0554 5E07              cpc R21,R30
 0556 09F4              brne X53
 0558 9EC0              xjmp L188
 055A           X53:
 055A           X39:
 055A 4730              cpi R20,7
 055C E0E0              ldi R30,0
 055E 5E07              cpc R21,R30
 0560 09F4              brne X54
 0562 A4C0              xjmp L191
 0564           X54:
 0564           X40:
 0564 ADC0              xjmp L142
 0566           L144:
 0566           ; 		{
 0566           ; 			case 0:			// 待机
 0566           ; 				TransmitControl.slaveState[curSlave] = state;
 0566 80E0              ldi R24,<_TransmitControl+1862
 0568 90E0              ldi R25,>_TransmitControl+1862
 056A EA2D              mov R30,R10
 056C FF27              clr R31
 056E E80F              add R30,R24
 0570 F91F              adc R31,R25
 0572 20900100          lds R2,L107
 0576 2082              std z+0,R2
 0578           ;                               break;
 0578 A3C0              xjmp L142
 057A           L146:
 057A           ; 			case 1:			// 空闲
 057A           ; 				TransmitControl.slaveState[curSlave] = state;
 057A 80E0              ldi R24,<_TransmitControl+1862
 057C 90E0              ldi R25,>_TransmitControl+1862
 057E EA2D              mov R30,R10
 0580 FF27              clr R31
 0582 E80F              add R30,R24
 0584 F91F              adc R31,R25
 0586 20900100          lds R2,L107
 058A 2082              std z+0,R2
 058C           ;                               if(TransmitControl.cmdBuf[curSlave].transmitState == 2)
 058C 0BE7              ldi R16,123
 058E 1A2D              mov R17,R10
 0590 0103              mulsu R16,R17
 0592 80E0              ldi R24,<_TransmitControl+17+122
 0594 90E0              ldi R25,>_TransmitControl+17+122
 0596 F001              movw R30,R0
 0598 E80F              add R30,R24
 059A F91F              adc R31,R25
 059C 8081              ldd R24,z+0
 059E 8230              cpi R24,2
 05A0 09F0              breq X55
 05A2 8EC0              xjmp L142
 05A4           X55:
 05A4           X41:
 05A4           ; 				{
 05A4           ; 					pTop = TransmitControl.cmdBuf[curSlave].pTop;
 05A4 0103              mulsu R16,R17
 05A6 80E0              ldi R24,<_TransmitControl+17+120
 05A8 90E0              ldi R25,>_TransmitControl+17+120
 05AA F001              movw R30,R0
 05AC E80F              add R30,R24
 05AE F91F              adc R31,R25
 05B0 4081              ldd R20,z+0
 05B2           ;                                       pEnd = TransmitControl.cmdBuf[curSlave].pEnd;
 05B2 0103              mulsu R16,R17
 05B4 80E0              ldi R24,<_TransmitControl+17+121
 05B6 90E0              ldi R25,>_TransmitControl+17+121
 05B8 F001              movw R30,R0
 05BA E80F              add R30,R24
 05BC F91F              adc R31,R25
 05BE C080              ldd R12,z+0
 05C0           ;                                       if(pTop != pEnd)
 05C0 4C15              cp R20,R12
 05C2 69F0              breq L156
 05C4           X42:
 05C4           ; 					{
 05C4           ; 						pTop ++;
 05C4 4395              inc R20
 05C6           ;                                               if(pTop == COMMAND_BUF_LEN)
 05C6 4F30              cpi R20,15
 05C8 09F4              brne L158
 05CA           X43:
 05CA           ; 							pTop = 0;
 05CA 4427              clr R20
 05CC           L158:
 05CC           ; 						TransmitControl.cmdBuf[curSlave].pTop = pTop;
 05CC 0BE7              ldi R16,123
 05CE 1A2D              mov R17,R10
 05D0 0103              mulsu R16,R17
 05D2 80E0              ldi R24,<_TransmitControl+17+120
 05D4 90E0              ldi R25,>_TransmitControl+17+120
 05D6 F001              movw R30,R0
 05D8 E80F              add R30,R24
 05DA F91F              adc R31,R25
 05DC 4083              std z+0,R20
 05DE           ;                                       }
 05DE           L156:
 05DE           ; 					TransmitControl.cmdBuf[curSlave].transmitState = 0;
 05DE 0BE7              ldi R16,123
 05E0 1A2D              mov R17,R10
 05E2 0103              mulsu R16,R17
 05E4 80E0              ldi R24,<_TransmitControl+17+122
 05E6 90E0              ldi R25,>_TransmitControl+17+122
 05E8 F001              movw R30,R0
 05EA E80F              add R30,R24
 05EC F91F              adc R31,R25
 05EE 2224              clr R2
 05F0 2082              std z+0,R2
 05F2           ;                                       Uart0ReUnable;  
 05F2 8091C100          lds R24,193
 05F6 8F7E              andi R24,239
 05F8 8093C100          sts 193,R24
 05FC           ;                                       uart_Printf("//CmdBackErr,No:%d\r\n", curSlave);
 05FC 2A2D              mov R18,R10
 05FE 3327              clr R19
 0600 00E0              ldi R16,<L164
 0602 10E0              ldi R17,>L164
 0604 0E940000          xcall _uart_Printf
 0608           ;                                       Uart0ReEnable;
 0608 8091C100          lds R24,193
 060C 8061              ori R24,16
 060E 8093C100          sts 193,R24
 0612           ;                               }
 0612           ;                               break;
 0612 56C0              xjmp L142
 0614           L165:
 0614           ; 			case 2:			// 忙
 0614           ; 				TransmitControl.slaveState[curSlave] = state;
 0614 80E0              ldi R24,<_TransmitControl+1862
 0616 90E0              ldi R25,>_TransmitControl+1862
 0618 EA2D              mov R30,R10
 061A FF27              clr R31
 061C E80F              add R30,R24
 061E F91F              adc R31,R25
 0620 20900100          lds R2,L107
 0624 2082              std z+0,R2
 0626           ;                               break;
 0626 4CC0              xjmp L142
 0628           L167:
 0628           ; 			case 3:			// 命令完成
 0628           ; 			case 4:			// 命令出错
 0628           ; 				// 发送命令缓冲区指针更新
 0628           ; 				pTop = TransmitControl.cmdBuf[curSlave].pTop;
 0628 0BE7              ldi R16,123
 062A 1A2D              mov R17,R10
 062C 0103              mulsu R16,R17
 062E 80E0              ldi R24,<_TransmitControl+17+120
 0630 90E0              ldi R25,>_TransmitControl+17+120
 0632 F001              movw R30,R0
 0634 E80F              add R30,R24
 0636 F91F              adc R31,R25
 0638 4081              ldd R20,z+0
 063A           ;                               pEnd = TransmitControl.cmdBuf[curSlave].pEnd;
 063A 0103              mulsu R16,R17
 063C 80E0              ldi R24,<_TransmitControl+17+121
 063E 90E0              ldi R25,>_TransmitControl+17+121
 0640 F001              movw R30,R0
 0642 E80F              add R30,R24
 0644 F91F              adc R31,R25
 0646 C080              ldd R12,z+0
 0648           ;                               if(pTop != pEnd)
 0648 4C15              cp R20,R12
 064A 69F0              breq L172
 064C           X44:
 064C           ; 				{
 064C           ; 					pTop ++;
 064C 4395              inc R20
 064E           ;                                       if(pTop == COMMAND_BUF_LEN)
 064E 4F30              cpi R20,15
 0650 09F4              brne L174
 0652           X45:
 0652           ; 						pTop = 0;
 0652 4427              clr R20
 0654           L174:
 0654           ; 					TransmitControl.cmdBuf[curSlave].pTop = pTop;		// 设置新的指针
 0654 0BE7              ldi R16,123
 0656 1A2D              mov R17,R10
 0658 0103              mulsu R16,R17
 065A 80E0              ldi R24,<_TransmitControl+17+120
 065C 90E0              ldi R25,>_TransmitControl+17+120
 065E F001              movw R30,R0
 0660 E80F              add R30,R24
 0662 F91F              adc R31,R25
 0664 4083              std z+0,R20
 0666           ;                               }
 0666           L172:
 0666           ; 				TransmitControl.cmdBuf[curSlave].transmitState = 0;		// 新的通讯开始
 0666 0BE7              ldi R16,123
 0668 1A2D              mov R17,R10
 066A 0103              mulsu R16,R17
 066C 80E0              ldi R24,<_TransmitControl+17+122
 066E 90E0              ldi R25,>_TransmitControl+17+122
 0670 F001              movw R30,R0
 0672 E80F              add R30,R24
 0674 F91F              adc R31,R25
 0676 2224              clr R2
 0678 2082              std z+0,R2
 067A           L180:
 067A           ; 			case 5:			// 状态发生改变
 067A           ; #ifdef DEBUG
 067A           ; 				if(state==4)
 067A           ; 				{
 067A           ; 					if(ControlModel != 0)
 067A           ; 					{
 067A           ; 						Uart0ReUnable;
 067A           ; 						uart_Printf("//CmdErr,No:%d\r\n", curSlave);
 067A           ; 						Uart0ReEnable;
 067A           ; 					}
 067A           ; 				}
 067A           ; #endif
 067A           ; 				if(state != 4)
 067A 80910100          lds R24,L107
 067E 8430              cpi R24,4
 0680 F9F0              breq L142
 0682           X46:
 0682           ; 					if(DeviceInfo.infoLen != 0)		// 空消息不处理
 0682 2090A000          lds R2,_DeviceInfo+21
 0686 2220              tst R2
 0688 D9F0              breq L142
 068A           X47:
 068A           ; 						AddInfoEventToStack(curSlave, &DeviceInfo.buf[1], DeviceInfo.infoLen);	
 068A 2882              std y+0,R2
 068C 20E0              ldi R18,<_DeviceInfo+1
 068E 30E0              ldi R19,>_DeviceInfo+1
 0690 0A2D              mov R16,R10
 0692 F6DC              xcall _AddInfoEventToStack
 0694           ;                               break;
 0694 15C0              xjmp L142
 0696           L188:
 0696           ; 			case 6:			// 命令发送成功
 0696           ; 				TransmitControl.cmdBuf[curSlave].transmitState = 2;	
 0696 0BE7              ldi R16,123
 0698 1A2D              mov R17,R10
 069A 0103              mulsu R16,R17
 069C 80E0              ldi R24,<_TransmitControl+17+122
 069E 90E0              ldi R25,>_TransmitControl+17+122
 06A0 F001              movw R30,R0
 06A2 E80F              add R30,R24
 06A4 F91F              adc R31,R25
 06A6 82E0              ldi R24,2
 06A8 8083              std z+0,R24
 06AA           ;                               break;
 06AA 0AC0              xjmp L142
 06AC           L191:
 06AC           ; 			case 7:			// 命令发送失败
 06AC           ; 				TransmitControl.cmdBuf[curSlave].transmitState = 0;	// 重新发送命令
 06AC 0BE7              ldi R16,123
 06AE 1A2D              mov R17,R10
 06B0 0103              mulsu R16,R17
 06B2 80E0              ldi R24,<_TransmitControl+17+122
 06B4 90E0              ldi R25,>_TransmitControl+17+122
 06B6 F001              movw R30,R0
 06B8 E80F              add R30,R24
 06BA F91F              adc R31,R25
 06BC 2224              clr R2
 06BE 2082              std z+0,R2
 06C0           ;                               break;
 06C0           ;                       default:
 06C0           ;                               break;
 06C0           L142:
 06C0           ; 			}
 06C0           ; 		TransmitControl.waitCount = 2;		// 通信结束，退出超时等待
 06C0 82E0              ldi R24,2
 06C2 8093BC00          sts _TransmitControl+16,R24
 06C6           ;               DeviceInfo.isValid = 0;
 06C6 2224              clr R2
 06C8 2092A100          sts _DeviceInfo+22,R2
 06CC           ;               DeviceInfo.infoLen = 0;
 06CC 2092A000          sts _DeviceInfo+21,R2
 06D0           ;               DeviceInfo.pRec = 0;
 06D0 20929F00          sts _DeviceInfo+20,R2
 06D4           ;               }
 06D4           L138:
 06D4           L106:
 06D4                   .dbline 0 ; func end
 06D4 2896              adiw R28,8
 06D6 0C940000          xjmp pop_xgset303C
 06DA           ;       slaveNum -> R16
                        .even
 06DA           _RegisterSlave::
 06DA           ; }
 06DA           ; 
 06DA           ; unsigned char RegisterSlave(unsigned char slaveNum)
 06DA           ; {
 06DA           ; //	if(TransferStart)
 06DA           ; //		return;				// 命令传输已启动，不能再注册从机
 06DA           ; 	TransmitControl.registerSlave[slaveNum] = 1;
 06DA 80E0              ldi R24,<_TransmitControl
 06DC 90E0              ldi R25,>_TransmitControl
 06DE E02F              mov R30,R16
 06E0 FF27              clr R31
 06E2 E80F              add R30,R24
 06E4 F91F              adc R31,R25
 06E6 81E0              ldi R24,1
 06E8 8083              std z+0,R24
 06EA           L198:
 06EA                   .dbline 0 ; func end
 06EA 0895              ret
 06EC           ;              i -> R20
                        .even
 06EC           _StartCommandTransfer::
 06EC 4A93              st -y,R20
 06EE           ; }
 06EE           ; void StartCommandTransfer(void)
 06EE           ; {
 06EE           ;       unsigned char i;
 06EE           ;       for(i = 0; i < SLAVE_NUM; i++)
 06EE 4427              clr R20
 06F0 11C0              xjmp L203
 06F2           L200:
 06F2           ; 	{
 06F2           ; 		if(TransmitControl.registerSlave[i] != 0)		// 找到第一个从机并设置默认命令，启动传输
 06F2 80E0              ldi R24,<_TransmitControl
 06F4 90E0              ldi R25,>_TransmitControl
 06F6 E42F              mov R30,R20
 06F8 FF27              clr R31
 06FA E80F              add R30,R24
 06FC F91F              adc R31,R25
 06FE 2080              ldd R2,z+0
 0700 2220              tst R2
 0702 39F0              breq L204
 0704           X56:
 0704           ; 		{
 0704           ; 			SetTransferBufStateQueryCmd(i);
 0704 042F              mov R16,R20
 0706 12DD              xcall _SetTransferBufStateQueryCmd
 0708           ;                       TransmitControl.curSlave = i;
 0708 4093BB00          sts _TransmitControl+15,R20
 070C           ;                       TransferStart = 1;
 070C 81E0              ldi R24,1
 070E 8093A200          sts _TransferStart,R24
 0712           ;               }
 0712           L204:
 0712           ; 	}
 0712           L201:
 0712 4395              inc R20
 0714           L203:
 0714 4F30              cpi R20,15
 0716 68F3              brlo L200
 0718           X57:
 0718           L199:
 0718                   .dbline 0 ; func end
 0718 4991              ld R20,y+
 071A 0895              ret
 071C           ;           pTop -> R14
 071C           ;              p -> R20
 071C           ;           pEnd -> R22
 071C           ;        pCmdStr -> R12,R13
 071C           ;       slaveNum -> R10
                        .even
 071C           _InsertCommand::
 071C 0E940000          xcall push_xgsetF0FC
 0720 6901              movw R12,R18
 0722 A02E              mov R10,R16
 0724 2197              sbiw R28,1
 0726           ; }
 0726           ; // 新命令
 0726           ; unsigned char InsertCommand(unsigned char slaveNum, COMMAND_STRING * pCmdStr){
 0726           ;       unsigned char pEnd, pTop, p;
 0726           ;       CLI();
 0726 F894              cli
 0728           ;       pTop = TransmitControl.cmdBuf[slaveNum].pTop;
 0728 0BE7              ldi R16,123
 072A 1A2D              mov R17,R10
 072C 0103              mulsu R16,R17
 072E 80E0              ldi R24,<_TransmitControl+17+120
 0730 90E0              ldi R25,>_TransmitControl+17+120
 0732 F001              movw R30,R0
 0734 E80F              add R30,R24
 0736 F91F              adc R31,R25
 0738 E080              ldd R14,z+0
 073A           ;       pEnd = TransmitControl.cmdBuf[slaveNum].pEnd;
 073A 0103              mulsu R16,R17
 073C 80E0              ldi R24,<_TransmitControl+17+121
 073E 90E0              ldi R25,>_TransmitControl+17+121
 0740 F001              movw R30,R0
 0742 E80F              add R30,R24
 0744 F91F              adc R31,R25
 0746 6081              ldd R22,z+0
 0748           ;       p = pEnd; // 1 1 
 0748 462F              mov R20,R22
 074A           ; 
 074A           ;       pEnd ++; // 1 2
 074A 6395              inc R22
 074C           ;       if(pEnd >= COMMAND_BUF_LEN)
 074C 6F30              cpi R22,15
 074E 08F0              brlo L212
 0750           X58:
 0750           ; 		pEnd = 0;
 0750 6627              clr R22
 0752           L212:
 0752           ; 	
 0752           ; 	if(pEnd != pTop) // 1 2 
 0752 6E15              cp R22,R14
 0754 29F1              breq L214
 0756           X59:
 0756           ; 	{
 0756           ; 		MemCopy(pCmdStr, &TransmitControl.cmdBuf[slaveNum].buf[p], sizeof(COMMAND_STRING)); // 1 2
 0756 88E0              ldi R24,8
 0758 8883              std y+0,R24
 075A 0BE7              ldi R16,123
 075C 1A2D              mov R17,R10
 075E 0103              mulsu R16,R17
 0760 1001              movw R2,R0
 0762 80E0              ldi R24,<_TransmitControl+17
 0764 90E0              ldi R25,>_TransmitControl+17
 0766 280E              add R2,R24
 0768 391E              adc R3,R25
 076A 242F              mov R18,R20
 076C 3327              clr R19
 076E 220F              lsl R18
 0770 331F              rol R19
 0772 220F              lsl R18
 0774 331F              rol R19
 0776 220F              lsl R18
 0778 331F              rol R19
 077A 220D              add R18,R2
 077C 331D              adc R19,R3
 077E 8601              movw R16,R12
 0780 0E940000          xcall _MemCopy
 0784           ;               p++; // 22 
 0784 4395              inc R20
 0786           ;               if(p == COMMAND_BUF_LEN)
 0786 4F30              cpi R20,15
 0788 09F4              brne L217
 078A           X60:
 078A           ; 			p = 0;
 078A 4427              clr R20
 078C           L217:
 078C           ; 		TransmitControl.cmdBuf[slaveNum].pEnd = p; // 2 2 
 078C 0BE7              ldi R16,123
 078E 1A2D              mov R17,R10
 0790 0103              mulsu R16,R17
 0792 80E0              ldi R24,<_TransmitControl+17+121
 0794 90E0              ldi R25,>_TransmitControl+17+121
 0796 F001              movw R30,R0
 0798 E80F              add R30,R24
 079A F91F              adc R31,R25
 079C 4083              std z+0,R20
 079E           ;       }
 079E 13C0              xjmp L215
 07A0           L214:
 07A0           ; 	else
 07A0           ; 	{
 07A0           ; 		Uart0ReUnable;
 07A0 8091C100          lds R24,193
 07A4 8F7E              andi R24,239
 07A6 8093C100          sts 193,R24
 07AA           ;               uart_Printf("// Command insert fail [%d]\r\n", slaveNum);
 07AA 2A2D              mov R18,R10
 07AC 3327              clr R19
 07AE 00E0              ldi R16,<L221
 07B0 10E0              ldi R17,>L221
 07B2 0E940000          xcall _uart_Printf
 07B6           ;               Uart0ReEnable;
 07B6 8091C100          lds R24,193
 07BA 8061              ori R24,16
 07BC 8093C100          sts 193,R24
 07C0           ;               SEI();
 07C0 7894              sei
 07C2           ;               return 1;
 07C2 01E0              ldi R16,1
 07C4 02C0              xjmp L207
 07C6           L215:
 07C6           ; 	}
 07C6           ; 	SEI();
 07C6 7894              sei
 07C8           ;       return 0;
 07C8 0027              clr R16
 07CA           L207:
 07CA                   .dbline 0 ; func end
 07CA 2196              adiw R28,1
 07CC 0C940000          xjmp pop_xgsetF0FC
 07D0           ;        pCmdStr -> R12,R13
 07D0           ;       slaveNum -> R10
                        .even
 07D0           _InsertUrgentCommand::
 07D0 0E940000          xcall push_xgset003C
 07D4 6901              movw R12,R18
 07D6 A02E              mov R10,R16
 07D8 2197              sbiw R28,1
 07DA           ; }
 07DA           ; 
 07DA           ; unsigned char InsertUrgentCommand(unsigned char slaveNum, COMMAND_STRING * pCmdStr){
 07DA           ; /*    unsigned char pEnd, pTop, p;
 07DA           ;       pTop = CmdUrgentBuf.pTop;
 07DA           ;       pEnd = CmdUrgentBuf.pEnd;
 07DA           ;       p = pEnd;
 07DA           ;       pEnd ++;
 07DA           ;       if(pEnd == COMMAND_BUF_LEN)
 07DA           ;               pEnd = 0;
 07DA           ;       if(pEnd != pTop){
 07DA           ;               MemCopy(pCmdStr, &CmdUrgentBuf.buf[p], sizeof(COMMAND_STRING));
 07DA           ;               CmdUrgentBuf.slaveNum[p] = slaveNum;
 07DA           ;               CmdUrgentBuf.pEnd = pEnd;
 07DA           ;               }
 07DA           ;       else{
 07DA           ;               uart_Printf("// UrgentCommand insert fail [%d]\r\n", slaveNum);
 07DA           ;               return 1;       
 07DA           ;               }
 07DA           ;       return 0;*/
 07DA           ;       CLI();
 07DA F894              cli
 07DC           ;       if(CmdUrgentBuf.state[slaveNum] == 0){
 07DC 80E0              ldi R24,<_CmdUrgentBuf+120
 07DE 90E0              ldi R25,>_CmdUrgentBuf+120
 07E0 EA2D              mov R30,R10
 07E2 FF27              clr R31
 07E4 E80F              add R30,R24
 07E6 F91F              adc R31,R25
 07E8 2080              ldd R2,z+0
 07EA 2220              tst R2
 07EC D1F4              brne L223
 07EE           X61:
 07EE           ; 		MemCopy(pCmdStr, &CmdUrgentBuf.buf[slaveNum], sizeof(COMMAND_STRING));
 07EE 88E0              ldi R24,8
 07F0 8883              std y+0,R24
 07F2 80E0              ldi R24,<_CmdUrgentBuf
 07F4 90E0              ldi R25,>_CmdUrgentBuf
 07F6 2A2D              mov R18,R10
 07F8 3327              clr R19
 07FA 220F              lsl R18
 07FC 331F              rol R19
 07FE 220F              lsl R18
 0800 331F              rol R19
 0802 220F              lsl R18
 0804 331F              rol R19
 0806 280F              add R18,R24
 0808 391F              adc R19,R25
 080A 8601              movw R16,R12
 080C 0E940000          xcall _MemCopy
 0810           ;               CmdUrgentBuf.state[slaveNum] = 1;
 0810 80E0              ldi R24,<_CmdUrgentBuf+120
 0812 90E0              ldi R25,>_CmdUrgentBuf+120
 0814 EA2D              mov R30,R10
 0816 FF27              clr R31
 0818 E80F              add R30,R24
 081A F91F              adc R31,R25
 081C 81E0              ldi R24,1
 081E 8083              std z+0,R24
 0820           ;               }
 0820 13C0              xjmp L224
 0822           L223:
 0822           ; 	else{
 0822           ; 		Uart0ReUnable;
 0822 8091C100          lds R24,193
 0826 8F7E              andi R24,239
 0828 8093C100          sts 193,R24
 082C           ;               uart_Printf("// UrgentCommand insert fail [%d]\r\n", slaveNum);
 082C 2A2D              mov R18,R10
 082E 3327              clr R19
 0830 00E0              ldi R16,<L227
 0832 10E0              ldi R17,>L227
 0834 0E940000          xcall _uart_Printf
 0838           ;               Uart0ReEnable;
 0838 8091C100          lds R24,193
 083C 8061              ori R24,16
 083E 8093C100          sts 193,R24
 0842           ;               SEI();
 0842 7894              sei
 0844           ;               return 1;
 0844 01E0              ldi R16,1
 0846 02C0              xjmp L222
 0848           L224:
 0848           ; 		}
 0848           ; 	SEI();
 0848 7894              sei
 084A           ;       return 0;
 084A 0027              clr R16
 084C           L222:
 084C                   .dbline 0 ; func end
 084C 2196              adiw R28,1
 084E 0C940000          xjmp pop_xgset003C
 0852           ;           pTop -> R12
 0852           ;           pEnd -> R14
 0852           ;       slaveNum -> R10
                        .even
 0852           _GetSlaveState::
 0852 0E940000          xcall push_xgset00FC
 0856 A02E              mov R10,R16
 0858           ; }
 0858           ; 
 0858           ; unsigned char GetSlaveState(unsigned char slaveNum)
 0858           ; {
 0858           ;       // 获取从机状态
 0858           ;       unsigned char pEnd, pTop;
 0858           ;       pTop = TransmitControl.cmdBuf[slaveNum].pTop;
 0858 0BE7              ldi R16,123
 085A 1A2D              mov R17,R10
 085C 0103              mulsu R16,R17
 085E 80E0              ldi R24,<_TransmitControl+17+120
 0860 90E0              ldi R25,>_TransmitControl+17+120
 0862 F001              movw R30,R0
 0864 E80F              add R30,R24
 0866 F91F              adc R31,R25
 0868 C080              ldd R12,z+0
 086A           ;       pEnd = TransmitControl.cmdBuf[slaveNum].pEnd;
 086A 0103              mulsu R16,R17
 086C 80E0              ldi R24,<_TransmitControl+17+121
 086E 90E0              ldi R25,>_TransmitControl+17+121
 0870 F001              movw R30,R0
 0872 E80F              add R30,R24
 0874 F91F              adc R31,R25
 0876 E080              ldd R14,z+0
 0878           ;       if(pTop == pEnd)                // 如果命令队列空，返回记录的电机状态
 0878 CE14              cp R12,R14
 087A 41F4              brne L233
 087C           X62:
 087C           ; 		return TransmitControl.slaveState[slaveNum];
 087C 80E0              ldi R24,<_TransmitControl+1862
 087E 90E0              ldi R25,>_TransmitControl+1862
 0880 EA2D              mov R30,R10
 0882 FF27              clr R31
 0884 E80F              add R30,R24
 0886 F91F              adc R31,R25
 0888 0081              ldd R16,z+0
 088A 01C0              xjmp L228
 088C           L233:
 088C           ; 	else					// 如果命令队列不空，返回忙状态
 088C           ; 		return STA_SLAVE_BUSY;
 088C 02E0              ldi R16,2
 088E           L228:
 088E                   .dbline 0 ; func end
 088E 0C940000          xjmp pop_xgset00FC
                        .area data(ram, con, rel)
 0001           _SendEventCritical:
 0001                   .blkb 1
                        .area idata
 0001 00                .byte 0
                        .area data(ram, con, rel)
                        .area text(rom, con, rel)
                ;           pTop -> R20
                        .even
 0892           _SendInfoEvent::
 0892 4A93              st -y,R20
 0894           ; }
 0894           ; 
 0894           ; static unsigned char SendEventCritical = 0;           // 临界值保护防函数重入
 0894           ; void SendInfoEvent(void)
 0894           ; {
 0894           ;       // 向模块的上层应用发送信息事件，定时调用
 0894           ;       unsigned char pTop;
 0894           ;       
 0894           ;       if(SendEventCritical)
 0894 20900100          lds R2,_SendEventCritical
 0898 2220              tst R2
 089A 09F0              breq L237
 089C           X63:
 089C           ; 		return;
 089C 1CC0              xjmp L236
 089E           L237:
 089E           ; 	SendEventCritical = 1;
 089E 81E0              ldi R24,1
 08A0 80930100          sts _SendEventCritical,R24
 08A4           ;       pTop = InfoEventStack.pTop;
 08A4 40910108          lds R20,_InfoEventStack
 08A8           ;       if(pTop != InfoEventStack.pEnd)
 08A8 20900208          lds R2,_InfoEventStack+1
 08AC 4215              cp R20,R2
 08AE 81F0              breq L239
 08B0           X64:
 08B0           ; 	{
 08B0           ; 		// 发送消息事件
 08B0           ; 		SlaveEventAssignProcess(&InfoEventStack.info[pTop]);
 08B0 0DE0              ldi R16,13
 08B2 142F              mov R17,R20
 08B4 0103              mulsu R16,R17
 08B6 8001              movw R16,R0
 08B8 80E0              ldi R24,<_InfoEventStack+2
 08BA 90E0              ldi R25,>_InfoEventStack+2
 08BC 080F              add R16,R24
 08BE 191F              adc R17,R25
 08C0 0E940000          xcall _SlaveEventAssignProcess
 08C4           ;               pTop ++;
 08C4 4395              inc R20
 08C6           ;               if(pTop == INFO_EVENT_NUM)
 08C6 4233              cpi R20,50
 08C8 09F4              brne L243
 08CA           X65:
 08CA           ; 			pTop = 0;
 08CA 4427              clr R20
 08CC           L243:
 08CC           ; 		InfoEventStack.pTop = pTop;
 08CC 40930108          sts _InfoEventStack,R20
 08D0           ;       }
 08D0           L239:
 08D0           ; 	SendEventCritical = 0;
 08D0 2224              clr R2
 08D2 20920100          sts _SendEventCritical,R2
 08D6           L236:
 08D6                   .dbline 0 ; func end
 08D6 4991              ld R20,y+
 08D8 0895              ret
                        .area bss(ram, con, rel)
 0003           _CommandBackFlag:
 0003                   .blkb 1
 0004           _CmdUrgentBuf::
 0004                   .blkb 135
 008B           _DeviceInfo::
 008B                   .blkb 23
 00A2           _TransferStart::
 00A2                   .blkb 1
 00A3           _TransferBuf::
 00A3                   .blkb 9
 00AC           _TransmitControl::
 00AC                   .blkb 1877
 0801           _InfoEventStack::
 0801                   .blkb 652
                        .area data(ram, con, rel)
 0002           L227:
 0002                   .blkb 36
                        .area idata
 0002 2F2F20557267656E74436F6D6D616E64  .byte 47,47,32,'U,'r,'g,'e,'n,'t,'C,'o,'m,'m,'a,'n,'d
 0012 20696E73657274206661696C205B2564  .byte 32,'i,'n,'s,'e,'r,'t,32,'f,'a,'i,'l,32,91,37,'d
 0022 5D0D0A00          .byte 93,13,10,0
                        .area data(ram, con, rel)
 0026           L221:
 0026                   .blkb 30
                        .area idata
 0026 2F2F20436F6D6D616E6420696E736572  .byte 47,47,32,'C,'o,'m,'m,'a,'n,'d,32,'i,'n,'s,'e,'r
 0036 74206661696C205B25645D0D0A00      .byte 't,32,'f,'a,'i,'l,32,91,37,'d,93,13,10,0
                        .area data(ram, con, rel)
 0044           L164:
 0044                   .blkb 21
                        .area idata
 0044 2F2F436D644261636B4572722C4E6F3A  .byte 47,47,'C,'m,'d,'B,'a,'c,'k,'E,'r,'r,44,'N,'o,58
 0054 25640D0A00        .byte 37,'d,13,10,0
                        .area data(ram, con, rel)
 0059           L132:
 0059                   .blkb 38
                        .area idata
 0059 2F2F20496E666F206572722C4E756D3A  .byte 47,47,32,'I,'n,'f,'o,32,'e,'r,'r,44,'N,'u,'m,58
 0069 25642C53756D3A25642C25642825642C  .byte 37,'d,44,'S,'u,'m,58,37,'d,44,37,'d,40,37,'d,44
 0079 2564290D0A00      .byte 37,'d,41,13,10,0
                        .area data(ram, con, rel)
 007F           L82:
 007F                   .blkb 23
                        .area idata
 007F 2F2F4461746153656E64457272322C4E  .byte 47,47,'D,'a,'t,'a,'S,'e,'n,'d,'E,'r,'r,50,44,'N
 008F 6F3A25640D0A00    .byte 'o,58,37,'d,13,10,0
                        .area data(ram, con, rel)
 0096           L74:
 0096                   .blkb 23
                        .area idata
 0096 2F2F4461746153656E64457272312C4E  .byte 47,47,'D,'a,'t,'a,'S,'e,'n,'d,'E,'r,'r,49,44,'N
 00A6 6F3A25640D0A00    .byte 'o,58,37,'d,13,10,0
                        .area data(ram, con, rel)
 00AD           L41:
 00AD                   .blkb 22
                        .area idata
 00AD 2F2F20536C6176654E756D206572726F  .byte 47,47,32,'S,'l,'a,'v,'e,'N,'u,'m,32,'e,'r,'r,'o
 00BD 7221200D0A00      .byte 'r,33,32,13,10,0
                        .area data(ram, con, rel)
 00C3           L37:
 00C3                   .blkb 25
                        .area idata
 00C3 2F2F204576656E207361766520666169  .byte 47,47,32,'E,'v,'e,'n,32,'s,'a,'v,'e,32,'f,'a,'i
 00D3 6C205B25645D0D0A00        .byte 'l,32,91,37,'d,93,13,10,0
                        .area data(ram, con, rel)
                ; }
                ; 
                ; 
                ; /********************************************* File end **********************************************/
                ; 
