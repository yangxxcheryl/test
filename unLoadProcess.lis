                        .module unLoadProcess.c
                        .area data(ram, con, rel)
 0000           _wasteCardNoneUseful::
 0000                   .blkb 1
                        .area idata
 0000 00                .byte 0
                        .area data(ram, con, rel)
                        .area text(rom, con, rel)
                ;              m -> R20
                        .even
 0000           _SetWasteCardState::
 0000 4A93              st -y,R20
 0002 402F              mov R20,R16
 0004 2297              sbiw R28,2
 0006           ; 
 0006           ; #include <iom1280v.h>
 0006           ; #include "B1404_LIB.h"
 0006           ; #include "Common.h"
 0006           ; #include "eeprom.h"
 0006           ; 
 0006           ; 
 0006           ; extern RING_QUEUE     RingQueue;
 0006           ; extern unsigned char insertflag[30];
 0006           ; UNLOAD_QUEUE UnloadQueue;
 0006           ; extern unsigned long SecondCount;     // 秒时钟计数
 0006           ; extern unsigned char TurnPlateUsedLock;               // 转盘使用锁
 0006           ; 
 0006           ; // 废片盒处理
 0006           ; unsigned long TranCanCountBase;
 0006           ; unsigned char TrashCanState;
 0006           ; extern unsigned char WorkProcessStep;
 0006           ; extern SAMP_INFO NewTestInfo;
 0006           ; extern unsigned char stopTestFlag;                    // 停止测试,如果废片仓连续开启时间超过20分钟
 0006           ; unsigned char wasteCardNoneUseful = 0;                // 废片仓功能开启 0   关闭 1
 0006           ; 
 0006           ; // 设置是否使用废片仓  0 使用  1 不使用
 0006           ; void SetWasteCardState(unsigned char m)
 0006           ; {
 0006           ;       if(m > 1)
 0006 81E0              ldi R24,1
 0008 8417              cp R24,R20
 000A 08F4              brsh L2
 000C           X0:
 000C           ; 		m = 1;
 000C 41E0              ldi R20,1
 000E           L2:
 000E           ; 	wasteCardNoneUseful = m;
 000E 40930000          sts _wasteCardNoneUseful,R20
 0012           ;       Uart0ReUnable;
 0012 8091C100          lds R24,193
 0016 8F7E              andi R24,239
 0018 8093C100          sts 193,R24
 001C           ;       uart_Printf("%s $%4d\r\n", strM3118, m);
 001C 242E              mov R2,R20
 001E 3324              clr R3
 0020 3982              std y+1,R3
 0022 2882              std y+0,R2
 0024 20E0              ldi R18,<_strM3118
 0026 30E0              ldi R19,>_strM3118
 0028 00E0              ldi R16,<L4
 002A 10E0              ldi R17,>L4
 002C 0E940000          xcall _uart_Printf
 0030           ;       Uart0ReEnable;
 0030 8091C100          lds R24,193
 0034 8061              ori R24,16
 0036 8093C100          sts 193,R24
 003A           L1:
 003A                   .dbline 0 ; func end
 003A 2296              adiw R28,2
 003C 4991              ld R20,y+
 003E 0895              ret
                        .even
 0040           _GetwasteCardState::
 0040           ; }
 0040           ; 
 0040           ; unsigned char GetwasteCardState(void)
 0040           ; {
 0040           ; 	return wasteCardNoneUseful;
 0040 00910000          lds R16,_wasteCardNoneUseful
 0044           L5:
 0044                   .dbline 0 ; func end
 0044 0895              ret
 0046           ;          pChar -> R22,R23
 0046           ;              i -> R20,R21
                        .even
 0046           _UnloadQueueDatInit::
 0046 0E940000          xcall push_xgsetF000
 004A           ; }
 004A           ; 
 004A           ; void UnloadQueueDatInit(void)
 004A           ; {
 004A           ;       unsigned int i;
 004A           ;       unsigned char *pChar;
 004A           ; 
 004A           ;       pChar = (unsigned char *)&(UnloadQueue);
 004A 60E0              ldi R22,<_UnloadQueue
 004C 70E0              ldi R23,>_UnloadQueue
 004E           ;       for(i = 0; i < sizeof(UNLOAD_QUEUE); i++)
 004E 4427              clr R20
 0050 5527              clr R21
 0052 06C0              xjmp L10
 0054           L7:
 0054           ; 	{
 0054           ; 		*pChar++ = 0;
 0054 2224              clr R2
 0056 FB01              movw R30,R22
 0058 2192              st Z+,R2
 005A BF01              movw R22,R30
 005C           ;       }
 005C           L8:
 005C 4F5F              subi R20,255  ; offset = 1
 005E 5F4F              sbci R21,255
 0060           L10:
 0060 4839              cpi R20,152
 0062 E0E0              ldi R30,0
 0064 5E07              cpc R21,R30
 0066 B0F3              brlo L7
 0068           X1:
 0068           ; 	for(i = 0; i < TEST_QUEUE_NUM; i++)
 0068 4427              clr R20
 006A 5527              clr R21
 006C 09C0              xjmp L14
 006E           L11:
 006E           ; 	{
 006E           ; 		UnloadQueue.ringNum[i] = 0xff;
 006E 80E0              ldi R24,<_UnloadQueue
 0070 90E0              ldi R25,>_UnloadQueue
 0072 FA01              movw R30,R20
 0074 E80F              add R30,R24
 0076 F91F              adc R31,R25
 0078 8FEF              ldi R24,255
 007A 8083              std z+0,R24
 007C           ;       }
 007C           L12:
 007C 4F5F              subi R20,255  ; offset = 1
 007E 5F4F              sbci R21,255
 0080           L14:
 0080 4832              cpi R20,40
 0082 E0E0              ldi R30,0
 0084 5E07              cpc R21,R30
 0086 98F3              brlo L11
 0088           X2:
 0088           ; 	TranCanCountBase = ReadCurTestSetial();
 0088 0E940000          xcall _ReadCurTestSetial
 008C 10931300          sts _TranCanCountBase+1,R17
 0090 00931200          sts _TranCanCountBase,R16
 0094 30931500          sts _TranCanCountBase+2+1,R19
 0098 20931400          sts _TranCanCountBase+2,R18
 009C           L6:
 009C                   .dbline 0 ; func end
 009C 0C940000          xjmp pop_xgsetF000
 00A0           ;              n -> R22
 00A0           ;              i -> R20
 00A0           ;           time -> y+2
 00A0           ;        ringNum -> R16
                        .even
 00A0           _UnloadQueueAdd::
 00A0 3A93              st -y,r19
 00A2 2A93              st -y,r18
 00A4 4A93              st -y,R20
 00A6 6A93              st -y,R22
 00A8           ; }
 00A8           ; 
 00A8           ; // 卸片任务入队
 00A8           ; void UnloadQueueAdd(unsigned char ringNum, signed long time)
 00A8           ; {
 00A8           ;       // 根据时间先后顺序将待卸载干片位置号放入卸片队列中等待卸片
 00A8           ;       unsigned char n, i;
 00A8           ; 
 00A8           ;       // 查找出插入位置
 00A8           ;       for(n=0; n<RING_QUEUE_NUM; n++)
 00A8 6627              clr R22
 00AA 23C0              xjmp L19
 00AC           L16:
 00AC           ; 	{
 00AC           ; 		if(UnloadQueue.ringNum[n] == 0xff)		// 已经到队尾了，直接插入到队尾
 00AC 80E0              ldi R24,<_UnloadQueue
 00AE 90E0              ldi R25,>_UnloadQueue
 00B0 E62F              mov R30,R22
 00B2 FF27              clr R31
 00B4 E80F              add R30,R24
 00B6 F91F              adc R31,R25
 00B8 8081              ldd R24,z+0
 00BA 8F3F              cpi R24,255
 00BC 09F4              brne L20
 00BE           X3:
 00BE           ; 			break;
 00BE 1BC0              xjmp L18
 00C0           L20:
 00C0           ; 		else
 00C0           ; 		{
 00C0           ; 			if(UnloadQueue.unloadTime[n] > time)
 00C0 80E0              ldi R24,<_UnloadQueue+30
 00C2 90E0              ldi R25,>_UnloadQueue+30
 00C4 E62F              mov R30,R22
 00C6 FF27              clr R31
 00C8 EE0F              lsl R30
 00CA FF1F              rol R31
 00CC EE0F              lsl R30
 00CE FF1F              rol R31
 00D0 E80F              add R30,R24
 00D2 F91F              adc R31,R25
 00D4 2080              ldd R2,z+0
 00D6 3180              ldd R3,z+1
 00D8 4280              ldd R4,z+2
 00DA 5380              ldd R5,z+3
 00DC 6A80              ldd R6,y+2
 00DE 7B80              ldd R7,y+3
 00E0 8C80              ldd R8,y+4
 00E2 9D80              ldd R9,y+5
 00E4 6214              cp R6,R2
 00E6 7304              cpc R7,R3
 00E8 8404              cpc R8,R4
 00EA 9504              cpc R9,R5
 00EC 0CF4              brge L22
 00EE           X4:
 00EE           ; 			{
 00EE           ; 				break;							// 查找到当前的元素的卸载时间比插入的更晚，插入当前位置
 00EE 03C0              xjmp L18
 00F0           L22:
 00F0           ; 			}
 00F0           ; 		}
 00F0           ; 	}
 00F0           L17:
 00F0 6395              inc R22
 00F2           L19:
 00F2 6E31              cpi R22,30
 00F4 D8F2              brlo L16
 00F6           X5:
 00F6           L18:
 00F6           ; 	// n为查找到的插入位置
 00F6           ; 	i = RING_QUEUE_NUM - 1;
 00F6 4DE1              ldi R20,29
 00F8 46C0              xjmp L26
 00FA           L25:
 00FA           ; 	while(i--)
 00FA           ; 	{
 00FA           ; 		if(i != n)
 00FA 4617              cp R20,R22
 00FC 51F1              breq L28
 00FE           X6:
 00FE           ; 		{
 00FE           ; 			// 插入位置后面的元素往后移动一步
 00FE           ; 			UnloadQueue.unloadTime[i] = UnloadQueue.unloadTime[i-1];
 00FE 80E0              ldi R24,<_UnloadQueue+30
 0100 90E0              ldi R25,>_UnloadQueue+30
 0102 E42F              mov R30,R20
 0104 FF27              clr R31
 0106 3197              sbiw R30,1
 0108 EE0F              lsl R30
 010A FF1F              rol R31
 010C EE0F              lsl R30
 010E FF1F              rol R31
 0110 E80F              add R30,R24
 0112 F91F              adc R31,R25
 0114 2080              ldd R2,z+0
 0116 3180              ldd R3,z+1
 0118 4280              ldd R4,z+2
 011A 5380              ldd R5,z+3
 011C E42F              mov R30,R20
 011E FF27              clr R31
 0120 EE0F              lsl R30
 0122 FF1F              rol R31
 0124 EE0F              lsl R30
 0126 FF1F              rol R31
 0128 E80F              add R30,R24
 012A F91F              adc R31,R25
 012C 2082              std z+0,R2
 012E 3182              std z+1,R3
 0130 4282              std z+2,R4
 0132 5382              std z+3,R5
 0134           ;                       UnloadQueue.ringNum[i] = UnloadQueue.ringNum[i-1];
 0134 80E0              ldi R24,<_UnloadQueue-1
 0136 90E0              ldi R25,>_UnloadQueue-1
 0138 E42F              mov R30,R20
 013A FF27              clr R31
 013C E80F              add R30,R24
 013E F91F              adc R31,R25
 0140 2080              ldd R2,z+0
 0142 80E0              ldi R24,<_UnloadQueue
 0144 90E0              ldi R25,>_UnloadQueue
 0146 E42F              mov R30,R20
 0148 FF27              clr R31
 014A E80F              add R30,R24
 014C F91F              adc R31,R25
 014E 2082              std z+0,R2
 0150           ;               }
 0150 1AC0              xjmp L29
 0152           L28:
 0152           ; 		else
 0152           ; 		{	
 0152           ; 			// 插入新的任务
 0152           ; 			UnloadQueue.unloadTime[i] = time;
 0152 80E0              ldi R24,<_UnloadQueue+30
 0154 90E0              ldi R25,>_UnloadQueue+30
 0156 E42F              mov R30,R20
 0158 FF27              clr R31
 015A EE0F              lsl R30
 015C FF1F              rol R31
 015E EE0F              lsl R30
 0160 FF1F              rol R31
 0162 E80F              add R30,R24
 0164 F91F              adc R31,R25
 0166 2A80              ldd R2,y+2
 0168 3B80              ldd R3,y+3
 016A 4C80              ldd R4,y+4
 016C 5D80              ldd R5,y+5
 016E 2082              std z+0,R2
 0170 3182              std z+1,R3
 0172 4282              std z+2,R4
 0174 5382              std z+3,R5
 0176           ;                       UnloadQueue.ringNum[i] = ringNum;
 0176 80E0              ldi R24,<_UnloadQueue
 0178 90E0              ldi R25,>_UnloadQueue
 017A E42F              mov R30,R20
 017C FF27              clr R31
 017E E80F              add R30,R24
 0180 F91F              adc R31,R25
 0182 0083              std z+0,R16
 0184           ;                       break;
 0184 06C0              xjmp L27
 0186           L29:
 0186           ; 		}
 0186           ; 	}
 0186           L26:
 0186 242E              mov R2,R20
 0188 3324              clr R3
 018A 4150              subi R20,1
 018C 2220              tst R2
 018E 09F0              breq X8
 0190 B4CF              xjmp L25
 0192           X8:
 0192           X7:
 0192           L27:
 0192           L15:
 0192                   .dbline 0 ; func end
 0192 6991              ld R22,y+
 0194 4991              ld R20,y+
 0196 2296              adiw R28,2
 0198 0895              ret
 019A           ;              i -> R16
                        .even
 019A           _UnloadQueueForward::
 019A           ; }
 019A           ; 
 019A           ; void UnloadQueueForward(){
 019A           ; 	// 测试队列前进一步，当队头测试完毕后，队头元素删除队列前进一步
 019A           ; 	unsigned char i;
 019A           ; 	for(i=0; i<RING_QUEUE_NUM; i++)
 019A 0027              clr R16
 019C 44C0              xjmp L38
 019E           L35:
 019E           ; 	{
 019E           ; 		if(i != (RING_QUEUE_NUM-1))
 019E 0D31              cpi R16,29
 01A0 51F1              breq L39
 01A2           X9:
 01A2           ; 		{
 01A2           ; 			// 每个元素往前移动一个，队头元素被后面覆盖
 01A2           ; 			UnloadQueue.unloadTime[i] = UnloadQueue.unloadTime[i+1];
 01A2 80E0              ldi R24,<_UnloadQueue+30
 01A4 90E0              ldi R25,>_UnloadQueue+30
 01A6 E02F              mov R30,R16
 01A8 FF27              clr R31
 01AA 3196              adiw R30,1
 01AC EE0F              lsl R30
 01AE FF1F              rol R31
 01B0 EE0F              lsl R30
 01B2 FF1F              rol R31
 01B4 E80F              add R30,R24
 01B6 F91F              adc R31,R25
 01B8 2080              ldd R2,z+0
 01BA 3180              ldd R3,z+1
 01BC 4280              ldd R4,z+2
 01BE 5380              ldd R5,z+3
 01C0 E02F              mov R30,R16
 01C2 FF27              clr R31
 01C4 EE0F              lsl R30
 01C6 FF1F              rol R31
 01C8 EE0F              lsl R30
 01CA FF1F              rol R31
 01CC E80F              add R30,R24
 01CE F91F              adc R31,R25
 01D0 2082              std z+0,R2
 01D2 3182              std z+1,R3
 01D4 4282              std z+2,R4
 01D6 5382              std z+3,R5
 01D8           ;                       UnloadQueue.ringNum[i] = UnloadQueue.ringNum[i+1];
 01D8 80E0              ldi R24,<_UnloadQueue+1
 01DA 90E0              ldi R25,>_UnloadQueue+1
 01DC E02F              mov R30,R16
 01DE FF27              clr R31
 01E0 E80F              add R30,R24
 01E2 F91F              adc R31,R25
 01E4 2080              ldd R2,z+0
 01E6 80E0              ldi R24,<_UnloadQueue
 01E8 90E0              ldi R25,>_UnloadQueue
 01EA E02F              mov R30,R16
 01EC FF27              clr R31
 01EE E80F              add R30,R24
 01F0 F91F              adc R31,R25
 01F2 2082              std z+0,R2
 01F4           ;               }
 01F4 17C0              xjmp L40
 01F6           L39:
 01F6           ; 		else
 01F6           ; 		{
 01F6           ; 			// 队尾填充零
 01F6           ; 			UnloadQueue.unloadTime[i] = 0;
 01F6 80E0              ldi R24,<_UnloadQueue+30
 01F8 90E0              ldi R25,>_UnloadQueue+30
 01FA E02F              mov R30,R16
 01FC FF27              clr R31
 01FE EE0F              lsl R30
 0200 FF1F              rol R31
 0202 EE0F              lsl R30
 0204 FF1F              rol R31
 0206 E80F              add R30,R24
 0208 F91F              adc R31,R25
 020A 80E0              ldi R24,0
 020C 8083              std z+0,R24
 020E 8183              std z+1,R24
 0210 8283              std z+2,R24
 0212 8383              std z+3,R24
 0214           ;                       UnloadQueue.ringNum[i] = 0xff;
 0214 80E0              ldi R24,<_UnloadQueue
 0216 90E0              ldi R25,>_UnloadQueue
 0218 E02F              mov R30,R16
 021A FF27              clr R31
 021C E80F              add R30,R24
 021E F91F              adc R31,R25
 0220 8FEF              ldi R24,255
 0222 8083              std z+0,R24
 0224           ;               }
 0224           L40:
 0224           ; 	}
 0224           L36:
 0224 0395              inc R16
 0226           L38:
 0226 0E31              cpi R16,30
 0228 08F4              brsh X11
 022A B9CF              xjmp L35
 022C           X11:
 022C           X10:
 022C           L34:
 022C                   .dbline 0 ; func end
 022C 0895              ret
                        .even
 022E           _printf_UnloadProcess_StepState::
 022E 2297              sbiw R28,2
 0230           ; }
 0230           ; 
 0230           ; static unsigned char UnloadProcess_workStep,UnloadProcess_mainStep;
 0230           ; 
 0230           ; void printf_UnloadProcess_StepState(void)
 0230           ; {
 0230           ;       uart_Printf("*3202 UnloadStepState $%2d $%2d\r\n",UnloadProcess_mainStep,UnloadProcess_workStep);
 0230 20901000          lds R2,_UnloadProcess_workStep
 0234 3324              clr R3
 0236 3982              std y+1,R3
 0238 2882              std y+0,R2
 023A 20910F00          lds R18,_UnloadProcess_mainStep
 023E 3327              clr R19
 0240 00E0              ldi R16,<L46
 0242 10E0              ldi R17,>L46
 0244 0E940000          xcall _uart_Printf
 0248           L45:
 0248                   .dbline 0 ; func end
 0248 2296              adiw R28,2
 024A 0895              ret
                        .area bss(ram, con, rel)
 0000           L48:
 0000                   .blkb 1
 0001           L49:
 0001                   .blkb 1
 0002           L50:
 0002                   .blkb 1
 0003           L51:
 0003                   .blkb 1
 0004           L52:
 0004                   .blkb 1
 0005           L53:
 0005                   .blkb 1
 0006           L54:
 0006                   .blkb 1
 0007           L55:
 0007                   .blkb 1
 0008           L56:
 0008                   .blkb 1
 0009           L57:
 0009                   .blkb 1
                        .area text(rom, con, rel)
                ;          ucTmp -> R20
                ;              i -> R20,R21
                ;              l -> y+4
                        .even
 024C           _UnloadQueueProcess::
 024C 0E940000          xcall push_xgset300C
 0250 2897              sbiw R28,8
 0252           ; }
 0252           ; 
 0252           ; unsigned char UnloadQueueProcess(void){
 0252           ;       // 监测卸片队列上的卸片时间，将到时间的干片卸载
 0252           ;       static unsigned char mainStep;          
 0252           ;       static unsigned char workStep;
 0252           ;       static unsigned char inWork;
 0252           ;       static unsigned char ringNum;
 0252           ;       static unsigned char n,m,j,k;
 0252           ;       static unsigned char watiMotTurnplate, waitMotUnload;
 0252           ;       unsigned char ucTmp;
 0252           ;       unsigned int i;
 0252           ;       unsigned long l;
 0252           ;       UnloadProcess_mainStep = mainStep;
 0252 20900000          lds R2,L48
 0256 20920F00          sts _UnloadProcess_mainStep,R2
 025A           ;       UnloadProcess_workStep = workStep;
 025A 20900100          lds R2,L49
 025E 20921000          sts _UnloadProcess_workStep,R2
 0262           ;       if(inWork)
 0262 20900200          lds R2,L50
 0266 2220              tst R2
 0268 21F1              breq L58
 026A           X12:
 026A           ; 	{
 026A           ; 		if(WaitDelayTime(MOT_CARD_UNLOAD))		return 0;
 026A 05E0              ldi R16,5
 026C 0E940000          xcall _WaitDelayTime
 0270 0023              tst R16
 0272 11F0              breq L60
 0274           X13:
 0274 0027              clr R16
 0276 20C2              xjmp L47
 0278           L60:
 0278           ; 		if(watiMotTurnplate)
 0278 20900800          lds R2,L56
 027C 2220              tst R2
 027E 51F0              breq L62
 0280           X14:
 0280           ; 		{	// 等待转盘电机
 0280           ; 			if(GetMotState(MOT_TURN_PLATE)!=STA_SLAVE_FREE)	return 0;
 0280 01E0              ldi R16,1
 0282 0E940000          xcall _GetMotState
 0286 0130              cpi R16,1
 0288 11F0              breq L64
 028A           X15:
 028A 0027              clr R16
 028C 15C2              xjmp L47
 028E           L64:
 028E           ; 			watiMotTurnplate = 0;
 028E 2224              clr R2
 0290 20920800          sts L56,R2
 0294           ;               }
 0294           L62:
 0294           ; 		if(waitMotUnload)	// 等待干片卸载电机
 0294 20900900          lds R2,L57
 0298 2220              tst R2
 029A 59F0              breq L66
 029C           X16:
 029C           ; 		{
 029C           ; 			if(GetMotState(MOT_CARD_UNLOAD)!=STA_SLAVE_FREE)	return 0;
 029C 05E0              ldi R16,5
 029E 0E940000          xcall _GetMotState
 02A2 402F              mov R20,R16
 02A4 0130              cpi R16,1
 02A6 11F0              breq L68
 02A8           X17:
 02A8 0027              clr R16
 02AA 06C2              xjmp L47
 02AC           L68:
 02AC           ; 			waitMotUnload = 0;
 02AC 2224              clr R2
 02AE 20920900          sts L57,R2
 02B2           ;               }
 02B2           L66:
 02B2           ; 	}
 02B2           L58:
 02B2           ; 	switch(mainStep)
 02B2 40910000          lds R20,L48
 02B6 5527              clr R21
 02B8 4030              cpi R20,0
 02BA 4507              cpc R20,R21
 02BC 81F0              breq L73
 02BE           X18:
 02BE 4130              cpi R20,1
 02C0 E0E0              ldi R30,0
 02C2 5E07              cpc R21,R30
 02C4 09F4              brne X44
 02C6 56C0              xjmp L89
 02C8           X44:
 02C8           X19:
 02C8 4230              cpi R20,2
 02CA E0E0              ldi R30,0
 02CC 5E07              cpc R21,R30
 02CE 09F4              brne X45
 02D0 95C1              xjmp L117
 02D2           X45:
 02D2           X20:
 02D2 4330              cpi R20,3
 02D4 E0E0              ldi R30,0
 02D6 5E07              cpc R21,R30
 02D8 09F4              brne X46
 02DA E5C1              xjmp L122
 02DC           X46:
 02DC           X21:
 02DC ECC1              xjmp L70
 02DE           L73:
 02DE           ; 	{
 02DE           ; 		case 0:		// 监测队头的时间
 02DE           ; 			if(UnloadQueue.ringNum[0] != 0xff)
 02DE 80911600          lds R24,_UnloadQueue
 02E2 8F3F              cpi R24,255
 02E4 09F4              brne X47
 02E6 44C0              xjmp L74
 02E8           X47:
 02E8           X22:
 02E8           ; 			{
 02E8           ; 				if(UnloadQueue.unloadTime[0] < SecondCount)
 02E8 40900200          lds R4,_SecondCount+2
 02EC 50900300          lds R5,_SecondCount+2+1
 02F0 20900000          lds R2,_SecondCount
 02F4 30900100          lds R3,_SecondCount+1
 02F8 80903600          lds R8,_UnloadQueue+30+2
 02FC 90903700          lds R9,_UnloadQueue+30+2+1
 0300 60903400          lds R6,_UnloadQueue+30
 0304 70903500          lds R7,_UnloadQueue+30+1
 0308 6214              cp R6,R2
 030A 7304              cpc R7,R3
 030C 8404              cpc R8,R4
 030E 9504              cpc R9,R5
 0310 08F0              brlo X48
 0312 D1C1              xjmp L71
 0314           X48:
 0314           X23:
 0314           ; 				{
 0314           ; 					ringNum = UnloadQueue.ringNum[0];
 0314 282E              mov R2,R24
 0316 20920300          sts L51,R2
 031A           ;                                       
 031A           ;                                       // 废片仓功能开启
 031A           ;                                       if(GetwasteCardState() == 0)
 031A 92DE              xcall _GetwasteCardState
 031C A02E              mov R10,R16
 031E 0023              tst R16
 0320 61F4              brne L79
 0322           X24:
 0322           ; 					{
 0322           ; 						// 卸片时间到
 0322           ; 						if(TrashCanCheck())
 0322 4DD2              xcall _TrashCanCheck
 0324 A02E              mov R10,R16
 0326 0023              tst R16
 0328 11F0              breq L81
 032A           X25:
 032A           ; 						{
 032A           ; 							// 监测废片盒
 032A           ; 							return 0;
 032A 0027              clr R16
 032C C5C1              xjmp L47
 032E           L81:
 032E           ; 						}
 032E           ; 						if((PINK & 0x02) == 0)
 032E 20900601          lds R2,262
 0332 21FC              sbrc R2,1
 0334 02C0              rjmp L83
 0336           X26:
 0336           ; 						{
 0336           ; 							return 0;
 0336 0027              clr R16
 0338 BFC1              xjmp L47
 033A           L83:
 033A           ; 						}
 033A           ; 					}
 033A           L79:
 033A           ; 					if(TurnPlateUsedLock == 0)
 033A 20900000          lds R2,_TurnPlateUsedLock
 033E 2220              tst R2
 0340 09F0              breq X49
 0342 B9C1              xjmp L71
 0344           X49:
 0344           X27:
 0344           ; 					{
 0344           ; 						if(200 == insertflag[ringNum])
 0344 80E0              ldi R24,<_insertflag
 0346 90E0              ldi R25,>_insertflag
 0348 E0910300          lds R30,L51
 034C FF27              clr R31
 034E E80F              add R30,R24
 0350 F91F              adc R31,R25
 0352 8081              ldd R24,z+0
 0354 883C              cpi R24,200
 0356 09F0              breq X50
 0358 AEC1              xjmp L71
 035A           X50:
 035A           X28:
 035A           ; 						{
 035A           ; 							TurnPlateUsedLock = 1;		// 占用转盘标识
 035A 81E0              ldi R24,1
 035C 80930000          sts _TurnPlateUsedLock,R24
 0360           ;                                                       mainStep = 1;
 0360 80930000          sts L48,R24
 0364           ;                                                       workStep = 0;
 0364 2224              clr R2
 0366 20920100          sts L49,R2
 036A           ;                                                       inWork = 1; 
 036A 80930200          sts L50,R24
 036E           ;                                               }
 036E           ;                                       }
 036E           ;                               }
 036E           ;                       }
 036E A3C1              xjmp L71
 0370           L74:
 0370           ; 			else
 0370           ; 			{
 0370           ; 				return 1;
 0370 01E0              ldi R16,1
 0372 A2C1              xjmp L47
 0374           L89:
 0374           ; 			}
 0374           ; 			break;
 0374           ; 		case 1:		// 转盘转到当前位置，将干片卸载
 0374           ; 			switch(workStep)
 0374 40910100          lds R20,L49
 0378 5527              clr R21
 037A 4030              cpi R20,0
 037C 4507              cpc R20,R21
 037E 19F1              breq L93
 0380           X29:
 0380 4130              cpi R20,1
 0382 E0E0              ldi R30,0
 0384 5E07              cpc R21,R30
 0386 09F4              brne X51
 0388 44C0              xjmp L97
 038A           X51:
 038A           X30:
 038A 4230              cpi R20,2
 038C E0E0              ldi R30,0
 038E 5E07              cpc R21,R30
 0390 09F4              brne X52
 0392 48C0              xjmp L98
 0394           X52:
 0394           X31:
 0394 4330              cpi R20,3
 0396 E0E0              ldi R30,0
 0398 5E07              cpc R21,R30
 039A 09F4              brne X53
 039C 8BC0              xjmp L104
 039E           X53:
 039E           X32:
 039E 4430              cpi R20,4
 03A0 E0E0              ldi R30,0
 03A2 5E07              cpc R21,R30
 03A4 09F4              brne X54
 03A6 B7C0              xjmp L109
 03A8           X54:
 03A8           X33:
 03A8 4530              cpi R20,5
 03AA E0E0              ldi R30,0
 03AC 5E07              cpc R21,R30
 03AE 09F4              brne X55
 03B0 C6C0              xjmp L110
 03B2           X55:
 03B2           X34:
 03B2 4630              cpi R20,6
 03B4 E0E0              ldi R30,0
 03B6 5E07              cpc R21,R30
 03B8 09F4              brne X56
 03BA CAC0              xjmp L111
 03BC           X56:
 03BC           X35:
 03BC 4A30              cpi R20,10
 03BE E0E0              ldi R30,0
 03C0 5E07              cpc R21,R30
 03C2 A1F0              breq L94
 03C4           X36:
 03C4 78C1              xjmp L71
 03C6           L93:
 03C6           ; 			{
 03C6           ; 				case 0:		// 转盘转至0位
 03C6           ; 					SetMotRunPam(MOT_TURN_PLATE,200,20,CURRENT_TURN_PLATE);
 03C6 81E0              ldi R24,1
 03C8 8A83              std y+2,R24
 03CA 84E1              ldi R24,20
 03CC 8883              std y+0,R24
 03CE 28EC              ldi R18,200
 03D0 01E0              ldi R16,1
 03D2 0E940000          xcall _SetMotRunPam
 03D6           ;                                       MotRunToSite(MOT_TURN_PLATE,0);         // 转盘运行到零位
 03D6 2227              clr R18
 03D8 01E0              ldi R16,1
 03DA 0E940000          xcall _MotRunToSite
 03DE           ;                                       workStep = 10;
 03DE 8AE0              ldi R24,10
 03E0 80930100          sts L49,R24
 03E4           ;                                       watiMotTurnplate = 1;
 03E4 81E0              ldi R24,1
 03E6 80930800          sts L56,R24
 03EA           ;                                       break;  
 03EA 65C1              xjmp L71
 03EC           L94:
 03EC           ; 				case 10:		// 转盘转到当前位置
 03EC           ; 					ringNum = UnloadQueue.ringNum[0];
 03EC 20901600          lds R2,_UnloadQueue
 03F0 20920300          sts L51,R2
 03F4           ;                                       ucTmp = ringNum + 25;
 03F4 422D              mov R20,R2
 03F6 475E              subi R20,231    ; addi 25
 03F8           ;                                       if(ucTmp>=RING_QUEUE_NUM)
 03F8 4E31              cpi R20,30
 03FA 08F0              brlo L95
 03FC           X37:
 03FC           ; 						ucTmp -= RING_QUEUE_NUM;
 03FC 4E51              subi R20,30
 03FE           L95:
 03FE           ; 					//SetMotRunPam(MOT_TURN_PLATE,200,20,CURRENT_TURN_PLATE);
 03FE           ; 					MotRunToSite(MOT_TURN_PLATE,ucTmp);		// 转盘转到当前位置
 03FE 242F              mov R18,R20
 0400 01E0              ldi R16,1
 0402 0E940000          xcall _MotRunToSite
 0406           ;                                       watiMotTurnplate = 1;
 0406 81E0              ldi R24,1
 0408 80930800          sts L56,R24
 040C           ;                                       workStep = 1;
 040C 80930100          sts L49,R24
 0410           ;                                       break;
 0410 52C1              xjmp L71
 0412           L97:
 0412           ; 				//////////////////////////////////////////////////////
 0412           ; 				case 1:
 0412           ; 					SetDelayTime(MOT_CARD_UNLOAD,5);
 0412 25E0              ldi R18,5
 0414 30E0              ldi R19,0
 0416 05E0              ldi R16,5
 0418 0E940000          xcall _SetDelayTime
 041C           ; #ifndef LoadCheck
 041C           ;                                       workStep = 3;
 041C           ; #else                                 
 041C           ;                                       workStep = 2;
 041C 82E0              ldi R24,2
 041E 80930100          sts L49,R24
 0422           ; #endif
 0422           ;                                       break;
 0422 49C1              xjmp L71
 0424           L98:
 0424           ; 				case 2:
 0424           ; 					i = getLiqDetADC(UnloadChannel);
 0424 02E0              ldi R16,2
 0426 0E940000          xcall _getLiqDetADC
 042A 5801              movw R10,R16
 042C A501              movw R20,R10
 042E           ;                                       /*
 042E           ;                                       if(i < 500)     // 当前位置没有试剂片
 042E           ;                                       {
 042E           ;                                               //mainStep = 2;
 042E           ;                                               //workStep = 0;
 042E           ;                                               //uart_Printf("%s $ %d\r\n",strE3933,i);
 042E           ;                                               j++;
 042E           ;                                               if(j > 1)
 042E           ;                                               {
 042E           ;                                                       j = 0;
 042E           ;                                                       mainStep = 2;
 042E           ;                                                       workStep = 0;
 042E           ;                                                       uart_Printf("%s $ %d\r\n",strE3933,i);
 042E           ;                                               }
 042E           ;                                               else
 042E           ;                                               {
 042E           ;                                                       workStep = 0;   // 重新转至该位置检测
 042E           ;                                               }
 042E           ;                                       }
 042E           ;                                       else if(i > 900)        // 有试剂片
 042E           ;                                       {
 042E           ;                                               workStep = 3;
 042E           ;                                               uart_Printf("%s $ %d\r\n",strM3194,i);
 042E           ;                                       }
 042E           ;                                       else
 042E           ;                                       {
 042E           ;                                               uart_Printf("!3945 UnloadAdcOutofScope $ %d\r\n",(unsigned int)i);
 042E           ;                                               workStep = 3;
 042E           ;                                       }
 042E           ;                                       */
 042E           ;                                       if(i < CardLocationAD)  // 当前位置没有试剂片
 042E 0438              cpi R16,132
 0430 E3E0              ldi R30,3
 0432 1E07              cpc R17,R30
 0434 48F5              brsh L99
 0436           X38:
 0436           ; 					{
 0436           ; 						j++;
 0436 80910600          lds R24,L54
 043A 8F5F              subi R24,255    ; addi 1
 043C 80930600          sts L54,R24
 0440           ;                                               if(j > 1)
 0440 81E0              ldi R24,1
 0442 20900600          lds R2,L54
 0446 8215              cp R24,R2
 0448 D8F4              brsh L101
 044A           X39:
 044A           ; 						{
 044A           ; 							j = 0;
 044A 2224              clr R2
 044C 20920600          sts L54,R2
 0450           ;                                                       mainStep = 2;
 0450 82E0              ldi R24,2
 0452 80930000          sts L48,R24
 0456           ;                                                       workStep = 0;
 0456 20920100          sts L49,R2
 045A           ;                                                       Uart0ReUnable;
 045A 8091C100          lds R24,193
 045E 8F7E              andi R24,239
 0460 8093C100          sts 193,R24
 0464           ;                                                       uart_Printf("%s $ %d\r\n",strE3933,i);
 0464 5983              std y+1,R21
 0466 4883              std y+0,R20
 0468 20E0              ldi R18,<_strE3933
 046A 30E0              ldi R19,>_strE3933
 046C 00E0              ldi R16,<L103
 046E 10E0              ldi R17,>L103
 0470 0E940000          xcall _uart_Printf
 0474           ;                                                       Uart0ReEnable;
 0474 8091C100          lds R24,193
 0478 8061              ori R24,16
 047A 8093C100          sts 193,R24
 047E           ;                                               }
 047E 1BC1              xjmp L71
 0480           L101:
 0480           ; 						else
 0480           ; 						{
 0480           ; 							workStep = 0;	// 重新转至该位置检测
 0480 2224              clr R2
 0482 20920100          sts L49,R2
 0486           ;                                               }
 0486           ;                                       }
 0486 17C1              xjmp L71
 0488           L99:
 0488           ; 					else 					// 有试剂片
 0488           ; 					{
 0488           ; 						workStep = 3;
 0488 83E0              ldi R24,3
 048A 80930100          sts L49,R24
 048E           ;                                               Uart0ReUnable;
 048E 8091C100          lds R24,193
 0492 8F7E              andi R24,239
 0494 8093C100          sts 193,R24
 0498           ;                                               uart_Printf("%s $ %d\r\n",strM3194,i);
 0498 5983              std y+1,R21
 049A 4883              std y+0,R20
 049C 20E0              ldi R18,<_strM3194
 049E 30E0              ldi R19,>_strM3194
 04A0 00E0              ldi R16,<L103
 04A2 10E0              ldi R17,>L103
 04A4 0E940000          xcall _uart_Printf
 04A8           ;                                               Uart0ReEnable;
 04A8 8091C100          lds R24,193
 04AC 8061              ori R24,16
 04AE 8093C100          sts 193,R24
 04B2           ;                                       }
 04B2           ;                                       break;
 04B2 01C1              xjmp L71
 04B4           L104:
 04B4           ; 				case 3:
 04B4           ; 					if(GetwasteCardState() == 0)
 04B4 C5DD              xcall _GetwasteCardState
 04B6 A02E              mov R10,R16
 04B8 0023              tst R16
 04BA C9F4              brne L105
 04BC           X40:
 04BC           ; 					{
 04BC           ; 						if((PINK & 0x02) == 0)
 04BC 20900601          lds R2,262
 04C0 21FC              sbrc R2,1
 04C2 15C0              rjmp L107
 04C4           X41:
 04C4           ; 						{		// 废片仓打开
 04C4           ; 							TurnPlateUsedLock = 0;
 04C4 2224              clr R2
 04C6 20920000          sts _TurnPlateUsedLock,R2
 04CA           ;                                                       TurnPlateUsedLock = 0;
 04CA 20920000          sts _TurnPlateUsedLock,R2
 04CE           ;                                                       insertflag[ringNum] = 200;
 04CE 80E0              ldi R24,<_insertflag
 04D0 90E0              ldi R25,>_insertflag
 04D2 E0910300          lds R30,L51
 04D6 FF27              clr R31
 04D8 E80F              add R30,R24
 04DA F91F              adc R31,R25
 04DC 88EC              ldi R24,200
 04DE 8083              std z+0,R24
 04E0           ;                                                       mainStep = 0;
 04E0 20920000          sts L48,R2
 04E4           ;                                                       workStep = 0;
 04E4 20920100          sts L49,R2
 04E8           ;                                                       inWork = 0;
 04E8 20920200          sts L50,R2
 04EC           ;                                                       break;
 04EC E4C0              xjmp L71
 04EE           L107:
 04EE           ; 						}
 04EE           ; 					}
 04EE           L105:
 04EE           ; 					SetMotRunPam(MOT_CARD_UNLOAD,200,20,CURRENT_CARD_UNLOAD);
 04EE 84E0              ldi R24,4
 04F0 8A83              std y+2,R24
 04F2 84E1              ldi R24,20
 04F4 8883              std y+0,R24
 04F6 28EC              ldi R18,200
 04F8 05E0              ldi R16,5
 04FA 0E940000          xcall _SetMotRunPam
 04FE           ;                                       MotRunTo(MOT_CARD_UNLOAD,_POS_UNLOAD_OUT);              // 卸片行程67mm/0.08128 = 824
 04FE 20E4              ldi R18,1600
 0500 36E0              ldi R19,6
 0502 05E0              ldi R16,5
 0504 0E940000          xcall _MotRunTo
 0508           ;                                       waitMotUnload = 1;
 0508 81E0              ldi R24,1
 050A 80930900          sts L57,R24
 050E           ;                                       workStep = 4;
 050E 84E0              ldi R24,4
 0510 80930100          sts L49,R24
 0514           ;                                       break;
 0514 D0C0              xjmp L71
 0516           L109:
 0516           ; 				case 4:
 0516           ; 					SetMotRunPam(MOT_CARD_UNLOAD,100,20,2);
 0516 82E0              ldi R24,2
 0518 8A83              std y+2,R24
 051A 84E1              ldi R24,20
 051C 8883              std y+0,R24
 051E 24E6              ldi R18,100
 0520 05E0              ldi R16,5
 0522 0E940000          xcall _SetMotRunPam
 0526           ;                                       MotRunTo(MOT_CARD_UNLOAD,0);
 0526 2227              clr R18
 0528 3327              clr R19
 052A 05E0              ldi R16,5
 052C 0E940000          xcall _MotRunTo
 0530           ;                                       waitMotUnload = 1;
 0530 81E0              ldi R24,1
 0532 80930900          sts L57,R24
 0536           ;                                       workStep = 5;
 0536 85E0              ldi R24,5
 0538 80930100          sts L49,R24
 053C           ;                                       break;
 053C BCC0              xjmp L71
 053E           L110:
 053E           ; 				case 5:
 053E           ; 					//SetDelayTime(MOT_CARD_UNLOAD,5);
 053E           ; 					SetDelayTime(MOT_CARD_UNLOAD,10);
 053E 2AE0              ldi R18,10
 0540 30E0              ldi R19,0
 0542 05E0              ldi R16,5
 0544 0E940000          xcall _SetDelayTime
 0548           ; #ifndef LoadCheck
 0548           ;                                       mainStep = 2; // 不检测下片
 0548           ;                                       workStep = 0; // 不检测下片
 0548           ; #else
 0548           ;                                       workStep = 6; // 检测下片
 0548 86E0              ldi R24,6
 054A 80930100          sts L49,R24
 054E           ; #endif
 054E           ;                                       break;
 054E B3C0              xjmp L71
 0550           L111:
 0550           ; 				case 6:	// 下片动作完成之后,重新检测是否有试剂片
 0550           ; 					i = getLiqDetADC(UnloadChannel);
 0550 02E0              ldi R16,2
 0552 0E940000          xcall _getLiqDetADC
 0556 5801              movw R10,R16
 0558 A501              movw R20,R10
 055A           ;                                       /*
 055A           ;                                       if(i < 500)     // 当前位置没有试剂片
 055A           ;                                       {
 055A           ;                                               mainStep = 2;
 055A           ;                                               workStep = 0;
 055A           ;                                       }
 055A           ;                                       else if(i > 900)        // 有试剂片
 055A           ;                                       {
 055A           ;                                               workStep = 0;
 055A           ;                                               uart_Printf("%s $%4d $%4d\r\n",strM3117,ringNum,j + 2);         // 对应位置再次下片
 055A           ;                                               j++;
 055A           ;                                               if(j > 2)
 055A           ;                                               {
 055A           ;                                                       j = 0;
 055A           ;                                                       mainStep = 2;
 055A           ;                                                       workStep = 0;
 055A           ;                                                       uart_Printf("%s $%4d\r\n",strE4909,ringNum);            // 对应位置连续3次下片失败
 055A           ;                                               }
 055A           ;                                       }
 055A           ;                                       else
 055A           ;                                       {
 055A           ;                                               uart_Printf("!3945 UnloadAdcOutofScope $ %d\r\n",(unsigned int)i);
 055A           ;                                               mainStep = 2;
 055A           ;                                               workStep = 0;
 055A           ;                                       }
 055A           ;                                       */
 055A           ;                                       if(i < CardLocationAD)  // 当前位置没有试剂片
 055A 0438              cpi R16,132
 055C E3E0              ldi R30,3
 055E 1E07              cpc R17,R30
 0560 38F4              brsh L112
 0562           X42:
 0562           ; 					{
 0562           ; 						mainStep = 2;
 0562 82E0              ldi R24,2
 0564 80930000          sts L48,R24
 0568           ;                                               workStep = 0;
 0568 2224              clr R2
 056A 20920100          sts L49,R2
 056E           ;                                       }
 056E A3C0              xjmp L71
 0570           L112:
 0570           ; 					else 					// 有试剂片
 0570           ; 					{
 0570           ; 						workStep = 0;
 0570 2224              clr R2
 0572 20920100          sts L49,R2
 0576           ;                                               Uart0ReUnable;
 0576 8091C100          lds R24,193
 057A 8F7E              andi R24,239
 057C 8093C100          sts 193,R24
 0580           ;                                               uart_Printf("%s $%4d $%4d\r\n",strM3117,ringNum,j + 2);         // 对应位置再次下片
 0580 80910600          lds R24,L54
 0584 9927              clr R25
 0586 0296              adiw R24,2
 0588 9B83              std y+3,R25
 058A 8A83              std y+2,R24
 058C 20900300          lds R2,L51
 0590 3324              clr R3
 0592 3982              std y+1,R3
 0594 2882              std y+0,R2
 0596 20E0              ldi R18,<_strM3117
 0598 30E0              ldi R19,>_strM3117
 059A 00E0              ldi R16,<L114
 059C 10E0              ldi R17,>L114
 059E 0E940000          xcall _uart_Printf
 05A2           ;                                               Uart0ReEnable;
 05A2 8091C100          lds R24,193
 05A6 8061              ori R24,16
 05A8 8093C100          sts 193,R24
 05AC           ;                                               j++;
 05AC 80910600          lds R24,L54
 05B0 8F5F              subi R24,255    ; addi 1
 05B2 80930600          sts L54,R24
 05B6           ;                                               if(j > 2)
 05B6 82E0              ldi R24,2
 05B8 20900600          lds R2,L54
 05BC 8215              cp R24,R2
 05BE 08F0              brlo X57
 05C0 7AC0              xjmp L71
 05C2           X57:
 05C2           X43:
 05C2           ; 						{
 05C2           ; 							j = 0;
 05C2 2224              clr R2
 05C4 20920600          sts L54,R2
 05C8           ;                                                       mainStep = 2;
 05C8 80930000          sts L48,R24
 05CC           ;                                                       workStep = 0;
 05CC 20920100          sts L49,R2
 05D0           ;                                                       Uart0ReUnable;
 05D0 8091C100          lds R24,193
 05D4 8F7E              andi R24,239
 05D6 8093C100          sts 193,R24
 05DA           ;                                                       uart_Printf("%s $%4d\r\n",strE4909,ringNum);            // 对应位置连续3次下片失败
 05DA 20900300          lds R2,L51
 05DE 3324              clr R3
 05E0 3982              std y+1,R3
 05E2 2882              std y+0,R2
 05E4 20E0              ldi R18,<_strE4909
 05E6 30E0              ldi R19,>_strE4909
 05E8 00E0              ldi R16,<L4
 05EA 10E0              ldi R17,>L4
 05EC 0E940000          xcall _uart_Printf
 05F0           ;                                                       Uart0ReEnable;
 05F0 8091C100          lds R24,193
 05F4 8061              ori R24,16
 05F6 8093C100          sts 193,R24
 05FA           ;                                               }
 05FA           ;                                       }
 05FA           ;                                       break;
 05FA           ;                       }
 05FA           ;                       break;
 05FA 5DC0              xjmp L71
 05FC           L117:
 05FC           ; 		case 2:		// 干片卸载，释放转盘使用权
 05FC           ; 			TurnPlateUsedLock = 0;
 05FC 2224              clr R2
 05FE 20920000          sts _TurnPlateUsedLock,R2
 0602           ;                       TurnPlateUsedLock = 0;                                  
 0602 20920000          sts _TurnPlateUsedLock,R2
 0606           ;                       ringNum = UnloadQueue.ringNum[0];
 0606 20901600          lds R2,_UnloadQueue
 060A 20920300          sts L51,R2
 060E           ;                       insertflag[ringNum] = 0;
 060E 80E0              ldi R24,<_insertflag
 0610 90E0              ldi R25,>_insertflag
 0612 E22D              mov R30,R2
 0614 FF27              clr R31
 0616 E80F              add R30,R24
 0618 F91F              adc R31,R25
 061A 2224              clr R2
 061C 2082              std z+0,R2
 061E           ;                       l = RingQueue.sampInfo[ringNum].testSerial;
 061E 10910300          lds R17,L51
 0622 0DE0              ldi R16,13
 0624 0103              mulsu R16,R17
 0626 80E0              ldi R24,<_RingQueue+1
 0628 90E0              ldi R25,>_RingQueue+1
 062A F001              movw R30,R0
 062C E80F              add R30,R24
 062E F91F              adc R31,R25
 0630 2080              ldd R2,z+0
 0632 3180              ldd R3,z+1
 0634 4280              ldd R4,z+2
 0636 5380              ldd R5,z+3
 0638 2C82              std y+4,R2
 063A 3D82              std y+5,R3
 063C 4E82              std y+6,R4
 063E 5F82              std y+7,R5
 0640           ;                       RingQueueDelete(ringNum);                       // 删除转盘上对应位置的干片信息，释放出位置继续使用
 0640 012F              mov R16,R17
 0642 1127              clr R17
 0644 0E940000          xcall _RingQueueDelete
 0648           ; #ifndef UartSendLong
 0648           ;                       Uart0ReUnable;
 0648           ;                       uart_Printf("%s $%8d",strM3116 , l);
 0648           ;                       uart_Printf(" $%4d",(unsigned char)ringNum);
 0648           ;                       uart_Printf(" $%8d\r\n",(unsigned long)SecondCount);
 0648           ;                       Uart0ReEnable;
 0648           ; #else
 0648           ;                       Uart0ReUnable;
 0648 8091C100          lds R24,193
 064C 8F7E              andi R24,239
 064E 8093C100          sts 193,R24
 0652           ;                       uart_Printf("%s $ ",strM3116);
 0652 20E0              ldi R18,<_strM3116
 0654 30E0              ldi R19,>_strM3116
 0656 00E0              ldi R16,<L119
 0658 10E0              ldi R17,>L119
 065A 0E940000          xcall _uart_Printf
 065E           ;                       uart0SendInt(l);
 065E 0C81              ldd R16,y+4
 0660 1D81              ldd R17,y+5
 0662 2E81              ldd R18,y+6
 0664 3F81              ldd R19,y+7
 0666 0E940000          xcall _uart0SendInt
 066A           ;                       uart_Printf(" $%4d $ ",(unsigned char)ringNum);
 066A 20910300          lds R18,L51
 066E 3327              clr R19
 0670 00E0              ldi R16,<L120
 0672 10E0              ldi R17,>L120
 0674 0E940000          xcall _uart_Printf
 0678           ;                       uart0SendInt(SecondCount);
 0678 20910200          lds R18,_SecondCount+2
 067C 30910300          lds R19,_SecondCount+2+1
 0680 00910000          lds R16,_SecondCount
 0684 10910100          lds R17,_SecondCount+1
 0688 0E940000          xcall _uart0SendInt
 068C           ;                       uart_Printf("\r\n");
 068C 00E0              ldi R16,<L121
 068E 10E0              ldi R17,>L121
 0690 0E940000          xcall _uart_Printf
 0694           ;                       Uart0ReEnable;
 0694 8091C100          lds R24,193
 0698 8061              ori R24,16
 069A 8093C100          sts 193,R24
 069E           ; #endif
 069E           ;                       mainStep = 3;
 069E 83E0              ldi R24,3
 06A0 80930000          sts L48,R24
 06A4           ;                       break;
 06A4 08C0              xjmp L71
 06A6           L122:
 06A6           ; 		case 3:
 06A6           ; 			// 废片盒容量监测处理
 06A6           ; 			mainStep = 0;
 06A6 2224              clr R2
 06A8 20920000          sts L48,R2
 06AC           ;                       workStep = 0;
 06AC 20920100          sts L49,R2
 06B0           ;                       inWork = 0;
 06B0 20920200          sts L50,R2
 06B4           ;                       UnloadQueueForward();           // 删除已完成的队头任务，队列前进一步
 06B4 72DD              xcall _UnloadQueueForward
 06B6           ;                       break;
 06B6           L70:
 06B6           L71:
 06B6           ; 		}
 06B6           ; 	return 0;
 06B6 0027              clr R16
 06B8           L47:
 06B8                   .dbline 0 ; func end
 06B8 2896              adiw R28,8
 06BA 0C940000          xjmp pop_xgset300C
                        .area bss(ram, con, rel)
 000A           L124:
 000A                   .blkb 1
 000B           L125:
 000B                   .blkb 1
 000C           L126:
 000C                   .blkb 1
 000D           L127:
 000D                   .blkb 2
                        .area text(rom, con, rel)
                        .even
 06BE           _TrashCanMonitor::
 06BE 2297              sbiw R28,2
 06C0           ; }
 06C0           ; 
 06C0           ; 
 06C0           ; 
 06C0           ; void TrashCanMonitor(void){
 06C0           ;       static unsigned char delayCnt, delayCnt2;
 06C0           ;       static unsigned char dustbinOldState;
 06C0           ;       static unsigned int openTime;
 06C0           ;       
 06C0           ;       if(WorkProcessStep == 3)
 06C0 80910000          lds R24,_WorkProcessStep
 06C4 8330              cpi R24,3
 06C6 09F0              breq X69
 06C8 78C0              xjmp L128
 06CA           X69:
 06CA           X58:
 06CA           ; 	{
 06CA           ; 		if((PINK & 0x02) == 0)		// 废片仓打开
 06CA 20900601          lds R2,262
 06CE 21FC              sbrc R2,1
 06D0 50C0              rjmp L130
 06D2           X59:
 06D2           ; 		{
 06D2           ; 			delayCnt ++;
 06D2 80910A00          lds R24,L124
 06D6 8F5F              subi R24,255    ; addi 1
 06D8 80930A00          sts L124,R24
 06DC           ;                       if(0 == stopTestFlag)
 06DC 20900000          lds R2,_stopTestFlag
 06E0 2220              tst R2
 06E2 49F4              brne L132
 06E4           X60:
 06E4           ; 				openTime++;
 06E4 80910D00          lds R24,L127
 06E8 90910E00          lds R25,L127+1
 06EC 0196              adiw R24,1
 06EE 90930E00          sts L127+1,R25
 06F2 80930D00          sts L127,R24
 06F6           L132:
 06F6           ; 			if(delayCnt == 1)
 06F6 80910A00          lds R24,L124
 06FA 8130              cpi R24,1
 06FC 39F4              brne L134
 06FE           X61:
 06FE           ; 			{
 06FE           ; 				if(dustbinOldState != 0)
 06FE 20900C00          lds R2,L126
 0702 2220              tst R2
 0704 19F0              breq L136
 0706           X62:
 0706           ; 				{
 0706           ; 					dustbinOldState = 0;
 0706 2224              clr R2
 0708 20920C00          sts L126,R2
 070C           ;                               }
 070C           L136:
 070C           ; 			}
 070C           L134:
 070C           ; 			if(delayCnt == 5)
 070C 80910A00          lds R24,L124
 0710 8530              cpi R24,5
 0712 A1F4              brne L138
 0714           X63:
 0714           ; 			{
 0714           ; 				// 片仓已打开并排空
 0714           ; 				TranCanCountBase = ReadCurTestSetial();		// 读取当前的测试自动序列号
 0714 0E940000          xcall _ReadCurTestSetial
 0718 10931300          sts _TranCanCountBase+1,R17
 071C 00931200          sts _TranCanCountBase,R16
 0720 30931500          sts _TranCanCountBase+2+1,R19
 0724 20931400          sts _TranCanCountBase+2,R18
 0728           ;                               EEPROM_WRITE(EEP_ADD_TRANSH_CNT, TranCanCountBase);             // 写入新的废片基数基数
 0728 84E0              ldi R24,4
 072A 90E0              ldi R25,0
 072C 9983              std y+1,R25
 072E 8883              std y+0,R24
 0730 20E0              ldi R18,<_TranCanCountBase
 0732 30E0              ldi R19,>_TranCanCountBase
 0734 08EC              ldi R16,200
 0736 10E0              ldi R17,0
 0738 0E940000          xcall _EEPROMWriteBytes_extIO
 073C           ;                       }
 073C           L138:
 073C           ; 			if(delayCnt == 60)	// 废片仓打开时间超时报警
 073C 80910A00          lds R24,L124
 0740 8C33              cpi R24,60
 0742 29F4              brne L140
 0744           X64:
 0744           ; 			{
 0744           ; 				SetBeepWarning();
 0744 0E940000          xcall _SetBeepWarning
 0748           ;                               delayCnt = 40;
 0748 88E2              ldi R24,40
 074A 80930A00          sts L124,R24
 074E           ;                       }
 074E           L140:
 074E           ; 			if(openTime >= 1200)	// 片仓开启时间超过20分钟
 074E 80910D00          lds R24,L127
 0752 90910E00          lds R25,L127+1
 0756 803B              cpi R24,176
 0758 E4E0              ldi R30,4
 075A 9E07              cpc R25,R30
 075C 70F1              brlo L131
 075E           X65:
 075E           ; 			{
 075E           ; 				openTime = 0;
 075E 2224              clr R2
 0760 3324              clr R3
 0762 30920E00          sts L127+1,R3
 0766 20920D00          sts L127,R2
 076A           ;                               stopTestFlag = 1;
 076A 81E0              ldi R24,1
 076C 80930000          sts _stopTestFlag,R24
 0770           ;                       }
 0770           ;               }
 0770 24C0              xjmp L131
 0772           L130:
 0772           ; 		else		// 废片仓关闭
 0772           ; 		{
 0772           ; 			if(dustbinOldState == 0)
 0772 20900C00          lds R2,L126
 0776 2220              tst R2
 0778 19F4              brne L144
 077A           X66:
 077A           ; 			{
 077A           ; 				dustbinOldState = 1;
 077A 81E0              ldi R24,1
 077C 80930C00          sts L126,R24
 0780           ;                       }
 0780           L144:
 0780           ; 			delayCnt = 0;
 0780 2224              clr R2
 0782 20920A00          sts L124,R2
 0786           ;                       openTime = 0;
 0786 3324              clr R3
 0788 30920E00          sts L127+1,R3
 078C 20920D00          sts L127,R2
 0790           ;                       stopTestFlag = 0;
 0790 20920000          sts _stopTestFlag,R2
 0794           ;                       if(TrashCanState)
 0794 20901100          lds R2,_TrashCanState
 0798 2220              tst R2
 079A 79F0              breq L146
 079C           X67:
 079C           ; 			{
 079C           ; 				delayCnt2 ++;
 079C 80910B00          lds R24,L125
 07A0 8F5F              subi R24,255    ; addi 1
 07A2 80930B00          sts L125,R24
 07A6           ;                               if(delayCnt2 > 20)      // 废片仓满报警
 07A6 84E1              ldi R24,20
 07A8 20900B00          lds R2,L125
 07AC 8215              cp R24,R2
 07AE 10F4              brsh L148
 07B0           X68:
 07B0           ; 					SetBeepWarning();
 07B0 0E940000          xcall _SetBeepWarning
 07B4           L148:
 07B4           ; 				delayCnt2 = 0;
 07B4 2224              clr R2
 07B6 20920B00          sts L125,R2
 07BA           ;                       }
 07BA           L146:
 07BA           ; 		}
 07BA           L131:
 07BA           ; 	}
 07BA           L128:
 07BA           L123:
 07BA                   .dbline 0 ; func end
 07BA 2296              adiw R28,2
 07BC 0895              ret
                        .even
 07BE           _TrashCanCheck::
 07BE           ; }
 07BE           ; unsigned char TrashCanCheck(void)
 07BE           ; {
 07BE           ; 	// 关闭废片仓满监控
 07BE           ; /*	if((NewTestInfo.testSerial - TranCanCountBase) > 100){
 07BE           ; 		TrashCanState = 1;
 07BE           ; 		return 1;
 07BE           ; 		}
 07BE           ; 		*/
 07BE           ; 	TrashCanState = 0;
 07BE 2224              clr R2
 07C0 20921100          sts _TrashCanState,R2
 07C4           ;       return 0;
 07C4 0027              clr R16
 07C6           L150:
 07C6                   .dbline 0 ; func end
 07C6 0895              ret
                        .area bss(ram, con, rel)
 000F           _UnloadProcess_mainStep:
 000F                   .blkb 1
 0010           _UnloadProcess_workStep:
 0010                   .blkb 1
 0011           _TrashCanState::
 0011                   .blkb 1
 0012           _TranCanCountBase::
 0012                   .blkb 4
 0016           _UnloadQueue::
 0016                   .blkb 152
                        .area data(ram, con, rel)
 0001           L121:
 0001                   .blkb 3
                        .area idata
 0001 0D0A00            .byte 13,10,0
                        .area data(ram, con, rel)
 0004           L120:
 0004                   .blkb 9
                        .area idata
 0004 202425346420242000        .byte 32,36,37,52,'d,32,36,32,0
                        .area data(ram, con, rel)
 000D           L119:
 000D                   .blkb 6
                        .area idata
 000D 257320242000      .byte 37,'s,32,36,32,0
                        .area data(ram, con, rel)
 0013           L114:
 0013                   .blkb 15
                        .area idata
 0013 2573202425346420242534640D0A00    .byte 37,'s,32,36,37,52,'d,32,36,37,52,'d,13,10,0
                        .area data(ram, con, rel)
 0022           L103:
 0022                   .blkb 10
                        .area idata
 0022 257320242025640D0A00      .byte 37,'s,32,36,32,37,'d,13,10,0
                        .area data(ram, con, rel)
 002C           L46:
 002C                   .blkb 34
                        .area idata
 002C 2A3332303220556E6C6F616453746570  .byte 42,51,50,48,50,32,'U,'n,'l,'o,'a,'d,'S,'t,'e,'p
 003C 5374617465202425326420242532640D  .byte 'S,'t,'a,'t,'e,32,36,37,50,'d,32,36,37,50,'d,13
 004C 0A00              .byte 10,0
                        .area data(ram, con, rel)
 004E           L4:
 004E                   .blkb 10
                        .area idata
 004E 257320242534640D0A00      .byte 37,'s,32,36,37,52,'d,13,10,0
                        .area data(ram, con, rel)
                ; }
                ; 
