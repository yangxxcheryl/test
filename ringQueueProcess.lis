                        .module ringQueueProcess.c
                        .area text(rom, con, rel)
                ;          pChar -> R18,R19
                ;              i -> R16,R17
                        .even
 0000           _RingQueueDatInit::
 0000           ; #include <iom1280v.h>
 0000           ; #include "B1404_LIB.h"
 0000           ; #include "Common.h"
 0000           ; 
 0000           ; 
 0000           ; // 转盘队列处理
 0000           ; 
 0000           ; unsigned char TurnPlateUsedLock;		// 转盘使用锁
 0000           ; 
 0000           ; RING_QUEUE	RingQueue;
 0000           ; extern unsigned long SecondCount;	// 秒时钟计数
 0000           ; 
 0000           ; void RingQueueDatInit(void){
 0000           ; 	unsigned int i;
 0000           ; 	unsigned char *pChar;
 0000           ; 
 0000           ; 	pChar = (unsigned char *)&(RingQueue);
 0000 20E0              ldi R18,<_RingQueue
 0002 30E0              ldi R19,>_RingQueue
 0004           ;       for(i=0; i<sizeof(RING_QUEUE); i++){
 0004 0027              clr R16
 0006 1127              clr R17
 0008 06C0              xjmp L5
 000A           L2:
 000A           ; 		*pChar++ = 0;
 000A 2224              clr R2
 000C F901              movw R30,R18
 000E 2192              st Z+,R2
 0010 9F01              movw R18,R30
 0012           ;               }
 0012           L3:
 0012 0F5F              subi R16,255  ; offset = 1
 0014 1F4F              sbci R17,255
 0016           L5:
 0016 053A              cpi R16,165
 0018 E1E0              ldi R30,1
 001A 1E07              cpc R17,R30
 001C B0F3              brlo L2
 001E           X0:
 001E           ; 	TurnPlateUsedLock = 0;
 001E 2224              clr R2
 0020 2092A501          sts _TurnPlateUsedLock,R2
 0024           L1:
 0024                   .dbline 0 ; func end
 0024 0895              ret
 0026           ;              i -> R22
 0026           ;        ringNum -> R20
                        .even
 0026           _RingQueueInsertCalculate::
 0026 4A93              st -y,R20
 0028 6A93              st -y,R22
 002A 2297              sbiw R28,2
 002C           ; }
 002C           ; 
 002C           ; unsigned char RingQueueInsertCalculate(void){
 002C           ;       // 查找出转盘下一个插入位置，返回查找到的位置编号
 002C           ;       unsigned char i, ringNum;
 002C           ;       ringNum = RingQueue.prevNum;            
 002C 4091A401          lds R20,_RingQueue+420
 0030           ;       i = RING_QUEUE_NUM;
 0030 6EE1              ldi R22,30
 0032 0EC0              xjmp L9
 0034           L8:
 0034           ; 	while(i--){
 0034           ; 		// 从转盘上次插入干片位置开始遍历查找空位置
 0034           ; 		ringNum ++;
 0034 4395              inc R20
 0036           ;               if(ringNum == RING_QUEUE_NUM)
 0036 4E31              cpi R20,30
 0038 09F4              brne L11
 003A           X1:
 003A           ; 			ringNum = 0;
 003A 4427              clr R20
 003C           L11:
 003C           ; 		if(RingQueue.flag[ringNum] == 0)	// 找到转盘空位置
 003C 80E0              ldi R24,<_RingQueue+390
 003E 90E0              ldi R25,>_RingQueue+390
 0040 E42F              mov R30,R20
 0042 FF27              clr R31
 0044 E80F              add R30,R24
 0046 F91F              adc R31,R25
 0048 2080              ldd R2,z+0
 004A 2220              tst R2
 004C 09F4              brne L13
 004E           X2:
 004E           ; 			break;
 004E 05C0              xjmp L10
 0050           L13:
 0050           ; 		}
 0050           L9:
 0050 262E              mov R2,R22
 0052 3324              clr R3
 0054 6150              subi R22,1
 0056 2220              tst R2
 0058 69F7              brne L8
 005A           X3:
 005A           L10:
 005A           ; 	if(i == 255)   // 0-1 = 255
 005A 6F3F              cpi R22,255
 005C B9F4              brne L16
 005E           X4:
 005E           ; 	{
 005E           ; 		Uart0ReUnable;
 005E 8091C100          lds R24,193
 0062 8F7E              andi R24,239
 0064 8093C100          sts 193,R24
 0068           ;               uart_Printf("%s $%d\r\n",strE3935,RingQueue.prevNum); 
 0068 2090A401          lds R2,_RingQueue+420
 006C 3324              clr R3
 006E 3982              std y+1,R3
 0070 2882              std y+0,R2
 0072 20E0              ldi R18,<_strE3935
 0074 30E0              ldi R19,>_strE3935
 0076 00E0              ldi R16,<L18
 0078 10E0              ldi R17,>L18
 007A 0E940000          xcall _uart_Printf
 007E           ;               Uart0ReEnable;
 007E 8091C100          lds R24,193
 0082 8061              ori R24,16
 0084 8093C100          sts 193,R24
 0088           ;               return 0xff;                    // 未找到空位置，查找失败
 0088 0FEF              ldi R16,255
 008A 03C0              xjmp L6
 008C           L16:
 008C           ; 	}
 008C           ; 	RingQueue.prevNum = ringNum;
 008C 4093A401          sts _RingQueue+420,R20
 0090           ;       return ringNum;
 0090 042F              mov R16,R20
 0092           L6:
 0092                   .dbline 0 ; func end
 0092 2296              adiw R28,2
 0094 6991              ld R22,y+
 0096 4991              ld R20,y+
 0098 0895              ret
 009A           ;        newSamp -> R10,R11
 009A           ;        ringNum -> R12
                        .even
 009A           _RingQueueInsert::
 009A 0E940000          xcall push_xgset003C
 009E 5901              movw R10,R18
 00A0 C02E              mov R12,R16
 00A2 2197              sbiw R28,1
 00A4           ; }
 00A4           ; 
 00A4           ; /*
 00A4           ; unsigned char RingQueueInsertCalculate(void)
 00A4           ; {
 00A4           ;       // 查找出转盘下一个插入位置，返回查找到的位置编号
 00A4           ;       unsigned char ringNum;
 00A4           ;       ringNum = RingQueue.prevNum;
 00A4           ;       ringNum++;
 00A4           ;       if(ringNum >= RING_QUEUE_NUM)
 00A4           ;               ringNum = 0;
 00A4           ;       RingQueue.prevNum = ringNum;
 00A4           ;       return ringNum;
 00A4           ; }
 00A4           ; */
 00A4           ; 
 00A4           ; void RingQueueInsert(unsigned char ringNum,SAMP_INFO * newSamp){
 00A4           ;       // 转盘队列插入新测试，只将标本信息放入转盘，等待干片装入转盘后再设置新插入位置有效标识
 00A4           ;       //RingQueue.flag[ringNum] = 1;          // 设置使用标记
 00A4           ;       MemCopy(newSamp, &(RingQueue.sampInfo[ringNum]), sizeof(SAMP_INFO));            // 存入测试信息
 00A4 8DE0              ldi R24,13
 00A6 8883              std y+0,R24
 00A8 0DE0              ldi R16,13
 00AA 1C2D              mov R17,R12
 00AC 0103              mulsu R16,R17
 00AE 9001              movw R18,R0
 00B0 80E0              ldi R24,<_RingQueue
 00B2 90E0              ldi R25,>_RingQueue
 00B4 280F              add R18,R24
 00B6 391F              adc R19,R25
 00B8 8501              movw R16,R10
 00BA 0E940000          xcall _MemCopy
 00BE           L21:
 00BE                   .dbline 0 ; func end
 00BE 2196              adiw R28,1
 00C0 0C940000          xjmp pop_xgset003C
 00C4           ;        ringNum -> R16
                        .even
 00C4           _RingQueueDelete::
 00C4           ; }
 00C4           ; 
 00C4           ; void RingQueueDelete(unsigned char ringNum){
 00C4           ; 	RingQueue.flag[ringNum] = 0;
 00C4 80E0              ldi R24,<_RingQueue+390
 00C6 90E0              ldi R25,>_RingQueue+390
 00C8 E02F              mov R30,R16
 00CA FF27              clr R31
 00CC E80F              add R30,R24
 00CE F91F              adc R31,R25
 00D0 2224              clr R2
 00D2 2082              std z+0,R2
 00D4           L22:
 00D4                   .dbline 0 ; func end
 00D4 0895              ret
 00D6           ;        ringNum -> R16
                        .even
 00D6           _SetRingQueueUnitUsed::
 00D6           ; }
 00D6           ; 
 00D6           ; void SetRingQueueUnitUsed(unsigned char ringNum){
 00D6           ; 	RingQueue.flag[ringNum] = 1;
 00D6 80E0              ldi R24,<_RingQueue+390
 00D8 90E0              ldi R25,>_RingQueue+390
 00DA E02F              mov R30,R16
 00DC FF27              clr R31
 00DE E80F              add R30,R24
 00E0 F91F              adc R31,R25
 00E2 81E0              ldi R24,1
 00E4 8083              std z+0,R24
 00E6           L24:
 00E6                   .dbline 0 ; func end
 00E6 0895              ret
                        .area bss(ram, con, rel)
 0000           _RingQueue::
 0000                   .blkb 421
 01A5           _TurnPlateUsedLock::
 01A5                   .blkb 1
                        .area data(ram, con, rel)
 0000           L18:
 0000                   .blkb 9
                        .area idata
 0000 2573202425640D0A00        .byte 37,'s,32,36,37,'d,13,10,0
                        .area data(ram, con, rel)
                ; }
